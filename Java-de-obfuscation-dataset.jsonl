{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers.a5; import com.thealgorithms.ciphers.a5.A5KeyStreamGenerator; import java.util.BitSet; public class A5Cipher { private final A5KeyStreamGenerator a = new A5KeyStreamGenerator(); public A5Cipher(BitSet bitSet, BitSet bitSet2) { this.a.initialize(bitSet, bitSet2); } public BitSet encrypt(BitSet bitSet) { BitSet bitSet2 = new BitSet(228); bitSet2.xor(bitSet); bitSet = this.a.getNextKeyStream(); bitSet2.xor(bitSet); return bitSet2; } public void resetCounter() { this.a.reInitialize(); } }", "deobfuscated_code": "package com.thealgorithms.ciphers.a5; import java.util.BitSet; /** * The A5Cipher class implements the A5/1 stream cipher, which is a widely used * encryption algorithm, particularly in mobile communications. * * This implementation uses a key stream generator to produce a stream of bits * that are XORed with the plaintext bits to produce the ciphertext. * * <p> * For more details about the A5/1 algorithm, refer to * <a href=\"https://en.wikipedia.org/wiki/A5/1\">Wikipedia</a>. * </p> */ public class A5Cipher { private final A5KeyStreamGenerator keyStreamGenerator; private static final int KEY_STREAM_LENGTH = 228; // Length of the key stream in bits (28.5 bytes) /** * Constructs an A5Cipher instance with the specified session key and frame counter. * * @param sessionKey a BitSet representing the session key used for encryption. * @param frameCounter a BitSet representing the frame counter that helps in key stream generation. */ public A5Cipher(BitSet sessionKey, BitSet frameCounter) { keyStreamGenerator = new A5KeyStreamGenerator(); keyStreamGenerator.initialize(sessionKey, frameCounter); } /** * Encrypts the given plaintext bits using the A5/1 cipher algorithm. * * This method generates a key stream and XORs it with the provided plaintext * bits to produce the ciphertext. * * @param plainTextBits a BitSet representing the plaintext bits to be encrypted. * @return a BitSet containing the encrypted ciphertext bits. */ public BitSet encrypt(BitSet plainTextBits) { // create a copy var result = new BitSet(KEY_STREAM_LENGTH); result.xor(plainTextBits); var key = keyStreamGenerator.getNextKeyStream(); result.xor(key); return result; } /** * Resets the internal counter of the key stream generator. * * This method can be called to re-initialize the state of the key stream * generator, allowing for new key streams to be generated for subsequent * encryptions. */ public void resetCounter() { keyStreamGenerator.reInitialize(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers.a5; import com.thealgorithms.ciphers.a5.CompositeLFSR; import com.thealgorithms.ciphers.a5.LFSR; import com.thealgorithms.ciphers.a5.Utils; import java.util.BitSet; public class A5KeyStreamGenerator extends CompositeLFSR { private BitSet b; private BitSet c; private BitSet d; @Override public void initialize(BitSet bitSet, BitSet bitSet2) { this.d = bitSet; this.c = (BitSet)bitSet2.clone(); this.b = (BitSet)bitSet2.clone(); this.a.clear(); LFSR lFSR2 = new LFSR(19, 8, new int[]{13, 16, 17, 18}); LFSR lFSR3 = new LFSR(22, 10, new int[]{20, 21}); LFSR lFSR4 = new LFSR(23, 10, new int[]{7, 20, 21, 22}); this.a.add(lFSR2); this.a.add(lFSR3); this.a.add(lFSR4); this.a.forEach(lFSR -> lFSR.initialize(bitSet, bitSet2)); } public void reInitialize() { A5KeyStreamGenerator a5KeyStreamGenerator = this; a5KeyStreamGenerator.initialize(a5KeyStreamGenerator.d, this.b); } public BitSet getNextKeyStream() { A5KeyStreamGenerator a5KeyStreamGenerator; for (int i = 1; i <= 100; ++i) { this.clock(); } BitSet bitSet = new BitSet(228); for (int i = 1; i <= 228; ++i) { boolean bl = this.clock(); bitSet.set(i - 1, bl); } A5KeyStreamGenerator a5KeyStreamGenerator2 = a5KeyStreamGenerator = this; Utils.increment(a5KeyStreamGenerator.c, 22); a5KeyStreamGenerator.a.forEach(lFSR -> lFSR.initialize(this.d, this.c)); return bitSet; } public BitSet getFrameCounter() { return this.c; } }", "deobfuscated_code": "package com.thealgorithms.ciphers.a5; import java.util.BitSet; /** * The A5KeyStreamGenerator class is responsible for generating key streams * for the A5/1 encryption algorithm using a combination of Linear Feedback Shift Registers (LFSRs). * * <p> * This class extends the CompositeLFSR and initializes a set of LFSRs with * a session key and a frame counter to produce a pseudo-random key stream. * </p> * * <p> * Note: Proper exception handling for invalid usage is to be implemented. * </p> */ public class A5KeyStreamGenerator extends CompositeLFSR { private BitSet initialFrameCounter; private BitSet frameCounter; private BitSet sessionKey; private static final int INITIAL_CLOCKING_CYCLES = 100; private static final int KEY_STREAM_LENGTH = 228; /** * Initializes the A5KeyStreamGenerator with the specified session key and frame counter. * * <p> * This method sets up the internal state of the LFSRs using the provided * session key and frame counter. It creates three LFSRs with specific * configurations and initializes them. * </p> * * @param sessionKey a BitSet representing the session key used for key stream generation. * @param frameCounter a BitSet representing the frame counter that influences the key stream. */ @Override public void initialize(BitSet sessionKey, BitSet frameCounter) { this.sessionKey = sessionKey; this.frameCounter = (BitSet) frameCounter.clone(); this.initialFrameCounter = (BitSet) frameCounter.clone(); registers.clear(); LFSR lfsr1 = new LFSR(19, 8, new int[] {13, 16, 17, 18}); LFSR lfsr2 = new LFSR(22, 10, new int[] {20, 21}); LFSR lfsr3 = new LFSR(23, 10, new int[] {7, 20, 21, 22}); registers.add(lfsr1); registers.add(lfsr2); registers.add(lfsr3); registers.forEach(lfsr -> lfsr.initialize(sessionKey, frameCounter)); } /** * Re-initializes the key stream generator with the original session key * and frame counter. This method restores the generator to its initial * state. */ public void reInitialize() { this.initialize(sessionKey, initialFrameCounter); } /** * Generates the next key stream of bits. * * <p> * This method performs an initial set of clocking cycles and then retrieves * a key stream of the specified length. After generation, it re-initializes * the internal registers. * </p> * * @return a BitSet containing the generated key stream bits. */ public BitSet getNextKeyStream() { for (int cycle = 1; cycle <= INITIAL_CLOCKING_CYCLES; ++cycle) { this.clock(); } BitSet result = new BitSet(KEY_STREAM_LENGTH); for (int cycle = 1; cycle <= KEY_STREAM_LENGTH; ++cycle) { boolean outputBit = this.clock(); result.set(cycle - 1, outputBit); } reInitializeRegisters(); return result; } /** * Re-initializes the registers for the LFSRs. * * <p> * This method increments the frame counter and re-initializes each LFSR * with the current session key and frame counter. * </p> */ private void reInitializeRegisters() { incrementFrameCounter(); registers.forEach(lfsr -> lfsr.initialize(sessionKey, frameCounter)); } /** * Increments the current frame counter. * * <p> * This method uses a utility function to increment the frame counter, * which influences the key stream generation process. * </p> */ private void incrementFrameCounter() { Utils.increment(frameCounter, FRAME_COUNTER_LENGTH); } /** * Retrieves the current frame counter. * * @return a BitSet representing the current state of the frame counter. */ public BitSet getFrameCounter() { return frameCounter; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.util.Arrays; import java.util.HashMap; import java.util.Map; public class ADFGVXCipher { private static final char[] a = new char[]{'A', 'D', 'F', 'G', 'V', 'X'}; private static final char[][] b = new char[][]{{'N', 'A', '1', 'C', '3', 'H'}, {'8', 'T', 'B', '2', 'O', 'M'}, {'E', '5', 'W', 'R', 'P', 'D'}, {'4', 'F', '6', 'G', '7', 'I'}, {'9', 'J', '0', 'K', 'L', 'Q'}, {'S', 'U', 'V', 'X', 'Y', 'Z'}}; private static final Map c = new HashMap(); private static final Map d = new HashMap(); /* * WARNING - void declaration */ public String encrypt(String object, String string) { void var6_16; char[][] cArray; int n; object = ((String)object).toUpperCase().replaceAll(\"[^A-Z0-9]\", \"\"); StringBuilder stringBuilder = new StringBuilder(); char[] cArray2 = ((String)object).toCharArray(); object = cArray2; int n2 = cArray2.length; for (n = 0; n < n2; ++n) { Object object2 = object[n]; stringBuilder.append((String)d.get(Character.valueOf((char)object2))); } object = stringBuilder.toString(); int n3 = (int)Math.ceil((double)((String)object).length() / (double)string.length()); char[][] cArray3 = cArray = new char[n3][string.length()]; n = cArray.length; boolean cArray6 = false; while (var6_16 < n) { char[] cArray4 = cArray3[var6_16]; Arrays.fill(cArray4, '_'); ++var6_16; } for (int i = 0; i < ((String)object).length(); ++i) { cArray[i / string.length()][i % string.length()] = ((String)object).charAt(i); } StringBuilder stringBuilder2 = new StringBuilder(); char[] cArray5 = string.toCharArray(); Arrays.sort(cArray5); char[] cArray7 = cArray5; int n4 = cArray5.length; for (int i = 0; i < n4; ++i) { int n5 = cArray7[i]; n5 = string.indexOf(n5); char[][] cArray8 = cArray; int n6 = cArray.length; for (int j = 0; j < n6; ++j) { char[] cArray9 = cArray8[j]; if (cArray9[n5] == '_') continue; stringBuilder2.append(cArray9[n5]); } } return stringBuilder2.toString(); } public String decrypt(String string, String charSequence) { int n = (int)Math.ceil((double)string.length() / (double)((String)charSequence).length()); Object object = new char[n][((String)charSequence).length()]; Object object2 = ((String)charSequence).toCharArray(); Arrays.sort((char[])object2); int n2 = 0; for (int n3 : object2) { int n4 = ((String)charSequence).indexOf(n3); for (int i = 0; i < n; ++i) { object[i][n4] = n2 < string.length() ? string.charAt(n2++) : (char)95; } } object2 = new StringBuilder(); char[][] cArray = object; int n5 = ((char[][])object).length; for (int n3 = 0; n3 < n5; ++n3) { char[] cArray2; char[] cArray3 = cArray2 = cArray[n3]; int n6 = cArray2.length; for (int i = 0; i < n6; ++i) { n = cArray3[i]; if (n == 95) continue; ((StringBuilder)object2).append((char)n); } } string = ((StringBuilder)object2).toString(); charSequence = new StringBuilder(); for (n = 0; n < string.length(); n += 2) { int n7 = n; object = string.substring(n7, n7 + 2); ((StringBuilder)charSequence).append(c.get(object)); } return ((StringBuilder)charSequence).toString(); } static { for (int i = 0; i < b.length; ++i) { for (int j = 0; j < b[i].length; ++j) { String string = \"\" + a[i] + a[j]; c.put(string, Character.valueOf(b[i][j])); d.put(Character.valueOf(b[i][j]), string); } } } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.util.Arrays; import java.util.HashMap; import java.util.Map; /** * The ADFGVX cipher is a fractionating transposition cipher that was used by * the German Army during World War I. It combines a **Polybius square substitution** * with a **columnar transposition** to enhance encryption strength. * <p> * The name \"ADFGVX\" refers to the six letters (A, D, F, G, V, X) used as row and * column labels in the Polybius square. This cipher was designed to secure * communication and create complex, hard-to-break ciphertexts. * <p> * Learn more: <a href=\"https://en.wikipedia.org/wiki/ADFGVX_cipher\">ADFGVX Cipher - Wikipedia</a>. * <p> * Example usage: * <pre> * ADFGVXCipher cipher = new ADFGVXCipher(); * String encrypted = cipher.encrypt(\"attack at 1200am\", \"PRIVACY\"); * String decrypted = cipher.decrypt(encrypted, \"PRIVACY\"); * </pre> * * @author bennybebo */ public class ADFGVXCipher { // Constants used in the Polybius square private static final char[] POLYBIUS_LETTERS = {'A', 'D', 'F', 'G', 'V', 'X'}; private static final char[][] POLYBIUS_SQUARE = {{'N', 'A', '1', 'C', '3', 'H'}, {'8', 'T', 'B', '2', 'O', 'M'}, {'E', '5', 'W', 'R', 'P', 'D'}, {'4', 'F', '6', 'G', '7', 'I'}, {'9', 'J', '0', 'K', 'L', 'Q'}, {'S', 'U', 'V', 'X', 'Y', 'Z'}}; // Maps for fast substitution lookups private static final Map<String, Character> POLYBIUS_MAP = new HashMap<>(); private static final Map<Character, String> REVERSE_POLYBIUS_MAP = new HashMap<>(); // Static block to initialize the lookup tables from the Polybius square static { for (int i = 0; i < POLYBIUS_SQUARE.length; i++) { for (int j = 0; j < POLYBIUS_SQUARE[i].length; j++) { String key = \"\" + POLYBIUS_LETTERS[i] + POLYBIUS_LETTERS[j]; POLYBIUS_MAP.put(key, POLYBIUS_SQUARE[i][j]); REVERSE_POLYBIUS_MAP.put(POLYBIUS_SQUARE[i][j], key); } } } /** * Encrypts a given plaintext using the ADFGVX cipher with the provided keyword. * Steps: * 1. Substitute each letter in the plaintext with a pair of ADFGVX letters. * 2. Perform a columnar transposition on the fractionated text using the keyword. * * @param plaintext The message to be encrypted (can contain letters and digits). * @param key The keyword for columnar transposition. * @return The encrypted message as ciphertext. */ public String encrypt(String plaintext, String key) { plaintext = plaintext.toUpperCase().replaceAll(\"[^A-Z0-9]\", \"\"); // Sanitize input StringBuilder fractionatedText = new StringBuilder(); for (char c : plaintext.toCharArray()) { fractionatedText.append(REVERSE_POLYBIUS_MAP.get(c)); } return columnarTransposition(fractionatedText.toString(), key); } /** * Decrypts a given ciphertext using the ADFGVX cipher with the provided keyword. * Steps: * 1. Reverse the columnar transposition performed during encryption. * 2. Substitute each pair of ADFGVX letters with the corresponding plaintext letter. * The resulting text is the decrypted message. * * @param ciphertext The encrypted message. * @param key The keyword used during encryption. * @return The decrypted plaintext message. */ public String decrypt(String ciphertext, String key) { String fractionatedText = reverseColumnarTransposition(ciphertext, key); StringBuilder plaintext = new StringBuilder(); for (int i = 0; i < fractionatedText.length(); i += 2) { String pair = fractionatedText.substring(i, i + 2); plaintext.append(POLYBIUS_MAP.get(pair)); } return plaintext.toString(); } /** * Helper method: Performs columnar transposition during encryption * * @param text The fractionated text to be transposed * @param key The keyword for columnar transposition * @return The transposed text */ private String columnarTransposition(String text, String key) { int numRows = (int) Math.ceil((double) text.length() / key.length()); char[][] table = new char[numRows][key.length()]; for (char[] row : table) { // Fill empty cells with underscores Arrays.fill(row, '_'); } // Populate the table row by row for (int i = 0; i < text.length(); i++) { table[i / key.length()][i % key.length()] = text.charAt(i); } // Read columns based on the alphabetical order of the key StringBuilder ciphertext = new StringBuilder(); char[] sortedKey = key.toCharArray(); Arrays.sort(sortedKey); for (char keyChar : sortedKey) { int column = key.indexOf(keyChar); for (char[] row : table) { if (row[column] != '_') { ciphertext.append(row[column]); } } } return ciphertext.toString(); } /** * Helper method: Reverses the columnar transposition during decryption * * @param ciphertext The transposed text to be reversed * @param key The keyword used during encryption * @return The reversed text */ private String reverseColumnarTransposition(String ciphertext, String key) { int numRows = (int) Math.ceil((double) ciphertext.length() / key.length()); char[][] table = new char[numRows][key.length()]; char[] sortedKey = key.toCharArray(); Arrays.sort(sortedKey); int index = 0; // Populate the table column by column according to the sorted key for (char keyChar : sortedKey) { int column = key.indexOf(keyChar); for (int row = 0; row < numRows; row++) { if (index < ciphertext.length()) { table[row][column] = ciphertext.charAt(index++); } else { table[row][column] = '_'; } } } // Read the table row by row to reconstruct the fractionated text StringBuilder fractionatedText = new StringBuilder(); for (char[] row : table) { for (char cell : row) { if (cell != '_') { fractionatedText.append(cell); } } } return fractionatedText.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; public final class ADTFraction extends Record { private final int a; private final int b; public ADTFraction(int n, int n2) { if (n2 == 0) { throw new IllegalArgumentException(\"Denominator cannot be 0\"); } this.a = n; this.b = n2; } public final ADTFraction plus(ADTFraction aDTFraction) { int n = this.b * aDTFraction.a + this.a * aDTFraction.b; int n2 = this.b * aDTFraction.b; return new ADTFraction(n, n2); } public final ADTFraction times(int n) { return this.times(new ADTFraction(n, 1)); } public final ADTFraction times(ADTFraction aDTFraction) { int n = this.a * aDTFraction.a; int n2 = this.b * aDTFraction.b; return new ADTFraction(n, n2); } public final ADTFraction reciprocal() { return new ADTFraction(this.b, this.a); } public final float value() { return (float)this.a / (float)this.b; } @Override public final String toString() { return String.format(\"%d/%d\", this.a, this.b); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{ADTFraction.class, \"numerator;denominator\", \"a\", \"b\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{ADTFraction.class, \"numerator;denominator\", \"a\", \"b\"}, this, object); } public final int numerator() { return this.a; } public final int denominator() { return this.b; } }", "deobfuscated_code": "package com.thealgorithms.maths; public record ADTFraction(int numerator, int denominator) { /** * Initializes a newly created {@code ADTFraction} object so that it represents * a fraction with the {@code numerator} and {@code denominator} provided as arguments. * * @param numerator The fraction numerator * @param denominator The fraction denominator */ public ADTFraction { if (denominator == 0) { throw new IllegalArgumentException(\"Denominator cannot be 0\"); } } /** * Add two fractions. * * @param fraction the {@code ADTFraction} to add * @return A new {@code ADTFraction} containing the result of the operation */ public ADTFraction plus(ADTFraction fraction) { var numerator = this.denominator * fraction.numerator + this.numerator * fraction.denominator; var denominator = this.denominator * fraction.denominator; return new ADTFraction(numerator, denominator); } /** * Multiply fraction by a number. * * @param number the number to multiply * @return A new {@code ADTFraction} containing the result of the operation */ public ADTFraction times(int number) { return times(new ADTFraction(number, 1)); } /** * Multiply two fractions. * * @param fraction the {@code ADTFraction} to multiply * @return A new {@code ADTFraction} containing the result of the operation */ public ADTFraction times(ADTFraction fraction) { var numerator = this.numerator * fraction.numerator; var denominator = this.denominator * fraction.denominator; return new ADTFraction(numerator, denominator); } /** * Generates the reciprocal of the fraction. * * @return A new {@code ADTFraction} with the {@code numerator} and {@code denominator} switched */ public ADTFraction reciprocal() { return new ADTFraction(this.denominator, this.numerator); } /** * Calculates the result of the fraction. * * @return The numerical result of the division between {@code numerator} and {@code * denominator} */ public float value() { return (float) this.numerator / this.denominator; } /** * Returns a string representation of this {@code ADTFraction} in the format * {@code numerator}/{@code denominator}. * * @return A string representation of this {@code ADTFraction} */ @Override public String toString() { return String.format(\"%d/%d\", this.numerator, this.denominator); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.math.BigInteger; import java.util.Scanner; public final class AES { private static final int[] a = new int[]{141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141}; private static final int[] b = new int[]{99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22}; private static final int[] c = new int[]{82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125}; private static final int[] d = new int[]{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 27, 25, 31, 29, 19, 17, 23, 21, 11, 9, 15, 13, 3, 1, 7, 5, 59, 57, 63, 61, 51, 49, 55, 53, 43, 41, 47, 45, 35, 33, 39, 37, 91, 89, 95, 93, 83, 81, 87, 85, 75, 73, 79, 77, 67, 65, 71, 69, 123, 121, 127, 125, 115, 113, 119, 117, 107, 105, 111, 109, 99, 97, 103, 101, 155, 153, 159, 157, 147, 145, 151, 149, 139, 137, 143, 141, 131, 129, 135, 133, 187, 185, 191, 189, 179, 177, 183, 181, 171, 169, 175, 173, 163, 161, 167, 165, 219, 217, 223, 221, 211, 209, 215, 213, 203, 201, 207, 205, 195, 193, 199, 197, 251, 249, 255, 253, 243, 241, 247, 245, 235, 233, 239, 237, 227, 225, 231, 229}; private static final int[] e = new int[]{0, 3, 6, 5, 12, 15, 10, 9, 24, 27, 30, 29, 20, 23, 18, 17, 48, 51, 54, 53, 60, 63, 58, 57, 40, 43, 46, 45, 36, 39, 34, 33, 96, 99, 102, 101, 108, 111, 106, 105, 120, 123, 126, 125, 116, 119, 114, 113, 80, 83, 86, 85, 92, 95, 90, 89, 72, 75, 78, 77, 68, 71, 66, 65, 192, 195, 198, 197, 204, 207, 202, 201, 216, 219, 222, 221, 212, 215, 210, 209, 240, 243, 246, 245, 252, 255, 250, 249, 232, 235, 238, 237, 228, 231, 226, 225, 160, 163, 166, 165, 172, 175, 170, 169, 184, 187, 190, 189, 180, 183, 178, 177, 144, 147, 150, 149, 156, 159, 154, 153, 136, 139, 142, 141, 132, 135, 130, 129, 155, 152, 157, 158, 151, 148, 145, 146, 131, 128, 133, 134, 143, 140, 137, 138, 171, 168, 173, 174, 167, 164, 161, 162, 179, 176, 181, 182, 191, 188, 185, 186, 251, 248, 253, 254, 247, 244, 241, 242, 227, 224, 229, 230, 239, 236, 233, 234, 203, 200, 205, 206, 199, 196, 193, 194, 211, 208, 213, 214, 223, 220, 217, 218, 91, 88, 93, 94, 87, 84, 81, 82, 67, 64, 69, 70, 79, 76, 73, 74, 107, 104, 109, 110, 103, 100, 97, 98, 115, 112, 117, 118, 127, 124, 121, 122, 59, 56, 61, 62, 55, 52, 49, 50, 35, 32, 37, 38, 47, 44, 41, 42, 11, 8, 13, 14, 7, 4, 1, 2, 19, 16, 21, 22, 31, 28, 25, 26}; private static final int[] f = new int[]{0, 9, 18, 27, 36, 45, 54, 63, 72, 65, 90, 83, 108, 101, 126, 119, 144, 153, 130, 139, 180, 189, 166, 175, 216, 209, 202, 195, 252, 245, 238, 231, 59, 50, 41, 32, 31, 22, 13, 4, 115, 122, 97, 104, 87, 94, 69, 76, 171, 162, 185, 176, 143, 134, 157, 148, 227, 234, 241, 248, 199, 206, 213, 220, 118, 127, 100, 109, 82, 91, 64, 73, 62, 55, 44, 37, 26, 19, 8, 1, 230, 239, 244, 253, 194, 203, 208, 217, 174, 167, 188, 181, 138, 131, 152, 145, 77, 68, 95, 86, 105, 96, 123, 114, 5, 12, 23, 30, 33, 40, 51, 58, 221, 212, 207, 198, 249, 240, 235, 226, 149, 156, 135, 142, 177, 184, 163, 170, 236, 229, 254, 247, 200, 193, 218, 211, 164, 173, 182, 191, 128, 137, 146, 155, 124, 117, 110, 103, 88, 81, 74, 67, 52, 61, 38, 47, 16, 25, 2, 11, 215, 222, 197, 204, 243, 250, 225, 232, 159, 150, 141, 132, 187, 178, 169, 160, 71, 78, 85, 92, 99, 106, 113, 120, 15, 6, 29, 20, 43, 34, 57, 48, 154, 147, 136, 129, 190, 183, 172, 165, 210, 219, 192, 201, 246, 255, 228, 237, 10, 3, 24, 17, 46, 39, 60, 53, 66, 75, 80, 89, 102, 111, 116, 125, 161, 168, 179, 186, 133, 140, 151, 158, 233, 224, 251, 242, 205, 196, 223, 214, 49, 56, 35, 42, 21, 28, 7, 14, 121, 112, 107, 98, 93, 84, 79, 70}; private static final int[] g = new int[]{0, 11, 22, 29, 44, 39, 58, 49, 88, 83, 78, 69, 116, 127, 98, 105, 176, 187, 166, 173, 156, 151, 138, 129, 232, 227, 254, 245, 196, 207, 210, 217, 123, 112, 109, 102, 87, 92, 65, 74, 35, 40, 53, 62, 15, 4, 25, 18, 203, 192, 221, 214, 231, 236, 241, 250, 147, 152, 133, 142, 191, 180, 169, 162, 246, 253, 224, 235, 218, 209, 204, 199, 174, 165, 184, 179, 130, 137, 148, 159, 70, 77, 80, 91, 106, 97, 124, 119, 30, 21, 8, 3, 50, 57, 36, 47, 141, 134, 155, 144, 161, 170, 183, 188, 213, 222, 195, 200, 249, 242, 239, 228, 61, 54, 43, 32, 17, 26, 7, 12, 101, 110, 115, 120, 73, 66, 95, 84, 247, 252, 225, 234, 219, 208, 205, 198, 175, 164, 185, 178, 131, 136, 149, 158, 71, 76, 81, 90, 107, 96, 125, 118, 31, 20, 9, 2, 51, 56, 37, 46, 140, 135, 154, 145, 160, 171, 182, 189, 212, 223, 194, 201, 248, 243, 238, 229, 60, 55, 42, 33, 16, 27, 6, 13, 100, 111, 114, 121, 72, 67, 94, 85, 1, 10, 23, 28, 45, 38, 59, 48, 89, 82, 79, 68, 117, 126, 99, 104, 177, 186, 167, 172, 157, 150, 139, 128, 233, 226, 255, 244, 197, 206, 211, 216, 122, 113, 108, 103, 86, 93, 64, 75, 34, 41, 52, 63, 14, 5, 24, 19, 202, 193, 220, 215, 230, 237, 240, 251, 146, 153, 132, 143, 190, 181, 168, 163}; private static final int[] h = new int[]{0, 13, 26, 23, 52, 57, 46, 35, 104, 101, 114, 127, 92, 81, 70, 75, 208, 221, 202, 199, 228, 233, 254, 243, 184, 181, 162, 175, 140, 129, 150, 155, 187, 182, 161, 172, 143, 130, 149, 152, 211, 222, 201, 196, 231, 234, 253, 240, 107, 102, 113, 124, 95, 82, 69, 72, 3, 14, 25, 20, 55, 58, 45, 32, 109, 96, 119, 122, 89, 84, 67, 78, 5, 8, 31, 18, 49, 60, 43, 38, 189, 176, 167, 170, 137, 132, 147, 158, 213, 216, 207, 194, 225, 236, 251, 246, 214, 219, 204, 193, 226, 239, 248, 245, 190, 179, 164, 169, 138, 135, 144, 157, 6, 11, 28, 17, 50, 63, 40, 37, 110, 99, 116, 121, 90, 87, 64, 77, 218, 215, 192, 205, 238, 227, 244, 249, 178, 191, 168, 165, 134, 139, 156, 145, 10, 7, 16, 29, 62, 51, 36, 41, 98, 111, 120, 117, 86, 91, 76, 65, 97, 108, 123, 118, 85, 88, 79, 66, 9, 4, 19, 30, 61, 48, 39, 42, 177, 188, 171, 166, 133, 136, 159, 146, 217, 212, 195, 206, 237, 224, 247, 250, 183, 186, 173, 160, 131, 142, 153, 148, 223, 210, 197, 200, 235, 230, 241, 252, 103, 106, 125, 112, 83, 94, 73, 68, 15, 2, 21, 24, 59, 54, 33, 44, 12, 1, 22, 27, 56, 53, 34, 47, 100, 105, 126, 115, 80, 93, 74, 71, 220, 209, 198, 203, 232, 229, 242, 255, 180, 185, 174, 163, 128, 141, 154, 151}; private static final int[] i = new int[]{0, 14, 28, 18, 56, 54, 36, 42, 112, 126, 108, 98, 72, 70, 84, 90, 224, 238, 252, 242, 216, 214, 196, 202, 144, 158, 140, 130, 168, 166, 180, 186, 219, 213, 199, 201, 227, 237, 255, 241, 171, 165, 183, 185, 147, 157, 143, 129, 59, 53, 39, 41, 3, 13, 31, 17, 75, 69, 87, 89, 115, 125, 111, 97, 173, 163, 177, 191, 149, 155, 137, 135, 221, 211, 193, 207, 229, 235, 249, 247, 77, 67, 81, 95, 117, 123, 105, 103, 61, 51, 33, 47, 5, 11, 25, 23, 118, 120, 106, 100, 78, 64, 82, 92, 6, 8, 26, 20, 62, 48, 34, 44, 150, 152, 138, 132, 174, 160, 178, 188, 230, 232, 250, 244, 222, 208, 194, 204, 65, 79, 93, 83, 121, 119, 101, 107, 49, 63, 45, 35, 9, 7, 21, 27, 161, 175, 189, 179, 153, 151, 133, 139, 209, 223, 205, 195, 233, 231, 245, 251, 154, 148, 134, 136, 162, 172, 190, 176, 234, 228, 246, 248, 210, 220, 206, 192, 122, 116, 102, 104, 66, 76, 94, 80, 10, 4, 22, 24, 50, 60, 46, 32, 236, 226, 240, 254, 212, 218, 200, 198, 156, 146, 128, 142, 164, 170, 184, 182, 12, 2, 16, 30, 52, 58, 40, 38, 124, 114, 96, 110, 68, 74, 88, 86, 55, 57, 43, 37, 15, 1, 19, 29, 71, 73, 91, 85, 127, 113, 99, 109, 215, 217, 203, 197, 239, 225, 243, 253, 167, 169, 187, 181, 159, 145, 131, 141}; private AES() { } public static BigInteger scheduleCore(BigInteger object, int n) { object = new StringBuilder(((BigInteger)object).toString(16)); while (((StringBuilder)object).length() < 8) { ((StringBuilder)object).insert(0, \"0\"); } String string = ((StringBuilder)object).substring(0, 2); object = ((StringBuilder)object).substring(2); object = new StringBuilder((String)object + string); for (int i = 0; i < 4; ++i) { StringBuilder stringBuilder = new StringBuilder(((StringBuilder)object).substring(i << 1, i + 1 << 1)); int n2 = Integer.parseInt(stringBuilder.toString(), 16); n2 = b[n2]; if (i == 0) { n2 ^= a[n]; } stringBuilder = new StringBuilder(Integer.toHexString(n2)); while (stringBuilder.length() < 2) { stringBuilder.insert(0, '0'); } object = new StringBuilder(((StringBuilder)object).substring(0, i << 1) + String.valueOf(stringBuilder) + ((StringBuilder)object).substring(i + 1 << 1)); } return new BigInteger(((StringBuilder)object).toString(), 16); } public static BigInteger[] keyExpansion(BigInteger bigIntegerArray) { bigIntegerArray = new BigInteger[]{bigIntegerArray, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO}; int n = 1; for (int i = 1; i < 11; ++i) { BigInteger bigInteger = bigIntegerArray[i - 1].remainder(new BigInteger(\"100000000\", 16)); Object object = new BigInteger[]{bigIntegerArray[i - 1].remainder(new BigInteger(\"100000000\", 16)), bigIntegerArray[i - 1].remainder(new BigInteger(\"10000000000000000\", 16)).divide(new BigInteger(\"100000000\", 16)), bigIntegerArray[i - 1].remainder(new BigInteger(\"1000000000000000000000000\", 16)).divide(new BigInteger(\"10000000000000000\", 16)), bigIntegerArray[i - 1].divide(new BigInteger(\"1000000000000000000000000\", 16))}; bigInteger = AES.scheduleCore(bigInteger, n); ++n; bigInteger = bigInteger.xor(object[3]); BigInteger bigInteger2 = bigInteger.xor(object[2]); BigInteger bigInteger3 = bigInteger2.xor(object[1]); object = bigInteger3.xor(object[0]); bigInteger3 = bigInteger3.multiply(new BigInteger(\"100000000\", 16)); bigInteger2 = bigInteger2.multiply(new BigInteger(\"10000000000000000\", 16)); bigInteger = bigInteger.multiply(new BigInteger(\"1000000000000000000000000\", 16)); bigIntegerArray[i] = bigInteger.add(bigInteger2).add(bigInteger3).add((BigInteger)object); } return bigIntegerArray; } public static int[] splitBlockIntoCells(BigInteger comparable) { int[] nArray = new int[16]; comparable = new StringBuilder(((BigInteger)comparable).toString(2)); while (((StringBuilder)comparable).length() < 128) { ((StringBuilder)comparable).insert(0, '0'); } for (int i = 0; i < nArray.length; ++i) { String string = ((StringBuilder)comparable).substring(i * 8, 8 * (i + 1)); nArray[i] = Integer.parseInt(string, 2); } return nArray; } public static BigInteger mergeCellsIntoBlock(int[] nArray) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < 16; ++i) { StringBuilder stringBuilder2 = new StringBuilder(Integer.toBinaryString(nArray[i])); while (stringBuilder2.length() < 8) { stringBuilder2.insert(0, '0'); } stringBuilder.append((CharSequence)stringBuilder2); } return new BigInteger(stringBuilder.toString(), 2); } public static BigInteger addRoundKey(BigInteger bigInteger, BigInteger bigInteger2) { return bigInteger.xor(bigInteger2); } public static BigInteger subBytes(BigInteger object) { object = AES.splitBlockIntoCells((BigInteger)object); for (int i = 0; i < 16; ++i) { object[i] = b[object[i]]; } return AES.mergeCellsIntoBlock((int[])object); } public static BigInteger subBytesDec(BigInteger object) { object = AES.splitBlockIntoCells((BigInteger)object); for (int i = 0; i < 16; ++i) { object[i] = c[object[i]]; } return AES.mergeCellsIntoBlock((int[])object); } public static BigInteger shiftRows(BigInteger object) { object = AES.splitBlockIntoCells((BigInteger)object); int[] nArray = new int[16]; int[] nArray2 = nArray; nArray[0] = (int)object[0]; nArray2[4] = (int)object[4]; nArray2[8] = (int)object[8]; nArray2[12] = (int)object[12]; nArray2[1] = (int)object[5]; nArray2[5] = (int)object[9]; nArray2[9] = (int)object[13]; nArray2[13] = (int)object[1]; nArray2[2] = (int)object[10]; nArray2[6] = (int)object[14]; nArray2[10] = (int)object[2]; nArray2[14] = (int)object[6]; nArray2[3] = (int)object[15]; nArray2[7] = (int)object[3]; nArray2[11] = (int)object[7]; nArray2[15] = (int)object[11]; return AES.mergeCellsIntoBlock(nArray2); } public static BigInteger shiftRowsDec(BigInteger object) { object = AES.splitBlockIntoCells((BigInteger)object); int[] nArray = new int[16]; int[] nArray2 = nArray; nArray[0] = (int)object[0]; nArray2[4] = (int)object[4]; nArray2[8] = (int)object[8]; nArray2[12] = (int)object[12]; nArray2[1] = (int)object[13]; nArray2[5] = (int)object[1]; nArray2[9] = (int)object[5]; nArray2[13] = (int)object[9]; nArray2[2] = (int)object[10]; nArray2[6] = (int)object[14]; nArray2[10] = (int)object[2]; nArray2[14] = (int)object[6]; nArray2[3] = (int)object[7]; nArray2[7] = (int)object[11]; nArray2[11] = (int)object[15]; nArray2[15] = (int)object[3]; return AES.mergeCellsIntoBlock(nArray2); } public static BigInteger mixColumns(BigInteger object) { object = AES.splitBlockIntoCells((BigInteger)object); int[] nArray = new int[16]; for (int i = 0; i < 4; ++i) { int[] nArray2 = new int[]{(int)object[i << 2], (int)object[(i << 2) + 1], (int)object[(i << 2) + 2], (int)object[(i << 2) + 3]}; nArray[i << 2] = d[nArray2[0]] ^ e[nArray2[1]] ^ nArray2[2] ^ nArray2[3]; nArray[(i << 2) + 1] = nArray2[0] ^ d[nArray2[1]] ^ e[nArray2[2]] ^ nArray2[3]; nArray[(i << 2) + 2] = nArray2[0] ^ nArray2[1] ^ d[nArray2[2]] ^ e[nArray2[3]]; nArray[(i << 2) + 3] = e[nArray2[0]] ^ nArray2[1] ^ nArray2[2] ^ d[nArray2[3]]; } return AES.mergeCellsIntoBlock(nArray); } public static BigInteger mixColumnsDec(BigInteger object) { object = AES.splitBlockIntoCells((BigInteger)object); int[] nArray = new int[16]; for (int i = 0; i < 4; ++i) { int[] nArray2 = new int[]{(int)object[i << 2], (int)object[(i << 2) + 1], (int)object[(i << 2) + 2], (int)object[(i << 2) + 3]}; nArray[i << 2] = AES.i[nArray2[0]] ^ g[nArray2[1]] ^ h[nArray2[2]] ^ f[nArray2[3]]; nArray[(i << 2) + 1] = f[nArray2[0]] ^ AES.i[nArray2[1]] ^ g[nArray2[2]] ^ h[nArray2[3]]; nArray[(i << 2) + 2] = h[nArray2[0]] ^ f[nArray2[1]] ^ AES.i[nArray2[2]] ^ g[nArray2[3]]; nArray[(i << 2) + 3] = g[nArray2[0]] ^ h[nArray2[1]] ^ f[nArray2[2]] ^ AES.i[nArray2[3]]; } return AES.mergeCellsIntoBlock(nArray); } public static BigInteger encrypt(BigInteger bigInteger, BigInteger bigIntegerArray) { bigIntegerArray = AES.keyExpansion((BigInteger)bigIntegerArray); bigInteger = AES.addRoundKey(bigInteger, bigIntegerArray[0]); for (int i = 1; i < 10; ++i) { bigInteger = AES.subBytes(bigInteger); bigInteger = AES.shiftRows(bigInteger); bigInteger = AES.mixColumns(bigInteger); bigInteger = AES.addRoundKey(bigInteger, bigIntegerArray[i]); } bigInteger = AES.subBytes(bigInteger); bigInteger = AES.shiftRows(bigInteger); bigInteger = AES.addRoundKey(bigInteger, bigIntegerArray[10]); return bigInteger; } public static BigInteger decrypt(BigInteger bigInteger, BigInteger bigIntegerArray) { bigIntegerArray = AES.keyExpansion((BigInteger)bigIntegerArray); bigInteger = AES.addRoundKey(bigInteger, bigIntegerArray[10]); bigInteger = AES.shiftRowsDec(bigInteger); bigInteger = AES.subBytesDec(bigInteger); for (int i = 9; i > 0; --i) { bigInteger = AES.addRoundKey(bigInteger, bigIntegerArray[i]); bigInteger = AES.mixColumnsDec(bigInteger); bigInteger = AES.shiftRowsDec(bigInteger); bigInteger = AES.subBytesDec(bigInteger); } bigInteger = AES.addRoundKey(bigInteger, bigIntegerArray[0]); return bigInteger; } /* * Enabled force condition propagation * Lifted jumps to return sites */ public static void main(String[] object) { object = new Scanner(System.in); try { System.out.println(\"Enter (e) letter for encrpyt or (d) letter for decrypt :\"); char c = ((Scanner)object).nextLine().charAt(0); switch (c) { case 'E': case 'e': { System.out.println(\"Choose a plaintext block (128-Bit Integer in base 16):\"); Object object2 = ((Scanner)object).nextLine(); BigInteger bigInteger = new BigInteger((String)object2, 16); System.out.println(\"Choose a Key (128-Bit Integer in base 16):\"); object2 = ((Scanner)object).nextLine(); object2 = new BigInteger((String)object2, 16); System.out.println(\"The encrypted message is: \\n\" + AES.encrypt(bigInteger, (BigInteger)object2).toString(16)); return; } case 'D': case 'd': { System.out.println(\"Enter your ciphertext block (128-Bit Integer in base 16):\"); Object object3 = ((Scanner)object).nextLine(); BigInteger bigInteger = new BigInteger((String)object3, 16); System.out.println(\"Choose a Key (128-Bit Integer in base 16):\"); object3 = ((Scanner)object).nextLine(); object3 = new BigInteger((String)object3, 16); System.out.println(\"The deciphered message is:\\n\" + AES.decrypt(bigInteger, (BigInteger)object3).toString(16)); return; } default: { System.out.println(\"** End **\"); return; } } } finally { ((Scanner)object).close(); } } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.math.BigInteger; import java.util.Scanner; /** * This class is build to demonstrate the application of the AES-algorithm on a * single 128-Bit block of data. */ public final class AES { private AES() { } /** * Precalculated values for x to the power of 2 in Rijndaels galois field. * Used as 'RCON' during the key expansion. */ private static final int[] RCON = { 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, }; /** * Rijndael S-box Substitution table used for encryption in the subBytes * step, as well as the key expansion. */ private static final int[] SBOX = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, }; /** * Inverse Rijndael S-box Substitution table used for decryption in the * subBytesDec step. */ private static final int[] INVERSE_SBOX = { 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D, }; /** * Precalculated lookup table for galois field multiplication by 2 used in * the MixColums step during encryption. */ private static final int[] MULT2 = { 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05, 0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25, 0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65, 0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85, 0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5, 0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5, 0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5, }; /** * Precalculated lookup table for galois field multiplication by 3 used in * the MixColums step during encryption. */ private static final int[] MULT3 = { 0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11, 0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21, 0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71, 0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41, 0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1, 0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1, 0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1, 0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81, 0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a, 0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba, 0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea, 0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda, 0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a, 0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a, 0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a, 0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a, }; /** * Precalculated lookup table for galois field multiplication by 9 used in * the MixColums step during decryption. */ private static final int[] MULT9 = { 0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77, 0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7, 0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c, 0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc, 0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01, 0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91, 0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a, 0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa, 0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b, 0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b, 0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0, 0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30, 0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed, 0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d, 0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6, 0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46, }; /** * Precalculated lookup table for galois field multiplication by 11 used in * the MixColums step during decryption. */ private static final int[] MULT11 = { 0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69, 0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9, 0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12, 0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2, 0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f, 0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f, 0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4, 0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54, 0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e, 0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e, 0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5, 0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55, 0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68, 0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8, 0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13, 0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3, }; /** * Precalculated lookup table for galois field multiplication by 13 used in * the MixColums step during decryption. */ private static final int[] MULT13 = { 0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b, 0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b, 0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0, 0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20, 0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26, 0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6, 0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d, 0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d, 0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91, 0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41, 0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a, 0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa, 0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc, 0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c, 0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47, 0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97, }; /** * Precalculated lookup table for galois field multiplication by 14 used in * the MixColums step during decryption. */ private static final int[] MULT14 = { 0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a, 0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba, 0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81, 0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61, 0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7, 0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17, 0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c, 0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc, 0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b, 0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb, 0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0, 0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20, 0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6, 0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56, 0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d, 0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d, }; /** * Subroutine of the Rijndael key expansion. */ public static BigInteger scheduleCore(BigInteger t, int rconCounter) { StringBuilder rBytes = new StringBuilder(t.toString(16)); // Add zero padding while (rBytes.length() < 8) { rBytes.insert(0, \"0\"); } // rotate the first 16 bits to the back String rotatingBytes = rBytes.substring(0, 2); String fixedBytes = rBytes.substring(2); rBytes = new StringBuilder(fixedBytes + rotatingBytes); // apply S-Box to all 8-Bit Substrings for (int i = 0; i < 4; i++) { StringBuilder currentByteBits = new StringBuilder(rBytes.substring(i * 2, (i + 1) * 2)); int currentByte = Integer.parseInt(currentByteBits.toString(), 16); currentByte = SBOX[currentByte]; // add the current RCON value to the first byte if (i == 0) { currentByte = currentByte ^ RCON[rconCounter]; } currentByteBits = new StringBuilder(Integer.toHexString(currentByte)); // Add zero padding while (currentByteBits.length() < 2) { currentByteBits.insert(0, '0'); } // replace bytes in original string rBytes = new StringBuilder(rBytes.substring(0, i * 2) + currentByteBits + rBytes.substring((i + 1) * 2)); } return new BigInteger(rBytes.toString(), 16); } /** * Returns an array of 10 + 1 round keys that are calculated by using * Rijndael key schedule * * @return array of 10 + 1 round keys */ public static BigInteger[] keyExpansion(BigInteger initialKey) { BigInteger[] roundKeys = { initialKey, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, }; // initialize rcon iteration int rconCounter = 1; for (int i = 1; i < 11; i++) { // get the previous 32 bits the key BigInteger t = roundKeys[i - 1].remainder(new BigInteger(\"100000000\", 16)); // split previous key into 8-bit segments BigInteger[] prevKey = { roundKeys[i - 1].remainder(new BigInteger(\"100000000\", 16)), roundKeys[i - 1].remainder(new BigInteger(\"10000000000000000\", 16)).divide(new BigInteger(\"100000000\", 16)), roundKeys[i - 1].remainder(new BigInteger(\"1000000000000000000000000\", 16)).divide(new BigInteger(\"10000000000000000\", 16)), roundKeys[i - 1].divide(new BigInteger(\"1000000000000000000000000\", 16)), }; // run schedule core t = scheduleCore(t, rconCounter); rconCounter += 1; // Calculate partial round key BigInteger t0 = t.xor(prevKey[3]); BigInteger t1 = t0.xor(prevKey[2]); BigInteger t2 = t1.xor(prevKey[1]); BigInteger t3 = t2.xor(prevKey[0]); // Join round key segments t2 = t2.multiply(new BigInteger(\"100000000\", 16)); t1 = t1.multiply(new BigInteger(\"10000000000000000\", 16)); t0 = t0.multiply(new BigInteger(\"1000000000000000000000000\", 16)); roundKeys[i] = t0.add(t1).add(t2).add(t3); } return roundKeys; } /** * representation of the input 128-bit block as an array of 8-bit integers. * * @param block of 128-bit integers * @return array of 8-bit integers */ public static int[] splitBlockIntoCells(BigInteger block) { int[] cells = new int[16]; StringBuilder blockBits = new StringBuilder(block.toString(2)); // Append leading 0 for full \"128-bit\" string while (blockBits.length() < 128) { blockBits.insert(0, '0'); } // split 128 to 8 bit cells for (int i = 0; i < cells.length; i++) { String cellBits = blockBits.substring(8 * i, 8 * (i + 1)); cells[i] = Integer.parseInt(cellBits, 2); } return cells; } /** * Returns the 128-bit BigInteger representation of the input of an array of * 8-bit integers. * * @param cells that we need to merge * @return block of merged cells */ public static BigInteger mergeCellsIntoBlock(int[] cells) { StringBuilder blockBits = new StringBuilder(); for (int i = 0; i < 16; i++) { StringBuilder cellBits = new StringBuilder(Integer.toBinaryString(cells[i])); // Append leading 0 for full \"8-bit\" strings while (cellBits.length() < 8) { cellBits.insert(0, '0'); } blockBits.append(cellBits); } return new BigInteger(blockBits.toString(), 2); } /** * @return ciphertext XOR key */ public static BigInteger addRoundKey(BigInteger ciphertext, BigInteger key) { return ciphertext.xor(key); } /** * substitutes 8-Bit long substrings of the input using the S-Box and * returns the result. * * @return subtraction Output */ public static BigInteger subBytes(BigInteger ciphertext) { int[] cells = splitBlockIntoCells(ciphertext); for (int i = 0; i < 16; i++) { cells[i] = SBOX[cells[i]]; } return mergeCellsIntoBlock(cells); } /** * substitutes 8-Bit long substrings of the input using the inverse S-Box * for decryption and returns the result. * * @return subtraction Output */ public static BigInteger subBytesDec(BigInteger ciphertext) { int[] cells = splitBlockIntoCells(ciphertext); for (int i = 0; i < 16; i++) { cells[i] = INVERSE_SBOX[cells[i]]; } return mergeCellsIntoBlock(cells); } /** * Cell permutation step. Shifts cells within the rows of the input and * returns the result. */ public static BigInteger shiftRows(BigInteger ciphertext) { int[] cells = splitBlockIntoCells(ciphertext); int[] output = new int[16]; // do nothing in the first row output[0] = cells[0]; output[4] = cells[4]; output[8] = cells[8]; output[12] = cells[12]; // shift the second row backwards by one cell output[1] = cells[5]; output[5] = cells[9]; output[9] = cells[13]; output[13] = cells[1]; // shift the third row backwards by two cell output[2] = cells[10]; output[6] = cells[14]; output[10] = cells[2]; output[14] = cells[6]; // shift the forth row backwards by tree cell output[3] = cells[15]; output[7] = cells[3]; output[11] = cells[7]; output[15] = cells[11]; return mergeCellsIntoBlock(output); } /** * Cell permutation step for decryption . Shifts cells within the rows of * the input and returns the result. */ public static BigInteger shiftRowsDec(BigInteger ciphertext) { int[] cells = splitBlockIntoCells(ciphertext); int[] output = new int[16]; // do nothing in the first row output[0] = cells[0]; output[4] = cells[4]; output[8] = cells[8]; output[12] = cells[12]; // shift the second row forwards by one cell output[1] = cells[13]; output[5] = cells[1]; output[9] = cells[5]; output[13] = cells[9]; // shift the third row forwards by two cell output[2] = cells[10]; output[6] = cells[14]; output[10] = cells[2]; output[14] = cells[6]; // shift the forth row forwards by tree cell output[3] = cells[7]; output[7] = cells[11]; output[11] = cells[15]; output[15] = cells[3]; return mergeCellsIntoBlock(output); } /** * Applies the Rijndael MixColumns to the input and returns the result. */ public static BigInteger mixColumns(BigInteger ciphertext) { int[] cells = splitBlockIntoCells(ciphertext); int[] outputCells = new int[16]; for (int i = 0; i < 4; i++) { int[] row = { cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3], }; outputCells[i * 4] = MULT2[row[0]] ^ MULT3[row[1]] ^ row[2] ^ row[3]; outputCells[i * 4 + 1] = row[0] ^ MULT2[row[1]] ^ MULT3[row[2]] ^ row[3]; outputCells[i * 4 + 2] = row[0] ^ row[1] ^ MULT2[row[2]] ^ MULT3[row[3]]; outputCells[i * 4 + 3] = MULT3[row[0]] ^ row[1] ^ row[2] ^ MULT2[row[3]]; } return mergeCellsIntoBlock(outputCells); } /** * Applies the inverse Rijndael MixColumns for decryption to the input and * returns the result. */ public static BigInteger mixColumnsDec(BigInteger ciphertext) { int[] cells = splitBlockIntoCells(ciphertext); int[] outputCells = new int[16]; for (int i = 0; i < 4; i++) { int[] row = { cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3], }; outputCells[i * 4] = MULT14[row[0]] ^ MULT11[row[1]] ^ MULT13[row[2]] ^ MULT9[row[3]]; outputCells[i * 4 + 1] = MULT9[row[0]] ^ MULT14[row[1]] ^ MULT11[row[2]] ^ MULT13[row[3]]; outputCells[i * 4 + 2] = MULT13[row[0]] ^ MULT9[row[1]] ^ MULT14[row[2]] ^ MULT11[row[3]]; outputCells[i * 4 + 3] = MULT11[row[0]] ^ MULT13[row[1]] ^ MULT9[row[2]] ^ MULT14[row[3]]; } return mergeCellsIntoBlock(outputCells); } /** * Encrypts the plaintext with the key and returns the result * * @param plainText which we want to encrypt * @param key the key for encrypt * @return EncryptedText */ public static BigInteger encrypt(BigInteger plainText, BigInteger key) { BigInteger[] roundKeys = keyExpansion(key); // Initial round plainText = addRoundKey(plainText, roundKeys[0]); // Main rounds for (int i = 1; i < 10; i++) { plainText = subBytes(plainText); plainText = shiftRows(plainText); plainText = mixColumns(plainText); plainText = addRoundKey(plainText, roundKeys[i]); } // Final round plainText = subBytes(plainText); plainText = shiftRows(plainText); plainText = addRoundKey(plainText, roundKeys[10]); return plainText; } /** * Decrypts the ciphertext with the key and returns the result * * @param cipherText The Encrypted text which we want to decrypt * @return decryptedText */ public static BigInteger decrypt(BigInteger cipherText, BigInteger key) { BigInteger[] roundKeys = keyExpansion(key); // Invert final round cipherText = addRoundKey(cipherText, roundKeys[10]); cipherText = shiftRowsDec(cipherText); cipherText = subBytesDec(cipherText); // Invert main rounds for (int i = 9; i > 0; i--) { cipherText = addRoundKey(cipherText, roundKeys[i]); cipherText = mixColumnsDec(cipherText); cipherText = shiftRowsDec(cipherText); cipherText = subBytesDec(cipherText); } // Invert initial round cipherText = addRoundKey(cipherText, roundKeys[0]); return cipherText; } public static void main(String[] args) { try (Scanner input = new Scanner(System.in)) { System.out.println(\"Enter (e) letter for encrpyt or (d) letter for decrypt :\"); char choice = input.nextLine().charAt(0); String in; switch (choice) { case 'E', 'e' -> { System.out.println( \"Choose a plaintext block (128-Bit Integer in base 16):\" ); in = input.nextLine(); BigInteger plaintext = new BigInteger(in, 16); System.out.println( \"Choose a Key (128-Bit Integer in base 16):\" ); in = input.nextLine(); BigInteger encryptionKey = new BigInteger(in, 16); System.out.println( \"The encrypted message is: \\n\" + encrypt(plaintext, encryptionKey).toString(16) ); } case 'D', 'd' -> { System.out.println( \"Enter your ciphertext block (128-Bit Integer in base 16):\" ); in = input.nextLine(); BigInteger ciphertext = new BigInteger(in, 16); System.out.println( \"Choose a Key (128-Bit Integer in base 16):\" ); in = input.nextLine(); BigInteger decryptionKey = new BigInteger(in, 16); System.out.println( \"The deciphered message is:\\n\" + decrypt(ciphertext, decryptionKey).toString(16) ); } default -> System.out.println(\"** End **\"); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.security.Key; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import javax.crypto.spec.GCMParameterSpec; public final class AESEncryption { private static final char[] a = \"0123456789ABCDEF\".toCharArray(); private static Cipher b; private AESEncryption() { } public static void main(String[] object) { object = \"Hello World\"; SecretKey secretKey = AESEncryption.getSecretEncryptionKey(); byte[] byArray = AESEncryption.encryptText((String)object, secretKey); String string = AESEncryption.decryptText(byArray, secretKey); System.out.println(\"Original Text:\" + (String)object); System.out.println(\"AES Key (Hex Form):\" + AESEncryption.bytesToHex(secretKey.getEncoded())); System.out.println(\"Encrypted Text (Hex Form):\" + AESEncryption.bytesToHex(byArray)); System.out.println(\"Descrypted Text:\" + string); } public static SecretKey getSecretEncryptionKey() { KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\"); keyGenerator.init(128); return keyGenerator.generateKey(); } public static byte[] encryptText(String string, SecretKey secretKey) { b = Cipher.getInstance(\"AES/GCM/NoPadding\"); b.init(1, secretKey); return b.doFinal(string.getBytes()); } public static String decryptText(byte[] byArray, SecretKey secretKey) { Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\"); GCMParameterSpec gCMParameterSpec = new GCMParameterSpec(128, b.getIV()); cipher.init(2, (Key)secretKey, gCMParameterSpec); byArray = cipher.doFinal(byArray); return new String(byArray); } public static String bytesToHex(byte[] byArray) { char[] cArray = new char[byArray.length << 1]; for (int i = 0; i < byArray.length; ++i) { int n = byArray[i] & 0xFF; cArray[i << 1] = a[n >>> 4]; cArray[(i << 1) + 1] = a[n & 0xF]; } return new String(cArray); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.spec.GCMParameterSpec; /** * This example program shows how AES encryption and decryption can be done in * Java. Please note that secret key and encrypted text is unreadable binary and * hence in the following program we display it in hexadecimal format of the * underlying bytes. */ public final class AESEncryption { private AESEncryption() { } private static final char[] HEX_ARRAY = \"0123456789ABCDEF\".toCharArray(); private static Cipher aesCipher; /** * 1. Generate a plain text for encryption 2. Get a secret key (printed in * hexadecimal form). In actual use this must be encrypted and kept safe. * The same key is required for decryption. */ public static void main(String[] args) throws Exception { String plainText = \"Hello World\"; SecretKey secKey = getSecretEncryptionKey(); byte[] cipherText = encryptText(plainText, secKey); String decryptedText = decryptText(cipherText, secKey); System.out.println(\"Original Text:\" + plainText); System.out.println(\"AES Key (Hex Form):\" + bytesToHex(secKey.getEncoded())); System.out.println(\"Encrypted Text (Hex Form):\" + bytesToHex(cipherText)); System.out.println(\"Descrypted Text:\" + decryptedText); } /** * gets the AES encryption key. In your actual programs, this should be * safely stored. * * @return secKey (Secret key that we encrypt using it) * @throws NoSuchAlgorithmException (from KeyGenrator) */ public static SecretKey getSecretEncryptionKey() throws NoSuchAlgorithmException { KeyGenerator aesKeyGenerator = KeyGenerator.getInstance(\"AES\"); aesKeyGenerator.init(128); // The AES key size in number of bits return aesKeyGenerator.generateKey(); } /** * Encrypts plainText in AES using the secret key * * @return byteCipherText (The encrypted text) * @throws NoSuchPaddingException (from Cipher) * @throws NoSuchAlgorithmException (from Cipher) * @throws InvalidKeyException (from Cipher) * @throws BadPaddingException (from Cipher) * @throws IllegalBlockSizeException (from Cipher) */ public static byte[] encryptText(String plainText, SecretKey secKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException { // AES defaults to AES/ECB/PKCS5Padding in Java 7 aesCipher = Cipher.getInstance(\"AES/GCM/NoPadding\"); aesCipher.init(Cipher.ENCRYPT_MODE, secKey); return aesCipher.doFinal(plainText.getBytes()); } /** * Decrypts encrypted byte array using the key used for encryption. * * @return plainText */ public static String decryptText(byte[] byteCipherText, SecretKey secKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException { // AES defaults to AES/ECB/PKCS5Padding in Java 7 Cipher decryptionCipher = Cipher.getInstance(\"AES/GCM/NoPadding\"); GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, aesCipher.getIV()); decryptionCipher.init(Cipher.DECRYPT_MODE, secKey, gcmParameterSpec); byte[] bytePlainText = decryptionCipher.doFinal(byteCipherText); return new String(bytePlainText); } /** * Convert a binary byte array into readable hex form Old library is * deprecated on OpenJdk 11 and this is faster regarding other solution is * using StringBuilder * * @return hexHash */ public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j < bytes.length; j++) { int v = bytes[j] & 0xFF; hexChars[j * 2] = HEX_ARRAY[v >>> 4]; hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F]; } return new String(hexChars); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class AStar$Edge { private int a; private int b; private int c; public int getFrom() { return this.a; } public int getTo() { return this.b; } public int getWeight() { return this.c; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class AStar$Edge { private int a; private int b; private int c; public int getFrom() { return this.a; } public int getTo() { return this.b; } public int getWeight() { return this.c; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; class AStar$Graph { private ArrayList a; private ArrayList a(int n) { throw new NullPointerException(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; class AStar$Graph { private ArrayList a; private ArrayList a(int n) { throw new NullPointerException(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; class AStar$PathAndDistance { private int a; private ArrayList b; private int c; AStar$PathAndDistance(int n, ArrayList arrayList, int n2) { this.a = n; this.b = arrayList; this.c = n2; } public int getDistance() { return this.a; } public ArrayList getPath() { return this.b; } public int getEstimated() { return this.c; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; class AStar$PathAndDistance { private int a; private ArrayList b; private int c; AStar$PathAndDistance(int n, ArrayList arrayList, int n2) { this.a = n; this.b = arrayList; this.c = n2; } public int getDistance() { return this.a; } public ArrayList getPath() { return this.b; } public int getEstimated() { return this.c; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.AStar$Edge; import com.thealgorithms.datastructures.graphs.AStar$Graph; import com.thealgorithms.datastructures.graphs.AStar$PathAndDistance; import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.PriorityQueue; public final class AStar { private AStar() { } public static AStar$PathAndDistance aStar(int n, int n2, AStar$Graph aStar$Graph, int[] nArray) { PriorityQueue<AStar$PathAndDistance> priorityQueue = new PriorityQueue<AStar$PathAndDistance>(Comparator.comparingInt(aStar$PathAndDistance -> aStar$PathAndDistance.getDistance() + aStar$PathAndDistance.getEstimated())); priorityQueue.add(new AStar$PathAndDistance(0, new ArrayList<Integer>(List.of(Integer.valueOf(n))), nArray[n])); n = 0; AStar$PathAndDistance aStar$PathAndDistance2 = new AStar$PathAndDistance(-1, null, -1); while (!priorityQueue.isEmpty() && n == 0) { aStar$PathAndDistance2 = priorityQueue.poll(); int n3 = (Integer)aStar$PathAndDistance2.getPath().get(aStar$PathAndDistance2.getPath().size() - 1); if (n3 == n2) { n = 1; continue; } for (AStar$Edge aStar$Edge : aStar$Graph.a(n3)) { if (aStar$PathAndDistance2.getPath().contains(aStar$Edge.getTo())) continue; ArrayList<Integer> arrayList = new ArrayList<Integer>(aStar$PathAndDistance2.getPath()); arrayList.add(aStar$Edge.getTo()); priorityQueue.add(new AStar$PathAndDistance(aStar$PathAndDistance2.getDistance() + aStar$Edge.getWeight(), arrayList, nArray[aStar$Edge.getTo()])); } } if (n != 0) { return aStar$PathAndDistance2; } return new AStar$PathAndDistance(-1, null, -1); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.PriorityQueue; /** * AStar class implements the A* pathfinding algorithm to find the shortest path in a graph. * The graph is represented using an adjacency list, and the algorithm uses a heuristic to estimate * the cost to reach the destination node. * Time Complexity = O(E), where E is equal to the number of edges */ public final class AStar { private AStar() { } /** * Represents a graph using an adjacency list. */ static class Graph { private ArrayList<ArrayList<Edge>> graph; Graph(int size) { this.graph = new ArrayList<>(); for (int i = 0; i < size; i++) { this.graph.add(new ArrayList<>()); } } private ArrayList<Edge> getNeighbours(int from) { return this.graph.get(from); } // Add a bidirectional edge to the graph private void addEdge(Edge edge) { this.graph.get(edge.getFrom()).add(new Edge(edge.getFrom(), edge.getTo(), edge.getWeight())); this.graph.get(edge.getTo()).add(new Edge(edge.getTo(), edge.getFrom(), edge.getWeight())); } } /** * Represents an edge in the graph with a start node, end node, and weight. */ private static class Edge { private int from; private int to; private int weight; Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } public int getFrom() { return from; } public int getTo() { return to; } public int getWeight() { return weight; } } /** * Contains information about the path and its total distance. */ static class PathAndDistance { private int distance; // total distance from the start node private ArrayList<Integer> path; // list of nodes in the path private int estimated; // heuristic estimate for reaching the destination PathAndDistance(int distance, ArrayList<Integer> path, int estimated) { this.distance = distance; this.path = path; this.estimated = estimated; } public int getDistance() { return distance; } public ArrayList<Integer> getPath() { return path; } public int getEstimated() { return estimated; } } // Initializes the graph with edges defined in the input data static void initializeGraph(Graph graph, List<Integer> data) { for (int i = 0; i < data.size(); i += 4) { graph.addEdge(new Edge(data.get(i), data.get(i + 1), data.get(i + 2))); } } /** * Implements the A* pathfinding algorithm to find the shortest path from a start node to a destination node. * * @param from the starting node * @param to the destination node * @param graph the graph representation of the problem * @param heuristic the heuristic estimates for each node * @return a PathAndDistance object containing the shortest path and its distance */ public static PathAndDistance aStar(int from, int to, Graph graph, int[] heuristic) { // PriorityQueue to explore nodes based on their distance and estimated cost to reach the destination PriorityQueue<PathAndDistance> queue = new PriorityQueue<>(Comparator.comparingInt(a -> (a.getDistance() + a.getEstimated()))); // Start with the initial node queue.add(new PathAndDistance(0, new ArrayList<>(List.of(from)), heuristic[from])); boolean solutionFound = false; PathAndDistance currentData = new PathAndDistance(-1, null, -1); while (!queue.isEmpty() && !solutionFound) { currentData = queue.poll(); // get the best node from the queue int currentPosition = currentData.getPath().get(currentData.getPath().size() - 1); // current node // Check if the destination has been reached if (currentPosition == to) { solutionFound = true; } else { for (Edge edge : graph.getNeighbours(currentPosition)) { // Avoid cycles by checking if the next node is already in the path if (!currentData.getPath().contains(edge.getTo())) { ArrayList<Integer> updatedPath = new ArrayList<>(currentData.getPath()); updatedPath.add(edge.getTo()); // Update the distance and heuristic for the new path queue.add(new PathAndDistance(currentData.getDistance() + edge.getWeight(), updatedPath, heuristic[edge.getTo()])); } } } } return (solutionFound) ? currentData : new PathAndDistance(-1, null, -1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class AVLSimple$Node { int a; int b; AVLSimple$Node c; AVLSimple$Node d; AVLSimple$Node(int n) { this.a = n; this.b = 1; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class AVLSimple$Node { int a; int b; AVLSimple$Node c; AVLSimple$Node d; AVLSimple$Node(int n) { this.a = n; this.b = 1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.AVLSimple$Node; public class AVLSimple { private AVLSimple$Node a; public void insert(int n) { this.a = this.a(this.a, n); } private AVLSimple$Node a(AVLSimple$Node aVLSimple$Node, int n) { if (aVLSimple$Node == null) { return new AVLSimple$Node(n); } if (aVLSimple$Node.a > n) { aVLSimple$Node.c = this.a(aVLSimple$Node.c, n); } if (aVLSimple$Node.a < n) { aVLSimple$Node.d = this.a(aVLSimple$Node.d, n); } aVLSimple$Node.b = Math.max(AVLSimple.b(aVLSimple$Node.c), AVLSimple.b(aVLSimple$Node.d)) + 1; int n2 = this.c(aVLSimple$Node); if (n2 > 1 && n < aVLSimple$Node.c.a) { return this.d(aVLSimple$Node); } if (n2 < -1 && n > aVLSimple$Node.d.a) { return this.e(aVLSimple$Node); } if (n2 < -1 && n < aVLSimple$Node.d.a) { aVLSimple$Node.d = this.d(aVLSimple$Node.d); return this.e(aVLSimple$Node); } if (n2 > 1 && n > aVLSimple$Node.c.a) { aVLSimple$Node.c = this.e(aVLSimple$Node.c); return this.d(aVLSimple$Node); } return aVLSimple$Node; } public void display() { AVLSimple aVLSimple = this; aVLSimple.a(aVLSimple.a); System.out.println(this.a.b); } private void a(AVLSimple$Node aVLSimple$Node) { while (true) { Object object = \"\"; object = aVLSimple$Node.c != null ? (String)object + aVLSimple$Node.c.a + \"=>\" : (String)object + \"END=>\"; object = (String)object + aVLSimple$Node.a; object = aVLSimple$Node.d != null ? (String)object + \"<=\" + aVLSimple$Node.d.a : (String)object + \"<=END\"; System.out.println((String)object); if (aVLSimple$Node.c != null) { this.a(aVLSimple$Node.c); } if (aVLSimple$Node.d == null) break; aVLSimple$Node = aVLSimple$Node.d; } } private static int b(AVLSimple$Node aVLSimple$Node) { if (aVLSimple$Node == null) { return 0; } return aVLSimple$Node.b; } private int c(AVLSimple$Node aVLSimple$Node) { if (aVLSimple$Node == null) { return 0; } return AVLSimple.b(aVLSimple$Node.c) - AVLSimple.b(aVLSimple$Node.d); } private AVLSimple$Node d(AVLSimple$Node aVLSimple$Node) { AVLSimple$Node aVLSimple$Node2 = aVLSimple$Node.c; AVLSimple$Node aVLSimple$Node3 = aVLSimple$Node2.d; aVLSimple$Node2.d = aVLSimple$Node; aVLSimple$Node.c = aVLSimple$Node3; aVLSimple$Node.b = Math.max(AVLSimple.b(aVLSimple$Node.c), AVLSimple.b(aVLSimple$Node.d)) + 1; aVLSimple$Node2.b = Math.max(AVLSimple.b(aVLSimple$Node2.c), AVLSimple.b(aVLSimple$Node2.d)) + 1; return aVLSimple$Node2; } private AVLSimple$Node e(AVLSimple$Node aVLSimple$Node) { AVLSimple$Node aVLSimple$Node2 = aVLSimple$Node.d; AVLSimple$Node aVLSimple$Node3 = aVLSimple$Node2.c; aVLSimple$Node2.c = aVLSimple$Node; aVLSimple$Node.d = aVLSimple$Node3; aVLSimple$Node.b = Math.max(AVLSimple.b(aVLSimple$Node.c), AVLSimple.b(aVLSimple$Node.d)) + 1; aVLSimple$Node2.b = Math.max(AVLSimple.b(aVLSimple$Node2.c), AVLSimple.b(aVLSimple$Node2.d)) + 1; return aVLSimple$Node2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; /* * Avl is algo that balance itself while adding new alues to tree * by rotating branches of binary tree and make itself Binary seaarch tree * there are four cases which has to tackle * rotating - left right ,left left,right right,right left Test Case: AVLTree tree=new AVLTree(); tree.insert(20); tree.insert(25); tree.insert(30); tree.insert(10); tree.insert(5); tree.insert(15); tree.insert(27); tree.insert(19); tree.insert(16); tree.display(); */ public class AVLSimple { private class Node { int data; int height; Node left; Node right; Node(int data) { this.data = data; this.height = 1; } } private Node root; public void insert(int data) { this.root = insert(this.root, data); } private Node insert(Node node, int item) { if (node == null) { return new Node(item); } if (node.data > item) { node.left = insert(node.left, item); } if (node.data < item) { node.right = insert(node.right, item); } node.height = Math.max(height(node.left), height(node.right)) + 1; int bf = bf(node); // LL case if (bf > 1 && item < node.left.data) { return rightRotate(node); } // RR case if (bf < -1 && item > node.right.data) { return leftRotate(node); } // RL case if (bf < -1 && item < node.right.data) { node.right = rightRotate(node.right); return leftRotate(node); } // LR case if (bf > 1 && item > node.left.data) { node.left = leftRotate(node.left); return rightRotate(node); } return node; } public void display() { this.display(this.root); System.out.println(this.root.height); } private void display(Node node) { String str = \"\"; if (node.left != null) { str += node.left.data + \"=>\"; } else { str += \"END=>\"; } str += node.data + \"\"; if (node.right != null) { str += \"<=\" + node.right.data; } else { str += \"<=END\"; } System.out.println(str); if (node.left != null) { display(node.left); } if (node.right != null) { display(node.right); } } private int height(Node node) { if (node == null) { return 0; } return node.height; } private int bf(Node node) { if (node == null) { return 0; } return height(node.left) - height(node.right); } private Node rightRotate(Node c) { Node b = c.left; Node t3 = b.right; b.right = c; c.left = t3; c.height = Math.max(height(c.left), height(c.right)) + 1; b.height = Math.max(height(b.left), height(b.right)) + 1; return b; } private Node leftRotate(Node c) { Node b = c.right; Node t3 = b.left; b.left = c; c.right = t3; c.height = Math.max(height(c.left), height(c.right)) + 1; b.height = Math.max(height(b.left), height(b.right)) + 1; return b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class AVLTree$Node { private int a; private int b; private int c; private AVLTree$Node d; private AVLTree$Node e; private AVLTree$Node f; AVLTree$Node(int n, AVLTree$Node aVLTree$Node) { this.a = n; this.f = aVLTree$Node; } public Integer getBalance() { return this.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class AVLTree$Node { private int a; private int b; private int c; private AVLTree$Node d; private AVLTree$Node e; private AVLTree$Node f; AVLTree$Node(int n, AVLTree$Node aVLTree$Node) { this.a = n; this.f = aVLTree$Node; } public Integer getBalance() { return this.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.AVLTree$Node; import java.util.ArrayList; import java.util.List; public class AVLTree { private AVLTree$Node a; public boolean insert(int n) { if (this.a == null) { this.a = new AVLTree$Node(n, null); } else { AVLTree$Node aVLTree$Node; boolean bl; AVLTree$Node aVLTree$Node2 = this.a; do { if (aVLTree$Node2.a == n) { return false; } aVLTree$Node = aVLTree$Node2; } while ((aVLTree$Node2 = (bl = aVLTree$Node2.a > n) ? aVLTree$Node2.d : aVLTree$Node2.e) != null); if (bl) { aVLTree$Node.d = new AVLTree$Node(n, aVLTree$Node); } else { aVLTree$Node.e = new AVLTree$Node(n, aVLTree$Node); } this.b(aVLTree$Node); } return true; } public void delete(int n) { if (this.a == null) { return; } AVLTree$Node aVLTree$Node = this.a; while (aVLTree$Node != null) { AVLTree$Node aVLTree$Node2 = aVLTree$Node; AVLTree$Node aVLTree$Node3 = aVLTree$Node = n >= aVLTree$Node2.a ? aVLTree$Node2.e : aVLTree$Node2.d; if (n != aVLTree$Node2.a) continue; this.a(aVLTree$Node2); return; } } private void a(AVLTree$Node aVLTree$Node) { while (true) { AVLTree$Node aVLTree$Node2; if (aVLTree$Node.d == null && aVLTree$Node.e == null) { if (aVLTree$Node.f == null) { this.a = null; return; } aVLTree$Node2 = aVLTree$Node.f; if (aVLTree$Node2.d == aVLTree$Node) { aVLTree$Node2.d = null; } else { aVLTree$Node2.e = null; } this.b(aVLTree$Node2); return; } if (aVLTree$Node.d != null) { aVLTree$Node2 = aVLTree$Node.d; while (aVLTree$Node2.e != null) { aVLTree$Node2 = aVLTree$Node2.e; } } else { aVLTree$Node2 = aVLTree$Node.e; while (aVLTree$Node2.d != null) { aVLTree$Node2 = aVLTree$Node2.d; } } aVLTree$Node.a = aVLTree$Node2.a; aVLTree$Node = aVLTree$Node2; } } public List returnBalance() { ArrayList arrayList = new ArrayList(); AVLTree aVLTree = this; aVLTree.a(aVLTree.a, arrayList); return arrayList; } private void a(AVLTree$Node aVLTree$Node, List list) { while (aVLTree$Node != null) { this.a(aVLTree$Node.d, list); list.add(aVLTree$Node.getBalance()); aVLTree$Node = aVLTree$Node.e; } } public boolean search(int n) { AVLTree aVLTree = this; AVLTree$Node aVLTree$Node = aVLTree.a(aVLTree.a, n); return aVLTree$Node != null; } private AVLTree$Node a(AVLTree$Node aVLTree$Node, int n) { while (aVLTree$Node != null && aVLTree$Node.a != n) { if (aVLTree$Node.a > n) { aVLTree$Node = aVLTree$Node.d; continue; } aVLTree$Node = aVLTree$Node.e; } return aVLTree$Node; } private void b(AVLTree$Node aVLTree$Node) { this.a(new AVLTree$Node[]{aVLTree$Node}); if (aVLTree$Node.b == -2) { aVLTree$Node = AVLTree.g(aVLTree$Node.d.d) >= AVLTree.g(aVLTree$Node.d.e) ? this.d(aVLTree$Node) : this.e(aVLTree$Node); } else if (aVLTree$Node.b == 2) { aVLTree$Node = AVLTree.g(aVLTree$Node.e.e) >= AVLTree.g(aVLTree$Node.e.d) ? this.c(aVLTree$Node) : this.f(aVLTree$Node); } if (aVLTree$Node.f != null) { this.b(aVLTree$Node.f); return; } this.a = aVLTree$Node; } private AVLTree$Node c(AVLTree$Node aVLTree$Node) { AVLTree$Node aVLTree$Node2 = aVLTree$Node.e; aVLTree$Node.e.f = aVLTree$Node.f; aVLTree$Node.e = aVLTree$Node2.d; if (aVLTree$Node.e != null) { aVLTree$Node.e.f = aVLTree$Node; } aVLTree$Node2.d = aVLTree$Node; aVLTree$Node.f = aVLTree$Node2; if (aVLTree$Node2.f != null) { if (aVLTree$Node2.f.e == aVLTree$Node) { aVLTree$Node2.f.e = aVLTree$Node2; } else { aVLTree$Node2.f.d = aVLTree$Node2; } } this.a(aVLTree$Node, aVLTree$Node2); return aVLTree$Node2; } private AVLTree$Node d(AVLTree$Node aVLTree$Node) { AVLTree$Node aVLTree$Node2 = aVLTree$Node.d; aVLTree$Node.d.f = aVLTree$Node.f; aVLTree$Node.d = aVLTree$Node2.e; if (aVLTree$Node.d != null) { aVLTree$Node.d.f = aVLTree$Node; } aVLTree$Node2.e = aVLTree$Node; aVLTree$Node.f = aVLTree$Node2; if (aVLTree$Node2.f != null) { if (aVLTree$Node2.f.e == aVLTree$Node) { aVLTree$Node2.f.e = aVLTree$Node2; } else { aVLTree$Node2.f.d = aVLTree$Node2; } } this.a(aVLTree$Node, aVLTree$Node2); return aVLTree$Node2; } private AVLTree$Node e(AVLTree$Node aVLTree$Node) { aVLTree$Node.d = this.c(aVLTree$Node.d); return this.d(aVLTree$Node); } private AVLTree$Node f(AVLTree$Node aVLTree$Node) { aVLTree$Node.e = this.d(aVLTree$Node.e); return this.c(aVLTree$Node); } private static int g(AVLTree$Node aVLTree$Node) { if (aVLTree$Node == null) { return -1; } return aVLTree$Node.c; } private void a(AVLTree$Node ... aVLTree$NodeArray) { for (AVLTree$Node aVLTree$Node : aVLTree$NodeArray) { this.h(aVLTree$Node); aVLTree$Node.b = AVLTree.g(aVLTree$Node.e) - AVLTree.g(aVLTree$Node.d); } } private void h(AVLTree$Node aVLTree$Node) { if (aVLTree$Node != null) { aVLTree$Node.c = 1 + Math.max(AVLTree.g(aVLTree$Node.d), AVLTree.g(aVLTree$Node.e)); } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayList; import java.util.List; /** * Represents an AVL Tree, a self-balancing binary search tree. * In an AVL tree, the heights of the two child subtrees of any node * differ by at most one. If they differ by more than one at any time, * rebalancing is performed to restore this property. */ public class AVLTree { private Node root; private static class Node { private int key; private int balance; private int height; private Node left; private Node right; private Node parent; Node(int k, Node p) { key = k; parent = p; } public Integer getBalance() { return balance; } } /** * Inserts a new key into the AVL tree. * * @param key the key to be inserted * @return {@code true} if the key was inserted, {@code false} if the key already exists */ public boolean insert(int key) { if (root == null) { root = new Node(key, null); } else { Node n = root; Node parent; while (true) { if (n.key == key) { return false; } parent = n; boolean goLeft = n.key > key; n = goLeft ? n.left : n.right; if (n == null) { if (goLeft) { parent.left = new Node(key, parent); } else { parent.right = new Node(key, parent); } rebalance(parent); break; } } } return true; } /** * Deletes a key from the AVL tree. * * @param delKey the key to be deleted */ public void delete(int delKey) { if (root == null) { return; } // Find the node to be deleted Node node = root; Node child = root; while (child != null) { node = child; child = delKey >= node.key ? node.right : node.left; if (delKey == node.key) { delete(node); return; } } } private void delete(Node node) { if (node.left == null && node.right == null) { // Leaf node if (node.parent == null) { root = null; } else { Node parent = node.parent; if (parent.left == node) { parent.left = null; } else { parent.right = null; } rebalance(parent); } return; } // Node has one or two children Node child; if (node.left != null) { child = node.left; while (child.right != null) { child = child.right; } } else { child = node.right; while (child.left != null) { child = child.left; } } node.key = child.key; delete(child); } /** * Returns a list of balance factors for each node in the tree. * * @return a list of integers representing the balance factors of the nodes */ public List<Integer> returnBalance() { List<Integer> balances = new ArrayList<>(); returnBalance(root, balances); return balances; } private void returnBalance(Node n, List<Integer> balances) { if (n != null) { returnBalance(n.left, balances); balances.add(n.getBalance()); returnBalance(n.right, balances); } } /** * Searches for a key in the AVL tree. * * @param key the key to be searched * @return true if the key is found, false otherwise */ public boolean search(int key) { Node result = searchHelper(this.root, key); return result != null; } private Node searchHelper(Node root, int key) { if (root == null || root.key == key) { return root; } if (root.key > key) { return searchHelper(root.left, key); } return searchHelper(root.right, key); } private void rebalance(Node n) { setBalance(n); if (n.balance == -2) { if (height(n.left.left) >= height(n.left.right)) { n = rotateRight(n); } else { n = rotateLeftThenRight(n); } } else if (n.balance == 2) { if (height(n.right.right) >= height(n.right.left)) { n = rotateLeft(n); } else { n = rotateRightThenLeft(n); } } if (n.parent != null) { rebalance(n.parent); } else { root = n; } } private Node rotateLeft(Node a) { Node b = a.right; b.parent = a.parent; a.right = b.left; if (a.right != null) { a.right.parent = a; } b.left = a; a.parent = b; if (b.parent != null) { if (b.parent.right == a) { b.parent.right = b; } else { b.parent.left = b; } } setBalance(a, b); return b; } private Node rotateRight(Node a) { Node b = a.left; b.parent = a.parent; a.left = b.right; if (a.left != null) { a.left.parent = a; } b.right = a; a.parent = b; if (b.parent != null) { if (b.parent.right == a) { b.parent.right = b; } else { b.parent.left = b; } } setBalance(a, b); return b; } private Node rotateLeftThenRight(Node n) { n.left = rotateLeft(n.left); return rotateRight(n); } private Node rotateRightThenLeft(Node n) { n.right = rotateRight(n.right); return rotateLeft(n); } private int height(Node n) { if (n == null) { return -1; } return n.height; } private void setBalance(Node... nodes) { for (Node n : nodes) { reheight(n); n.balance = height(n.right) - height(n.left); } } private void reheight(Node node) { if (node != null) { node.height = 1 + Math.max(height(node.left), height(node.right)); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class Abbreviation { private Abbreviation() { } public static boolean abbr(String string, String string2) { int n = string.length(); int n2 = string2.length(); boolean[][] blArray = new boolean[n + 1][n2 + 1]; blArray[0][0] = true; for (int i = 0; i < n; ++i) { for (int j = 0; j <= n2; ++j) { if (!blArray[i][j]) continue; if (j < n2 && Character.toUpperCase(string.charAt(i)) == string2.charAt(j)) { blArray[i + 1][j + 1] = true; } if (!Character.isLowerCase(string.charAt(i))) continue; blArray[i + 1][j] = true; } } return blArray[n][n2]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * A class that provides a solution to the abbreviation problem. * * Problem: Given two strings, `a` and `b`, determine if string `a` can be * transformed into string `b` by performing the following operations: * 1. Capitalize zero or more of `a`'s lowercase letters (i.e., convert them to uppercase). * 2. Delete any of the remaining lowercase letters from `a`. * * The task is to determine whether it is possible to make string `a` equal to string `b`. * * @author Hardvan */ public final class Abbreviation { private Abbreviation() { } /** * Determines if string `a` can be transformed into string `b` by capitalizing * some of its lowercase letters and deleting the rest. * * @param a The input string which may contain both uppercase and lowercase letters. * @param b The target string containing only uppercase letters. * @return {@code true} if string `a` can be transformed into string `b`, * {@code false} otherwise. * * Time Complexity: O(n * m) where n = length of string `a` and m = length of string `b`. * Space Complexity: O(n * m) due to the dynamic programming table. */ public static boolean abbr(String a, String b) { int n = a.length(); int m = b.length(); boolean[][] dp = new boolean[n + 1][m + 1]; dp[0][0] = true; for (int i = 0; i < n; i++) { for (int j = 0; j <= m; j++) { if (dp[i][j]) { // Case 1: If the current characters match (or can be capitalized to match) if (j < m && Character.toUpperCase(a.charAt(i)) == b.charAt(j)) { dp[i + 1][j + 1] = true; } // Case 2: If the character in `a` is lowercase, we can skip it if (Character.isLowerCase(a.charAt(i))) { dp[i + 1][j] = true; } } } } return dp[n][m]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class AbsoluteMax { private AbsoluteMax() { } public static int getMaxValue(int ... nArray) { if (nArray == null || nArray.length == 0) { throw new IllegalArgumentException(\"Numbers array cannot be empty or null\"); } int n = nArray[0]; for (int i = 1; i < nArray.length; ++i) { if (Math.abs(nArray[i]) <= Math.abs(n) && (Math.abs(nArray[i]) != Math.abs(n) || nArray[i] <= n)) continue; n = nArray[i]; } return n; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class AbsoluteMax { private AbsoluteMax() { } /** * Finds the absolute maximum value among the given numbers. * * @param numbers The numbers to compare. * @return The absolute maximum value. * @throws IllegalArgumentException If the input array is empty or null. */ public static int getMaxValue(int... numbers) { if (numbers == null || numbers.length == 0) { throw new IllegalArgumentException(\"Numbers array cannot be empty or null\"); } int absMax = numbers[0]; for (int i = 1; i < numbers.length; i++) { if (Math.abs(numbers[i]) > Math.abs(absMax) || (Math.abs(numbers[i]) == Math.abs(absMax) && numbers[i] > absMax)) { absMax = numbers[i]; } } return absMax; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; class AbsoluteMin$1 { int a; private /* synthetic */ int[] b; AbsoluteMin$1(int[] nArray) { this.b = nArray; this.a = this.b[0]; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; class AbsoluteMin$1 { int a; private /* synthetic */ int[] b; AbsoluteMin$1(int[] nArray) { this.b = nArray; this.a = this.b[0]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.AbsoluteMin$1; import java.util.Arrays; public final class AbsoluteMin { private AbsoluteMin() { } public static int getMinValue(int ... nArray) { if (nArray.length == 0) { throw new IllegalArgumentException(\"Numbers array cannot be empty\"); } AbsoluteMin$1 absoluteMin$1 = new AbsoluteMin$1(nArray); Arrays.stream(nArray).skip(1L).filter(n -> Math.abs(n) <= Math.abs(absoluteMin$1.a)).forEach(n -> { absoluteMin$1.a = Math.min(absoluteMin$1.a, n); }); return absoluteMin$1.a; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.Arrays; public final class AbsoluteMin { private AbsoluteMin() { } /** * Compares the numbers given as arguments to get the absolute min value. * * @param numbers The numbers to compare * @return The absolute min value */ public static int getMinValue(int... numbers) { if (numbers.length == 0) { throw new IllegalArgumentException(\"Numbers array cannot be empty\"); } var absMinWrapper = new Object() { int value = numbers[0]; }; Arrays.stream(numbers).skip(1).filter(number -> Math.abs(number) <= Math.abs(absMinWrapper.value)).forEach(number -> absMinWrapper.value = Math.min(absMinWrapper.value, number)); return absMinWrapper.value; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class AbsoluteValue { private AbsoluteValue() { } public static int getAbsValue(int n) { if (n < 0) { return -n; } return n; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class AbsoluteValue { private AbsoluteValue() { } /** * Returns the absolute value of a number. * * @param number The number to be transformed * @return The absolute value of the {@code number} */ public static int getAbsValue(int number) { return number < 0 ? -number : number; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; public final class ActivitySelection { private ActivitySelection() { } public static ArrayList activitySelection(int[] object, int[] nArray2) { int n; int n2 = ((int[])object).length; int[][] nArray3 = new int[n2][3]; for (n = 0; n < n2; ++n) { nArray3[n][0] = n; nArray3[n][1] = object[n]; nArray3[n][2] = nArray2[n]; } Arrays.sort(nArray3, Comparator.comparingDouble(nArray -> nArray[2])); ArrayList<Integer> arrayList = new ArrayList<Integer>(); object = arrayList; arrayList.add(nArray3[0][0]); n = nArray3[0][2]; for (int i = 1; i < n2; ++i) { if (nArray3[i][1] < n) continue; ((ArrayList)object).add(nArray3[i][0]); n = nArray3[i][2]; } return object; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; // Problem Link: https://en.wikipedia.org/wiki/Activity_selection_problem public final class ActivitySelection { // Private constructor to prevent instantiation of the utility class private ActivitySelection() { } /** * Function to perform activity selection using a greedy approach. * * The goal is to select the maximum number of activities that don't overlap * with each other, based on their start and end times. Activities are chosen * such that no two selected activities overlap. * * @param startTimes Array containing the start times of the activities. * @param endTimes Array containing the end times of the activities. * @return A list of indices representing the selected activities that can be * performed without overlap. */ public static ArrayList<Integer> activitySelection(int[] startTimes, int[] endTimes) { int n = startTimes.length; // Create a 2D array to store activity indices along with their start and end // times. // Each row represents an activity in the format: [activity index, start time, // end time]. int[][] activities = new int[n][3]; // Populate the 2D array with the activity index, start time, and end time. for (int i = 0; i < n; i++) { activities[i][0] = i; // Assign the activity index activities[i][1] = startTimes[i]; // Assign the start time of the activity activities[i][2] = endTimes[i]; // Assign the end time of the activity } // Sort activities based on their end times in ascending order. // This ensures that we always try to finish earlier activities first. Arrays.sort(activities, Comparator.comparingDouble(activity -> activity[2])); int lastEndTime; // Variable to store the end time of the last selected activity // List to store the indices of selected activities ArrayList<Integer> selectedActivities = new ArrayList<>(); // Select the first activity (as it has the earliest end time after sorting) selectedActivities.add(activities[0][0]); // Add the first activity index to the result lastEndTime = activities[0][2]; // Keep track of the end time of the last selected activity // Iterate over the sorted activities to select the maximum number of compatible // activities. for (int i = 1; i < n; i++) { // If the start time of the current activity is greater than or equal to the // end time of the last selected activity, it means there's no overlap. if (activities[i][1] >= lastEndTime) { selectedActivities.add(activities[i][0]); // Select this activity lastEndTime = activities[i][2]; // Update the end time of the last selected activity } } // Return the list of selected activity indices. return selectedActivities; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class AdaptiveMergeSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length <= 1) { return comparableArray; } Comparable[] comparableArray2 = (Comparable[])comparableArray.clone(); this.a(comparableArray, comparableArray2, 0, comparableArray.length - 1); return comparableArray; } private void a(Comparable[] comparableArray, Comparable[] comparableArray2, int n, int n2) { if (n >= n2) { return; } int n3 = n + (n2 - n) / 2; this.a(comparableArray, comparableArray2, n, n3); this.a(comparableArray, comparableArray2, n3 + 1, n2); AdaptiveMergeSort.a(comparableArray, comparableArray2, n, n3, n2); } private static void a(Comparable[] comparableArray, Comparable[] comparableArray2, int n, int n2, int n3) { System.arraycopy(comparableArray, n, comparableArray2, n, n3 - n + 1); int n4 = n; int n5 = n2 + 1; while (n <= n3) { comparableArray[n] = n4 > n2 ? comparableArray2[n5++] : (n5 <= n3 && SortUtils.less(comparableArray2[n5], comparableArray2[n4]) ? comparableArray2[n5++] : comparableArray2[n4++]); ++n; } } }", "deobfuscated_code": "package com.thealgorithms.sorts; public class AdaptiveMergeSort implements SortAlgorithm { @SuppressWarnings(\"unchecked\") public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length <= 1) { return array; } T[] aux = array.clone(); sort(array, aux, 0, array.length - 1); return array; } private <T extends Comparable<T>> void sort(T[] array, T[] aux, int low, int high) { if (low >= high) { return; } int mid = low + (high - low) / 2; sort(array, aux, low, mid); sort(array, aux, mid + 1, high); merge(array, aux, low, mid, high); } private <T extends Comparable<T>> void merge(T[] array, T[] aux, int low, int mid, int high) { System.arraycopy(array, low, aux, low, high - low + 1); int i = low; int j = mid + 1; for (int k = low; k <= high; k++) { if (i > mid) { array[k] = aux[j++]; } else if (j > high) { array[k] = aux[i++]; } else if (SortUtils.less(aux[j], aux[i])) { array[k] = aux[j++]; } else { array[k] = aux[i++]; } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.LinkedHashMap; import java.util.Map; import java.util.Set; class AdjacencyList { private Map a = new LinkedHashMap(); AdjacencyList() { } final void a(Comparable comparable, Comparable comparable2) { if (!this.a.containsKey(comparable)) { this.a.put(comparable, new ArrayList()); } ((ArrayList)this.a.get(comparable)).add(comparable2); if (!this.a.containsKey(comparable2)) { this.a.put(comparable2, new ArrayList()); } } final ArrayList a(Comparable comparable) { return (ArrayList)this.a.get(comparable); } final Set a() { return this.a.keySet(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.LinkedHashMap; import java.util.Map; import java.util.Set; class AdjacencyList { private Map a = new LinkedHashMap(); AdjacencyList() { } final void a(Comparable comparable, Comparable comparable2) { if (!this.a.containsKey(comparable)) { this.a.put(comparable, new ArrayList()); } ((ArrayList)this.a.get(comparable)).add(comparable2); if (!this.a.containsKey(comparable2)) { this.a.put(comparable2, new ArrayList()); } } final ArrayList a(Comparable comparable) { return (ArrayList)this.a.get(comparable); } final Set a() { return this.a.keySet(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; class AdjacencyListGraph$Vertex { Comparable a; ArrayList b = new ArrayList(); AdjacencyListGraph$Vertex(Comparable comparable) { this.a = comparable; } public boolean addAdjacentVertex(AdjacencyListGraph$Vertex adjacencyListGraph$Vertex) { for (AdjacencyListGraph$Vertex adjacencyListGraph$Vertex2 : this.b) { if (adjacencyListGraph$Vertex2.a.compareTo(adjacencyListGraph$Vertex.a) != 0) continue; return false; } return this.b.add(adjacencyListGraph$Vertex); } public boolean removeAdjacentVertex(Comparable comparable) { for (int i = 0; i < this.b.size(); ++i) { if (((AdjacencyListGraph$Vertex)this.b.get((int)i)).a.compareTo(comparable) != 0) continue; this.b.remove(i); return true; } return false; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; class AdjacencyListGraph$Vertex { Comparable a; ArrayList b = new ArrayList(); AdjacencyListGraph$Vertex(Comparable comparable) { this.a = comparable; } public boolean addAdjacentVertex(AdjacencyListGraph$Vertex adjacencyListGraph$Vertex) { for (AdjacencyListGraph$Vertex adjacencyListGraph$Vertex2 : this.b) { if (adjacencyListGraph$Vertex2.a.compareTo(adjacencyListGraph$Vertex.a) != 0) continue; return false; } return this.b.add(adjacencyListGraph$Vertex); } public boolean removeAdjacentVertex(Comparable comparable) { for (int i = 0; i < this.b.size(); ++i) { if (((AdjacencyListGraph$Vertex)this.b.get((int)i)).a.compareTo(comparable) != 0) continue; this.b.remove(i); return true; } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.AdjacencyListGraph$Vertex; import java.util.ArrayList; class AdjacencyListGraph { private ArrayList a = new ArrayList(); AdjacencyListGraph() { } public boolean removeEdge(Comparable comparable, Comparable comparable2) { AdjacencyListGraph$Vertex adjacencyListGraph$Vertex = null; for (AdjacencyListGraph$Vertex adjacencyListGraph$Vertex2 : this.a) { if (comparable.compareTo(adjacencyListGraph$Vertex2.a) != 0) continue; adjacencyListGraph$Vertex = adjacencyListGraph$Vertex2; break; } if (adjacencyListGraph$Vertex == null) { return false; } return adjacencyListGraph$Vertex.removeAdjacentVertex(comparable2); } public boolean addEdge(Comparable comparable, Comparable comparable2) { AdjacencyListGraph$Vertex adjacencyListGraph$Vertex = null; AdjacencyListGraph$Vertex adjacencyListGraph$Vertex2 = null; for (AdjacencyListGraph$Vertex adjacencyListGraph$Vertex3 : this.a) { if (comparable.compareTo(adjacencyListGraph$Vertex3.a) == 0) { adjacencyListGraph$Vertex = adjacencyListGraph$Vertex3; } else if (comparable2.compareTo(adjacencyListGraph$Vertex3.a) == 0) { adjacencyListGraph$Vertex2 = adjacencyListGraph$Vertex3; } if (adjacencyListGraph$Vertex == null || adjacencyListGraph$Vertex2 == null) continue; } if (adjacencyListGraph$Vertex == null) { adjacencyListGraph$Vertex = new AdjacencyListGraph$Vertex(comparable); this.a.add(adjacencyListGraph$Vertex); } if (adjacencyListGraph$Vertex2 == null) { adjacencyListGraph$Vertex2 = new AdjacencyListGraph$Vertex(comparable2); this.a.add(adjacencyListGraph$Vertex2); } return adjacencyListGraph$Vertex.addAdjacentVertex(adjacencyListGraph$Vertex2); } public String toString() { StringBuilder stringBuilder = new StringBuilder(); for (Object object : this.a) { stringBuilder.append(\"Vertex: \"); stringBuilder.append(((AdjacencyListGraph$Vertex)object).a); stringBuilder.append(\"\\n\"); stringBuilder.append(\"Adjacent vertices: \"); for (AdjacencyListGraph$Vertex adjacencyListGraph$Vertex : ((AdjacencyListGraph$Vertex)object).b) { stringBuilder.append(adjacencyListGraph$Vertex.a); stringBuilder.append(\" \"); } stringBuilder.append(\"\\n\"); } return stringBuilder.toString(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.AdjacencyListGraph$Vertex; import java.util.ArrayList; class AdjacencyListGraph { private ArrayList a = new ArrayList(); AdjacencyListGraph() { } public boolean removeEdge(Comparable comparable, Comparable comparable2) { AdjacencyListGraph$Vertex adjacencyListGraph$Vertex = null; for (AdjacencyListGraph$Vertex adjacencyListGraph$Vertex2 : this.a) { if (comparable.compareTo(adjacencyListGraph$Vertex2.a) != 0) continue; adjacencyListGraph$Vertex = adjacencyListGraph$Vertex2; break; } if (adjacencyListGraph$Vertex == null) { return false; } return adjacencyListGraph$Vertex.removeAdjacentVertex(comparable2); } public boolean addEdge(Comparable comparable, Comparable comparable2) { AdjacencyListGraph$Vertex adjacencyListGraph$Vertex = null; AdjacencyListGraph$Vertex adjacencyListGraph$Vertex2 = null; for (AdjacencyListGraph$Vertex adjacencyListGraph$Vertex3 : this.a) { if (comparable.compareTo(adjacencyListGraph$Vertex3.a) == 0) { adjacencyListGraph$Vertex = adjacencyListGraph$Vertex3; } else if (comparable2.compareTo(adjacencyListGraph$Vertex3.a) == 0) { adjacencyListGraph$Vertex2 = adjacencyListGraph$Vertex3; } if (adjacencyListGraph$Vertex == null || adjacencyListGraph$Vertex2 == null) continue; } if (adjacencyListGraph$Vertex == null) { adjacencyListGraph$Vertex = new AdjacencyListGraph$Vertex(comparable); this.a.add(adjacencyListGraph$Vertex); } if (adjacencyListGraph$Vertex2 == null) { adjacencyListGraph$Vertex2 = new AdjacencyListGraph$Vertex(comparable2); this.a.add(adjacencyListGraph$Vertex2); } return adjacencyListGraph$Vertex.addAdjacentVertex(adjacencyListGraph$Vertex2); } public String toString() { StringBuilder stringBuilder = new StringBuilder(); for (Object object : this.a) { stringBuilder.append(\"Vertex: \"); stringBuilder.append(((AdjacencyListGraph$Vertex)object).a); stringBuilder.append(\"\\n\"); stringBuilder.append(\"Adjacent vertices: \"); for (AdjacencyListGraph$Vertex adjacencyListGraph$Vertex : ((AdjacencyListGraph$Vertex)object).b) { stringBuilder.append(adjacencyListGraph$Vertex.a); stringBuilder.append(\" \"); } stringBuilder.append(\"\\n\"); } return stringBuilder.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; class AdjacencyMatrixGraph { private int a; private int b; private int[][] c; AdjacencyMatrixGraph(int n) { int n2 = 10; AdjacencyMatrixGraph adjacencyMatrixGraph = this; this.a = n2; int n3 = 0; AdjacencyMatrixGraph adjacencyMatrixGraph2 = this; this.b = n3; int[][] nArray = new int[10][10]; AdjacencyMatrixGraph adjacencyMatrixGraph3 = this; this.c = nArray; for (int i = 0; i < 10; ++i) { for (int j = 0; j < 10; ++j) { adjacencyMatrixGraph2 = this; adjacencyMatrixGraph2.c[i][j] = 0; } } } public int numberOfVertices() { return this.a; } public int numberOfEdges() { return this.b; } private boolean a(int n, int n2) { AdjacencyMatrixGraph adjacencyMatrixGraph = this; return adjacencyMatrixGraph.c[n][n2] != 0; } public boolean vertexDoesExist(int n) { return n >= 0 && n < this.numberOfVertices(); } public boolean edgeDoesExist(int n, int n2) { if (this.vertexDoesExist(n) && this.vertexDoesExist(n2)) { return this.a(n, n2); } return false; } public boolean addEdge(int n, int n2) { if (this.vertexDoesExist(n) && this.vertexDoesExist(n2) && !this.a(n, n2)) { AdjacencyMatrixGraph adjacencyMatrixGraph = this; adjacencyMatrixGraph.c[n][n2] = 1; adjacencyMatrixGraph = this; adjacencyMatrixGraph.c[n2][n] = 1; AdjacencyMatrixGraph adjacencyMatrixGraph2 = this; n = adjacencyMatrixGraph2.numberOfEdges() + 1; adjacencyMatrixGraph = adjacencyMatrixGraph2; adjacencyMatrixGraph2.b = n; return true; } return false; } public boolean removeEdge(int n, int n2) { if (this.vertexDoesExist(n) && this.vertexDoesExist(n2) && this.a(n, n2)) { AdjacencyMatrixGraph adjacencyMatrixGraph = this; adjacencyMatrixGraph.c[n][n2] = 0; adjacencyMatrixGraph = this; adjacencyMatrixGraph.c[n2][n] = 0; AdjacencyMatrixGraph adjacencyMatrixGraph2 = this; n = adjacencyMatrixGraph2.numberOfEdges() - 1; adjacencyMatrixGraph = adjacencyMatrixGraph2; adjacencyMatrixGraph2.b = n; return true; } return false; } public List depthFirstOrder(int n) { if (n >= this.a || n < 0) { return new ArrayList(); } boolean[] blArray = new boolean[this.a]; ArrayList arrayList = new ArrayList(); this.a(n, blArray, arrayList); return arrayList; } private void a(int n, boolean[] blArray, List list) { if (blArray[n]) { return; } blArray[n] = true; list.add(n); int[] nArray = this.c[n]; for (int i = 0; i < nArray.length; ++i) { if (nArray[i] != 1) continue; this.a(i, blArray, list); } } public List breadthFirstOrder(int n) { if (n >= this.a || n < 0) { return new ArrayList(); } boolean[] blArray = new boolean[this.a]; ArrayList<Integer> arrayList = new ArrayList<Integer>(); LinkedList<Integer> linkedList = new LinkedList<Integer>(); linkedList.add(n); while (!linkedList.isEmpty()) { n = (Integer)linkedList.poll(); if (blArray[n]) continue; arrayList.add(n); blArray[n] = true; int[] nArray = this.c[n]; for (int i = 0; i < nArray.length; ++i) { if (nArray[i] != 1) continue; linkedList.add(i); } } return arrayList; } public String toString() { int n; StringBuilder stringBuilder = new StringBuilder(\" \"); for (n = 0; n < this.numberOfVertices(); ++n) { stringBuilder.append(n).append(\" \"); } stringBuilder.append(\" \\n\"); for (n = 0; n < this.numberOfVertices(); ++n) { stringBuilder.append(n).append(\" : \"); for (int i = 0; i < this.numberOfVertices(); ++i) { stringBuilder.append(this.c[n][i]).append(\" \"); } stringBuilder.append(\"\\n\"); } return stringBuilder.toString(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; class AdjacencyMatrixGraph { private int a; private int b; private int[][] c; AdjacencyMatrixGraph(int n) { int n2 = 10; AdjacencyMatrixGraph adjacencyMatrixGraph = this; this.a = n2; int n3 = 0; AdjacencyMatrixGraph adjacencyMatrixGraph2 = this; this.b = n3; int[][] nArray = new int[10][10]; AdjacencyMatrixGraph adjacencyMatrixGraph3 = this; this.c = nArray; for (int i = 0; i < 10; ++i) { for (int j = 0; j < 10; ++j) { adjacencyMatrixGraph2 = this; adjacencyMatrixGraph2.c[i][j] = 0; } } } public int numberOfVertices() { return this.a; } public int numberOfEdges() { return this.b; } private boolean a(int n, int n2) { AdjacencyMatrixGraph adjacencyMatrixGraph = this; return adjacencyMatrixGraph.c[n][n2] != 0; } public boolean vertexDoesExist(int n) { return n >= 0 && n < this.numberOfVertices(); } public boolean edgeDoesExist(int n, int n2) { if (this.vertexDoesExist(n) && this.vertexDoesExist(n2)) { return this.a(n, n2); } return false; } public boolean addEdge(int n, int n2) { if (this.vertexDoesExist(n) && this.vertexDoesExist(n2) && !this.a(n, n2)) { AdjacencyMatrixGraph adjacencyMatrixGraph = this; adjacencyMatrixGraph.c[n][n2] = 1; adjacencyMatrixGraph = this; adjacencyMatrixGraph.c[n2][n] = 1; AdjacencyMatrixGraph adjacencyMatrixGraph2 = this; n = adjacencyMatrixGraph2.numberOfEdges() + 1; adjacencyMatrixGraph = adjacencyMatrixGraph2; adjacencyMatrixGraph2.b = n; return true; } return false; } public boolean removeEdge(int n, int n2) { if (this.vertexDoesExist(n) && this.vertexDoesExist(n2) && this.a(n, n2)) { AdjacencyMatrixGraph adjacencyMatrixGraph = this; adjacencyMatrixGraph.c[n][n2] = 0; adjacencyMatrixGraph = this; adjacencyMatrixGraph.c[n2][n] = 0; AdjacencyMatrixGraph adjacencyMatrixGraph2 = this; n = adjacencyMatrixGraph2.numberOfEdges() - 1; adjacencyMatrixGraph = adjacencyMatrixGraph2; adjacencyMatrixGraph2.b = n; return true; } return false; } public List depthFirstOrder(int n) { if (n >= this.a || n < 0) { return new ArrayList(); } boolean[] blArray = new boolean[this.a]; ArrayList arrayList = new ArrayList(); this.a(n, blArray, arrayList); return arrayList; } private void a(int n, boolean[] blArray, List list) { if (blArray[n]) { return; } blArray[n] = true; list.add(n); int[] nArray = this.c[n]; for (int i = 0; i < nArray.length; ++i) { if (nArray[i] != 1) continue; this.a(i, blArray, list); } } public List breadthFirstOrder(int n) { if (n >= this.a || n < 0) { return new ArrayList(); } boolean[] blArray = new boolean[this.a]; ArrayList<Integer> arrayList = new ArrayList<Integer>(); LinkedList<Integer> linkedList = new LinkedList<Integer>(); linkedList.add(n); while (!linkedList.isEmpty()) { n = (Integer)linkedList.poll(); if (blArray[n]) continue; arrayList.add(n); blArray[n] = true; int[] nArray = this.c[n]; for (int i = 0; i < nArray.length; ++i) { if (nArray[i] != 1) continue; linkedList.add(i); } } return arrayList; } public String toString() { int n; StringBuilder stringBuilder = new StringBuilder(\" \"); for (n = 0; n < this.numberOfVertices(); ++n) { stringBuilder.append(n).append(\" \"); } stringBuilder.append(\" \\n\"); for (n = 0; n < this.numberOfVertices(); ++n) { stringBuilder.append(n).append(\" : \"); for (int i = 0; i < this.numberOfVertices(); ++i) { stringBuilder.append(this.c[n][i]).append(\" \"); } stringBuilder.append(\"\\n\"); } return stringBuilder.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; final class AffineCipher { private AffineCipher() { } }", "deobfuscated_code": "package com.thealgorithms.ciphers; /** * The AffineCipher class implements the Affine cipher, a type of monoalphabetic substitution cipher. * It encrypts and decrypts messages using a linear transformation defined by the formula: * * E(x) = (a * x + b) mod m * D(y) = a^-1 * (y - b) mod m * * where: * - E(x) is the encrypted character, * - D(y) is the decrypted character, * - a is the multiplicative key (must be coprime to m), * - b is the additive key, * - x is the index of the plaintext character, * - y is the index of the ciphertext character, * - m is the size of the alphabet (26 for the English alphabet). * * The class provides methods for encrypting and decrypting messages, as well as a main method to demonstrate its usage. */ final class AffineCipher { private AffineCipher() { } // Key values of a and b static int a = 17; static int b = 20; /** * Encrypts a message using the Affine cipher. * * @param msg the plaintext message as a character array * @return the encrypted ciphertext */ static String encryptMessage(char[] msg) { // Cipher Text initially empty StringBuilder cipher = new StringBuilder(); for (int i = 0; i < msg.length; i++) { // Avoid space to be encrypted /* applying encryption formula ( a * x + b ) mod m {here x is msg[i] and m is 26} and added 'A' to bring it in the range of ASCII alphabet [65-90 | A-Z] */ if (msg[i] != ' ') { cipher.append((char) ((((a * (msg[i] - 'A')) + b) % 26) + 'A')); } else { // else simply append space character cipher.append(msg[i]); } } return cipher.toString(); } /** * Decrypts a ciphertext using the Affine cipher. * * @param cipher the ciphertext to decrypt * @return the decrypted plaintext message */ static String decryptCipher(String cipher) { StringBuilder msg = new StringBuilder(); int aInv = 0; int flag; // Find a^-1 (the multiplicative inverse of a in the group of integers modulo m.) for (int i = 0; i < 26; i++) { flag = (a * i) % 26; // Check if (a * i) % 26 == 1, // then i will be the multiplicative inverse of a if (flag == 1) { aInv = i; break; } } for (int i = 0; i < cipher.length(); i++) { /* Applying decryption formula a^-1 * (x - b) mod m {here x is cipher[i] and m is 26} and added 'A' to bring it in the range of ASCII alphabet [65-90 | A-Z] */ if (cipher.charAt(i) != ' ') { msg.append((char) (((aInv * ((cipher.charAt(i) - 'A') - b + 26)) % 26) + 'A')); } else { // else simply append space character msg.append(cipher.charAt(i)); } } return msg.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class AffineConverter { private final double a; private final double b; public AffineConverter(double d, double d2) { if (Double.isNaN(d) || Double.isNaN(d2)) { throw new IllegalArgumentException(\"Slope and intercept must be valid numbers.\"); } this.a = d; this.b = d2; } public final double convert(double d) { return this.a * d + this.b; } public final AffineConverter invert() { assert (this.a != 0.0) : \"Slope cannot be zero for inversion.\"; return new AffineConverter(1.0 / this.a, -this.b / this.a); } public final AffineConverter compose(AffineConverter affineConverter) { double d = this.a * affineConverter.a; double d2 = this.a * affineConverter.b + this.b; return new AffineConverter(d, d2); } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * A utility class to perform affine transformations of the form: * y = slope * x + intercept. * * This class supports inversion and composition of affine transformations. * It is immutable, meaning each instance represents a fixed transformation. */ public final class AffineConverter { private final double slope; private final double intercept; /** * Constructs an AffineConverter with the given slope and intercept. * * @param inSlope The slope of the affine transformation. * @param inIntercept The intercept (constant term) of the affine transformation. * @throws IllegalArgumentException if either parameter is NaN. */ public AffineConverter(final double inSlope, final double inIntercept) { if (Double.isNaN(inSlope) || Double.isNaN(inIntercept)) { throw new IllegalArgumentException(\"Slope and intercept must be valid numbers.\"); } slope = inSlope; intercept = inIntercept; } /** * Converts the given input value using the affine transformation: * result = slope * inValue + intercept. * * @param inValue The input value to convert. * @return The transformed value. */ public double convert(final double inValue) { return slope * inValue + intercept; } /** * Returns a new AffineConverter representing the inverse of the current transformation. * The inverse of y = slope * x + intercept is x = (y - intercept) / slope. * * @return A new AffineConverter representing the inverse transformation. * @throws AssertionError if the slope is zero, as the inverse would be undefined. */ public AffineConverter invert() { assert slope != 0.0 : \"Slope cannot be zero for inversion.\"; return new AffineConverter(1.0 / slope, -intercept / slope); } /** * Composes this affine transformation with another, returning a new AffineConverter. * If this transformation is f(x) and the other is g(x), the result is f(g(x)). * * @param other Another AffineConverter to compose with. * @return A new AffineConverter representing the composition of the two transformations. */ public AffineConverter compose(final AffineConverter other) { double newSlope = slope * other.slope; double newIntercept = slope * other.intercept + intercept; return new AffineConverter(newSlope, newIntercept); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class AgingScheduling$Task { String a; int b; int c; AgingScheduling$Task(String string, int n) { this.a = string; this.c = n; this.b = 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class AgingScheduling$Task { String a; int b; int c; AgingScheduling$Task(String string, int n) { this.a = string; this.c = n; this.b = 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.AgingScheduling$Task; import java.util.LinkedList; import java.util.Queue; public final class AgingScheduling { private final Queue a = new LinkedList(); public final void addTask(String string, int n) { this.a.offer(new AgingScheduling$Task(string, n)); } public final String scheduleNext() { if (this.a.isEmpty()) { return null; } AgingScheduling$Task agingScheduling$Task = (AgingScheduling$Task)this.a.poll(); ++agingScheduling$Task.b; agingScheduling$Task.c += agingScheduling$Task.b; this.a.offer(agingScheduling$Task); return agingScheduling$Task.a; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.LinkedList; import java.util.Queue; /** * AgingScheduling is an algorithm designed to prevent starvation * by gradually increasing the priority of waiting tasks. * The longer a process waits, the higher its priority becomes. * * Use Case: Useful in systems with mixed workloads to avoid * lower-priority tasks being starved by higher-priority tasks. * * @author Hardvan */ public final class AgingScheduling { static class Task { String name; int waitTime; int priority; Task(String name, int priority) { this.name = name; this.priority = priority; this.waitTime = 0; } } private final Queue<Task> taskQueue; public AgingScheduling() { taskQueue = new LinkedList<>(); } /** * Adds a task to the scheduler with a given priority. * * @param name name of the task * @param priority priority of the task */ public void addTask(String name, int priority) { taskQueue.offer(new Task(name, priority)); } /** * Schedules the next task based on the priority and wait time. * The priority of a task increases with the time it spends waiting. * * @return name of the next task to be executed */ public String scheduleNext() { if (taskQueue.isEmpty()) { return null; } Task nextTask = taskQueue.poll(); nextTask.waitTime++; nextTask.priority += nextTask.waitTime; taskQueue.offer(nextTask); return nextTask.name; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.HashMap; import java.util.Map; class AhoCorasick$Node { private final Map a = new HashMap(); private AhoCorasick$Node b = null; private AhoCorasick$Node c = null; private int d = -1; AhoCorasick$Node() { } public Map getChild() { return this.a; } public AhoCorasick$Node getSuffixLink() { return this.b; } public void setSuffixLink(AhoCorasick$Node ahoCorasick$Node) { this.b = ahoCorasick$Node; } public AhoCorasick$Node getOutputLink() { return this.c; } public void setOutputLink(AhoCorasick$Node ahoCorasick$Node) { this.c = ahoCorasick$Node; } public int getPatternInd() { return this.d; } public void setPatternInd(int n) { this.d = n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.HashMap; import java.util.Map; class AhoCorasick$Node { private final Map a = new HashMap(); private AhoCorasick$Node b = null; private AhoCorasick$Node c = null; private int d = -1; AhoCorasick$Node() { } public Map getChild() { return this.a; } public AhoCorasick$Node getSuffixLink() { return this.b; } public void setSuffixLink(AhoCorasick$Node ahoCorasick$Node) { this.b = ahoCorasick$Node; } public AhoCorasick$Node getOutputLink() { return this.c; } public void setOutputLink(AhoCorasick$Node ahoCorasick$Node) { this.c = ahoCorasick$Node; } public int getPatternInd() { return this.d; } public void setPatternInd(int n) { this.d = n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import com.thealgorithms.strings.AhoCorasick$Node; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; import java.util.List; final class AhoCorasick$PatternPositionRecorder extends Record { private final List a; private AhoCorasick$PatternPositionRecorder(List list) { this.a = list; } public final void recordPatternPositions(AhoCorasick$Node ahoCorasick$Node, int n) { if (ahoCorasick$Node.getPatternInd() >= 0) { ((List)this.a.get(ahoCorasick$Node.getPatternInd())).add(n); } for (ahoCorasick$Node = ahoCorasick$Node.getOutputLink(); ahoCorasick$Node != null; ahoCorasick$Node = ahoCorasick$Node.getOutputLink()) { ((List)this.a.get(ahoCorasick$Node.getPatternInd())).add(n); } } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{AhoCorasick$PatternPositionRecorder.class, \"positionByStringIndexValue\", \"a\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{AhoCorasick$PatternPositionRecorder.class, \"positionByStringIndexValue\", \"a\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{AhoCorasick$PatternPositionRecorder.class, \"positionByStringIndexValue\", \"a\"}, this, object); } public final List positionByStringIndexValue() { return this.a; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import com.thealgorithms.strings.AhoCorasick$Node; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; import java.util.List; final class AhoCorasick$PatternPositionRecorder extends Record { private final List a; private AhoCorasick$PatternPositionRecorder(List list) { this.a = list; } public final void recordPatternPositions(AhoCorasick$Node ahoCorasick$Node, int n) { if (ahoCorasick$Node.getPatternInd() >= 0) { ((List)this.a.get(ahoCorasick$Node.getPatternInd())).add(n); } for (ahoCorasick$Node = ahoCorasick$Node.getOutputLink(); ahoCorasick$Node != null; ahoCorasick$Node = ahoCorasick$Node.getOutputLink()) { ((List)this.a.get(ahoCorasick$Node.getPatternInd())).add(n); } } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{AhoCorasick$PatternPositionRecorder.class, \"positionByStringIndexValue\", \"a\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{AhoCorasick$PatternPositionRecorder.class, \"positionByStringIndexValue\", \"a\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{AhoCorasick$PatternPositionRecorder.class, \"positionByStringIndexValue\", \"a\"}, this, object); } public final List positionByStringIndexValue() { return this.a; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import com.thealgorithms.strings.AhoCorasick$Node; import com.thealgorithms.strings.AhoCorasick$PatternPositionRecorder; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedList; import java.util.List; public class AhoCorasick$Trie { private AhoCorasick$Node a = new AhoCorasick$Node(); private final String[] b; public AhoCorasick$Trie(String[] object) { AhoCorasick$Node ahoCorasick$Node; Object object2; this.b = object; object = this; for (int i = 0; i < ((AhoCorasick$Trie)object).b.length; ++i) { object2 = ((AhoCorasick$Trie)object).a; for (int j = 0; j < ((AhoCorasick$Trie)object).b[i].length(); ++j) { char c = ((AhoCorasick$Trie)object).b[i].charAt(j); if (((AhoCorasick$Node)object2).getChild().containsKey(Character.valueOf(c))) { object2 = (AhoCorasick$Node)((AhoCorasick$Node)object2).getChild().get(Character.valueOf(c)); continue; } ahoCorasick$Node = new AhoCorasick$Node(); ((AhoCorasick$Node)object2).getChild().put(Character.valueOf(c), ahoCorasick$Node); object2 = ahoCorasick$Node; } ((AhoCorasick$Node)object2).setPatternInd(i); } object = this; ((AhoCorasick$Trie)object).a.setSuffixLink(((AhoCorasick$Trie)object).a); LinkedList<AhoCorasick$Node> linkedList = new LinkedList<AhoCorasick$Node>(); Object object3 = linkedList; object2 = object; Iterator iterator = ((AhoCorasick$Trie)object2).a.getChild().keySet().iterator(); while (iterator.hasNext()) { char c = ((Character)iterator.next()).charValue(); ahoCorasick$Node = (AhoCorasick$Node)((AhoCorasick$Trie)object2).a.getChild().get(Character.valueOf(c)); object3.add(ahoCorasick$Node); ahoCorasick$Node.setSuffixLink(((AhoCorasick$Trie)object2).a); } while (!linkedList.isEmpty()) { object2 = (AhoCorasick$Node)linkedList.poll(); object3 = ((AhoCorasick$Node)object2).getChild().keySet().iterator(); while (object3.hasNext()) { AhoCorasick$Node ahoCorasick$Node2; char c = ((Character)object3.next()).charValue(); ahoCorasick$Node = (AhoCorasick$Node)((AhoCorasick$Node)object2).getChild().get(Character.valueOf(c)); for (ahoCorasick$Node2 = ((AhoCorasick$Node)object2).getSuffixLink(); !ahoCorasick$Node2.getChild().containsKey(Character.valueOf(c)) && ahoCorasick$Node2 != ((AhoCorasick$Trie)object).a; ahoCorasick$Node2 = ahoCorasick$Node2.getSuffixLink()) { } if (ahoCorasick$Node2.getChild().containsKey(Character.valueOf(c))) { ahoCorasick$Node.setSuffixLink((AhoCorasick$Node)ahoCorasick$Node2.getChild().get(Character.valueOf(c))); } else { ahoCorasick$Node.setSuffixLink(((AhoCorasick$Trie)object).a); } linkedList.add(ahoCorasick$Node); } if (((AhoCorasick$Node)object2).getSuffixLink().getPatternInd() >= 0) { Object object4 = object2; ((AhoCorasick$Node)object4).setOutputLink(((AhoCorasick$Node)object4).getSuffixLink()); continue; } Object object5 = object2; ((AhoCorasick$Node)object5).setOutputLink(((AhoCorasick$Node)object5).getSuffixLink().getOutputLink()); } } public List searchIn(String string) { int n; int n2; Object object = this; ArrayList arrayList = new ArrayList(((AhoCorasick$Trie)object).b.length); for (n2 = 0; n2 < ((AhoCorasick$Trie)object).b.length; ++n2) { arrayList.add(new ArrayList()); } ArrayList arrayList2 = arrayList; object = this.a; arrayList = new AhoCorasick$PatternPositionRecorder(arrayList2); for (n2 = 0; n2 < string.length(); ++n2) { n = string.charAt(n2); if (((AhoCorasick$Node)object).getChild().containsKey(Character.valueOf((char)n))) { object = (AhoCorasick$Node)((AhoCorasick$Node)object).getChild().get(Character.valueOf((char)n)); ((AhoCorasick$PatternPositionRecorder)((Object)arrayList)).recordPatternPositions((AhoCorasick$Node)object, n2); continue; } while (object != this.a && !((AhoCorasick$Node)object).getChild().containsKey(Character.valueOf((char)n))) { object = ((AhoCorasick$Node)object).getSuffixLink(); } if (!((AhoCorasick$Node)object).getChild().containsKey(Character.valueOf((char)n))) continue; --n2; } arrayList = arrayList2; object = this; for (n2 = 0; n2 < ((AhoCorasick$Trie)object).b.length; ++n2) { for (int i = 0; i < ((List)arrayList.get(n2)).size(); ++i) { n = (Integer)((List)arrayList.get(n2)).get(i); ((List)arrayList.get(n2)).set(i, n - ((AhoCorasick$Trie)object).b[n2].length() + 1); } } return arrayList2; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import com.thealgorithms.strings.AhoCorasick$Node; import com.thealgorithms.strings.AhoCorasick$PatternPositionRecorder; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedList; import java.util.List; public class AhoCorasick$Trie { private AhoCorasick$Node a = new AhoCorasick$Node(); private final String[] b; public AhoCorasick$Trie(String[] object) { AhoCorasick$Node ahoCorasick$Node; Object object2; this.b = object; object = this; for (int i = 0; i < ((AhoCorasick$Trie)object).b.length; ++i) { object2 = ((AhoCorasick$Trie)object).a; for (int j = 0; j < ((AhoCorasick$Trie)object).b[i].length(); ++j) { char c = ((AhoCorasick$Trie)object).b[i].charAt(j); if (((AhoCorasick$Node)object2).getChild().containsKey(Character.valueOf(c))) { object2 = (AhoCorasick$Node)((AhoCorasick$Node)object2).getChild().get(Character.valueOf(c)); continue; } ahoCorasick$Node = new AhoCorasick$Node(); ((AhoCorasick$Node)object2).getChild().put(Character.valueOf(c), ahoCorasick$Node); object2 = ahoCorasick$Node; } ((AhoCorasick$Node)object2).setPatternInd(i); } object = this; ((AhoCorasick$Trie)object).a.setSuffixLink(((AhoCorasick$Trie)object).a); LinkedList<AhoCorasick$Node> linkedList = new LinkedList<AhoCorasick$Node>(); Object object3 = linkedList; object2 = object; Iterator iterator = ((AhoCorasick$Trie)object2).a.getChild().keySet().iterator(); while (iterator.hasNext()) { char c = ((Character)iterator.next()).charValue(); ahoCorasick$Node = (AhoCorasick$Node)((AhoCorasick$Trie)object2).a.getChild().get(Character.valueOf(c)); object3.add(ahoCorasick$Node); ahoCorasick$Node.setSuffixLink(((AhoCorasick$Trie)object2).a); } while (!linkedList.isEmpty()) { object2 = (AhoCorasick$Node)linkedList.poll(); object3 = ((AhoCorasick$Node)object2).getChild().keySet().iterator(); while (object3.hasNext()) { AhoCorasick$Node ahoCorasick$Node2; char c = ((Character)object3.next()).charValue(); ahoCorasick$Node = (AhoCorasick$Node)((AhoCorasick$Node)object2).getChild().get(Character.valueOf(c)); for (ahoCorasick$Node2 = ((AhoCorasick$Node)object2).getSuffixLink(); !ahoCorasick$Node2.getChild().containsKey(Character.valueOf(c)) && ahoCorasick$Node2 != ((AhoCorasick$Trie)object).a; ahoCorasick$Node2 = ahoCorasick$Node2.getSuffixLink()) { } if (ahoCorasick$Node2.getChild().containsKey(Character.valueOf(c))) { ahoCorasick$Node.setSuffixLink((AhoCorasick$Node)ahoCorasick$Node2.getChild().get(Character.valueOf(c))); } else { ahoCorasick$Node.setSuffixLink(((AhoCorasick$Trie)object).a); } linkedList.add(ahoCorasick$Node); } if (((AhoCorasick$Node)object2).getSuffixLink().getPatternInd() >= 0) { Object object4 = object2; ((AhoCorasick$Node)object4).setOutputLink(((AhoCorasick$Node)object4).getSuffixLink()); continue; } Object object5 = object2; ((AhoCorasick$Node)object5).setOutputLink(((AhoCorasick$Node)object5).getSuffixLink().getOutputLink()); } } public List searchIn(String string) { int n; int n2; Object object = this; ArrayList arrayList = new ArrayList(((AhoCorasick$Trie)object).b.length); for (n2 = 0; n2 < ((AhoCorasick$Trie)object).b.length; ++n2) { arrayList.add(new ArrayList()); } ArrayList arrayList2 = arrayList; object = this.a; arrayList = new AhoCorasick$PatternPositionRecorder(arrayList2); for (n2 = 0; n2 < string.length(); ++n2) { n = string.charAt(n2); if (((AhoCorasick$Node)object).getChild().containsKey(Character.valueOf((char)n))) { object = (AhoCorasick$Node)((AhoCorasick$Node)object).getChild().get(Character.valueOf((char)n)); ((AhoCorasick$PatternPositionRecorder)((Object)arrayList)).recordPatternPositions((AhoCorasick$Node)object, n2); continue; } while (object != this.a && !((AhoCorasick$Node)object).getChild().containsKey(Character.valueOf((char)n))) { object = ((AhoCorasick$Node)object).getSuffixLink(); } if (!((AhoCorasick$Node)object).getChild().containsKey(Character.valueOf((char)n))) continue; --n2; } arrayList = arrayList2; object = this; for (n2 = 0; n2 < ((AhoCorasick$Trie)object).b.length; ++n2) { for (int i = 0; i < ((List)arrayList.get(n2)).size(); ++i) { n = (Integer)((List)arrayList.get(n2)).get(i); ((List)arrayList.get(n2)).set(i, n - ((AhoCorasick$Trie)object).b[n2].length() + 1); } } return arrayList2; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import com.thealgorithms.strings.AhoCorasick$Trie; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public final class AhoCorasick { private AhoCorasick() { } public static Map search(String object, String[] stringArray) { Object object2 = new AhoCorasick$Trie(stringArray); object = ((AhoCorasick$Trie)object2).searchIn((String)object); object2 = new HashMap(); for (int i = 0; i < stringArray.length; ++i) { String string = stringArray[i]; List list = (List)object.get(i); object2.put(string, new ArrayList(list)); } return object2; } }", "deobfuscated_code": "/* * Aho-Corasick String Matching Algorithm Implementation * * This code implements the Aho-Corasick algorithm, which is used for efficient * string matching in a given text. It can find multiple patterns simultaneously * and records their positions in the text. * * Author: Prabhat-Kumar-42 * GitHub: https://github.com/Prabhat-Kumar-42 */ package com.thealgorithms.strings; import java.util.ArrayList; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Queue; public final class AhoCorasick { private AhoCorasick() { } // Trie Node Class private static class Node { // Represents a character in the trie private final Map<Character, Node> child = new HashMap<>(); // Child nodes of the current node private Node suffixLink; // Suffix link to another node in the trie private Node outputLink; // Output link to another node in the trie private int patternInd; // Index of the pattern that ends at this node Node() { this.suffixLink = null; this.outputLink = null; this.patternInd = -1; } public Map<Character, Node> getChild() { return child; } public Node getSuffixLink() { return suffixLink; } public void setSuffixLink(final Node suffixLink) { this.suffixLink = suffixLink; } public Node getOutputLink() { return outputLink; } public void setOutputLink(final Node outputLink) { this.outputLink = outputLink; } public int getPatternInd() { return patternInd; } public void setPatternInd(final int patternInd) { this.patternInd = patternInd; } } // Trie Class public static class Trie { private Node root = null; // Root node of the trie private final String[] patterns; // patterns according to which Trie is constructed public Trie(final String[] patterns) { root = new Node(); // Initialize the root of the trie this.patterns = patterns; buildTrie(); buildSuffixAndOutputLinks(); } // builds AhoCorasick Trie private void buildTrie() { // Loop through each input pattern and building Trie for (int i = 0; i < patterns.length; i++) { Node curr = root; // Start at the root of the trie for each pattern // Loop through each character in the current pattern for (int j = 0; j < patterns[i].length(); j++) { char c = patterns[i].charAt(j); // Get the current character // Check if the current node has a child for the current character if (curr.getChild().containsKey(c)) { curr = curr.getChild().get(c); // Update the current node to the child node } else { // If no child node exists, create a new one and add it to the current node's children Node nn = new Node(); curr.getChild().put(c, nn); curr = nn; // Update the current node to the new child node } } curr.setPatternInd(i); // Store the index of the pattern in the current leaf node } } private void initializeSuffixLinksForChildNodesOfTheRoot(Queue<Node> q) { for (char rc : root.getChild().keySet()) { Node childNode = root.getChild().get(rc); q.add(childNode); // Add child node to the queue childNode.setSuffixLink(root); // Set suffix link to the root } } private void buildSuffixAndOutputLinks() { root.setSuffixLink(root); // Initialize the suffix link of the root to itself Queue<Node> q = new LinkedList<>(); // Initialize a queue for BFS traversal initializeSuffixLinksForChildNodesOfTheRoot(q); while (!q.isEmpty()) { Node currentState = q.poll(); // Get the current node for processing // Iterate through child nodes of the current node for (char cc : currentState.getChild().keySet()) { Node currentChild = currentState.getChild().get(cc); // Get the child node Node parentSuffix = currentState.getSuffixLink(); // Get the parent's suffix link // Calculate the suffix link for the child based on the parent's suffix link while (!parentSuffix.getChild().containsKey(cc) && parentSuffix != root) { parentSuffix = parentSuffix.getSuffixLink(); } // Set the calculated suffix link or default to root if (parentSuffix.getChild().containsKey(cc)) { currentChild.setSuffixLink(parentSuffix.getChild().get(cc)); } else { currentChild.setSuffixLink(root); } q.add(currentChild); // Add the child node to the queue for further processing } // Establish output links for nodes to efficiently identify patterns within patterns if (currentState.getSuffixLink().getPatternInd() >= 0) { currentState.setOutputLink(currentState.getSuffixLink()); } else { currentState.setOutputLink(currentState.getSuffixLink().getOutputLink()); } } } private List<List<Integer>> initializePositionByStringIndexValue() { List<List<Integer>> positionByStringIndexValue = new ArrayList<>(patterns.length); // Stores positions where patterns are found in the text for (int i = 0; i < patterns.length; i++) { positionByStringIndexValue.add(new ArrayList<>()); } return positionByStringIndexValue; } // Searches for patterns in the input text and records their positions public List<List<Integer>> searchIn(final String text) { var positionByStringIndexValue = initializePositionByStringIndexValue(); // Initialize a list to store positions of the current pattern Node parent = root; // Start searching from the root node PatternPositionRecorder positionRecorder = new PatternPositionRecorder(positionByStringIndexValue); for (int i = 0; i < text.length(); i++) { char ch = text.charAt(i); // Get the current character in the text // Check if the current node has a child for the current character if (parent.getChild().containsKey(ch)) { parent = parent.getChild().get(ch); // Update the current node to the child node positionRecorder.recordPatternPositions(parent, i); // Use the method in PatternPositionRecorder to record positions } else { // If no child node exists for the character, backtrack using suffix links while (parent != root && !parent.getChild().containsKey(ch)) { parent = parent.getSuffixLink(); } if (parent.getChild().containsKey(ch)) { i--; // Decrement i to reprocess the same character } } } setUpStartPoints(positionByStringIndexValue); return positionByStringIndexValue; } // by default positionByStringIndexValue contains end-points. This function converts those // endpoints to start points private void setUpStartPoints(List<List<Integer>> positionByStringIndexValue) { for (int i = 0; i < patterns.length; i++) { for (int j = 0; j < positionByStringIndexValue.get(i).size(); j++) { int endpoint = positionByStringIndexValue.get(i).get(j); positionByStringIndexValue.get(i).set(j, endpoint - patterns[i].length() + 1); } } } } // Class to handle pattern position recording private record PatternPositionRecorder(List<List<Integer>> positionByStringIndexValue) { // Constructor to initialize the recorder with the position list /** * Records positions for a pattern when it's found in the input text and follows * output links to record positions of other patterns. * * @param parent The current node representing a character in the pattern trie. * @param currentPosition The current position in the input text. */ public void recordPatternPositions(final Node parent, final int currentPosition) { // Check if the current node represents the end of a pattern if (parent.getPatternInd() > -1) { // Add the current position to the list of positions for the found pattern positionByStringIndexValue.get(parent.getPatternInd()).add(currentPosition); } Node outputLink = parent.getOutputLink(); // Follow output links to find and record positions of other patterns while (outputLink != null) { // Add the current position to the list of positions for the pattern linked by outputLink positionByStringIndexValue.get(outputLink.getPatternInd()).add(currentPosition); outputLink = outputLink.getOutputLink(); } } } // method to search for patterns in text public static Map<String, List<Integer>> search(final String text, final String[] patterns) { final var trie = new Trie(patterns); final var positionByStringIndexValue = trie.searchIn(text); return convert(positionByStringIndexValue, patterns); } // method for converting results to a map private static Map<String, List<Integer>> convert(final List<List<Integer>> positionByStringIndexValue, final String[] patterns) { Map<String, List<Integer>> positionByString = new HashMap<>(); for (int i = 0; i < patterns.length; i++) { String pattern = patterns[i]; List<Integer> positions = positionByStringIndexValue.get(i); positionByString.put(pattern, new ArrayList<>(positions)); } return positionByString; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; class AliquotSum$1 { int a = 0; AliquotSum$1() { } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; class AliquotSum$1 { int a = 0; AliquotSum$1() { } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.AliquotSum$1; import java.util.stream.IntStream; public final class AliquotSum { private AliquotSum() { } public static int getAliquotValue(int n3) { AliquotSum$1 aliquotSum$1 = new AliquotSum$1(); IntStream.iterate(1, n -> ++n).limit(n3 / 2).filter(n2 -> n3 % n2 == 0).forEach(n -> aliquotSum$1.a += n); return aliquotSum$1.a; } public static int getAliquotSum(int n) { if (n <= 0) { return -1; } int n2 = 1; double d = Math.sqrt(n); int n3 = 2; while ((double)n3 <= d) { if (n % n3 == 0) { n2 += n3 + n / n3; } ++n3; } double d2 = d; if (d2 == (double)((int)d2)) { n2 -= (int)d; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.stream.IntStream; /** * In number theory, the aliquot sum s(n) of a positive integer n is the sum of * all proper divisors of n, that is, all divisors of n other than n itself. For * example, the proper divisors of 15 (that is, the positive divisors of 15 that * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 + * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum */ public final class AliquotSum { private AliquotSum() { } /** * Finds the aliquot sum of an integer number. * * @param number a positive integer * @return aliquot sum of given {@code number} */ public static int getAliquotValue(int number) { var sumWrapper = new Object() { int value = 0; }; IntStream.iterate(1, i -> ++i).limit(number / 2).filter(i -> number % i == 0).forEach(i -> sumWrapper.value += i); return sumWrapper.value; } /** * Function to calculate the aliquot sum of an integer number * * @param n a positive integer * @return aliquot sum of given {@code number} */ public static int getAliquotSum(int n) { if (n <= 0) { return -1; } int sum = 1; double root = Math.sqrt(n); /* * We can get the factors after the root by dividing number by its factors * before the root. * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100. * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5. * Now by dividing 100 by each factor before 10 we get: * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20 * So we get 100, 50, 25 and 20 which are factors of 100 after 10 */ for (int i = 2; i <= root; i++) { if (n % i == 0) { sum += i + n / i; } } // if n is a perfect square then its root was added twice in above loop, so subtracting root // from sum if (root == (int) root) { sum -= (int) root; } return sum; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import java.util.ArrayList; import java.util.List; public final class AllConstruct { private AllConstruct() { } public static List allConstruct(String string, Iterable iterable) { int n; ArrayList arrayList = new ArrayList(string.length() + 1); for (n = 0; n <= string.length(); ++n) { arrayList.add(new ArrayList()); } ((List)arrayList.get(0)).add(new ArrayList()); for (n = 0; n <= string.length(); ++n) { if (((List)arrayList.get(n)).isEmpty()) continue; for (String string2 : iterable) { if (n + string2.length() > string.length()) continue; int n2 = n; if (!string.substring(n2, n2 + string2.length()).equals(string2)) continue; ArrayList arrayList2 = new ArrayList(); for (ArrayList<String> arrayList3 : (List)arrayList.get(n)) { arrayList3 = new ArrayList<String>(arrayList3); arrayList3.add(string2); arrayList2.add(arrayList3); } ((List)arrayList.get(n + string2.length())).addAll(arrayList2); } } return (List)arrayList.get(string.length()); } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.ArrayList; import java.util.List; /** * This class provides a solution to the \"All Construct\" problem. * * The problem is to determine all the ways a target string can be constructed * from a given list of substrings. Each substring in the word bank can be used * multiple times, and the order of substrings matters. * * @author Hardvan */ public final class AllConstruct { private AllConstruct() { } /** * Finds all possible ways to construct the target string using substrings * from the given word bank. * Time Complexity: O(n * m * k), where n = length of the target, * m = number of words in wordBank, and k = average length of a word. * * Space Complexity: O(n * m) due to the size of the table storing combinations. * * @param target The target string to construct. * @param wordBank An iterable collection of substrings that can be used to construct the target. * @return A list of lists, where each inner list represents one possible * way of constructing the target string using the given word bank. */ public static List<List<String>> allConstruct(String target, Iterable<String> wordBank) { List<List<List<String>>> table = new ArrayList<>(target.length() + 1); for (int i = 0; i <= target.length(); i++) { table.add(new ArrayList<>()); } table.get(0).add(new ArrayList<>()); for (int i = 0; i <= target.length(); i++) { if (!table.get(i).isEmpty()) { for (String word : wordBank) { if (i + word.length() <= target.length() && target.substring(i, i + word.length()).equals(word)) { List<List<String>> newCombinations = new ArrayList<>(); for (List<String> combination : table.get(i)) { List<String> newCombination = new ArrayList<>(combination); newCombination.add(word); newCombinations.add(newCombination); } table.get(i + word.length()).addAll(newCombinations); } } } } return table.get(target.length()); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.List; public class AllPathsFromSourceToTarget { private final int a; private static List b = new ArrayList(); private ArrayList[] c; public AllPathsFromSourceToTarget(int n) { this.a = n; AllPathsFromSourceToTarget allPathsFromSourceToTarget = this; this.c = new ArrayList[allPathsFromSourceToTarget.a]; for (int i = 0; i < allPathsFromSourceToTarget.a; ++i) { allPathsFromSourceToTarget.c[i] = new ArrayList(); } } public void addEdge(int n, int n2) { this.c[n].add(n2); } public void storeAllPaths(int n, int n2) { boolean[] blArray = new boolean[this.a]; ArrayList<Integer> arrayList = new ArrayList<Integer>(); arrayList.add(n); this.a(n, n2, blArray, arrayList); } private void a(Integer n, Integer n2, boolean[] blArray, List list) { if (n.equals(n2)) { b.add(new ArrayList(list)); return; } blArray[n.intValue()] = true; for (Integer n3 : this.c[n]) { if (blArray[n3]) continue; list.add(n3); this.a(n3, n2, blArray, list); list.remove(n3); } blArray[n.intValue()] = false; } public static List allPathsFromSourceToTarget(int n, int[][] nArray, int n2, int n3) { AllPathsFromSourceToTarget allPathsFromSourceToTarget = new AllPathsFromSourceToTarget(n); for (int[] nArray2 : nArray) { allPathsFromSourceToTarget.addEdge(nArray2[0], nArray2[1]); } allPathsFromSourceToTarget.storeAllPaths(n2, n3); return b; } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.List; /** * Program description - To find all possible paths from source to destination * <a href=\"https://en.wikipedia.org/wiki/Shortest_path_problem\">Wikipedia</a> * * @author <a href=\"https://github.com/siddhant2002\">Siddhant Swarup Mallick</a> */ @SuppressWarnings({\"rawtypes\", \"unchecked\"}) public class AllPathsFromSourceToTarget { // No. of vertices in graph private final int v; // To store the paths from source to destination static List<List<Integer>> nm = new ArrayList<>(); // adjacency list private ArrayList<Integer>[] adjList; // Constructor public AllPathsFromSourceToTarget(int vertices) { // initialise vertex count this.v = vertices; // initialise adjacency list initAdjList(); } // utility method to initialise adjacency list private void initAdjList() { adjList = new ArrayList[v]; for (int i = 0; i < v; i++) { adjList[i] = new ArrayList<>(); } } // add edge from u to v public void addEdge(int u, int v) { // Add v to u's list. adjList[u].add(v); } public void storeAllPaths(int s, int d) { boolean[] isVisited = new boolean[v]; ArrayList<Integer> pathList = new ArrayList<>(); // add source to path[] pathList.add(s); // Call recursive utility storeAllPathsUtil(s, d, isVisited, pathList); } // A recursive function to print all paths from 'u' to 'd'. // isVisited[] keeps track of vertices in current path. // localPathList<> stores actual vertices in the current path private void storeAllPathsUtil(Integer u, Integer d, boolean[] isVisited, List<Integer> localPathList) { if (u.equals(d)) { nm.add(new ArrayList<>(localPathList)); return; } // Mark the current node isVisited[u] = true; // Recursion for all the vertices adjacent to current vertex for (Integer i : adjList[u]) { if (!isVisited[i]) { // store current node in path[] localPathList.add(i); storeAllPathsUtil(i, d, isVisited, localPathList); // remove current node in path[] localPathList.remove(i); } } // Mark the current node isVisited[u] = false; } // Driver program public static List<List<Integer>> allPathsFromSourceToTarget(int vertices, int[][] a, int source, int destination) { // Create a sample graph AllPathsFromSourceToTarget g = new AllPathsFromSourceToTarget(vertices); for (int[] i : a) { g.addEdge(i[0], i[1]); // edges are added } g.storeAllPaths(source, destination); // method call to store all possible paths return nm; // returns all possible paths from source to destination } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class Alphabetical { private Alphabetical() { } public static boolean isAlphabetical(String string) { string = string.toLowerCase(); for (int i = 0; i < string.length() - 1; ++i) { if (Character.isLetter(string.charAt(i)) && string.charAt(i) <= string.charAt(i + 1)) continue; return false; } if (!string.isEmpty()) { String string2 = string; if (Character.isLetter(string2.charAt(string2.length() - 1))) { return true; } } return false; } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * Utility class for checking if a string's characters are in alphabetical order. * <p> * Alphabetical order is a system whereby character strings are placed in order * based on the position of the characters in the conventional ordering of an * alphabet. * <p> * Reference: <a href=\"https://en.wikipedia.org/wiki/Alphabetical_order\">Wikipedia: Alphabetical Order</a> */ public final class Alphabetical { private Alphabetical() { } /** * Checks whether the characters in the given string are in alphabetical order. * Non-letter characters will cause the check to fail. * * @param s the input string * @return {@code true} if all characters are in alphabetical order (case-insensitive), otherwise {@code false} */ public static boolean isAlphabetical(String s) { s = s.toLowerCase(); for (int i = 0; i < s.length() - 1; ++i) { if (!Character.isLetter(s.charAt(i)) || s.charAt(i) > s.charAt(i + 1)) { return false; } } return !s.isEmpty() && Character.isLetter(s.charAt(s.length() - 1)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. * * Could not load the following classes: * org.apache.commons.lang3.tuple.Pair */ package com.thealgorithms.maths; import java.util.LinkedHashSet; import java.util.Set; import org.apache.commons.lang3.tuple.Pair; public final class AmicableNumber { private AmicableNumber() { } public static Set findAllInRange(int n, int n2) { if (n <= 0 || n2 <= 0 || n2 < n) { throw new IllegalArgumentException(\"Given range of values is invalid!\"); } LinkedHashSet<Pair> linkedHashSet = new LinkedHashSet<Pair>(); while (n < n2) { for (int i = n + 1; i <= n2; ++i) { if (!AmicableNumber.isAmicableNumber(n, i)) continue; linkedHashSet.add(Pair.of((Object)n, (Object)i)); } ++n; } return linkedHashSet; } public static boolean isAmicableNumber(int n, int n2) { if (n <= 0 || n2 <= 0) { throw new IllegalArgumentException(\"Input numbers must be natural!\"); } int n3 = n; if (AmicableNumber.a(n3, n3) == n2) { int n4 = n2; if (AmicableNumber.a(n4, n4) == n) { return true; } } return false; } private static int a(int n, int n2) { while (n2 != 1) { if (n % --n2 != 0) continue; return AmicableNumber.a(n, n2) + n2; } return 0; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.LinkedHashSet; import java.util.Set; import org.apache.commons.lang3.tuple.Pair; /** * Amicable numbers are two different natural numbers that the sum of the * proper divisors of each is equal to the other number. * (A proper divisor of a number is a positive factor of that number other than the number itself. * For example, the proper divisors of 6 are 1, 2, and 3.) * A pair of amicable numbers constitutes an aliquot sequence of period 2. * It is unknown if there are infinitely many pairs of amicable numbers. * * <p> * link: https://en.wikipedia.org/wiki/Amicable_numbers * <p> * Simple Example: (220, 284) * 220 is divisible by {1,2,4,5,10,11,20,22,44,55,110} <-SUM = 284 * 284 is divisible by {1,2,4,71,142} <-SUM = 220. */ public final class AmicableNumber { private AmicableNumber() { } /** * Finds all the amicable numbers in a given range. * * @param from range start value * @param to range end value (inclusive) * @return list with amicable numbers found in given range. */ public static Set<Pair<Integer, Integer>> findAllInRange(int from, int to) { if (from <= 0 || to <= 0 || to < from) { throw new IllegalArgumentException(\"Given range of values is invalid!\"); } Set<Pair<Integer, Integer>> result = new LinkedHashSet<>(); for (int i = from; i < to; i++) { for (int j = i + 1; j <= to; j++) { if (isAmicableNumber(i, j)) { result.add(Pair.of(i, j)); } } } return result; } /** * Checks whether 2 numbers are AmicableNumbers or not. */ public static boolean isAmicableNumber(int a, int b) { if (a <= 0 || b <= 0) { throw new IllegalArgumentException(\"Input numbers must be natural!\"); } return sumOfDividers(a, a) == b && sumOfDividers(b, b) == a; } /** * Recursively calculates the sum of all dividers for a given number excluding the divider itself. */ private static int sumOfDividers(int number, int divisor) { if (divisor == 1) { return 0; } else if (number % --divisor == 0) { return sumOfDividers(number, divisor) + divisor; } else { return sumOfDividers(number, divisor); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.Arrays; import java.util.HashMap; public final class Anagrams { private Anagrams() { } public static boolean areAnagramsBySorting(String object, String object2) { object = ((String)object).toLowerCase().replaceAll(\"[^a-z]\", \"\"); object2 = ((String)object2).toLowerCase().replaceAll(\"[^a-z]\", \"\"); if (((String)object).length() != ((String)object2).length()) { return false; } object = ((String)object).toCharArray(); object2 = ((String)object2).toCharArray(); Arrays.sort((char[])object); Arrays.sort((char[])object2); return Arrays.equals((char[])object, (char[])object2); } public static boolean areAnagramsByCountingChars(String object, String string) { Object object2; int n; object = ((String)object).toLowerCase().replaceAll(\"[^a-z]\", \"\"); string = string.toLowerCase().replaceAll(\"[^a-z]\", \"\"); int[] nArray = new int[128]; char[] cArray = ((String)object).toCharArray(); object = cArray; int n2 = cArray.length; for (n = 0; n < n2; ++n) { Object object3 = object2 = object[n]; nArray[object3] = nArray[object3] + 1; } char[] cArray2 = string.toCharArray(); object = cArray2; n2 = cArray2.length; for (n = 0; n < n2; ++n) { Object object4 = object2 = object[n]; nArray[object4] = nArray[object4] - 1; } object = nArray; int cfr_ignored_0 = nArray.length; for (n = 0; n < 128; ++n) { object2 = object[n]; if (object2 == false) continue; return false; } return true; } public static boolean areAnagramsByCountingCharsSingleArray(String string, String string2) { string = string.toLowerCase().replaceAll(\"[^a-z]\", \"\"); string2 = string2.toLowerCase().replaceAll(\"[^a-z]\", \"\"); if (string.length() != string2.length()) { return false; } int[] nArray = new int[26]; for (int i = 0; i < string.length(); ++i) { int n = string.charAt(i) - 97; nArray[n] = nArray[n] + 1; int n2 = string2.charAt(i) - 97; nArray[n2] = nArray[n2] - 1; } int[] nArray2 = nArray; int cfr_ignored_0 = nArray.length; for (int i = 0; i < 26; ++i) { int n = nArray2[i]; if (n == 0) continue; return false; } return true; } public static boolean areAnagramsUsingHashMap(String object, String string) { Object object2; int n2; object = ((String)object).toLowerCase().replaceAll(\"[^a-z]\", \"\"); string = string.toLowerCase().replaceAll(\"[^a-z]\", \"\"); if (((String)object).length() != string.length()) { return false; } HashMap<Character, Integer> hashMap = new HashMap<Character, Integer>(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n3 = cArray.length; for (n2 = 0; n2 < n3; ++n2) { object2 = object[n2]; hashMap.put(Character.valueOf((char)object2), hashMap.getOrDefault(Character.valueOf((char)object2), 0) + 1); } char[] cArray2 = string.toCharArray(); object = cArray2; n3 = cArray2.length; for (n2 = 0; n2 < n3; ++n2) { object2 = object[n2]; if (!hashMap.containsKey(Character.valueOf((char)object2)) || (Integer)hashMap.get(Character.valueOf((char)object2)) == 0) { return false; } hashMap.put(Character.valueOf((char)object2), (Integer)hashMap.get(Character.valueOf((char)object2)) - 1); } return hashMap.values().stream().allMatch(n -> n == 0); } public static boolean areAnagramsBySingleFreqArray(String string, String string2) { string = string.toLowerCase().replaceAll(\"[^a-z]\", \"\"); string2 = string2.toLowerCase().replaceAll(\"[^a-z]\", \"\"); if (string.length() != string2.length()) { return false; } int[] nArray = new int[26]; for (int i = 0; i < string.length(); ++i) { int n = string.charAt(i) - 97; nArray[n] = nArray[n] + 1; int n2 = string2.charAt(i) - 97; nArray[n2] = nArray[n2] - 1; } int[] nArray2 = nArray; int cfr_ignored_0 = nArray.length; for (int i = 0; i < 26; ++i) { int n = nArray2[i]; if (n == 0) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.Arrays; import java.util.HashMap; /** * An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, * typically using all the original letters exactly once.[1] * For example, the word anagram itself can be rearranged into nag a ram, * also the word binary into brainy and the word adobe into abode. * Reference from https://en.wikipedia.org/wiki/Anagram */ public final class Anagrams { private Anagrams() { } /** * Checks if two strings are anagrams by sorting the characters and comparing them. * Time Complexity: O(n log n) * Space Complexity: O(n) * * @param s the first string * @param t the second string * @return true if the strings are anagrams, false otherwise */ public static boolean areAnagramsBySorting(String s, String t) { s = s.toLowerCase().replaceAll(\"[^a-z]\", \"\"); t = t.toLowerCase().replaceAll(\"[^a-z]\", \"\"); if (s.length() != t.length()) { return false; } char[] c = s.toCharArray(); char[] d = t.toCharArray(); Arrays.sort(c); Arrays.sort(d); return Arrays.equals(c, d); } /** * Checks if two strings are anagrams by counting the frequency of each character. * Time Complexity: O(n) * Space Complexity: O(1) * * @param s the first string * @param t the second string * @return true if the strings are anagrams, false otherwise */ public static boolean areAnagramsByCountingChars(String s, String t) { s = s.toLowerCase().replaceAll(\"[^a-z]\", \"\"); t = t.toLowerCase().replaceAll(\"[^a-z]\", \"\"); int[] dict = new int[128]; for (char ch : s.toCharArray()) { dict[ch]++; } for (char ch : t.toCharArray()) { dict[ch]--; } for (int e : dict) { if (e != 0) { return false; } } return true; } /** * Checks if two strings are anagrams by counting the frequency of each character * using a single array. * Time Complexity: O(n) * Space Complexity: O(1) * * @param s the first string * @param t the second string * @return true if the strings are anagrams, false otherwise */ public static boolean areAnagramsByCountingCharsSingleArray(String s, String t) { s = s.toLowerCase().replaceAll(\"[^a-z]\", \"\"); t = t.toLowerCase().replaceAll(\"[^a-z]\", \"\"); if (s.length() != t.length()) { return false; } int[] charCount = new int[26]; for (int i = 0; i < s.length(); i++) { charCount[s.charAt(i) - 'a']++; charCount[t.charAt(i) - 'a']--; } for (int count : charCount) { if (count != 0) { return false; } } return true; } /** * Checks if two strings are anagrams using a HashMap to store character frequencies. * Time Complexity: O(n) * Space Complexity: O(n) * * @param s the first string * @param t the second string * @return true if the strings are anagrams, false otherwise */ public static boolean areAnagramsUsingHashMap(String s, String t) { s = s.toLowerCase().replaceAll(\"[^a-z]\", \"\"); t = t.toLowerCase().replaceAll(\"[^a-z]\", \"\"); if (s.length() != t.length()) { return false; } HashMap<Character, Integer> charCountMap = new HashMap<>(); for (char c : s.toCharArray()) { charCountMap.put(c, charCountMap.getOrDefault(c, 0) + 1); } for (char c : t.toCharArray()) { if (!charCountMap.containsKey(c) || charCountMap.get(c) == 0) { return false; } charCountMap.put(c, charCountMap.get(c) - 1); } return charCountMap.values().stream().allMatch(count -> count == 0); } /** * Checks if two strings are anagrams using an array to track character frequencies. * This approach optimizes space complexity by using only one array. * Time Complexity: O(n) * Space Complexity: O(1) * * @param s the first string * @param t the second string * @return true if the strings are anagrams, false otherwise */ public static boolean areAnagramsBySingleFreqArray(String s, String t) { s = s.toLowerCase().replaceAll(\"[^a-z]\", \"\"); t = t.toLowerCase().replaceAll(\"[^a-z]\", \"\"); if (s.length() != t.length()) { return false; } int[] freq = new int[26]; for (int i = 0; i < s.length(); i++) { freq[s.charAt(i) - 'a']++; freq[t.charAt(i) - 'a']--; } for (int count : freq) { if (count != 0) { return false; } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.util.Arrays; import java.util.HashSet; import java.util.InputMismatchException; import java.util.Scanner; public final class AnyBaseToAnyBase { private AnyBaseToAnyBase() { } public static void main(String[] object) { int n; int n2; String string; object = new Scanner(System.in); block2: while (true) { try { while (true) { System.out.print(\"Enter number: \"); string = ((Scanner)object).next(); System.out.print(\"Enter beginning base (between 2 and 36): \"); n2 = ((Scanner)object).nextInt(); if (n2 > 36 || n2 < 2) { System.out.println(\"Invalid base!\"); continue; } if (!AnyBaseToAnyBase.validForBase(string, n2)) { System.out.println(\"The number is invalid for this base!\"); continue; } System.out.print(\"Enter end base (between 2 and 36): \"); n = ((Scanner)object).nextInt(); if (n <= 36 && n >= 2) break block2; System.out.println(\"Invalid base!\"); } } catch (InputMismatchException inputMismatchException) { System.out.println(\"Invalid input.\"); ((Scanner)object).next(); continue; } break; } System.out.println(AnyBaseToAnyBase.base2base(string, n2, n)); ((Scanner)object).close(); } public static boolean validForBase(String string, int n) { Object object = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'}; char[] cArray = Arrays.copyOfRange((char[])object, 0, n); object = new HashSet(); for (int i = 0; i < cArray.length; ++i) { ((HashSet)object).add(Character.valueOf(cArray[i])); } for (char c : string.toCharArray()) { if (((HashSet)object).contains(Character.valueOf(c))) continue; return false; } return true; } public static String base2base(String string, int n, int n2) { int n3 = 0; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < string.length(); ++i) { int n4 = string.charAt(i); n4 = n4 >= 65 && n4 <= 90 ? 10 + (n4 - 65) : (n4 -= 48); n3 = n3 * n + n4; } if (n3 == 0) { return \"0\"; } while (n3 != 0) { if (n3 % n2 < 10) { stringBuilder.insert(0, n3 % n2); } else { stringBuilder.insert(0, (char)(n3 % n2 + 55)); } n3 /= n2; } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.util.Arrays; import java.util.HashSet; import java.util.InputMismatchException; import java.util.Scanner; /** * Class for converting from \"any\" base to \"any\" other base, when \"any\" means * from 2-36. Works by going from base 1 to decimal to base 2. Includes * auxiliary method for determining whether a number is valid for a given base. * * @author Michael Rolland * @version 2017.10.10 */ public final class AnyBaseToAnyBase { private AnyBaseToAnyBase() { } /** * Smallest and largest base you want to accept as valid input */ static final int MINIMUM_BASE = 2; static final int MAXIMUM_BASE = 36; public static void main(String[] args) { Scanner in = new Scanner(System.in); String n; int b1; int b2; while (true) { try { System.out.print(\"Enter number: \"); n = in.next(); System.out.print(\"Enter beginning base (between \" + MINIMUM_BASE + \" and \" + MAXIMUM_BASE + \"): \"); b1 = in.nextInt(); if (b1 > MAXIMUM_BASE || b1 < MINIMUM_BASE) { System.out.println(\"Invalid base!\"); continue; } if (!validForBase(n, b1)) { System.out.println(\"The number is invalid for this base!\"); continue; } System.out.print(\"Enter end base (between \" + MINIMUM_BASE + \" and \" + MAXIMUM_BASE + \"): \"); b2 = in.nextInt(); if (b2 > MAXIMUM_BASE || b2 < MINIMUM_BASE) { System.out.println(\"Invalid base!\"); continue; } break; } catch (InputMismatchException e) { System.out.println(\"Invalid input.\"); in.next(); } } System.out.println(base2base(n, b1, b2)); in.close(); } /** * Checks if a number (as a String) is valid for a given base. */ public static boolean validForBase(String n, int base) { char[] validDigits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', }; // digitsForBase contains all the valid digits for the base given char[] digitsForBase = Arrays.copyOfRange(validDigits, 0, base); // Convert character array into set for convenience of contains() method HashSet<Character> digitsList = new HashSet<>(); for (int i = 0; i < digitsForBase.length; i++) { digitsList.add(digitsForBase[i]); } // Check that every digit in n is within the list of valid digits for that base. for (char c : n.toCharArray()) { if (!digitsList.contains(c)) { return false; } } return true; } /** * Method to convert any integer from base b1 to base b2. Works by * converting from b1 to decimal, then decimal to b2. * * @param n The integer to be converted. * @param b1 Beginning base. * @param b2 End base. * @return n in base b2. */ public static String base2base(String n, int b1, int b2) { // Declare variables: decimal value of n, // character of base b1, character of base b2, // and the string that will be returned. int decimalValue = 0; int charB2; char charB1; StringBuilder output = new StringBuilder(); // Go through every character of n for (int i = 0; i < n.length(); i++) { // store the character in charB1 charB1 = n.charAt(i); // if it is a non-number, convert it to a decimal value >9 and store it in charB2 if (charB1 >= 'A' && charB1 <= 'Z') { charB2 = 10 + (charB1 - 'A'); } // Else, store the integer value in charB2 else { charB2 = charB1 - '0'; } // Convert the digit to decimal and add it to the // decimalValue of n decimalValue = decimalValue * b1 + charB2; } // Converting the decimal value to base b2: // A number is converted from decimal to another base // by continuously dividing by the base and recording // the remainder until the quotient is zero. The number in the // new base is the remainders, with the last remainder // being the left-most digit. if (0 == decimalValue) { return \"0\"; } // While the quotient is NOT zero: while (decimalValue != 0) { // If the remainder is a digit < 10, simply add it to // the left side of the new number. if (decimalValue % b2 < 10) { output.insert(0, decimalValue % b2); } // If the remainder is >= 10, add a character with the // corresponding value to the new number. (A = 10, B = 11, C = 12, ...) else { output.insert(0, (char) ((decimalValue % b2) + 55)); } // Divide by the new base again decimalValue /= b2; } return output.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class AnyBaseToDecimal { private AnyBaseToDecimal() { } public static int convertToDecimal(String string, int n) { int n2 = 0; int n3 = 1; for (int i = string.length() - 1; i >= 0; --i) { char c; char c2 = string.charAt(i); if (Character.isDigit(c2)) { c = c2 - 48; } else if (Character.isUpperCase(c2)) { c = c2 - 55; } else { throw new NumberFormatException(\"invalid character:\" + c2); } c2 = c; if (c >= n) { throw new NumberFormatException(\"For input string: \" + string); } n2 += c2 * n3; n3 *= n; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * @author Varun Upadhyay (<a href=\"https://github.com/varunu28\">...</a>) */ public final class AnyBaseToDecimal { private static final int CHAR_OFFSET_FOR_DIGIT = '0'; private static final int CHAR_OFFSET_FOR_UPPERCASE = 'A' - 10; private AnyBaseToDecimal() { } /** * Convert any radix to a decimal number. * * @param input the string to be converted * @param radix the radix (base) of the input string * @return the decimal equivalent of the input string * @throws NumberFormatException if the input string or radix is invalid */ public static int convertToDecimal(String input, int radix) { int result = 0; int power = 1; for (int i = input.length() - 1; i >= 0; i--) { int digit = valOfChar(input.charAt(i)); if (digit >= radix) { throw new NumberFormatException(\"For input string: \" + input); } result += digit * power; power *= radix; } return result; } /** * Convert a character to its integer value. * * @param character the character to be converted * @return the integer value represented by the character * @throws NumberFormatException if the character is not an uppercase letter or a digit */ private static int valOfChar(char character) { if (Character.isDigit(character)) { return character - CHAR_OFFSET_FOR_DIGIT; } else if (Character.isUpperCase(character)) { return character - CHAR_OFFSET_FOR_UPPERCASE; } else { throw new NumberFormatException(\"invalid character:\" + character); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class AnytoAny { private AnytoAny() { } public static int convertBase(int n, int n2, int n3) { if (n2 < 2 || n2 > 10 || n3 < 2 || n3 > 10) { throw new IllegalArgumentException(\"Bases must be between 2 and 10.\"); } int n4 = 0; int n5 = 1; while (n != 0) { n4 += n % 10 * n5; n5 *= n2; n /= 10; } n = n4; n2 = n3; n4 = 0; n5 = 1; while (n != 0) { n4 += n % n2 * n5; n5 *= 10; n /= n2; } return n4; } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * A utility class for converting numbers from any base to any other base. * * This class provides a method to convert a source number from a given base * to a destination number in another base. Valid bases range from 2 to 10. */ public final class AnytoAny { private AnytoAny() { } /** * Converts a number from a source base to a destination base. * * @param sourceNumber The number in the source base (as an integer). * @param sourceBase The base of the source number (between 2 and 10). * @param destBase The base to which the number should be converted (between 2 and 10). * @throws IllegalArgumentException if the bases are not between 2 and 10. * @return The converted number in the destination base (as an integer). */ public static int convertBase(int sourceNumber, int sourceBase, int destBase) { if (sourceBase < 2 || sourceBase > 10 || destBase < 2 || destBase > 10) { throw new IllegalArgumentException(\"Bases must be between 2 and 10.\"); } int decimalValue = toDecimal(sourceNumber, sourceBase); return fromDecimal(decimalValue, destBase); } /** * Converts a number from a given base to its decimal representation (base 10). * * @param number The number in the original base. * @param base The base of the given number. * @return The decimal representation of the number. */ private static int toDecimal(int number, int base) { int decimalValue = 0; int multiplier = 1; while (number != 0) { decimalValue += (number % 10) * multiplier; multiplier *= base; number /= 10; } return decimalValue; } /** * Converts a decimal (base 10) number to a specified base. * * @param decimal The decimal number to convert. * @param base The destination base for conversion. * @return The number in the specified base. */ private static int fromDecimal(int decimal, int base) { int result = 0; int multiplier = 1; while (decimal != 0) { result += (decimal % base) * multiplier; multiplier *= 10; decimal /= base; } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class Area { private Area() { } public static double surfaceAreaCube(double d) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive sideLength\"); } return d * 6.0 * d; } public static double surfaceAreaSphere(double d) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive radius\"); } return d * (Math.PI * 4) * d; } public static double surfaceAreaRectangle(double d, double d2) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive length\"); } if (d2 <= 0.0) { throw new IllegalArgumentException(\"Must be a positive width\"); } return d * d2; } public static double surfaceAreaCylinder(double d, double d2) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive radius\"); } if (d2 <= 0.0) { throw new IllegalArgumentException(\"Must be a positive radius\"); } return 2.0 * (d * Math.PI * d + d * Math.PI * d2); } public static double surfaceAreaSquare(double d) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive sideLength\"); } double d2 = d; return d2 * d2; } public static double surfaceAreaTriangle(double d, double d2) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive base\"); } if (d2 <= 0.0) { throw new IllegalArgumentException(\"Must be a positive height\"); } return d * d2 / 2.0; } public static double surfaceAreaParallelogram(double d, double d2) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive base\"); } if (d2 <= 0.0) { throw new IllegalArgumentException(\"Must be a positive height\"); } return d * d2; } public static double surfaceAreaTrapezium(double d, double d2, double d3) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive base1\"); } if (d2 <= 0.0) { throw new IllegalArgumentException(\"Must be a positive base2\"); } if (d3 <= 0.0) { throw new IllegalArgumentException(\"Must be a positive height\"); } return (d + d2) * d3 / 2.0; } public static double surfaceAreaCircle(double d) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive radius\"); } return d * Math.PI * d; } public static double surfaceAreaHemisphere(double d) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive radius\"); } return d * (Math.PI * 3) * d; } public static double surfaceAreaCone(double d, double d2) { if (d <= 0.0) { throw new IllegalArgumentException(\"Must be a positive radius\"); } if (d2 <= 0.0) { throw new IllegalArgumentException(\"Must be a positive height\"); } double d3 = d2; double d4 = d; return d * Math.PI * (d + Math.pow(d3 * d3 + d4 * d4, 0.5)); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Find the area of various geometric shapes */ public final class Area { private Area() { } /** * String of IllegalArgumentException for radius */ private static final String POSITIVE_RADIUS = \"Must be a positive radius\"; /** * String of IllegalArgumentException for height */ private static final String POSITIVE_HEIGHT = \"Must be a positive height\"; /** * String of IllegalArgumentException for base */ private static final String POSITIVE_BASE = \"Must be a positive base\"; /** * Calculate the surface area of a cube. * * @param sideLength side length of cube * @return surface area of given cube */ public static double surfaceAreaCube(final double sideLength) { if (sideLength <= 0) { throw new IllegalArgumentException(\"Must be a positive sideLength\"); } return 6 * sideLength * sideLength; } /** * Calculate the surface area of a sphere. * * @param radius radius of sphere * @return surface area of given sphere */ public static double surfaceAreaSphere(final double radius) { if (radius <= 0) { throw new IllegalArgumentException(POSITIVE_RADIUS); } return 4 * Math.PI * radius * radius; } /** * Calculate the area of a rectangle. * * @param length length of a rectangle * @param width width of a rectangle * @return area of given rectangle */ public static double surfaceAreaRectangle(final double length, final double width) { if (length <= 0) { throw new IllegalArgumentException(\"Must be a positive length\"); } if (width <= 0) { throw new IllegalArgumentException(\"Must be a positive width\"); } return length * width; } /** * Calculate surface area of a cylinder. * * @param radius radius of the floor * @param height height of the cylinder. * @return volume of given cylinder */ public static double surfaceAreaCylinder(final double radius, final double height) { if (radius <= 0) { throw new IllegalArgumentException(POSITIVE_RADIUS); } if (height <= 0) { throw new IllegalArgumentException(POSITIVE_RADIUS); } return 2 * (Math.PI * radius * radius + Math.PI * radius * height); } /** * Calculate the area of a square. * * @param sideLength side length of square * @return area of given square */ public static double surfaceAreaSquare(final double sideLength) { if (sideLength <= 0) { throw new IllegalArgumentException(\"Must be a positive sideLength\"); } return sideLength * sideLength; } /** * Calculate the area of a triangle. * * @param base base of triangle * @param height height of triangle * @return area of given triangle */ public static double surfaceAreaTriangle(final double base, final double height) { if (base <= 0) { throw new IllegalArgumentException(POSITIVE_BASE); } if (height <= 0) { throw new IllegalArgumentException(POSITIVE_HEIGHT); } return base * height / 2; } /** * Calculate the area of a parallelogram. * * @param base base of a parallelogram * @param height height of a parallelogram * @return area of given parallelogram */ public static double surfaceAreaParallelogram(final double base, final double height) { if (base <= 0) { throw new IllegalArgumentException(POSITIVE_BASE); } if (height <= 0) { throw new IllegalArgumentException(POSITIVE_HEIGHT); } return base * height; } /** * Calculate the area of a trapezium. * * @param base1 upper base of trapezium * @param base2 bottom base of trapezium * @param height height of trapezium * @return area of given trapezium */ public static double surfaceAreaTrapezium(final double base1, final double base2, final double height) { if (base1 <= 0) { throw new IllegalArgumentException(POSITIVE_BASE + 1); } if (base2 <= 0) { throw new IllegalArgumentException(POSITIVE_BASE + 2); } if (height <= 0) { throw new IllegalArgumentException(POSITIVE_HEIGHT); } return (base1 + base2) * height / 2; } /** * Calculate the area of a circle. * * @param radius radius of circle * @return area of given circle */ public static double surfaceAreaCircle(final double radius) { if (radius <= 0) { throw new IllegalArgumentException(POSITIVE_RADIUS); } return Math.PI * radius * radius; } /** * Calculate the surface area of a hemisphere. * * @param radius radius of hemisphere * @return surface area of given hemisphere */ public static double surfaceAreaHemisphere(final double radius) { if (radius <= 0) { throw new IllegalArgumentException(POSITIVE_RADIUS); } return 3 * Math.PI * radius * radius; } /** * Calculate the surface area of a cone. * * @param radius radius of cone. * @param height of cone. * @return surface area of given cone. */ public static double surfaceAreaCone(final double radius, final double height) { if (radius <= 0) { throw new IllegalArgumentException(POSITIVE_RADIUS); } if (height <= 0) { throw new IllegalArgumentException(POSITIVE_HEIGHT); } return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public class Armstrong { public boolean isArmstrong(int n) { if (n < 0) { return false; } long l = 0L; int n2 = (int)Math.log10(n) + 1; for (long i = (long)n; i > 0L; i /= 10L) { long l2 = i % 10L; l += (long)Math.pow(l2, n2); } return l == (long)n; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * This class checks whether a given number is an Armstrong number or not. * An Armstrong number is a number that is equal to the sum of its own digits, * each raised to the power of the number of digits. * * For example, 370 is an Armstrong number because 3^3 + 7^3 + 0^3 = 370. * 1634 is an Armstrong number because 1^4 + 6^4 + 3^4 + 4^4 = 1634. * An Armstrong number is often called a Narcissistic number. * * @author satyabarghav * @modifier rahul katteda - (13/01/2025) - [updated the logic for getting total number of digits] */ public class Armstrong { /** * Checks whether a given number is an Armstrong number or not. * * @param number the number to check * @return {@code true} if the given number is an Armstrong number, {@code false} otherwise */ public boolean isArmstrong(int number) { if (number < 0) { return false; // Negative numbers cannot be Armstrong numbers } long sum = 0; int totalDigits = (int) Math.log10(number) + 1; // get the length of the number (number of digits) long originalNumber = number; while (originalNumber > 0) { long digit = originalNumber % 10; sum += (long) Math.pow(digit, totalDigits); // The digit raised to the power of total number of digits and added to the sum. originalNumber /= 10; } return sum == number; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.List; public final class ArrayCombination { private ArrayCombination() { } public static List combination(int n, int n2) { if (n < 0 || n2 < 0 || n2 > n) { throw new IllegalArgumentException(\"Invalid input: n must be non-negative, k must be non-negative and less than or equal to n.\"); } ArrayList arrayList = new ArrayList(); ArrayCombination.a(arrayList, new ArrayList(), 0, n, n2); return arrayList; } private static void a(List list, List list2, int n, int n2, int n3) { if (list2.size() == n3) { list.add(new ArrayList(list2)); return; } while (n < n2) { list2.add(n); ArrayCombination.a(list, list2, n + 1, n2, n3); List list3 = list2; list3.remove(list3.size() - 1); ++n; } } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.List; /** * This class provides methods to find all combinations of integers from 0 to n-1 * of a specified length k using backtracking. */ public final class ArrayCombination { private ArrayCombination() { } /** * Generates all possible combinations of length k from the integers 0 to n-1. * * @param n The total number of elements (0 to n-1). * @param k The desired length of each combination. * @return A list containing all combinations of length k. * @throws IllegalArgumentException if n or k are negative, or if k is greater than n. */ public static List<List<Integer>> combination(int n, int k) { if (n < 0 || k < 0 || k > n) { throw new IllegalArgumentException(\"Invalid input: n must be non-negative, k must be non-negative and less than or equal to n.\"); } List<List<Integer>> combinations = new ArrayList<>(); combine(combinations, new ArrayList<>(), 0, n, k); return combinations; } /** * A helper method that uses backtracking to find combinations. * * @param combinations The list to store all valid combinations found. * @param current The current combination being built. * @param start The starting index for the current recursion. * @param n The total number of elements (0 to n-1). * @param k The desired length of each combination. */ private static void combine(List<List<Integer>> combinations, List<Integer> current, int start, int n, int k) { // Base case: combination found if (current.size() == k) { combinations.add(new ArrayList<>(current)); return; } for (int i = start; i < n; i++) { current.add(i); combine(combinations, current, i + 1, n, k); current.remove(current.size() - 1); // Backtrack } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; public final class ArrayLeftRotation { private ArrayLeftRotation() { } public static int[] rotateLeft(int[] nArray, int n) { int n2 = nArray.length; if (n2 == 0 || n <= 0) { return (int[])nArray.clone(); } if ((n %= n2) == 0) { return (int[])nArray.clone(); } int[] nArray2 = new int[n2]; for (int i = 0; i < n2; ++i) { nArray2[i] = nArray[(i + n) % n2]; } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.others; /** * Provides a method to perform a left rotation on an array. * A left rotation operation shifts each element of the array * by a specified number of positions to the left. * * @author sangin-lee */ public final class ArrayLeftRotation { private ArrayLeftRotation() { } /** * Performs a left rotation on the given array by the specified number of positions. * * @param arr the array to be rotated * @param n the number of positions to rotate the array to the left * @return a new array containing the elements of the input array rotated to the left */ public static int[] rotateLeft(int[] arr, int n) { int size = arr.length; // Handle cases where array is empty or rotation count is zero if (size == 0 || n <= 0) { return arr.clone(); } // Normalize the number of rotations n = n % size; if (n == 0) { return arr.clone(); } int[] rotated = new int[size]; // Perform rotation for (int i = 0; i < size; i++) { rotated[i] = arr[(i + n) % size]; } return rotated; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; public final class ArrayRightRotation { private ArrayRightRotation() { } public static int[] rotateRight(int[] nArray, int n) { if (nArray == null || nArray.length == 0 || n < 0) { throw new IllegalArgumentException(\"Invalid input\"); } int n2 = nArray.length; ArrayRightRotation.a(nArray, 0, n2 - 1); ArrayRightRotation.a(nArray, 0, (n %= n2) - 1); ArrayRightRotation.a(nArray, n, n2 - 1); return nArray; } private static void a(int[] nArray, int n, int n2) { while (n < n2) { int n3 = nArray[n]; nArray[n] = nArray[n2]; nArray[n2] = n3; ++n; --n2; } } }", "deobfuscated_code": "package com.thealgorithms.others; /** * Provides a method to perform a right rotation on an array. * A left rotation operation shifts each element of the array * by a specified number of positions to the right. * * https://en.wikipedia.org/wiki/Right_rotation * */ public final class ArrayRightRotation { private ArrayRightRotation() { } /** * Performs a right rotation on the given array by the specified number of positions. * * @param arr the array to be rotated * @param k the number of positions to rotate the array to the left * @return a new array containing the elements of the input array rotated to the left */ public static int[] rotateRight(int[] arr, int k) { if (arr == null || arr.length == 0 || k < 0) { throw new IllegalArgumentException(\"Invalid input\"); } int n = arr.length; k = k % n; // Handle cases where k is larger than the array length reverseArray(arr, 0, n - 1); reverseArray(arr, 0, k - 1); reverseArray(arr, k, n - 1); return arr; } /** * Performs reversing of a array * @param arr the array to be reversed * @param start starting position * @param end ending position */ private static void reverseArray(int[] arr, int start, int end) { while (start < end) { int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start++; end--; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.List; public final class AssignmentUsingBitmask { private final int a; private final int[][] b; private final List c; private final int d; public AssignmentUsingBitmask(List list, int n) { int n2; int n3; this.a = n; int[][] nArray = this.b = new int[1 << list.size()][n + 1]; int n4 = this.b.length; for (n3 = 0; n3 < n4; ++n3) { int[] nArray2 = nArray[n3]; Arrays.fill(nArray2, -1); } this.c = new ArrayList(this.a + 1); for (n2 = 0; n2 <= this.a; ++n2) { this.c.add(new ArrayList()); } this.d = (1 << list.size()) - 1; for (n2 = 0; n2 < list.size(); ++n2) { Iterator iterator = ((List)list.get(n2)).iterator(); while (iterator.hasNext()) { n3 = (Integer)iterator.next(); ((List)this.c.get(n3)).add(n2); } } } private int a(int n, int n2) { if (n == this.d) { return 1; } if (n2 > this.a) { return 0; } if (this.b[n][n2] != -1) { return this.b[n][n2]; } int n3 = this.a(n, n2 + 1); Iterator iterator = ((List)this.c.get(n2)).iterator(); while (iterator.hasNext()) { int n4 = (Integer)iterator.next(); if ((n & 1 << n4) != 0) continue; n3 += this.a(n | 1 << n4, n2 + 1); } this.b[n][n2] = n3; return this.b[n][n2]; } public final int countNoOfWays() { return this.a(0, 1); } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.ArrayList; import java.util.Arrays; import java.util.List; /** * The AssignmentUsingBitmask class is used to calculate the total number of ways * tasks can be distributed among people, given specific constraints on who can perform which tasks. * The approach uses bitmasking and dynamic programming to efficiently solve the problem. * * @author Hardvan */ public final class AssignmentUsingBitmask { private final int totalTasks; private final int[][] dp; private final List<List<Integer>> task; private final int finalMask; /** * Constructor for the AssignmentUsingBitmask class. * * @param taskPerformed a list of lists, where each inner list contains the tasks that a person can perform. * @param total the total number of tasks. */ public AssignmentUsingBitmask(List<List<Integer>> taskPerformed, int total) { this.totalTasks = total; this.dp = new int[1 << taskPerformed.size()][total + 1]; for (int[] row : dp) { Arrays.fill(row, -1); } this.task = new ArrayList<>(totalTasks + 1); for (int i = 0; i <= totalTasks; i++) { this.task.add(new ArrayList<>()); } // Final mask to check if all persons are included this.finalMask = (1 << taskPerformed.size()) - 1; // Fill the task list for (int i = 0; i < taskPerformed.size(); i++) { for (int j : taskPerformed.get(i)) { this.task.get(j).add(i); } } } /** * Counts the ways to assign tasks until the given task number with the specified mask. * * @param mask the bitmask representing the current state of assignments. * @param taskNo the current task number being processed. * @return the number of ways to assign tasks. */ private int countWaysUntil(int mask, int taskNo) { if (mask == finalMask) { return 1; } if (taskNo > totalTasks) { return 0; } if (dp[mask][taskNo] != -1) { return dp[mask][taskNo]; } int totalWays = countWaysUntil(mask, taskNo + 1); // Assign tasks to all possible persons for (int p : task.get(taskNo)) { // If the person is already assigned a task if ((mask & (1 << p)) != 0) { continue; } totalWays += countWaysUntil(mask | (1 << p), taskNo + 1); } dp[mask][taskNo] = totalWays; return dp[mask][taskNo]; } /** * Counts the total number of ways to distribute tasks among persons. * * @return the total number of ways to distribute tasks. */ public int countNoOfWays() { return countWaysUntil(0, 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; public class AtbashCipher { private String a; public AtbashCipher() { } public AtbashCipher(String string) { this.a = string; } public String getString() { return this.a; } public void setString(String string) { this.a = string; } public String convert() { StringBuilder stringBuilder = new StringBuilder(); char[] cArray = this.a.toCharArray(); int n = cArray.length; for (int i = 0; i < n; ++i) { char c; char c2 = c = cArray[i]; if (c >= 'a' && c2 <= 'z') { stringBuilder.append((char)(122 - (c - 97))); continue; } c2 = c; if (c2 >= 'A' && c2 <= 'Z') { stringBuilder.append((char)(90 - (c - 65))); continue; } stringBuilder.append(c); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; /** * The Atbash cipher is a classic substitution cipher that substitutes each letter * with its opposite letter in the alphabet. * * For example: * - 'A' becomes 'Z', 'B' becomes 'Y', 'C' becomes 'X', and so on. * - Similarly, 'a' becomes 'z', 'b' becomes 'y', and so on. * * The cipher works identically for both uppercase and lowercase letters. * Non-alphabetical characters remain unchanged in the output. * * This cipher is symmetric, meaning that applying the cipher twice will return * the original text. Therefore, the same function is used for both encryption and decryption. * * <p>Usage Example:</p> * <pre> * AtbashCipher cipher = new AtbashCipher(\"Hello World!\"); * String encrypted = cipher.convert(); // Output: \"Svool Dliow!\" * </pre> * * @author <a href=\"https://github.com/Krounosity\">Krounosity</a> * @see <a href=\"https://en.wikipedia.org/wiki/Atbash\">Atbash Cipher (Wikipedia)</a> */ public class AtbashCipher { private String toConvert; public AtbashCipher() { } /** * Constructor with a string parameter. * * @param str The string to be converted using the Atbash cipher */ public AtbashCipher(String str) { this.toConvert = str; } /** * Returns the current string set for conversion. * * @return The string to be converted */ public String getString() { return toConvert; } /** * Sets the string to be converted using the Atbash cipher. * * @param str The new string to convert */ public void setString(String str) { this.toConvert = str; } /** * Checks if a character is uppercase. * * @param ch The character to check * @return {@code true} if the character is uppercase, {@code false} otherwise */ private boolean isCapital(char ch) { return ch >= 'A' && ch <= 'Z'; } /** * Checks if a character is lowercase. * * @param ch The character to check * @return {@code true} if the character is lowercase, {@code false} otherwise */ private boolean isSmall(char ch) { return ch >= 'a' && ch <= 'z'; } /** * Converts the input string using the Atbash cipher. * Alphabetic characters are substituted with their opposite in the alphabet, * while non-alphabetic characters remain unchanged. * * @return The converted string after applying the Atbash cipher */ public String convert() { StringBuilder convertedString = new StringBuilder(); for (char ch : toConvert.toCharArray()) { if (isSmall(ch)) { convertedString.append((char) ('z' - (ch - 'a'))); } else if (isCapital(ch)) { convertedString.append((char) ('Z' - (ch - 'A'))); } else { convertedString.append(ch); } } return convertedString.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.CrossCorrelation; public final class AutoCorrelation { private AutoCorrelation() { } public static double[] autoCorrelation(double[] dArray) { return CrossCorrelation.crossCorrelation(dArray, dArray); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Class for linear auto-correlation of a discrete signal * * @author Athina-Frederiki Swinkels * @version 2.0 */ public final class AutoCorrelation { private AutoCorrelation() { } /** * Discrete linear auto-correlation function. * Input and output signals have starting index 0. * * @param x The discrete signal * @return The result of the auto-correlation of signals x. The result is also a signal. */ public static double[] autoCorrelation(double[] x) { /* To find the auto-correlation of a discrete signal x, we perform cross-correlation between x signal and itself. Here's an example: x=[1,2,1,1] y=[1,2,1,1] i=0: [1,2,1,1] [1,2,1,1] result[0]=1*1=1 i=1: [1,2,1,1] [1,2,1,1] result[1]=1*1+2*1=3 i=2: [1,2,1,1] [1,2,1,1] result[2]=1*2+2*1+1*1=5 i=3: [1,2,1,1] [1,2,1,1] result[3]=1*1+2*2+1*1+1*1=7 i=4: [1,2,1,1] [1,2,1,1] result[4]=2*1+1*2+1*1=5 i=5: [1,2,1,1] [1,2,1,1] result[5]=1*1+1*2=3 i=1: [1,2,1,1] [1,2,1,1] result[6]=1*1=1 result=[1,3,5,7,5,3,1] */ return CrossCorrelation.crossCorrelation(x, x); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; public class Autokey { public String encrypt(String string, String charSequence) { string = string.toUpperCase().replaceAll(\"[^A-Z]\", \"\"); charSequence = ((String)charSequence).toUpperCase(); charSequence = new StringBuilder((String)charSequence); ((StringBuilder)charSequence).append(string); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < string.length(); ++i) { int n = string.charAt(i); char c = ((StringBuilder)charSequence).charAt(i); n = (n - 65 + c - 65) % 26 + 65; stringBuilder.append((char)n); } return stringBuilder.toString(); } public String decrypt(String string, String charSequence) { string = string.toUpperCase().replaceAll(\"[^A-Z]\", \"\"); charSequence = ((String)charSequence).toUpperCase(); StringBuilder stringBuilder = new StringBuilder(); charSequence = new StringBuilder((String)charSequence); for (int i = 0; i < string.length(); ++i) { int n = string.charAt(i); char c = ((StringBuilder)charSequence).charAt(i); n = (n - 65 - (c - 65) + 26) % 26 + 65; stringBuilder.append((char)n); ((StringBuilder)charSequence).append((char)n); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; /** * The Autokey Cipher is an interesting and historically significant encryption method, * as it improves upon the classic Vigenre Cipher by using the plaintext itself to * extend the key. This makes it harder to break using frequency analysis, as it * doesnt rely solely on a repeated key. * https://en.wikipedia.org/wiki/Autokey_cipher * * @author bennybebo */ public class Autokey { // Encrypts the plaintext using the Autokey cipher public String encrypt(String plaintext, String keyword) { plaintext = plaintext.toUpperCase().replaceAll(\"[^A-Z]\", \"\"); // Sanitize input keyword = keyword.toUpperCase(); StringBuilder extendedKey = new StringBuilder(keyword); extendedKey.append(plaintext); // Extend key with plaintext StringBuilder ciphertext = new StringBuilder(); for (int i = 0; i < plaintext.length(); i++) { char plainChar = plaintext.charAt(i); char keyChar = extendedKey.charAt(i); int encryptedChar = (plainChar - 'A' + keyChar - 'A') % 26 + 'A'; ciphertext.append((char) encryptedChar); } return ciphertext.toString(); } // Decrypts the ciphertext using the Autokey cipher public String decrypt(String ciphertext, String keyword) { ciphertext = ciphertext.toUpperCase().replaceAll(\"[^A-Z]\", \"\"); // Sanitize input keyword = keyword.toUpperCase(); StringBuilder plaintext = new StringBuilder(); StringBuilder extendedKey = new StringBuilder(keyword); for (int i = 0; i < ciphertext.length(); i++) { char cipherChar = ciphertext.charAt(i); char keyChar = extendedKey.charAt(i); int decryptedChar = (cipherChar - 'A' - (keyChar - 'A') + 26) % 26 + 'A'; plaintext.append((char) decryptedChar); extendedKey.append((char) decryptedChar); // Extend key with each decrypted char } return plaintext.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.math.BigInteger; public final class AutomorphicNumber { private AutomorphicNumber() { } public static boolean isAutomorphic(long l) { if (l < 0L) { return false; } long l2 = l; long l3 = l2 * l2; long l4 = 0L; for (long i = l; i > 0L; i /= 10L) { ++l4; } long l5 = l3 % (long)Math.pow(10.0, l4); return l == l5; } public static boolean isAutomorphic2(long l) { if (l < 0L) { return false; } long l2 = l; long l3 = l2 * l2; return String.valueOf(l3).endsWith(String.valueOf(l)); } public static boolean isAutomorphic3(String object) { if (((BigInteger)(object = new BigInteger((String)object))).signum() == -1) { return false; } Object object2 = object; BigInteger bigInteger = ((BigInteger)object2).multiply((BigInteger)object2); return String.valueOf(bigInteger).endsWith(String.valueOf(object)); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.math.BigInteger; /** * <a href=\"https://en.wikipedia.org/wiki/Automorphic_number\">Automorphic Number</a> * A number is said to be an Automorphic, if it is present in the last digit(s) * of its square. Example- Let the number be 25, its square is 625. Since, * 25(The input number) is present in the last two digits of its square(625), it * is an Automorphic Number. */ public final class AutomorphicNumber { private AutomorphicNumber() { } /** * A function to check if a number is Automorphic number or not * * @param n The number to be checked * @return {@code true} if {@code a} is Automorphic number, otherwise * {@code false} */ public static boolean isAutomorphic(long n) { if (n < 0) { return false; } long square = n * n; // Calculating square of the number long t = n; long numberOfdigits = 0; while (t > 0) { numberOfdigits++; // Calculating number of digits in n t /= 10; } long lastDigits = square % (long) Math.pow(10, numberOfdigits); // Extracting last Digits of square return n == lastDigits; } /** * A function to check if a number is Automorphic number or not by using String functions * * @param n The number to be checked * @return {@code true} if {@code a} is Automorphic number, otherwise * {@code false} */ public static boolean isAutomorphic2(long n) { if (n < 0) { return false; } long square = n * n; // Calculating square of the number return String.valueOf(square).endsWith(String.valueOf(n)); } /** * A function to check if a number is Automorphic number or not by using BigInteger * * @param s The number in String to be checked * @return {@code true} if {@code a} is Automorphic number, otherwise * {@code false} */ public static boolean isAutomorphic3(String s) { BigInteger n = new BigInteger(s); if (n.signum() == -1) { return false; // if number is negative, return false } BigInteger square = n.multiply(n); // Calculating square of the number return String.valueOf(square).endsWith(String.valueOf(n)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class Average { private Average() { throw new UnsupportedOperationException(\"This is a utility class and cannot be instantiated.\"); } public static double average(double[] dArray) { if (dArray == null || dArray.length == 0) { throw new IllegalArgumentException(\"Numbers array cannot be empty or null\"); } double d = 0.0; double[] dArray2 = dArray; int n = dArray.length; for (int i = 0; i < n; ++i) { double d2 = dArray2[i]; d += d2; } return d / (double)dArray.length; } public static long average(int[] nArray) { if (nArray == null || nArray.length == 0) { throw new IllegalArgumentException(\"Numbers array cannot be empty or null\"); } long l = 0L; int[] nArray2 = nArray; int n = nArray.length; for (int i = 0; i < n; ++i) { int n2 = nArray2[i]; l += (long)n2; } return l / (long)nArray.length; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * A utility class for computing the average of numeric arrays. * This class provides static methods to calculate the average of arrays * of both {@code double} and {@code int} values. */ public final class Average { // Prevent instantiation of this utility class private Average() { throw new UnsupportedOperationException(\"This is a utility class and cannot be instantiated.\"); } /** * Computes the average of a {@code double} array. * * @param numbers an array of {@code double} values * @return the average of the given numbers * @throws IllegalArgumentException if the input array is {@code null} or empty */ public static double average(double[] numbers) { if (numbers == null || numbers.length == 0) { throw new IllegalArgumentException(\"Numbers array cannot be empty or null\"); } double sum = 0; for (double number : numbers) { sum += number; } return sum / numbers.length; } /** * Computes the average of an {@code int} array. * * @param numbers an array of {@code int} values * @return the average of the given numbers * @throws IllegalArgumentException if the input array is {@code null} or empty */ public static long average(int[] numbers) { if (numbers == null || numbers.length == 0) { throw new IllegalArgumentException(\"Numbers array cannot be empty or null\"); } long sum = 0; for (int number : numbers) { sum += number; } return sum / numbers.length; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; public final class BFPRT { private BFPRT() { } public static int[] getMinKNumsByBFPRT(int[] nArray, int n) { if (n <= 0 || n > nArray.length) { return null; } int n2 = BFPRT.getMinKthByBFPRT(nArray, n); int[] nArray2 = new int[n]; int n3 = 0; for (int n4 : nArray) { if (n4 >= n2) continue; nArray2[n3++] = n4; } while (n3 != nArray2.length) { nArray2[n3] = n2; ++n3; } return nArray2; } public static int getMinKthByBFPRT(int[] nArray, int n) { nArray = BFPRT.copyArray(nArray); return BFPRT.bfprt(nArray, 0, nArray.length - 1, n - 1); } public static int[] copyArray(int[] nArray) { int[] nArray2 = new int[nArray.length]; System.arraycopy(nArray, 0, nArray2, 0, nArray.length); return nArray2; } public static int bfprt(int[] nArray, int n, int n2, int n3) { while (n != n2) { int n4 = BFPRT.medianOfMedians(nArray, n, n2); int[] nArray2 = BFPRT.partition(nArray, n, n2, n4); if (n3 >= nArray2[0] && n3 <= nArray2[1]) { return nArray[n3]; } if (n3 < nArray2[0]) { n2 = nArray2[0] - 1; continue; } n = nArray2[1] + 1; } return nArray[n]; } public static int medianOfMedians(int[] nArray, int n, int n2) { int n3 = n2 - n + 1; int n4 = n3 % 5 == 0 ? 0 : 1; int[] nArray2 = new int[n3 / 5 + n4]; for (n4 = 0; n4 < nArray2.length; ++n4) { nArray2[n4] = BFPRT.getMedian(nArray, n + n4 * 5, Math.min(n2, n + n4 * 5 + 4)); } return BFPRT.bfprt(nArray2, 0, nArray2.length - 1, nArray2.length / 2); } public static int[] partition(int[] nArray, int n, int n2, int n3) { int n4 = n - 1; ++n2; while (n != n2) { if (nArray[n] < n3) { BFPRT.swap(nArray, ++n4, n++); continue; } if (nArray[n] > n3) { BFPRT.swap(nArray, --n2, n); continue; } ++n; } return new int[]{n4 + 1, n2 - 1}; } public static int getMedian(int[] nArray, int n, int n2) { BFPRT.insertionSort(nArray, n, n2); n += n2; n = n / 2 + n % 2; return nArray[n]; } public static void insertionSort(int[] nArray, int n, int n2) { if (nArray == null || nArray.length < 2) { return; } for (int i = n + 1; i != n2 + 1; ++i) { for (int j = i; j != n && nArray[j - 1] > nArray[j]; --j) { BFPRT.swap(nArray, j - 1, j); } } } public static void swap(int[] nArray, int n, int n2) { int n3 = nArray[n]; nArray[n] = nArray[n2]; nArray[n2] = n3; } }", "deobfuscated_code": "package com.thealgorithms.others; /** * The BFPRT (Median of Medians) algorithm implementation. * It provides a way to find the k-th smallest element in an unsorted array * with an optimal worst-case time complexity of O(n). * This algorithm is used to find the k smallest numbers in an array. */ public final class BFPRT { private BFPRT() { } /** * Returns the k smallest elements from the array using the BFPRT algorithm. * * @param arr the input array * @param k the number of smallest elements to return * @return an array containing the k smallest elements, or null if k is invalid */ public static int[] getMinKNumsByBFPRT(int[] arr, int k) { if (k < 1 || k > arr.length) { return null; } int minKth = getMinKthByBFPRT(arr, k); int[] res = new int[k]; int index = 0; for (int value : arr) { if (value < minKth) { res[index++] = value; } } for (; index != res.length; index++) { res[index] = minKth; } return res; } /** * Returns the k-th smallest element from the array using the BFPRT algorithm. * * @param arr the input array * @param k the rank of the smallest element to find * @return the k-th smallest element */ public static int getMinKthByBFPRT(int[] arr, int k) { int[] copyArr = copyArray(arr); return bfprt(copyArr, 0, copyArr.length - 1, k - 1); } /** * Creates a copy of the input array. * * @param arr the input array * @return a copy of the array */ public static int[] copyArray(int[] arr) { int[] copyArr = new int[arr.length]; System.arraycopy(arr, 0, copyArr, 0, arr.length); return copyArr; } /** * BFPRT recursive method to find the k-th smallest element. * * @param arr the input array * @param begin the starting index * @param end the ending index * @param i the index of the desired smallest element * @return the k-th smallest element */ public static int bfprt(int[] arr, int begin, int end, int i) { if (begin == end) { return arr[begin]; } int pivot = medianOfMedians(arr, begin, end); int[] pivotRange = partition(arr, begin, end, pivot); if (i >= pivotRange[0] && i <= pivotRange[1]) { return arr[i]; } else if (i < pivotRange[0]) { return bfprt(arr, begin, pivotRange[0] - 1, i); } else { return bfprt(arr, pivotRange[1] + 1, end, i); } } /** * Finds the median of medians as the pivot element. * * @param arr the input array * @param begin the starting index * @param end the ending index * @return the median of medians */ public static int medianOfMedians(int[] arr, int begin, int end) { int num = end - begin + 1; int offset = num % 5 == 0 ? 0 : 1; int[] mArr = new int[num / 5 + offset]; for (int i = 0; i < mArr.length; i++) { mArr[i] = getMedian(arr, begin + i * 5, Math.min(end, begin + i * 5 + 4)); } return bfprt(mArr, 0, mArr.length - 1, mArr.length / 2); } /** * Partitions the array around a pivot. * * @param arr the input array * @param begin the starting index * @param end the ending index * @param num the pivot element * @return the range where the pivot is located */ public static int[] partition(int[] arr, int begin, int end, int num) { int small = begin - 1; int cur = begin; int big = end + 1; while (cur != big) { if (arr[cur] < num) { swap(arr, ++small, cur++); } else if (arr[cur] > num) { swap(arr, --big, cur); } else { cur++; } } return new int[] {small + 1, big - 1}; } /** * Finds the median of the elements between the specified range. * * @param arr the input array * @param begin the starting index * @param end the ending index * @return the median of the specified range */ public static int getMedian(int[] arr, int begin, int end) { insertionSort(arr, begin, end); int sum = begin + end; int mid = sum / 2 + (sum % 2); return arr[mid]; } /** * Sorts a portion of the array using insertion sort. * * @param arr the input array * @param begin the starting index * @param end the ending index */ public static void insertionSort(int[] arr, int begin, int end) { if (arr == null || arr.length < 2) { return; } for (int i = begin + 1; i != end + 1; i++) { for (int j = i; j != begin; j--) { if (arr[j - 1] > arr[j]) { swap(arr, j - 1, j); } else { break; } } } } /** * Swaps two elements in an array. * * @param arr the input array * @param i the index of the first element * @param j the index of the second element */ public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.searches.Movie; import com.thealgorithms.searches.SearchResult; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public final class BM25InvertedIndex { private Map a = new HashMap(); private Map b = new HashMap(); private int c = 0; private double d = 0.0; BM25InvertedIndex() { } public final void addMovie(int n, String stringArray, double d, int n2, String hashMap) { stringArray = new Movie(n, (String)stringArray, d, n2, (String)((Object)hashMap)); this.b.put(n, stringArray); ++this.c; stringArray = stringArray.getWords(); int n3 = stringArray.length; this.d = (this.d * (double)(this.c - 1) + (double)n3) / (double)this.c; for (String string : stringArray) { this.a.putIfAbsent(string, new HashMap()); hashMap = (Map)this.a.get(string); if (hashMap == null) { hashMap = new HashMap<Integer, Integer>(); this.a.put(string, hashMap); } hashMap.put(n, hashMap.getOrDefault(n, 0) + 1); } } public final int getMoviesLength() { return this.b.size(); } public final List search(String iterator) { if (!this.a.containsKey(iterator = ((String)((Object)iterator)).toLowerCase())) { return new ArrayList(); } iterator = (Map)this.a.get(iterator); ArrayList<SearchResult> arrayList = new ArrayList<SearchResult>(); int n = iterator.size(); BM25InvertedIndex object2 = this; double d = Math.log(((double)(object2.c - n) + 0.5) / ((double)n + 0.5) + 1.0); for (Map.Entry n3 : iterator.entrySet()) { int n2 = (Integer)n3.getKey(); int bM25InvertedIndex = (Integer)n3.getValue(); Movie movie = (Movie)this.b.get(n2); if (movie == null) continue; double d2 = movie.getWords().length; double d3 = d; double d4 = d2; int n4 = bM25InvertedIndex; BM25InvertedIndex bM25InvertedIndex2 = this; double d5 = (double)n4 * 2.5; double d6 = (double)n4 + 1.5 * (0.25 + 0.75 * (d4 / bM25InvertedIndex2.d)); double d7 = d3 * (d5 / d6); arrayList.add(new SearchResult(n2, d7)); } arrayList.sort((searchResult, searchResult2) -> Double.compare(searchResult2.a, searchResult.a)); return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.searches; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Objects; /** * Inverted Index implementation with BM25 Scoring for movie search. * This class supports adding movie documents and searching for terms * within those documents using the BM25 algorithm. * @author Prayas Kumar (https://github.com/prayas7102) */ class Movie { int docId; // Unique identifier for the movie String name; // Movie name double imdbRating; // IMDb rating of the movie int releaseYear; // Year the movie was released String content; // Full text content (could be the description or script) /** * Constructor for the Movie class. * @param docId Unique identifier for the movie. * @param name Name of the movie. * @param imdbRating IMDb rating of the movie. * @param releaseYear Release year of the movie. * @param content Content or description of the movie. */ Movie(int docId, String name, double imdbRating, int releaseYear, String content) { this.docId = docId; this.name = name; this.imdbRating = imdbRating; this.releaseYear = releaseYear; this.content = content; } /** * Get all the words from the movie's name and content. * Converts the name and content to lowercase and splits on non-word characters. * @return Array of words from the movie name and content. */ public String[] getWords() { return (name + \" \" + content).toLowerCase().split(\"\\\\W+\"); } @Override public String toString() { return \"Movie{\" + \"docId=\" + docId + \", name='\" + name + '\\'' + \", imdbRating=\" + imdbRating + \", releaseYear=\" + releaseYear + '}'; } } class SearchResult { int docId; // Unique identifier of the movie document double relevanceScore; // Relevance score based on the BM25 algorithm /** * Constructor for SearchResult class. * @param docId Document ID (movie) for this search result. * @param relevanceScore The relevance score based on BM25 scoring. */ SearchResult(int docId, double relevanceScore) { this.docId = docId; this.relevanceScore = relevanceScore; } public int getDocId() { return docId; } @Override public String toString() { return \"SearchResult{\" + \"docId=\" + docId + \", relevanceScore=\" + relevanceScore + '}'; } @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } SearchResult that = (SearchResult) o; return docId == that.docId && Double.compare(that.relevanceScore, relevanceScore) == 0; } @Override public int hashCode() { return Objects.hash(docId, relevanceScore); } public double getRelevanceScore() { return this.relevanceScore; } } public final class BM25InvertedIndex { private Map<String, Map<Integer, Integer>> index; // Inverted index mapping terms to document id and frequency private Map<Integer, Movie> movies; // Mapping of movie document IDs to Movie objects private int totalDocuments; // Total number of movies/documents private double avgDocumentLength; // Average length of documents (number of words) private static final double K = 1.5; // BM25 tuning parameter, controls term frequency saturation private static final double B = 0.75; // BM25 tuning parameter, controls length normalization /** * Constructor for BM25InvertedIndex. * Initializes the inverted index and movie storage. */ BM25InvertedIndex() { index = new HashMap<>(); movies = new HashMap<>(); totalDocuments = 0; avgDocumentLength = 0.0; } /** * Add a movie to the index. * @param docId Unique identifier for the movie. * @param name Name of the movie. * @param imdbRating IMDb rating of the movie. * @param releaseYear Release year of the movie. * @param content Content or description of the movie. */ public void addMovie(int docId, String name, double imdbRating, int releaseYear, String content) { Movie movie = new Movie(docId, name, imdbRating, releaseYear, content); movies.put(docId, movie); totalDocuments++; // Get words (terms) from the movie's name and content String[] terms = movie.getWords(); int docLength = terms.length; // Update the average document length avgDocumentLength = (avgDocumentLength * (totalDocuments - 1) + docLength) / totalDocuments; // Update the inverted index for (String term : terms) { // Create a new entry if the term is not yet in the index index.putIfAbsent(term, new HashMap<>()); // Get the list of documents containing the term Map<Integer, Integer> docList = index.get(term); if (docList == null) { docList = new HashMap<>(); index.put(term, docList); // Ensure docList is added to the index } // Increment the term frequency in this document docList.put(docId, docList.getOrDefault(docId, 0) + 1); } } public int getMoviesLength() { return movies.size(); } /** * Search for documents containing a term using BM25 scoring. * @param term The search term. * @return A list of search results sorted by relevance score. */ public List<SearchResult> search(String term) { term = term.toLowerCase(); // Normalize search term if (!index.containsKey(term)) { return new ArrayList<>(); // Return empty list if term not found } Map<Integer, Integer> termDocs = index.get(term); // Documents containing the term List<SearchResult> results = new ArrayList<>(); // Compute IDF for the search term double idf = computeIDF(termDocs.size()); // Calculate relevance scores for all documents containing the term for (Map.Entry<Integer, Integer> entry : termDocs.entrySet()) { int docId = entry.getKey(); int termFrequency = entry.getValue(); Movie movie = movies.get(docId); if (movie == null) { continue; // Skip this document if movie doesn't exist } double docLength = movie.getWords().length; // Compute BM25 relevance score double score = computeBM25Score(termFrequency, docLength, idf); results.add(new SearchResult(docId, score)); } // Sort the results by relevance score in descending order results.sort((r1, r2) -> Double.compare(r2.relevanceScore, r1.relevanceScore)); return results; } /** * Compute the BM25 score for a given term and document. * @param termFrequency The frequency of the term in the document. * @param docLength The length of the document. * @param idf The inverse document frequency of the term. * @return The BM25 relevance score for the term in the document. */ private double computeBM25Score(int termFrequency, double docLength, double idf) { double numerator = termFrequency * (K + 1); double denominator = termFrequency + K * (1 - B + B * (docLength / avgDocumentLength)); return idf * (numerator / denominator); } /** * Compute the inverse document frequency (IDF) of a term. * The IDF measures the importance of a term across the entire document set. * @param docFrequency The number of documents that contain the term. * @return The inverse document frequency (IDF) value. */ private double computeIDF(int docFrequency) { // Total number of documents in the index return Math.log((totalDocuments - docFrequency + 0.5) / (docFrequency + 0.5) + 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; public final class BSTFromSortedArray { private BSTFromSortedArray() { } public static BinaryTree$Node createBST(int[] nArray) { if (nArray == null || nArray.length == 0) { return null; } return BSTFromSortedArray.a(nArray, 0, nArray.length - 1); } private static BinaryTree$Node a(int[] nArray, int n, int n2) { if (n > n2) { return null; } int n3 = n + (n2 - n) / 2; BinaryTree$Node binaryTree$Node = new BinaryTree$Node(nArray[n3]); new BinaryTree$Node(nArray[n3]).left = BSTFromSortedArray.a(nArray, n, n3 - 1); binaryTree$Node.right = BSTFromSortedArray.a(nArray, n3 + 1, n2); return binaryTree$Node; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree.Node; /** * Given a sorted array. Create a balanced binary search tree from it. * * Steps: 1. Find the middle element of array. This will act as root 2. Use the * left half recursively to create left subtree 3. Use the right half * recursively to create right subtree */ public final class BSTFromSortedArray { private BSTFromSortedArray() { } public static Node createBST(int[] array) { if (array == null || array.length == 0) { return null; } return createBST(array, 0, array.length - 1); } private static Node createBST(int[] array, int startIdx, int endIdx) { // No element left. if (startIdx > endIdx) { return null; } int mid = startIdx + (endIdx - startIdx) / 2; // middle element will be the root Node root = new Node(array[mid]); root.left = createBST(array, startIdx, mid - 1); root.right = createBST(array, mid + 1, endIdx); return root; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; public class BSTIterative { private BinaryTree$Node a = null; BSTIterative() { } public BinaryTree$Node getRoot() { return this.a; } public void add(int n) { BinaryTree$Node binaryTree$Node = null; BinaryTree$Node binaryTree$Node2 = this.a; int n2 = -1; while (binaryTree$Node2 != null) { if (binaryTree$Node2.data > n) { binaryTree$Node = binaryTree$Node2; binaryTree$Node2 = binaryTree$Node.left; n2 = 0; continue; } if (binaryTree$Node2.data < n) { binaryTree$Node = binaryTree$Node2; binaryTree$Node2 = binaryTree$Node.right; n2 = 1; continue; } System.out.println(n + \" is already present in BST.\"); return; } BinaryTree$Node binaryTree$Node3 = new BinaryTree$Node(n); if (binaryTree$Node == null) { this.a = binaryTree$Node3; return; } if (n2 == 0) { binaryTree$Node.left = binaryTree$Node3; return; } binaryTree$Node.right = binaryTree$Node3; } public void remove(int n) { BinaryTree$Node binaryTree$Node = null; BinaryTree$Node binaryTree$Node2 = this.a; int n2 = -1; while (binaryTree$Node2 != null && binaryTree$Node2.data != n) { if (binaryTree$Node2.data > n) { binaryTree$Node = binaryTree$Node2; binaryTree$Node2 = binaryTree$Node.left; n2 = 0; continue; } binaryTree$Node = binaryTree$Node2; binaryTree$Node2 = binaryTree$Node.right; n2 = 1; } if (binaryTree$Node2 != null) { BinaryTree$Node binaryTree$Node3; if (binaryTree$Node2.right == null && binaryTree$Node2.left == null) { binaryTree$Node3 = null; } else if (binaryTree$Node2.right == null) { binaryTree$Node3 = binaryTree$Node2.left; binaryTree$Node2.left = null; } else if (binaryTree$Node2.left == null) { binaryTree$Node3 = binaryTree$Node2.right; binaryTree$Node2.right = null; } else if (binaryTree$Node2.right.left == null) { binaryTree$Node2.data = binaryTree$Node2.right.data; binaryTree$Node3 = binaryTree$Node2; binaryTree$Node2.right = binaryTree$Node2.right.right; } else { binaryTree$Node3 = binaryTree$Node2.right; BinaryTree$Node binaryTree$Node4 = binaryTree$Node2.right.left; while (binaryTree$Node4.left != null) { binaryTree$Node3 = binaryTree$Node4; binaryTree$Node4 = binaryTree$Node3.left; } binaryTree$Node2.data = binaryTree$Node4.data; binaryTree$Node3.left = binaryTree$Node4.right; binaryTree$Node3 = binaryTree$Node2; } if (binaryTree$Node == null) { this.a = binaryTree$Node3; return; } if (n2 == 0) { binaryTree$Node.left = binaryTree$Node3; return; } binaryTree$Node.right = binaryTree$Node3; } } public boolean find(int n) { BinaryTree$Node binaryTree$Node = this.a; while (binaryTree$Node != null) { if (binaryTree$Node.data > n) { binaryTree$Node = binaryTree$Node.left; continue; } if (binaryTree$Node.data < n) { binaryTree$Node = binaryTree$Node.right; continue; } System.out.println(n + \" is present in the BST.\"); return true; } System.out.println(n + \" not found.\"); return false; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree.Node; /** * * * <h1>Binary Search Tree (Iterative)</h1> * * <p> * An implementation of BST iteratively. Binary Search Tree is a binary tree * which satisfies three properties: left child is less than root node, right * child is grater than root node, both left and right child must themselves be * a BST. * * @author [Lakhan Nad](<a href=\"https://github.com/Lakhan-Nad\">git-Lakhan Nad</a>) */ public class BSTIterative { /** * Reference for the node of BST. */ private Node root; /** * Default Constructor Initializes the root of BST with null. */ BSTIterative() { root = null; } public Node getRoot() { return root; } /** * A method to insert a new value in BST. If the given value is already * present in BST the insertion is ignored. * * @param data the value to be inserted */ public void add(int data) { Node parent = null; Node temp = this.root; int rightOrLeft = -1; /* Finds the proper place this node can * be placed in according to rules of BST. */ while (temp != null) { if (temp.data > data) { parent = temp; temp = parent.left; rightOrLeft = 0; } else if (temp.data < data) { parent = temp; temp = parent.right; rightOrLeft = 1; } else { System.out.println(data + \" is already present in BST.\"); return; // if data already present we ignore insertion } } /* Creates a newNode with the value passed * Since this data doesn't already exists */ Node newNode = new Node(data); /* If the parent node is null * then the insertion is to be done in * root itself. */ if (parent == null) { this.root = newNode; } else { /* Check if insertion is to be made in * left or right subtree. */ if (rightOrLeft == 0) { parent.left = newNode; } else { parent.right = newNode; } } } /** * A method to delete the node in BST. If node is present it will be deleted * * @param data the value that needs to be deleted */ public void remove(int data) { Node parent = null; Node temp = this.root; int rightOrLeft = -1; /* Find the parent of the node and node itself * That is to be deleted. * parent variable store parent * temp stores node itself. * rightOrLeft use to keep track weather child * is left or right subtree */ while (temp != null) { if (temp.data == data) { break; } else if (temp.data > data) { parent = temp; temp = parent.left; rightOrLeft = 0; } else { parent = temp; temp = parent.right; rightOrLeft = 1; } } /* If temp is null than node with given value is not * present in our tree. */ if (temp != null) { Node replacement; // used to store the new values for replacing nodes if (temp.right == null && temp.left == null) { // Leaf node Case replacement = null; } else if (temp.right == null) { // Node with only right child replacement = temp.left; temp.left = null; } else if (temp.left == null) { // Node with only left child replacement = temp.right; temp.right = null; } else { /* If both left and right child are present * we replace this nodes data with * leftmost node's data in its right subtree * to maintain the balance of BST. * And then delete that node */ if (temp.right.left == null) { temp.data = temp.right.data; replacement = temp; temp.right = temp.right.right; } else { Node parent2 = temp.right; Node child = temp.right.left; while (child.left != null) { parent2 = child; child = parent2.left; } temp.data = child.data; parent2.left = child.right; replacement = temp; } } /* Change references of parent after * deleting the child. */ if (parent == null) { this.root = replacement; } else { if (rightOrLeft == 0) { parent.left = replacement; } else { parent.right = replacement; } } } } /** * A method to check if given data exists in out Binary Search Tree. * * @param data the value that needs to be searched for * @return boolean representing if the value was find */ public boolean find(int data) { Node temp = this.root; /* Check if node exists */ while (temp != null) { if (temp.data > data) { temp = temp.left; } else if (temp.data < data) { temp = temp.right; } else { /* If found return true */ System.out.println(data + \" is present in the BST.\"); return true; } } System.out.println(data + \" not found.\"); return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; public class BSTRecursive { private BinaryTree$Node a = null; BSTRecursive() { } public BinaryTree$Node getRoot() { return this.a; } private BinaryTree$Node a(BinaryTree$Node binaryTree$Node, int n) { if (binaryTree$Node == null) { System.out.println(\"No such data present in BST.\"); } else if (binaryTree$Node.data > n) { binaryTree$Node.left = this.a(binaryTree$Node.left, n); } else if (binaryTree$Node.data < n) { binaryTree$Node.right = this.a(binaryTree$Node.right, n); } else if (binaryTree$Node.right == null && binaryTree$Node.left == null) { binaryTree$Node = null; } else if (binaryTree$Node.left == null) { BinaryTree$Node binaryTree$Node2 = binaryTree$Node.right; binaryTree$Node.right = null; binaryTree$Node = binaryTree$Node2; } else if (binaryTree$Node.right == null) { BinaryTree$Node binaryTree$Node3 = binaryTree$Node.left; binaryTree$Node.left = null; binaryTree$Node = binaryTree$Node3; } else { BinaryTree$Node binaryTree$Node4 = binaryTree$Node.right; while (binaryTree$Node4.left != null) { binaryTree$Node4 = binaryTree$Node4.left; } binaryTree$Node.data = binaryTree$Node4.data; binaryTree$Node.right = this.a(binaryTree$Node.right, binaryTree$Node4.data); } return binaryTree$Node; } private BinaryTree$Node b(BinaryTree$Node binaryTree$Node, int n) { if (binaryTree$Node == null) { binaryTree$Node = new BinaryTree$Node(n); } else if (binaryTree$Node.data > n) { binaryTree$Node.left = this.b(binaryTree$Node.left, n); } else if (binaryTree$Node.data < n) { binaryTree$Node.right = this.b(binaryTree$Node.right, n); } return binaryTree$Node; } private boolean c(BinaryTree$Node binaryTree$Node, int n) { while (binaryTree$Node != null) { if (binaryTree$Node.data == n) { return true; } if (binaryTree$Node.data > n) { binaryTree$Node = binaryTree$Node.left; continue; } binaryTree$Node = binaryTree$Node.right; } return false; } public void add(int n) { this.a = this.b(this.a, n); } public void remove(int n) { this.a = this.a(this.a, n); } public boolean find(int n) { BSTRecursive bSTRecursive = this; if (bSTRecursive.c(bSTRecursive.a, n)) { System.out.println(n + \" is present in given BST.\"); return true; } System.out.println(n + \" not found.\"); return false; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree.Node; /** * * * <h1>Binary Search Tree (Recursive)</h1> * * An implementation of BST recursively. In recursive implementation the checks * are down the tree First root is checked if not found then its children are * checked Binary Search Tree is a binary tree which satisfies three properties: * left child is less than root node, right child is grater than root node, both * left and right children must themselves be a BST. * * <p> * I have made public functions as methods and to actually implement recursive * approach I have used private methods * * @author [Lakhan Nad](<a href=\"https://github.com/Lakhan-Nad\">git-Lakhan Nad</a>) */ public class BSTRecursive { /** * only data member is root of BST */ private Node root; /** * Constructor use to initialize node as null */ BSTRecursive() { root = null; } public Node getRoot() { return root; } /** * Recursive method to delete a data if present in BST. * * @param node the current node to search for data * @param data the value to be deleted * @return Node the updated value of root parameter after delete operation */ private Node delete(Node node, int data) { if (node == null) { System.out.println(\"No such data present in BST.\"); } else if (node.data > data) { node.left = delete(node.left, data); } else if (node.data < data) { node.right = delete(node.right, data); } else { if (node.right == null && node.left == null) { // If it is leaf node node = null; } else if (node.left == null) { // If only right node is present Node temp = node.right; node.right = null; node = temp; } else if (node.right == null) { // Only left node is present Node temp = node.left; node.left = null; node = temp; } else { // both children are present Node temp = node.right; // Find leftmost child of right subtree while (temp.left != null) { temp = temp.left; } node.data = temp.data; node.right = delete(node.right, temp.data); } } return node; } /** * Recursive insertion of value in BST. * * @param node to check if the data can be inserted in current node or its * subtree * @param data the value to be inserted * @return the modified value of the root parameter after insertion */ private Node insert(Node node, int data) { if (node == null) { node = new Node(data); } else if (node.data > data) { node.left = insert(node.left, data); } else if (node.data < data) { node.right = insert(node.right, data); } return node; } /** * Search recursively if the given value is present in BST or not. * * @param node the current node to check * @param data the value to be checked * @return boolean if data is present or not */ private boolean search(Node node, int data) { if (node == null) { return false; } else if (node.data == data) { return true; } else if (node.data > data) { return search(node.left, data); } else { return search(node.right, data); } } /** * add in BST. if the value is not already present it is inserted or else no * change takes place. * * @param data the value to be inserted */ public void add(int data) { this.root = insert(this.root, data); } /** * If data is present in BST delete it else do nothing. * * @param data the value to be removed */ public void remove(int data) { this.root = delete(this.root, data); } /** * To check if given value is present in tree or not. * * @param data the data to be found for */ public boolean find(int data) { if (search(this.root, data)) { System.out.println(data + \" is present in given BST.\"); return true; } System.out.println(data + \" not found.\"); return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class BSTRecursiveGeneric$Node { Object a; BSTRecursiveGeneric$Node b; BSTRecursiveGeneric$Node c; BSTRecursiveGeneric$Node(Object object) { this.a = object; this.b = null; this.c = null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class BSTRecursiveGeneric$Node { Object a; BSTRecursiveGeneric$Node b; BSTRecursiveGeneric$Node c; BSTRecursiveGeneric$Node(Object object) { this.a = object; this.b = null; this.c = null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BSTRecursiveGeneric$Node; import java.util.ArrayList; import java.util.List; public class BSTRecursiveGeneric { private BSTRecursiveGeneric$Node a = null; public static void main(String[] object) { System.out.println(\"Testing for integer data...\"); object = new BSTRecursiveGeneric(); ((BSTRecursiveGeneric)object).add(Integer.valueOf(5)); ((BSTRecursiveGeneric)object).add(Integer.valueOf(10)); ((BSTRecursiveGeneric)object).add(Integer.valueOf(9)); assert (!((BSTRecursiveGeneric)object).find(Integer.valueOf(4))) : \"4 is not yet present in BST\"; assert (((BSTRecursiveGeneric)object).find(Integer.valueOf(10))) : \"10 should be present in BST\"; ((BSTRecursiveGeneric)object).remove(Integer.valueOf(9)); assert (!((BSTRecursiveGeneric)object).find(Integer.valueOf(9))) : \"9 was just deleted from BST\"; ((BSTRecursiveGeneric)object).remove(Integer.valueOf(1)); assert (!((BSTRecursiveGeneric)object).find(Integer.valueOf(1))) : \"Since 1 was not present so find deleting would do no change\"; ((BSTRecursiveGeneric)object).add(Integer.valueOf(20)); ((BSTRecursiveGeneric)object).add(Integer.valueOf(70)); assert (((BSTRecursiveGeneric)object).find(Integer.valueOf(70))) : \"70 was inserted but not found\"; ((BSTRecursiveGeneric)object).inorder(); System.out.println(); System.out.println(\"Testing for string data...\"); object = new BSTRecursiveGeneric(); ((BSTRecursiveGeneric)object).add((Comparable)((Object)\"banana\")); ((BSTRecursiveGeneric)object).add((Comparable)((Object)\"pineapple\")); ((BSTRecursiveGeneric)object).add((Comparable)((Object)\"date\")); assert (!((BSTRecursiveGeneric)object).find((Comparable)((Object)\"girl\"))) : \"girl is not yet present in BST\"; assert (((BSTRecursiveGeneric)object).find((Comparable)((Object)\"pineapple\"))) : \"10 should be present in BST\"; ((BSTRecursiveGeneric)object).remove((Comparable)((Object)\"date\")); assert (!((BSTRecursiveGeneric)object).find((Comparable)((Object)\"date\"))) : \"date was just deleted from BST\"; ((BSTRecursiveGeneric)object).remove((Comparable)((Object)\"boy\")); assert (!((BSTRecursiveGeneric)object).find((Comparable)((Object)\"boy\"))) : \"Since boy was not present so deleting would do no change\"; ((BSTRecursiveGeneric)object).add((Comparable)((Object)\"india\")); ((BSTRecursiveGeneric)object).add((Comparable)((Object)\"hills\")); assert (((BSTRecursiveGeneric)object).find((Comparable)((Object)\"hills\"))) : \"hills was inserted but not found\"; ((BSTRecursiveGeneric)object).inorder(); } private BSTRecursiveGeneric$Node a(BSTRecursiveGeneric$Node object, Comparable object2) { if (object == null) { System.out.println(\"No such data present in BST.\"); } else if (((Comparable)((BSTRecursiveGeneric$Node)object).a).compareTo(object2) > 0) { ((BSTRecursiveGeneric$Node)object).b = this.a(((BSTRecursiveGeneric$Node)object).b, (Comparable)object2); } else if (((Comparable)((BSTRecursiveGeneric$Node)object).a).compareTo(object2) < 0) { ((BSTRecursiveGeneric$Node)object).c = this.a(((BSTRecursiveGeneric$Node)object).c, (Comparable)object2); } else if (((BSTRecursiveGeneric$Node)object).c == null && ((BSTRecursiveGeneric$Node)object).b == null) { object = null; } else if (((BSTRecursiveGeneric$Node)object).b == null) { object2 = ((BSTRecursiveGeneric$Node)object).c; ((BSTRecursiveGeneric$Node)object).c = null; object = object2; } else if (((BSTRecursiveGeneric$Node)object).c == null) { object2 = ((BSTRecursiveGeneric$Node)object).b; ((BSTRecursiveGeneric$Node)object).b = null; object = object2; } else { object2 = ((BSTRecursiveGeneric$Node)object).c; while (((BSTRecursiveGeneric$Node)object2).b != null) { object2 = ((BSTRecursiveGeneric$Node)object2).b; } ((BSTRecursiveGeneric$Node)object).a = ((BSTRecursiveGeneric$Node)object2).a; ((BSTRecursiveGeneric$Node)object).c = this.a(((BSTRecursiveGeneric$Node)object).c, (Comparable)((BSTRecursiveGeneric$Node)object2).a); } return object; } private BSTRecursiveGeneric$Node b(BSTRecursiveGeneric$Node bSTRecursiveGeneric$Node, Comparable comparable) { if (bSTRecursiveGeneric$Node == null) { bSTRecursiveGeneric$Node = new BSTRecursiveGeneric$Node(comparable); } else if (((Comparable)bSTRecursiveGeneric$Node.a).compareTo(comparable) > 0) { bSTRecursiveGeneric$Node.b = this.b(bSTRecursiveGeneric$Node.b, comparable); } else if (((Comparable)bSTRecursiveGeneric$Node.a).compareTo(comparable) < 0) { bSTRecursiveGeneric$Node.c = this.b(bSTRecursiveGeneric$Node.c, comparable); } return bSTRecursiveGeneric$Node; } private void a(BSTRecursiveGeneric$Node bSTRecursiveGeneric$Node) { while (true) { if (bSTRecursiveGeneric$Node == null) { return; } System.out.print(String.valueOf(bSTRecursiveGeneric$Node.a) + \" \"); if (bSTRecursiveGeneric$Node.b != null) { this.a(bSTRecursiveGeneric$Node.b); } if (bSTRecursiveGeneric$Node.c == null) break; bSTRecursiveGeneric$Node = bSTRecursiveGeneric$Node.c; } } private void b(BSTRecursiveGeneric$Node bSTRecursiveGeneric$Node) { if (bSTRecursiveGeneric$Node == null) { return; } if (bSTRecursiveGeneric$Node.b != null) { this.b(bSTRecursiveGeneric$Node.b); } if (bSTRecursiveGeneric$Node.c != null) { this.b(bSTRecursiveGeneric$Node.c); } System.out.print(String.valueOf(bSTRecursiveGeneric$Node.a) + \" \"); } private void c(BSTRecursiveGeneric$Node bSTRecursiveGeneric$Node) { while (true) { if (bSTRecursiveGeneric$Node == null) { return; } if (bSTRecursiveGeneric$Node.b != null) { this.c(bSTRecursiveGeneric$Node.b); } System.out.print(String.valueOf(bSTRecursiveGeneric$Node.a) + \" \"); if (bSTRecursiveGeneric$Node.c == null) break; bSTRecursiveGeneric$Node = bSTRecursiveGeneric$Node.c; } } private void a(BSTRecursiveGeneric$Node bSTRecursiveGeneric$Node, List list) { while (true) { if (bSTRecursiveGeneric$Node == null) { return; } if (bSTRecursiveGeneric$Node.b != null) { this.a(bSTRecursiveGeneric$Node.b, list); } list.add((Comparable)bSTRecursiveGeneric$Node.a); if (bSTRecursiveGeneric$Node.c == null) break; bSTRecursiveGeneric$Node = bSTRecursiveGeneric$Node.c; } } private boolean c(BSTRecursiveGeneric$Node bSTRecursiveGeneric$Node, Comparable comparable) { while (bSTRecursiveGeneric$Node != null) { if (((Comparable)bSTRecursiveGeneric$Node.a).compareTo(comparable) == 0) { return true; } if (((Comparable)bSTRecursiveGeneric$Node.a).compareTo(comparable) > 0) { bSTRecursiveGeneric$Node = bSTRecursiveGeneric$Node.b; continue; } bSTRecursiveGeneric$Node = bSTRecursiveGeneric$Node.c; } return false; } public void add(Comparable comparable) { this.a = this.b(this.a, comparable); } public void remove(Comparable comparable) { this.a = this.a(this.a, comparable); } public void inorder() { System.out.println(\"Inorder traversal of this tree is:\"); BSTRecursiveGeneric bSTRecursiveGeneric = this; bSTRecursiveGeneric.c(bSTRecursiveGeneric.a); System.out.println(); } public List inorderSort() { ArrayList arrayList = new ArrayList(); BSTRecursiveGeneric bSTRecursiveGeneric = this; bSTRecursiveGeneric.a(bSTRecursiveGeneric.a, arrayList); return arrayList; } public void postorder() { System.out.println(\"Postorder traversal of this tree is:\"); BSTRecursiveGeneric bSTRecursiveGeneric = this; bSTRecursiveGeneric.b(bSTRecursiveGeneric.a); System.out.println(); } public void preorder() { System.out.println(\"Preorder traversal of this tree is:\"); BSTRecursiveGeneric bSTRecursiveGeneric = this; bSTRecursiveGeneric.a(bSTRecursiveGeneric.a); System.out.println(); } public boolean find(Comparable comparable) { BSTRecursiveGeneric bSTRecursiveGeneric = this; if (bSTRecursiveGeneric.c(bSTRecursiveGeneric.a, comparable)) { System.out.println(String.valueOf(comparable) + \" is present in given BST.\"); return true; } System.out.println(String.valueOf(comparable) + \" not found.\"); return false; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayList; import java.util.List; /** * <h1>Binary Search Tree (Recursive) Generic Type Implementation</h1> * * <p> * A recursive implementation of generic type BST. * * Reference: <a href=\"https://en.wikipedia.org/wiki/Binary_search_tree\">Wiki links for BST</a> * </p> * * @author [Madhur Panwar](<a href=\"https://github.com/mdrpanwar\">git-Madhur Panwar</a>) */ public class BSTRecursiveGeneric<T extends Comparable<T>> { /** * only data member is root of BST */ private Node<T> root; /** * Constructor use to initialize node as null */ public BSTRecursiveGeneric() { root = null; } /** * main function for testing */ public static void main(String[] args) { System.out.println(\"Testing for integer data...\"); // Integer BSTRecursiveGeneric<Integer> integerTree = new BSTRecursiveGeneric<Integer>(); integerTree.add(5); integerTree.add(10); integerTree.add(9); assert !integerTree.find(4) : \"4 is not yet present in BST\"; assert integerTree.find(10) : \"10 should be present in BST\"; integerTree.remove(9); assert !integerTree.find(9) : \"9 was just deleted from BST\"; integerTree.remove(1); assert !integerTree.find(1) : \"Since 1 was not present so find deleting would do no change\"; integerTree.add(20); integerTree.add(70); assert integerTree.find(70) : \"70 was inserted but not found\"; /* Will print in following order 5 10 20 70 */ integerTree.inorder(); System.out.println(); System.out.println(\"Testing for string data...\"); // String BSTRecursiveGeneric<String> stringTree = new BSTRecursiveGeneric<String>(); stringTree.add(\"banana\"); stringTree.add(\"pineapple\"); stringTree.add(\"date\"); assert !stringTree.find(\"girl\") : \"girl is not yet present in BST\"; assert stringTree.find(\"pineapple\") : \"10 should be present in BST\"; stringTree.remove(\"date\"); assert !stringTree.find(\"date\") : \"date was just deleted from BST\"; stringTree.remove(\"boy\"); assert !stringTree.find(\"boy\") : \"Since boy was not present so deleting would do no change\"; stringTree.add(\"india\"); stringTree.add(\"hills\"); assert stringTree.find(\"hills\") : \"hills was inserted but not found\"; /* Will print in following order banana hills india pineapple */ stringTree.inorder(); } /** * Recursive method to delete a data if present in BST. * * @param node the node under which to (recursively) search for data * @param data the value to be deleted * @return Node the updated value of root parameter after delete operation */ private Node<T> delete(Node<T> node, T data) { if (node == null) { System.out.println(\"No such data present in BST.\"); } else if (node.data.compareTo(data) > 0) { node.left = delete(node.left, data); } else if (node.data.compareTo(data) < 0) { node.right = delete(node.right, data); } else { if (node.right == null && node.left == null) { // If it is leaf node node = null; } else if (node.left == null) { // If only right node is present Node<T> temp = node.right; node.right = null; node = temp; } else if (node.right == null) { // Only left node is present Node<T> temp = node.left; node.left = null; node = temp; } else { // both child are present Node<T> temp = node.right; // Find leftmost child of right subtree while (temp.left != null) { temp = temp.left; } node.data = temp.data; node.right = delete(node.right, temp.data); } } return node; } /** * Recursive insertion of value in BST. * * @param node to check if the data can be inserted in current node or its * subtree * @param data the value to be inserted * @return the modified value of the root parameter after insertion */ private Node<T> insert(Node<T> node, T data) { if (node == null) { node = new Node<>(data); } else if (node.data.compareTo(data) > 0) { node.left = insert(node.left, data); } else if (node.data.compareTo(data) < 0) { node.right = insert(node.right, data); } return node; } /** * Recursively print Preorder traversal of the BST * * @param node the root node */ private void preOrder(Node<T> node) { if (node == null) { return; } System.out.print(node.data + \" \"); if (node.left != null) { preOrder(node.left); } if (node.right != null) { preOrder(node.right); } } /** * Recursively print Postorder traversal of BST. * * @param node the root node */ private void postOrder(Node<T> node) { if (node == null) { return; } if (node.left != null) { postOrder(node.left); } if (node.right != null) { postOrder(node.right); } System.out.print(node.data + \" \"); } /** * Recursively print Inorder traversal of BST. * * @param node the root node */ private void inOrder(Node<T> node) { if (node == null) { return; } if (node.left != null) { inOrder(node.left); } System.out.print(node.data + \" \"); if (node.right != null) { inOrder(node.right); } } /** * Recursively traverse the tree using inorder traversal and keep adding * elements to argument list. * * @param node the root node * @param sortedList the list to add the srted elements into */ private void inOrderSort(Node<T> node, List<T> sortedList) { if (node == null) { return; } if (node.left != null) { inOrderSort(node.left, sortedList); } sortedList.add(node.data); if (node.right != null) { inOrderSort(node.right, sortedList); } } /** * Search recursively if the given value is present in BST or not. * * @param node the node under which to check * @param data the value to be checked * @return boolean if data is present or not */ private boolean search(Node<T> node, T data) { if (node == null) { return false; } else if (node.data.compareTo(data) == 0) { return true; } else if (node.data.compareTo(data) > 0) { return search(node.left, data); } else { return search(node.right, data); } } /** * add in BST. if the value is not already present it is inserted or else no * change takes place. * * @param data the value to be inserted */ public void add(T data) { this.root = insert(this.root, data); } /** * If data is present in BST delete it else do nothing. * * @param data the value to be removed */ public void remove(T data) { this.root = delete(this.root, data); } /** * To call inorder traversal on tree */ public void inorder() { System.out.println(\"Inorder traversal of this tree is:\"); inOrder(this.root); System.out.println(); // for next line } /** * return a sorted list by traversing the tree elements using inorder * traversal */ public List<T> inorderSort() { List<T> sortedList = new ArrayList<>(); inOrderSort(this.root, sortedList); return sortedList; } /** * To call postorder traversal on tree */ public void postorder() { System.out.println(\"Postorder traversal of this tree is:\"); postOrder(this.root); System.out.println(); // for next line } /** * To call preorder traversal on tree. */ public void preorder() { System.out.println(\"Preorder traversal of this tree is:\"); preOrder(this.root); System.out.println(); // for next line } /** * To check if given value is present in tree or not. * * @param data the data to be found for */ public boolean find(T data) { if (search(this.root, data)) { System.out.println(data + \" is present in given BST.\"); return true; } System.out.println(data + \" not found.\"); return false; } /** * The generic Node class used for building binary search tree */ private static class Node<T> { T data; Node<T> left; Node<T> right; /** * Constructor with data as parameter */ Node(T d) { data = d; left = null; right = null; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import java.util.ArrayList; class BTree$BTreeNode { int[] a; private int e; BTree$BTreeNode[] b; int c; boolean d; BTree$BTreeNode(int n, boolean bl) { this.e = n; this.d = bl; this.a = new int[2 * n - 1]; this.b = new BTree$BTreeNode[2 * n]; this.c = 0; } final void a(ArrayList arrayList) { while (true) { for (int i = 0; i < bTree$BTreeNode.c; ++i) { if (!bTree$BTreeNode.d) { bTree$BTreeNode.b[i].a(arrayList); } arrayList.add(bTree$BTreeNode.a[i]); } if (bTree$BTreeNode.d) break; BTree$BTreeNode bTree$BTreeNode = bTree$BTreeNode.b[bTree$BTreeNode.c]; } } final BTree$BTreeNode a(int n) { while (true) { int n2; for (n2 = 0; n2 < bTree$BTreeNode.c && n > bTree$BTreeNode.a[n2]; ++n2) { } if (n2 < bTree$BTreeNode.c && bTree$BTreeNode.a[n2] == n) { return bTree$BTreeNode; } if (bTree$BTreeNode.d) { return null; } BTree$BTreeNode bTree$BTreeNode = bTree$BTreeNode.b[n2]; } } final void b(int n) { while (true) { int n2; if (bTree$BTreeNode.d) { for (n2 = bTree$BTreeNode.c - 1; n2 >= 0 && bTree$BTreeNode.a[n2] > n; --n2) { bTree$BTreeNode.a[n2 + 1] = bTree$BTreeNode.a[n2]; } bTree$BTreeNode.a[n2 + 1] = n; ++bTree$BTreeNode.c; return; } while (n2 >= 0 && bTree$BTreeNode.a[n2] > n) { --n2; } if (bTree$BTreeNode.b[n2 + 1].c == 2 * bTree$BTreeNode.e - 1) { bTree$BTreeNode.a(n2 + 1, bTree$BTreeNode.b[n2 + 1]); if (bTree$BTreeNode.a[n2 + 1] < n) { ++n2; } } BTree$BTreeNode bTree$BTreeNode = bTree$BTreeNode.b[n2 + 1]; } } final void a(int n, BTree$BTreeNode bTree$BTreeNode) { int n2; BTree$BTreeNode bTree$BTreeNode2 = new BTree$BTreeNode(bTree$BTreeNode.e, bTree$BTreeNode.d); new BTree$BTreeNode(bTree$BTreeNode.e, bTree$BTreeNode.d).c = this.e - 1; System.arraycopy(bTree$BTreeNode.a, this.e, bTree$BTreeNode2.a, 0, this.e - 1); if (!bTree$BTreeNode.d) { System.arraycopy(bTree$BTreeNode.b, this.e, bTree$BTreeNode2.b, 0, this.e); } bTree$BTreeNode.c = this.e - 1; for (n2 = this.c; n2 >= n + 1; --n2) { this.b[n2 + 1] = this.b[n2]; } this.b[n + 1] = bTree$BTreeNode2; for (n2 = this.c - 1; n2 >= n; --n2) { this.a[n2 + 1] = this.a[n2]; } this.a[n] = bTree$BTreeNode.a[this.e - 1]; ++this.c; } final void c(int n) { while (true) { boolean bl; int n2; BTree$BTreeNode bTree$BTreeNode; int n3; int n4 = n; BTree$BTreeNode bTree$BTreeNode2 = bTree$BTreeNode7; for (n3 = 0; n3 < bTree$BTreeNode2.c && bTree$BTreeNode2.a[n3] < n4; ++n3) { } int n5 = n3; if (n5 < bTree$BTreeNode7.c && bTree$BTreeNode7.a[n5] == n) { if (bTree$BTreeNode7.d) { n4 = n5; bTree$BTreeNode2 = bTree$BTreeNode7; for (n3 = n4 + 1; n3 < bTree$BTreeNode2.c; ++n3) { bTree$BTreeNode2.a[n3 - 1] = bTree$BTreeNode2.a[n3]; } --bTree$BTreeNode2.c; return; } n4 = n5; bTree$BTreeNode2 = bTree$BTreeNode7; n3 = bTree$BTreeNode2.a[n4]; if (bTree$BTreeNode2.b[n4].c >= bTree$BTreeNode2.e) { int n6 = n4; bTree$BTreeNode = bTree$BTreeNode2; BTree$BTreeNode bTree$BTreeNode3 = bTree$BTreeNode.b[n6]; while (!bTree$BTreeNode3.d) { bTree$BTreeNode3 = bTree$BTreeNode3.b[bTree$BTreeNode3.c]; } bTree$BTreeNode2.a[n4] = n2 = bTree$BTreeNode3.a[bTree$BTreeNode3.c - 1]; bTree$BTreeNode2.b[n4].c(n2); break; } if (bTree$BTreeNode2.b[n4 + 1].c >= bTree$BTreeNode2.e) { int n7 = n4; bTree$BTreeNode = bTree$BTreeNode2; BTree$BTreeNode bTree$BTreeNode4 = bTree$BTreeNode.b[n7 + 1]; while (!bTree$BTreeNode4.d) { bTree$BTreeNode4 = bTree$BTreeNode4.b[0]; } bTree$BTreeNode2.a[n4] = n2 = bTree$BTreeNode4.a[0]; bTree$BTreeNode2.b[n4 + 1].c(n2); break; } bTree$BTreeNode2.d(n4); bTree$BTreeNode2.b[n4].c(n3); return; } if (bTree$BTreeNode7.d) { return; } boolean bl2 = bl = n5 == bTree$BTreeNode7.c; if (bTree$BTreeNode7.b[n5].c < bTree$BTreeNode7.e) { n4 = n5; bTree$BTreeNode2 = bTree$BTreeNode7; if (n4 != 0 && bTree$BTreeNode2.b[n4 - 1].c >= bTree$BTreeNode2.e) { n2 = n4; BTree$BTreeNode bTree$BTreeNode5 = bTree$BTreeNode2; bTree$BTreeNode = bTree$BTreeNode5.b[n2]; var9_11 = bTree$BTreeNode5.b[n2 - 1]; for (var10_14 = bTree$BTreeNode.c - 1; var10_14 >= 0; --var10_14) { bTree$BTreeNode.a[var10_14 + 1] = bTree$BTreeNode.a[var10_14]; } if (!bTree$BTreeNode.d) { for (var10_14 = bTree$BTreeNode.c; var10_14 >= 0; --var10_14) { bTree$BTreeNode.b[var10_14 + 1] = bTree$BTreeNode.b[var10_14]; } } bTree$BTreeNode.a[0] = bTree$BTreeNode5.a[n2 - 1]; if (!bTree$BTreeNode.d) { bTree$BTreeNode.b[0] = var9_11.b[var9_11.c]; } bTree$BTreeNode5.a[n2 - 1] = var9_11.a[var9_11.c - 1]; ++bTree$BTreeNode.c; --var9_11.c; } else if (n4 != bTree$BTreeNode2.c && bTree$BTreeNode2.b[n4 + 1].c >= bTree$BTreeNode2.e) { n2 = n4; BTree$BTreeNode bTree$BTreeNode6 = bTree$BTreeNode2; bTree$BTreeNode = bTree$BTreeNode6.b[n2]; var9_11 = bTree$BTreeNode6.b[n2 + 1]; bTree$BTreeNode.a[bTree$BTreeNode.c] = bTree$BTreeNode6.a[n2]; if (!bTree$BTreeNode.d) { bTree$BTreeNode.b[bTree$BTreeNode.c + 1] = var9_11.b[0]; } bTree$BTreeNode6.a[n2] = var9_11.a[0]; for (var10_14 = 1; var10_14 < var9_11.c; ++var10_14) { var9_11.a[var10_14 - 1] = var9_11.a[var10_14]; } if (!var9_11.d) { for (var10_14 = 1; var10_14 <= var9_11.c; ++var10_14) { var9_11.b[var10_14 - 1] = var9_11.b[var10_14]; } } ++bTree$BTreeNode.c; --var9_11.c; } else if (n4 != bTree$BTreeNode2.c) { bTree$BTreeNode2.d(n4); } else { bTree$BTreeNode2.d(n4 - 1); } } if (bl && n5 > bTree$BTreeNode7.c) { bTree$BTreeNode7.b[n5 - 1].c(n); return; } BTree$BTreeNode bTree$BTreeNode7 = bTree$BTreeNode7.b[n5]; } } private void d(int n) { int n2; BTree$BTreeNode bTree$BTreeNode = this.b[n]; BTree$BTreeNode bTree$BTreeNode2 = this.b[n + 1]; bTree$BTreeNode.a[this.e - 1] = this.a[n]; for (n2 = 0; n2 < bTree$BTreeNode2.c; ++n2) { bTree$BTreeNode.a[n2 + this.e] = bTree$BTreeNode2.a[n2]; } if (!bTree$BTreeNode.d) { for (n2 = 0; n2 <= bTree$BTreeNode2.c; ++n2) { bTree$BTreeNode.b[n2 + this.e] = bTree$BTreeNode2.b[n2]; } } for (n2 = n + 1; n2 < this.c; ++n2) { this.a[n2 - 1] = this.a[n2]; } for (n2 = n + 2; n2 <= this.c; ++n2) { this.b[n2 - 1] = this.b[n2]; } bTree$BTreeNode.c += bTree$BTreeNode2.c + 1; --this.c; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import java.util.ArrayList; class BTree$BTreeNode { int[] a; private int e; BTree$BTreeNode[] b; int c; boolean d; BTree$BTreeNode(int n, boolean bl) { this.e = n; this.d = bl; this.a = new int[2 * n - 1]; this.b = new BTree$BTreeNode[2 * n]; this.c = 0; } final void a(ArrayList arrayList) { while (true) { for (int i = 0; i < bTree$BTreeNode.c; ++i) { if (!bTree$BTreeNode.d) { bTree$BTreeNode.b[i].a(arrayList); } arrayList.add(bTree$BTreeNode.a[i]); } if (bTree$BTreeNode.d) break; BTree$BTreeNode bTree$BTreeNode = bTree$BTreeNode.b[bTree$BTreeNode.c]; } } final BTree$BTreeNode a(int n) { while (true) { int n2; for (n2 = 0; n2 < bTree$BTreeNode.c && n > bTree$BTreeNode.a[n2]; ++n2) { } if (n2 < bTree$BTreeNode.c && bTree$BTreeNode.a[n2] == n) { return bTree$BTreeNode; } if (bTree$BTreeNode.d) { return null; } BTree$BTreeNode bTree$BTreeNode = bTree$BTreeNode.b[n2]; } } final void b(int n) { while (true) { int n2; if (bTree$BTreeNode.d) { for (n2 = bTree$BTreeNode.c - 1; n2 >= 0 && bTree$BTreeNode.a[n2] > n; --n2) { bTree$BTreeNode.a[n2 + 1] = bTree$BTreeNode.a[n2]; } bTree$BTreeNode.a[n2 + 1] = n; ++bTree$BTreeNode.c; return; } while (n2 >= 0 && bTree$BTreeNode.a[n2] > n) { --n2; } if (bTree$BTreeNode.b[n2 + 1].c == 2 * bTree$BTreeNode.e - 1) { bTree$BTreeNode.a(n2 + 1, bTree$BTreeNode.b[n2 + 1]); if (bTree$BTreeNode.a[n2 + 1] < n) { ++n2; } } BTree$BTreeNode bTree$BTreeNode = bTree$BTreeNode.b[n2 + 1]; } } final void a(int n, BTree$BTreeNode bTree$BTreeNode) { int n2; BTree$BTreeNode bTree$BTreeNode2 = new BTree$BTreeNode(bTree$BTreeNode.e, bTree$BTreeNode.d); new BTree$BTreeNode(bTree$BTreeNode.e, bTree$BTreeNode.d).c = this.e - 1; System.arraycopy(bTree$BTreeNode.a, this.e, bTree$BTreeNode2.a, 0, this.e - 1); if (!bTree$BTreeNode.d) { System.arraycopy(bTree$BTreeNode.b, this.e, bTree$BTreeNode2.b, 0, this.e); } bTree$BTreeNode.c = this.e - 1; for (n2 = this.c; n2 >= n + 1; --n2) { this.b[n2 + 1] = this.b[n2]; } this.b[n + 1] = bTree$BTreeNode2; for (n2 = this.c - 1; n2 >= n; --n2) { this.a[n2 + 1] = this.a[n2]; } this.a[n] = bTree$BTreeNode.a[this.e - 1]; ++this.c; } final void c(int n) { while (true) { boolean bl; int n2; BTree$BTreeNode bTree$BTreeNode; int n3; int n4 = n; BTree$BTreeNode bTree$BTreeNode2 = bTree$BTreeNode7; for (n3 = 0; n3 < bTree$BTreeNode2.c && bTree$BTreeNode2.a[n3] < n4; ++n3) { } int n5 = n3; if (n5 < bTree$BTreeNode7.c && bTree$BTreeNode7.a[n5] == n) { if (bTree$BTreeNode7.d) { n4 = n5; bTree$BTreeNode2 = bTree$BTreeNode7; for (n3 = n4 + 1; n3 < bTree$BTreeNode2.c; ++n3) { bTree$BTreeNode2.a[n3 - 1] = bTree$BTreeNode2.a[n3]; } --bTree$BTreeNode2.c; return; } n4 = n5; bTree$BTreeNode2 = bTree$BTreeNode7; n3 = bTree$BTreeNode2.a[n4]; if (bTree$BTreeNode2.b[n4].c >= bTree$BTreeNode2.e) { int n6 = n4; bTree$BTreeNode = bTree$BTreeNode2; BTree$BTreeNode bTree$BTreeNode3 = bTree$BTreeNode.b[n6]; while (!bTree$BTreeNode3.d) { bTree$BTreeNode3 = bTree$BTreeNode3.b[bTree$BTreeNode3.c]; } bTree$BTreeNode2.a[n4] = n2 = bTree$BTreeNode3.a[bTree$BTreeNode3.c - 1]; bTree$BTreeNode2.b[n4].c(n2); break; } if (bTree$BTreeNode2.b[n4 + 1].c >= bTree$BTreeNode2.e) { int n7 = n4; bTree$BTreeNode = bTree$BTreeNode2; BTree$BTreeNode bTree$BTreeNode4 = bTree$BTreeNode.b[n7 + 1]; while (!bTree$BTreeNode4.d) { bTree$BTreeNode4 = bTree$BTreeNode4.b[0]; } bTree$BTreeNode2.a[n4] = n2 = bTree$BTreeNode4.a[0]; bTree$BTreeNode2.b[n4 + 1].c(n2); break; } bTree$BTreeNode2.d(n4); bTree$BTreeNode2.b[n4].c(n3); return; } if (bTree$BTreeNode7.d) { return; } boolean bl2 = bl = n5 == bTree$BTreeNode7.c; if (bTree$BTreeNode7.b[n5].c < bTree$BTreeNode7.e) { n4 = n5; bTree$BTreeNode2 = bTree$BTreeNode7; if (n4 != 0 && bTree$BTreeNode2.b[n4 - 1].c >= bTree$BTreeNode2.e) { n2 = n4; BTree$BTreeNode bTree$BTreeNode5 = bTree$BTreeNode2; bTree$BTreeNode = bTree$BTreeNode5.b[n2]; var9_11 = bTree$BTreeNode5.b[n2 - 1]; for (var10_14 = bTree$BTreeNode.c - 1; var10_14 >= 0; --var10_14) { bTree$BTreeNode.a[var10_14 + 1] = bTree$BTreeNode.a[var10_14]; } if (!bTree$BTreeNode.d) { for (var10_14 = bTree$BTreeNode.c; var10_14 >= 0; --var10_14) { bTree$BTreeNode.b[var10_14 + 1] = bTree$BTreeNode.b[var10_14]; } } bTree$BTreeNode.a[0] = bTree$BTreeNode5.a[n2 - 1]; if (!bTree$BTreeNode.d) { bTree$BTreeNode.b[0] = var9_11.b[var9_11.c]; } bTree$BTreeNode5.a[n2 - 1] = var9_11.a[var9_11.c - 1]; ++bTree$BTreeNode.c; --var9_11.c; } else if (n4 != bTree$BTreeNode2.c && bTree$BTreeNode2.b[n4 + 1].c >= bTree$BTreeNode2.e) { n2 = n4; BTree$BTreeNode bTree$BTreeNode6 = bTree$BTreeNode2; bTree$BTreeNode = bTree$BTreeNode6.b[n2]; var9_11 = bTree$BTreeNode6.b[n2 + 1]; bTree$BTreeNode.a[bTree$BTreeNode.c] = bTree$BTreeNode6.a[n2]; if (!bTree$BTreeNode.d) { bTree$BTreeNode.b[bTree$BTreeNode.c + 1] = var9_11.b[0]; } bTree$BTreeNode6.a[n2] = var9_11.a[0]; for (var10_14 = 1; var10_14 < var9_11.c; ++var10_14) { var9_11.a[var10_14 - 1] = var9_11.a[var10_14]; } if (!var9_11.d) { for (var10_14 = 1; var10_14 <= var9_11.c; ++var10_14) { var9_11.b[var10_14 - 1] = var9_11.b[var10_14]; } } ++bTree$BTreeNode.c; --var9_11.c; } else if (n4 != bTree$BTreeNode2.c) { bTree$BTreeNode2.d(n4); } else { bTree$BTreeNode2.d(n4 - 1); } } if (bl && n5 > bTree$BTreeNode7.c) { bTree$BTreeNode7.b[n5 - 1].c(n); return; } BTree$BTreeNode bTree$BTreeNode7 = bTree$BTreeNode7.b[n5]; } } private void d(int n) { int n2; BTree$BTreeNode bTree$BTreeNode = this.b[n]; BTree$BTreeNode bTree$BTreeNode2 = this.b[n + 1]; bTree$BTreeNode.a[this.e - 1] = this.a[n]; for (n2 = 0; n2 < bTree$BTreeNode2.c; ++n2) { bTree$BTreeNode.a[n2 + this.e] = bTree$BTreeNode2.a[n2]; } if (!bTree$BTreeNode.d) { for (n2 = 0; n2 <= bTree$BTreeNode2.c; ++n2) { bTree$BTreeNode.b[n2 + this.e] = bTree$BTreeNode2.b[n2]; } } for (n2 = n + 1; n2 < this.c; ++n2) { this.a[n2 - 1] = this.a[n2]; } for (n2 = n + 2; n2 <= this.c; ++n2) { this.b[n2 - 1] = this.b[n2]; } bTree$BTreeNode.c += bTree$BTreeNode2.c + 1; --this.c; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BTree$BTreeNode; import java.util.ArrayList; public class BTree { private BTree$BTreeNode a = null; private final int b; public BTree(int n) { this.b = n; } public void traverse(ArrayList arrayList) { if (this.a != null) { this.a.a(arrayList); } } public boolean search(int n) { return this.a != null && this.a.a(n) != null; } public void insert(int n) { if (this.search(n)) { return; } if (this.a == null) { this.a = new BTree$BTreeNode(this.b, true); this.a.a[0] = n; this.a.c = 1; return; } if (this.a.c == 2 * this.b - 1) { BTree$BTreeNode bTree$BTreeNode = new BTree$BTreeNode(this.b, false); bTree$BTreeNode.b[0] = this.a; bTree$BTreeNode.a(0, this.a); int n2 = 0; if (bTree$BTreeNode.a[0] < n) { ++n2; } bTree$BTreeNode.b[n2].b(n); this.a = bTree$BTreeNode; return; } this.a.b(n); } public void delete(int n) { if (this.a == null) { return; } this.a.c(n); if (this.a.c == 0) { this.a = this.a.d ? null : this.a.b[0]; } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayList; /** * Implementation of a B-Tree, a self-balancing tree data structure that maintains sorted data * and allows searches, sequential access, insertions, and deletions in logarithmic time. * * B-Trees are generalizations of binary search trees in that a node can have more than two children. * They're widely used in databases and file systems. * * For more information: https://en.wikipedia.org/wiki/B-tree */ public class BTree { static class BTreeNode { int[] keys; int t; // Minimum degree (defines range for number of keys) BTreeNode[] children; int n; // Current number of keys boolean leaf; BTreeNode(int t, boolean leaf) { this.t = t; this.leaf = leaf; this.keys = new int[2 * t - 1]; this.children = new BTreeNode[2 * t]; this.n = 0; } void traverse(ArrayList<Integer> result) { for (int i = 0; i < n; i++) { if (!leaf) { children[i].traverse(result); } result.add(keys[i]); } if (!leaf) { children[n].traverse(result); } } BTreeNode search(int key) { int i = 0; while (i < n && key > keys[i]) { i++; } if (i < n && keys[i] == key) { return this; } if (leaf) { return null; } return children[i].search(key); } void insertNonFull(int key) { int i = n - 1; if (leaf) { while (i >= 0 && keys[i] > key) { keys[i + 1] = keys[i]; i--; } keys[i + 1] = key; n++; } else { while (i >= 0 && keys[i] > key) { i--; } if (children[i + 1].n == 2 * t - 1) { splitChild(i + 1, children[i + 1]); if (keys[i + 1] < key) { i++; } } children[i + 1].insertNonFull(key); } } void splitChild(int i, BTreeNode y) { BTreeNode z = new BTreeNode(y.t, y.leaf); z.n = t - 1; System.arraycopy(y.keys, t, z.keys, 0, t - 1); if (!y.leaf) { System.arraycopy(y.children, t, z.children, 0, t); } y.n = t - 1; for (int j = n; j >= i + 1; j--) { children[j + 1] = children[j]; } children[i + 1] = z; for (int j = n - 1; j >= i; j--) { keys[j + 1] = keys[j]; } keys[i] = y.keys[t - 1]; n++; } void remove(int key) { int idx = findKey(key); if (idx < n && keys[idx] == key) { if (leaf) { removeFromLeaf(idx); } else { removeFromNonLeaf(idx); } } else { if (leaf) { return; // Key not found } boolean flag = idx == n; if (children[idx].n < t) { fill(idx); } if (flag && idx > n) { children[idx - 1].remove(key); } else { children[idx].remove(key); } } } private int findKey(int key) { int idx = 0; while (idx < n && keys[idx] < key) { ++idx; } return idx; } private void removeFromLeaf(int idx) { for (int i = idx + 1; i < n; ++i) { keys[i - 1] = keys[i]; } n--; } private void removeFromNonLeaf(int idx) { int key = keys[idx]; if (children[idx].n >= t) { int pred = getPredecessor(idx); keys[idx] = pred; children[idx].remove(pred); } else if (children[idx + 1].n >= t) { int succ = getSuccessor(idx); keys[idx] = succ; children[idx + 1].remove(succ); } else { merge(idx); children[idx].remove(key); } } private int getPredecessor(int idx) { BTreeNode cur = children[idx]; while (!cur.leaf) { cur = cur.children[cur.n]; } return cur.keys[cur.n - 1]; } private int getSuccessor(int idx) { BTreeNode cur = children[idx + 1]; while (!cur.leaf) { cur = cur.children[0]; } return cur.keys[0]; } private void fill(int idx) { if (idx != 0 && children[idx - 1].n >= t) { borrowFromPrev(idx); } else if (idx != n && children[idx + 1].n >= t) { borrowFromNext(idx); } else { if (idx != n) { merge(idx); } else { merge(idx - 1); } } } private void borrowFromPrev(int idx) { BTreeNode child = children[idx]; BTreeNode sibling = children[idx - 1]; for (int i = child.n - 1; i >= 0; --i) { child.keys[i + 1] = child.keys[i]; } if (!child.leaf) { for (int i = child.n; i >= 0; --i) { child.children[i + 1] = child.children[i]; } } child.keys[0] = keys[idx - 1]; if (!child.leaf) { child.children[0] = sibling.children[sibling.n]; } keys[idx - 1] = sibling.keys[sibling.n - 1]; child.n += 1; sibling.n -= 1; } private void borrowFromNext(int idx) { BTreeNode child = children[idx]; BTreeNode sibling = children[idx + 1]; child.keys[child.n] = keys[idx]; if (!child.leaf) { child.children[child.n + 1] = sibling.children[0]; } keys[idx] = sibling.keys[0]; for (int i = 1; i < sibling.n; ++i) { sibling.keys[i - 1] = sibling.keys[i]; } if (!sibling.leaf) { for (int i = 1; i <= sibling.n; ++i) { sibling.children[i - 1] = sibling.children[i]; } } child.n += 1; sibling.n -= 1; } private void merge(int idx) { BTreeNode child = children[idx]; BTreeNode sibling = children[idx + 1]; child.keys[t - 1] = keys[idx]; for (int i = 0; i < sibling.n; ++i) { child.keys[i + t] = sibling.keys[i]; } if (!child.leaf) { for (int i = 0; i <= sibling.n; ++i) { child.children[i + t] = sibling.children[i]; } } for (int i = idx + 1; i < n; ++i) { keys[i - 1] = keys[i]; } for (int i = idx + 2; i <= n; ++i) { children[i - 1] = children[i]; } child.n += sibling.n + 1; n--; } } private BTreeNode root; private final int t; public BTree(int t) { this.root = null; this.t = t; } public void traverse(ArrayList<Integer> result) { if (root != null) { root.traverse(result); } } public boolean search(int key) { return root != null && root.search(key) != null; } public void insert(int key) { if (search(key)) { return; } if (root == null) { root = new BTreeNode(t, true); root.keys[0] = key; root.n = 1; } else { if (root.n == 2 * t - 1) { BTreeNode s = new BTreeNode(t, false); s.children[0] = root; s.splitChild(0, root); int i = 0; if (s.keys[0] < key) { i++; } s.children[i].insertNonFull(key); root = s; } else { root.insertNonFull(key); } } } public void delete(int key) { if (root == null) { return; } root.remove(key); if (root.n == 0) { root = root.leaf ? null : root.children[0]; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.util.HashMap; import java.util.Map; public class BaconianCipher { private static final Map a = new HashMap(); private static final Map b = new HashMap(); public String encrypt(String object) { StringBuilder stringBuilder = new StringBuilder(); object = ((String)object).toUpperCase().replaceAll(\"[^A-Z]\", \"\"); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object2 = object[i]; stringBuilder.append((String)a.get(Character.valueOf((char)object2))); } return stringBuilder.toString(); } public String decrypt(String string) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < string.length(); i += 5) { int n = i; String string2 = string.substring(n, n + 5); if (!b.containsKey(string2)) { throw new IllegalArgumentException(\"Invalid Baconian code: \" + string2); } stringBuilder.append(b.get(string2)); } return stringBuilder.toString(); } static { String[] stringArray = new String[]{\"AAAAA\", \"AAAAB\", \"AAABA\", \"AAABB\", \"AABAA\", \"AABAB\", \"AABBA\", \"AABBB\", \"ABAAA\", \"ABAAB\", \"ABABA\", \"ABABB\", \"ABBAA\", \"ABBAB\", \"ABBBA\", \"ABBBB\", \"BAAAA\", \"BAAAB\", \"BAABA\", \"BAABB\", \"BABAA\", \"BABAB\", \"BABBA\", \"BABBB\", \"BBAAA\", \"BBAAB\"}; char c = 'A'; int cfr_ignored_0 = stringArray.length; for (int i = 0; i < 26; ++i) { String string = stringArray[i]; a.put(Character.valueOf(c), string); b.put(string, Character.valueOf(c)); c = (char)(c + '\\u0001'); } a.put(Character.valueOf('I'), (String)a.get(Character.valueOf('J'))); b.put((String)a.get(Character.valueOf('I')), Character.valueOf('I')); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.util.HashMap; import java.util.Map; /** * The Baconian Cipher is a substitution cipher where each letter is represented * by a group of five binary digits (A's and B's). It can also be used to hide * messages within other texts, making it a simple form of steganography. * https://en.wikipedia.org/wiki/Bacon%27s_cipher * * @author Bennybebo */ public class BaconianCipher { private static final Map<Character, String> BACONIAN_MAP = new HashMap<>(); private static final Map<String, Character> REVERSE_BACONIAN_MAP = new HashMap<>(); static { // Initialize the Baconian cipher mappings String[] baconianAlphabet = {\"AAAAA\", \"AAAAB\", \"AAABA\", \"AAABB\", \"AABAA\", \"AABAB\", \"AABBA\", \"AABBB\", \"ABAAA\", \"ABAAB\", \"ABABA\", \"ABABB\", \"ABBAA\", \"ABBAB\", \"ABBBA\", \"ABBBB\", \"BAAAA\", \"BAAAB\", \"BAABA\", \"BAABB\", \"BABAA\", \"BABAB\", \"BABBA\", \"BABBB\", \"BBAAA\", \"BBAAB\"}; char letter = 'A'; for (String code : baconianAlphabet) { BACONIAN_MAP.put(letter, code); REVERSE_BACONIAN_MAP.put(code, letter); letter++; } // Handle I/J as the same letter BACONIAN_MAP.put('I', BACONIAN_MAP.get('J')); REVERSE_BACONIAN_MAP.put(BACONIAN_MAP.get('I'), 'I'); } /** * Encrypts the given plaintext using the Baconian cipher. * * @param plaintext The plaintext message to encrypt. * @return The ciphertext as a binary (A/B) sequence. */ public String encrypt(String plaintext) { StringBuilder ciphertext = new StringBuilder(); plaintext = plaintext.toUpperCase().replaceAll(\"[^A-Z]\", \"\"); // Remove non-letter characters for (char letter : plaintext.toCharArray()) { ciphertext.append(BACONIAN_MAP.get(letter)); } return ciphertext.toString(); } /** * Decrypts the given ciphertext encoded in binary (A/B) format using the Baconian cipher. * * @param ciphertext The ciphertext to decrypt. * @return The decrypted plaintext message. */ public String decrypt(String ciphertext) { StringBuilder plaintext = new StringBuilder(); for (int i = 0; i < ciphertext.length(); i += 5) { String code = ciphertext.substring(i, i + 5); if (REVERSE_BACONIAN_MAP.containsKey(code)) { plaintext.append(REVERSE_BACONIAN_MAP.get(code)); } else { throw new IllegalArgumentException(\"Invalid Baconian code: \" + code); } } return plaintext.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.bags; import com.thealgorithms.datastructures.bags.Bag$Node; import java.util.Iterator; import java.util.NoSuchElementException; class Bag$ListIterator implements Iterator { private Bag$Node a; Bag$ListIterator(Bag$Node node) { this.a = node; } @Override public boolean hasNext() { return this.a != null; } public Object next() { if (!this.hasNext()) { throw new NoSuchElementException(\"No more elements in the bag.\"); } Object object = this.a.a; this.a = this.a.b; return object; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.bags; import com.thealgorithms.datastructures.bags.Bag$Node; import java.util.Iterator; import java.util.NoSuchElementException; class Bag$ListIterator implements Iterator { private Bag$Node a; Bag$ListIterator(Bag$Node node) { this.a = node; } @Override public boolean hasNext() { return this.a != null; } public Object next() { if (!this.hasNext()) { throw new NoSuchElementException(\"No more elements in the bag.\"); } Object object = this.a.a; this.a = this.a.b; return object; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.bags; final class Bag$Node { private Object a; private Bag$Node b; private Bag$Node() { } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.bags; final class Bag$Node { private Object a; private Bag$Node b; private Bag$Node() { } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.bags; import com.thealgorithms.datastructures.bags.Bag$ListIterator; import com.thealgorithms.datastructures.bags.Bag$Node; import java.util.Iterator; public class Bag implements Iterable { private Bag$Node a = null; private int b = 0; public boolean isEmpty() { return this.b == 0; } public int size() { return this.b; } public void add(Object object) { Bag$Node bag$Node = new Bag$Node(); new Bag$Node().a = object; bag$Node.b = this.a; this.a = bag$Node; ++this.b; } public boolean contains(Object object) { for (Object e : this) { if (!e.equals(object)) continue; return true; } return false; } public Iterator iterator() { return new Bag$ListIterator(this.a); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.bags; import java.util.Iterator; import java.util.NoSuchElementException; /** * A generic collection that allows adding and iterating over elements but does not support * element removal. This class implements a simple bag data structure, which can hold duplicate * elements and provides operations to check for membership and the size of the collection. * * <p>Bag is not thread-safe and should not be accessed by multiple threads concurrently. * * @param <E> the type of elements in this bag */ public class Bag<E> implements Iterable<E> { private Node<E> firstElement; // Reference to the first element in the bag private int size; // Count of elements in the bag // Node class representing each element in the bag private static final class Node<E> { private E content; private Node<E> nextElement; } /** * Constructs an empty bag. * <p>This initializes the bag with zero elements. */ public Bag() { firstElement = null; size = 0; } /** * Checks if the bag is empty. * * @return {@code true} if the bag contains no elements; {@code false} otherwise */ public boolean isEmpty() { return size == 0; } /** * Returns the number of elements in the bag. * * @return the number of elements currently in the bag */ public int size() { return size; } /** * Adds an element to the bag. * * <p>This method adds the specified element to the bag. Duplicates are allowed, and the * bag will maintain the order in which elements are added. * * @param element the element to add; must not be {@code null} */ public void add(E element) { Node<E> newNode = new Node<>(); newNode.content = element; newNode.nextElement = firstElement; firstElement = newNode; size++; } /** * Checks if the bag contains a specific element. * * <p>This method uses the {@code equals} method of the element to determine membership. * * @param element the element to check for; must not be {@code null} * @return {@code true} if the bag contains the specified element; {@code false} otherwise */ public boolean contains(E element) { for (E value : this) { if (value.equals(element)) { return true; } } return false; } /** * Returns an iterator over the elements in this bag. * * <p>The iterator provides a way to traverse the elements in the order they were added. * * @return an iterator that iterates over the elements in the bag */ @Override public Iterator<E> iterator() { return new ListIterator<>(firstElement); } // Private class for iterating over elements private static class ListIterator<E> implements Iterator<E> { private Node<E> currentElement; /** * Constructs a ListIterator starting from the given first element. * * @param firstElement the first element of the bag to iterate over */ ListIterator(Node<E> firstElement) { this.currentElement = firstElement; } /** * Checks if there are more elements to iterate over. * * @return {@code true} if there are more elements; {@code false} otherwise */ @Override public boolean hasNext() { return currentElement != null; } /** * Returns the next element in the iteration. * * @return the next element in the bag * @throws NoSuchElementException if there are no more elements to return */ @Override public E next() { if (!hasNext()) { throw new NoSuchElementException(\"No more elements in the bag.\"); } E element = currentElement.content; currentElement = currentElement.nextElement; return element; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Stack; final class BalancedBrackets { private BalancedBrackets() { } public static boolean isPaired(char c, char c2) { char[][] cArrayArray = new char[][]{{'(', ')'}, {'[', ']'}, {'{', '}'}, {'<', '>'}}; char[][] cArrayArray2 = cArrayArray; cArrayArray2 = cArrayArray; int cfr_ignored_0 = cArrayArray.length; for (int i = 0; i < 4; ++i) { char[] cArray = cArrayArray2[i]; if (cArray[0] != c || cArray[1] != c2) continue; return true; } return false; } public static boolean isBalanced(String object) { if (object == null) { throw new IllegalArgumentException(\"brackets is null\"); } Stack<Character> stack = new Stack<Character>(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; block4: for (int i = 0; i < n; ++i) { Object object2 = object[i]; switch (object2) { case 40: case 60: case 91: case 123: { stack.push(Character.valueOf((char)object2)); continue block4; } case 41: case 62: case 93: case 125: { if (!stack.isEmpty() && BalancedBrackets.isPaired(((Character)stack.pop()).charValue(), (char)object2)) continue block4; return false; } default: { return false; } } } return stack.isEmpty(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; /** * The nested brackets problem is a problem that determines if a sequence of * brackets are properly nested. A sequence of brackets s is considered properly * nested if any of the following conditions are true: - s is empty - s has the * form (U) or [U] or {U} where U is a properly nested string - s has the form * VW where V and W are properly nested strings For example, the string * \"()()[()]\" is properly nested but \"[(()]\" is not. The function called * is_balanced takes as input a string S which is a sequence of brackets and * returns true if S is nested and false otherwise. * * @author akshay sharma * @author <a href=\"https://github.com/khalil2535\">khalil2535<a> * @author shellhub */ final class BalancedBrackets { private BalancedBrackets() { } /** * Check if {@code leftBracket} and {@code rightBracket} is paired or not * * @param leftBracket left bracket * @param rightBracket right bracket * @return {@code true} if {@code leftBracket} and {@code rightBracket} is * paired, otherwise {@code false} */ public static boolean isPaired(char leftBracket, char rightBracket) { char[][] pairedBrackets = { {'(', ')'}, {'[', ']'}, {'{', '}'}, {'<', '>'}, }; for (char[] pairedBracket : pairedBrackets) { if (pairedBracket[0] == leftBracket && pairedBracket[1] == rightBracket) { return true; } } return false; } /** * Check if {@code brackets} is balanced * * @param brackets the brackets * @return {@code true} if {@code brackets} is balanced, otherwise * {@code false} */ public static boolean isBalanced(String brackets) { if (brackets == null) { throw new IllegalArgumentException(\"brackets is null\"); } Stack<Character> bracketsStack = new Stack<>(); for (char bracket : brackets.toCharArray()) { switch (bracket) { case '(': case '[': case '<': case '{': bracketsStack.push(bracket); break; case ')': case ']': case '>': case '}': if (bracketsStack.isEmpty() || !isPaired(bracketsStack.pop(), bracket)) { return false; } break; default: return false; } } return bracketsStack.isEmpty(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.Arrays; public final class BandwidthAllocation { private BandwidthAllocation() { } public static int maxValue(int n, int[] nArray, int[] nArray2) { int n2; int n3 = nArray.length; double[][] dArray3 = new double[n3][2]; for (n2 = 0; n2 < n3; ++n2) { dArray3[n2][0] = n2; dArray3[n2][1] = (double)nArray2[n2] / (double)nArray[n2]; } Arrays.sort(dArray3, (dArray, dArray2) -> Double.compare(dArray2[1], dArray[1])); n2 = 0; for (int i = 0; i < n3; ++i) { int n4 = (int)dArray3[i][0]; if (n >= nArray[n4]) { n2 += nArray2[n4]; n -= nArray[n4]; continue; } n2 += (int)(dArray3[i][1] * (double)n); break; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.Arrays; /** * Class to solve the Bandwidth Allocation Problem. * The goal is to maximize the value gained by allocating bandwidth to users. * Example: * Bandwidth = 10 * Users = [3, 5, 7] * Values = [10, 20, 30] * The maximum value achievable is 40 by allocating 3 units to user 0 and 7 units to user 2. * * @author Hardvan */ public final class BandwidthAllocation { private BandwidthAllocation() { } /** * Allocates bandwidth to maximize value. * Steps: * 1. Calculate the ratio of value/demand for each user. * 2. Sort the users in descending order of the ratio. * 3. Allocate bandwidth to users in order of the sorted list. * 4. If the bandwidth is not enough to allocate the full demand of a user, allocate a fraction of the demand. * 5. Return the maximum value achievable. * * @param bandwidth total available bandwidth to allocate * @param users array of user demands * @param values array of values associated with each user's demand * @return the maximum value achievable */ public static int maxValue(int bandwidth, int[] users, int[] values) { int n = users.length; double[][] ratio = new double[n][2]; // {index, ratio} for (int i = 0; i < n; i++) { ratio[i][0] = i; ratio[i][1] = (double) values[i] / users[i]; } Arrays.sort(ratio, (a, b) -> Double.compare(b[1], a[1])); int maxValue = 0; for (int i = 0; i < n; i++) { int index = (int) ratio[i][0]; if (bandwidth >= users[index]) { maxValue += values[index]; bandwidth -= users[index]; } else { maxValue += (int) (ratio[i][1] * bandwidth); break; } } return maxValue; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Scanner; public final class BankersAlgorithm { private BankersAlgorithm() { } public static void main(String[] stringArray) { Scanner scanner; block13: { boolean bl; int n; int n2; scanner = new Scanner(System.in); System.out.println(\"Enter total number of processes\"); int n3 = scanner.nextInt(); System.out.println(\"Enter total number of resources\"); int n4 = scanner.nextInt(); int[] nArray = new int[n3]; int n5 = 0; while (n5 < n3) { int n6 = n5++; nArray[n6] = n6; } System.out.println(\"--Enter the availability of--\"); int[] nArray2 = new int[n4]; for (int i = 0; i < n4; ++i) { System.out.println(\"resource \" + i + \": \"); nArray2[i] = scanner.nextInt(); } System.out.println(\"--Enter the maximum matrix--\"); int[][] nArray3 = new int[n3][n4]; for (int i = 0; i < n3; ++i) { System.out.println(\"For process \" + i + \": \"); for (n2 = 0; n2 < n4; ++n2) { System.out.println(\"Enter the maximum instances of resource \" + n2); nArray3[i][n2] = scanner.nextInt(); } } System.out.println(\"--Enter the allocation matrix--\"); int[][] nArray4 = new int[n3][n4]; for (n2 = 0; n2 < n3; ++n2) { System.out.println(\"For process \" + n2 + \": \"); for (int i = 0; i < n4; ++i) { System.out.println(\"Allocated instances of resource \" + i); nArray4[n2][i] = scanner.nextInt(); } } int[][] nArray5 = nArray3; int n7 = n4; int n8 = n3; nArray3 = nArray4; Object object = nArray5; int[] nArray6 = nArray2; int[][] nArray7 = new int[n8][n7]; int n9 = n7; int n10 = n8; Object object2 = nArray3; Object object3 = object; object = nArray7; for (n = 0; n < n10; ++n) { for (int i = 0; i < n9; ++i) { object[n][i] = object3[n][i] - object2[n][i]; } } object = new boolean[n8]; object3 = new int[n8]; object2 = new int[n7]; System.arraycopy(nArray6, 0, object2, 0, n7); int n11 = 0; while (n11 < n8) { n10 = 0; for (n9 = 0; n9 < n8; ++n9) { if (object[n9] != false) continue; for (n = 0; n < n7 && nArray7[n9][n] <= object2[n]; ++n) { } if (n != n7) continue; for (n10 = 0; n10 < n7; ++n10) { int n12 = n10; object2[n12] = object2[n12] + nArray3[n9][n10]; } object3[n11++] = (int[])n9; object[n9] = (int[])true; n10 = 1; } if (n10 != 0) continue; System.out.print(\"The system is not in the safe state because lack of resources\"); bl = false; break block13; } System.out.print(\"The system is in safe sequence and the sequence is as follows: \"); for (n10 = 0; n10 < n8; ++n10) { System.out.print(\"P\" + (int)object3[n10] + \" \"); } bl = true; } scanner.close(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Scanner; /** * This file contains an implementation of BANKER'S ALGORITM Wikipedia: * https://en.wikipedia.org/wiki/Banker%27s_algorithm * * The algorithm for finding out whether or not a system is in a safe state can * be described as follows: 1. Let Work and Finish be vectors of length m and * n respectively. Initialize: Work= Available Finish [i]=false; for * i=1,2,,n 2. Find an i such that both a) Finish [i]=false b) Need_i<=work * * if no such i exists goto step (4) 3. Work=Work + Allocation_i Finish[i]= true * goto step(2) 4. If Finish[i]=true for all i, then the system is in safe * state. * * Time Complexity: O(n*n*m) Space Complexity: O(n*m) where n = number of * processes and m = number of resources. * * @author AMRITESH ANAND (https://github.com/amritesh19) */ public final class BankersAlgorithm { private BankersAlgorithm() { } /** * This method finds the need of each process */ static void calculateNeed(int[][] needArray, int[][] maxArray, int[][] allocationArray, int totalProcess, int totalResources) { for (int i = 0; i < totalProcess; i++) { for (int j = 0; j < totalResources; j++) { needArray[i][j] = maxArray[i][j] - allocationArray[i][j]; } } } /** * This method find the system is in safe state or not * * @param processes[] int array of processes (0...n-1), size = n * @param availableArray[] int array of number of instances of each * resource, size = m * @param maxArray[][] int matrix(2-D array) of maximum demand of each * process in a system, size = n*m * @param allocationArray[][] int matrix(2-D array) of the number of * resources of each type currently allocated to each process, size = n*m * @param totalProcess number of total processes, n * @param totalResources number of total resources, m * * @return boolean if the system is in safe state or not */ static boolean checkSafeSystem(int[] processes, int[] availableArray, int[][] maxArray, int[][] allocationArray, int totalProcess, int totalResources) { int[][] needArray = new int[totalProcess][totalResources]; calculateNeed(needArray, maxArray, allocationArray, totalProcess, totalResources); boolean[] finishProcesses = new boolean[totalProcess]; int[] safeSequenceArray = new int[totalProcess]; int[] workArray = new int[totalResources]; System.arraycopy(availableArray, 0, workArray, 0, totalResources); int count = 0; // While all processes are not finished or system is not in safe state. while (count < totalProcess) { boolean foundSafeSystem = false; for (int m = 0; m < totalProcess; m++) { if (!finishProcesses[m]) { int j; for (j = 0; j < totalResources; j++) { if (needArray[m][j] > workArray[j]) { break; } } if (j == totalResources) { for (int k = 0; k < totalResources; k++) { workArray[k] += allocationArray[m][k]; } safeSequenceArray[count++] = m; finishProcesses[m] = true; foundSafeSystem = true; } } } // If we could not find a next process in safe sequence. if (!foundSafeSystem) { System.out.print(\"The system is not in the safe state because lack of resources\"); return false; } } System.out.print(\"The system is in safe sequence and the sequence is as follows: \"); for (int i = 0; i < totalProcess; i++) { System.out.print(\"P\" + safeSequenceArray[i] + \" \"); } return true; } /** * This is main method of Banker's Algorithm */ public static void main(String[] args) { int numberOfProcesses; int numberOfResources; Scanner sc = new Scanner(System.in); System.out.println(\"Enter total number of processes\"); numberOfProcesses = sc.nextInt(); System.out.println(\"Enter total number of resources\"); numberOfResources = sc.nextInt(); int[] processes = new int[numberOfProcesses]; for (int i = 0; i < numberOfProcesses; i++) { processes[i] = i; } System.out.println(\"--Enter the availability of--\"); int[] availableArray = new int[numberOfResources]; for (int i = 0; i < numberOfResources; i++) { System.out.println(\"resource \" + i + \": \"); availableArray[i] = sc.nextInt(); } System.out.println(\"--Enter the maximum matrix--\"); int[][] maxArray = new int[numberOfProcesses][numberOfResources]; for (int i = 0; i < numberOfProcesses; i++) { System.out.println(\"For process \" + i + \": \"); for (int j = 0; j < numberOfResources; j++) { System.out.println(\"Enter the maximum instances of resource \" + j); maxArray[i][j] = sc.nextInt(); } } System.out.println(\"--Enter the allocation matrix--\"); int[][] allocationArray = new int[numberOfProcesses][numberOfResources]; for (int i = 0; i < numberOfProcesses; i++) { System.out.println(\"For process \" + i + \": \"); for (int j = 0; j < numberOfResources; j++) { System.out.println(\"Allocated instances of resource \" + j); allocationArray[i][j] = sc.nextInt(); } } checkSafeSystem(processes, availableArray, maxArray, allocationArray, numberOfProcesses, numberOfResources); sc.close(); } } /* Example: n = 5 m = 3 Process Allocation Max Available 0 1 2 0 1 2 0 1 2 0 0 1 0 7 5 3 3 3 2 1 2 0 0 3 2 2 2 3 0 2 9 0 2 3 2 1 1 2 2 2 4 0 0 2 4 3 3 Result: The system is in safe sequence and the sequence is as follows: P1, P3, P4, P0, P2 */"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers.a5; import java.util.BitSet; public interface BaseLFSR { public static final int SESSION_KEY_LENGTH = 64; public static final int FRAME_COUNTER_LENGTH = 22; public void initialize(BitSet var1, BitSet var2); public boolean clock(); }", "deobfuscated_code": "package com.thealgorithms.ciphers.a5; import java.util.BitSet; public interface BaseLFSR { void initialize(BitSet sessionKey, BitSet frameCounter); boolean clock(); int SESSION_KEY_LENGTH = 64; int FRAME_COUNTER_LENGTH = 22; }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class BcdConversion { private BcdConversion() { } public static int bcdToDecimal(int n) { int n2 = 0; int n3 = 1; while (n > 0) { int n4 = n & 0xF; if (n4 > 9) { throw new IllegalArgumentException(\"Invalid BCD digit: \" + n4); } n2 += n4 * n3; n3 *= 10; n >>= 4; } return n2; } public static int decimalToBcd(int n) { if (n < 0 || n > 9999) { throw new IllegalArgumentException(\"Value out of bounds for BCD representation: \" + n); } int n2 = 0; int n3 = 0; while (n > 0) { int n4 = n % 10; n2 |= n4 << (n3 << 2); n /= 10; ++n3; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class provides methods to convert between BCD (Binary-Coded Decimal) and decimal numbers. * * BCD is a class of binary encodings of decimal numbers where each decimal digit is represented by a fixed number of binary digits, usually four or eight. * * For more information, refer to the * <a href=\"https://en.wikipedia.org/wiki/Binary-coded_decimal\">Binary-Coded Decimal</a> Wikipedia page. * * <b>Example usage:</b> * <pre> * int decimal = BcdConversion.bcdToDecimal(0x1234); * System.out.println(\"BCD 0x1234 to decimal: \" + decimal); // Output: 1234 * * int bcd = BcdConversion.decimalToBcd(1234); * System.out.println(\"Decimal 1234 to BCD: \" + Integer.toHexString(bcd)); // Output: 0x1234 * </pre> */ public final class BcdConversion { private BcdConversion() { } /** * Converts a BCD (Binary-Coded Decimal) number to a decimal number. * <p>Steps: * <p>1. Validate the BCD number to ensure all digits are between 0 and 9. * <p>2. Extract the last 4 bits (one BCD digit) from the BCD number. * <p>3. Multiply the extracted digit by the corresponding power of 10 and add it to the decimal number. * <p>4. Shift the BCD number right by 4 bits to process the next BCD digit. * <p>5. Repeat steps 1-4 until the BCD number is zero. * * @param bcd The BCD number. * @return The corresponding decimal number. * @throws IllegalArgumentException if the BCD number contains invalid digits. */ public static int bcdToDecimal(int bcd) { int decimal = 0; int multiplier = 1; // Validate BCD digits while (bcd > 0) { int digit = bcd & 0xF; if (digit > 9) { throw new IllegalArgumentException(\"Invalid BCD digit: \" + digit); } decimal += digit * multiplier; multiplier *= 10; bcd >>= 4; } return decimal; } /** * Converts a decimal number to BCD (Binary-Coded Decimal). * <p>Steps: * <p>1. Check if the decimal number is within the valid range for BCD (0 to 9999). * <p>2. Extract the last decimal digit from the decimal number. * <p>3. Shift the digit to the correct BCD position and add it to the BCD number. * <p>4. Remove the last decimal digit from the decimal number. * <p>5. Repeat steps 2-4 until the decimal number is zero. * * @param decimal The decimal number. * @return The corresponding BCD number. * @throws IllegalArgumentException if the decimal number is greater than 9999. */ public static int decimalToBcd(int decimal) { if (decimal < 0 || decimal > 9999) { throw new IllegalArgumentException(\"Value out of bounds for BCD representation: \" + decimal); } int bcd = 0; int shift = 0; while (decimal > 0) { int digit = decimal % 10; bcd |= (digit << (shift * 4)); decimal /= 10; shift++; } return bcd; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; enum BeadSort$BeadState { BEAD, EMPTY; }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; enum BeadSort$BeadState { BEAD, EMPTY; }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.BeadSort$BeadState; import java.util.Arrays; public class BeadSort { public int[] sort(int[] nArray) { int n2; int n3; int n4; Object object = nArray; if (Arrays.stream(nArray).anyMatch(n -> n < 0)) { throw new IllegalArgumentException(\"BeadSort cannot sort negative numbers.\"); } object = this; int n5 = n4 = Arrays.stream(nArray).max().orElse(0); int n6 = nArray.length; Object object2 = new BeadSort$BeadState[n6][n5]; for (n3 = 0; n3 < n6; ++n3) { for (n2 = 0; n2 < n5; ++n2) { object2[n3][n2] = BeadSort$BeadState.EMPTY; } } BeadSort$BeadState[][] beadSort$BeadStateArray = object2; object2 = new int[n4]; n6 = nArray.length; for (n3 = 0; n3 < n6; ++n3) { n2 = 0; for (int i = 0; i < nArray[n3]; ++i) { int n7 = n4 - n2 - 1; BeadSort$BeadState[] beadSort$BeadStateArray2 = object2[n7]; object2[n7] = beadSort$BeadStateArray2 + true; beadSort$BeadStateArray[beadSort$BeadStateArray2][n2] = BeadSort$BeadState.BEAD; ++n2; } } BeadSort$BeadState[][] beadSort$BeadStateArray3 = beadSort$BeadStateArray; int[] nArray2 = new int[beadSort$BeadStateArray.length]; for (int i = 0; i < beadSort$BeadStateArray3.length; ++i) { int n8 = 0; for (n3 = 0; n3 < beadSort$BeadStateArray3[beadSort$BeadStateArray3.length - 1 - i].length && beadSort$BeadStateArray3[beadSort$BeadStateArray3.length - 1 - i][n3] == BeadSort$BeadState.BEAD; ++n3) { ++n8; } nArray2[i] = n8; } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.Arrays; public class BeadSort { private enum BeadState { BEAD, EMPTY } /** * Sorts the given array using the BeadSort algorithm. * * @param array The array of non-negative integers to be sorted. * @return The sorted array. * @throws IllegalArgumentException If the array contains negative numbers. */ public int[] sort(int[] array) { allInputsMustBeNonNegative(array); return extractSortedFromGrid(fillGrid(array)); } private void allInputsMustBeNonNegative(final int[] array) { if (Arrays.stream(array).anyMatch(s -> s < 0)) { throw new IllegalArgumentException(\"BeadSort cannot sort negative numbers.\"); } } private BeadState[][] fillGrid(final int[] array) { final var maxValue = Arrays.stream(array).max().orElse(0); var grid = getEmptyGrid(array.length, maxValue); int[] count = new int[maxValue]; for (int i = 0, arrayLength = array.length; i < arrayLength; i++) { int k = 0; for (int j = 0; j < array[i]; j++) { grid[count[maxValue - k - 1]++][k] = BeadState.BEAD; k++; } } return grid; } private BeadState[][] getEmptyGrid(final int arrayLength, final int maxValue) { BeadState[][] grid = new BeadState[arrayLength][maxValue]; for (int i = 0; i < arrayLength; i++) { for (int j = 0; j < maxValue; j++) { grid[i][j] = BeadState.EMPTY; } } return grid; } private int[] extractSortedFromGrid(final BeadState[][] grid) { int[] sorted = new int[grid.length]; for (int i = 0; i < grid.length; i++) { int k = 0; for (int j = 0; j < grid[grid.length - 1 - i].length && grid[grid.length - 1 - i][j] == BeadState.BEAD; j++) { k++; } sorted[i] = k; } return sorted; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class BellmanFord$Edge { int a; int b; int c; BellmanFord$Edge(int n, int n2, int n3) { this.a = n; this.b = n2; this.c = n3; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class BellmanFord$Edge { int a; int b; int c; BellmanFord$Edge(int n, int n2, int n3) { this.a = n; this.b = n2; this.c = n3; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.BellmanFord$Edge; import java.util.Scanner; class BellmanFord { private int a = 0; private int b = 0; private BellmanFord$Edge[] c = new BellmanFord$Edge[0]; private int d = 0; private BellmanFord(int n, int n2) { } private void a(int[] nArray, int n) { if (nArray[n] == -1) { return; } this.a(nArray, nArray[n]); System.out.print(n + \" \"); } public static void main(String[] object) { object = new BellmanFord(0, 0); object.go(); } public void go() { try (Scanner scanner = new Scanner(System.in);){ int n; int n2; boolean bl = false; System.out.println(\"Enter no. of vertices and edges please\"); int n3 = scanner.nextInt(); int n4 = scanner.nextInt(); BellmanFord$Edge[] bellmanFord$EdgeArray = new BellmanFord$Edge[n4]; System.out.println(\"Input edges\"); for (n2 = 0; n2 < n4; ++n2) { n = scanner.nextInt(); int n5 = scanner.nextInt(); int n6 = scanner.nextInt(); bellmanFord$EdgeArray[n2] = new BellmanFord$Edge(n, n5, n6); } int[] nArray = new int[n3]; int[] nArray2 = new int[n3]; for (n2 = 0; n2 < n3; ++n2) { nArray[n2] = Integer.MAX_VALUE; } nArray[0] = 0; nArray2[0] = -1; for (n2 = 0; n2 < n3 - 1; ++n2) { for (n = 0; n < n4; ++n) { if (nArray[bellmanFord$EdgeArray[n].a] == Integer.MAX_VALUE || nArray[bellmanFord$EdgeArray[n].b] <= nArray[bellmanFord$EdgeArray[n].a] + bellmanFord$EdgeArray[n].c) continue; nArray[bellmanFord$EdgeArray[n].b] = nArray[bellmanFord$EdgeArray[n].a] + bellmanFord$EdgeArray[n].c; nArray2[bellmanFord$EdgeArray[n].b] = bellmanFord$EdgeArray[n].a; } } for (n = 0; n < n4; ++n) { if (nArray[bellmanFord$EdgeArray[n].a] == Integer.MAX_VALUE || nArray[bellmanFord$EdgeArray[n].b] <= nArray[bellmanFord$EdgeArray[n].a] + bellmanFord$EdgeArray[n].c) continue; bl = true; System.out.println(\"Negative cycle\"); break; } if (!bl) { System.out.println(\"Distances are: \"); for (n2 = 0; n2 < n3; ++n2) { System.out.println(n2 + \" \" + nArray[n2]); } System.out.println(\"Path followed:\"); for (n2 = 0; n2 < n3; ++n2) { System.out.print(\"0 \"); this.a(nArray2, n2); System.out.println(); } } return; } } public void show(int n, int n2, BellmanFord$Edge[] bellmanFord$EdgeArray) { int n3; int n4; int n5 = this.a; int n6 = this.b; boolean bl = false; double[] dArray = new double[n5]; int[] nArray = new int[n5]; for (n4 = 0; n4 < n5; ++n4) { dArray[n4] = 2.147483647E9; } dArray[n] = 0.0; nArray[n] = -1; for (n4 = 0; n4 < n5 - 1; ++n4) { for (n3 = 0; n3 < n6; ++n3) { if ((int)dArray[bellmanFord$EdgeArray[n3].a] == Integer.MAX_VALUE || !(dArray[bellmanFord$EdgeArray[n3].b] > dArray[bellmanFord$EdgeArray[n3].a] + (double)bellmanFord$EdgeArray[n3].c)) continue; dArray[bellmanFord$EdgeArray[n3].b] = dArray[bellmanFord$EdgeArray[n3].a] + (double)bellmanFord$EdgeArray[n3].c; nArray[bellmanFord$EdgeArray[n3].b] = bellmanFord$EdgeArray[n3].a; } } for (n3 = 0; n3 < n6; ++n3) { if ((int)dArray[bellmanFord$EdgeArray[n3].a] == Integer.MAX_VALUE || !(dArray[bellmanFord$EdgeArray[n3].b] > dArray[bellmanFord$EdgeArray[n3].a] + (double)bellmanFord$EdgeArray[n3].c)) continue; bl = true; System.out.println(\"Negative cycle\"); break; } if (!bl) { System.out.println(\"Distance is: \" + dArray[n2]); System.out.println(\"Path followed:\"); System.out.print(n + \" \"); this.a(nArray, n2); System.out.println(); } } public void addEdge(int n, int n2, int n3) { this.c[this.d++] = new BellmanFord$Edge(n, n2, n3); } public BellmanFord$Edge[] getEdgeArray() { return this.c; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.Scanner; class BellmanFord /* * Implementation of Bellman ford to detect negative cycles. Graph accepts * inputs * in form of edges which have start vertex, end vertex and weights. Vertices * should be labelled with a * number between 0 and total number of vertices-1,both inclusive */ { int vertex; int edge; private Edge[] edges; private int index = 0; BellmanFord(int v, int e) { vertex = v; edge = e; edges = new Edge[e]; } class Edge { int u; int v; int w; /** * @param u Source Vertex * @param v End vertex * @param c Weight */ Edge(int a, int b, int c) { u = a; v = b; w = c; } } /** * @param p[] Parent array which shows updates in edges * @param i Current vertex under consideration */ void printPath(int[] p, int i) { if (p[i] == -1) { // Found the path back to parent return; } printPath(p, p[i]); System.out.print(i + \" \"); } public static void main(String[] args) { BellmanFord obj = new BellmanFord(0, 0); // Dummy object to call nonstatic variables obj.go(); } public void go() { // shows distance to all vertices // Interactive run for understanding the // class first time. Assumes source vertex is 0 and try (Scanner sc = new Scanner(System.in)) { int i; int v; int e; int u; int ve; int w; int j; int neg = 0; System.out.println(\"Enter no. of vertices and edges please\"); v = sc.nextInt(); e = sc.nextInt(); Edge[] arr = new Edge[e]; // Array of edges System.out.println(\"Input edges\"); for (i = 0; i < e; i++) { u = sc.nextInt(); ve = sc.nextInt(); w = sc.nextInt(); arr[i] = new Edge(u, ve, w); } int[] dist = new int[v]; // Distance array for holding the finalized shortest path distance // between source // and all vertices int[] p = new int[v]; // Parent array for holding the paths for (i = 0; i < v; i++) { dist[i] = Integer.MAX_VALUE; // Initializing distance values } dist[0] = 0; p[0] = -1; for (i = 0; i < v - 1; i++) { for (j = 0; j < e; j++) { if (dist[arr[j].u] != Integer.MAX_VALUE && dist[arr[j].v] > dist[arr[j].u] + arr[j].w) { dist[arr[j].v] = dist[arr[j].u] + arr[j].w; // Update p[arr[j].v] = arr[j].u; } } } // Final cycle for negative checking for (j = 0; j < e; j++) { if (dist[arr[j].u] != Integer.MAX_VALUE && dist[arr[j].v] > dist[arr[j].u] + arr[j].w) { neg = 1; System.out.println(\"Negative cycle\"); break; } } if (neg == 0) { // Go ahead and show results of computation System.out.println(\"Distances are: \"); for (i = 0; i < v; i++) { System.out.println(i + \" \" + dist[i]); } System.out.println(\"Path followed:\"); for (i = 0; i < v; i++) { System.out.print(\"0 \"); printPath(p, i); System.out.println(); } } } } /** * @param source Starting vertex * @param end Ending vertex * @param Edge Array of edges */ public void show(int source, int end, Edge[] arr) { // be created by using addEdge() method and passed by calling getEdgeArray() // method // Just shows results of computation, if graph is passed to it. The // graph should int i; int j; int v = vertex; int e = edge; int neg = 0; double[] dist = new double[v]; // Distance array for holding the finalized shortest path // distance between source // and all vertices int[] p = new int[v]; // Parent array for holding the paths for (i = 0; i < v; i++) { dist[i] = Integer.MAX_VALUE; // Initializing distance values } dist[source] = 0; p[source] = -1; for (i = 0; i < v - 1; i++) { for (j = 0; j < e; j++) { if ((int) dist[arr[j].u] != Integer.MAX_VALUE && dist[arr[j].v] > dist[arr[j].u] + arr[j].w) { dist[arr[j].v] = dist[arr[j].u] + arr[j].w; // Update p[arr[j].v] = arr[j].u; } } } // Final cycle for negative checking for (j = 0; j < e; j++) { if ((int) dist[arr[j].u] != Integer.MAX_VALUE && dist[arr[j].v] > dist[arr[j].u] + arr[j].w) { neg = 1; System.out.println(\"Negative cycle\"); break; } } if (neg == 0) { // Go ahead and show results of computaion System.out.println(\"Distance is: \" + dist[end]); System.out.println(\"Path followed:\"); System.out.print(source + \" \"); printPath(p, end); System.out.println(); } } /** * @param x Source Vertex * @param y End vertex * @param z Weight */ public void addEdge(int x, int y, int z) { // Adds unidirectional edge edges[index++] = new Edge(x, y, z); } public Edge[] getEdgeArray() { return edges; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.MemoryManagementAlgorithms; import java.util.ArrayList; class BestFitCPU extends MemoryManagementAlgorithms { BestFitCPU() { } @Override public ArrayList fitProcess(int[] nArray, int[] nArray2) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); int n = nArray2.length; for (int i = 0; i < n; ++i) { int n2; int n3 = n2 = nArray2[i]; int[] nArray3 = nArray; int[] nArray4 = nArray; int n4 = -1; int n5 = nArray4.length; for (int j = 0; j < n5; ++j) { int n6 = nArray4[j]; if (n6 <= n4) continue; n4 = n6; } int n7 = n4; n4 = -255; for (n5 = 0; n5 < nArray3.length; ++n5) { if (nArray3[n5] - n3 >= n7 || nArray3[n5] - n3 < 0) continue; n7 = nArray3[n5] - n3; n4 = n5; } int n8 = n4; arrayList.add(n8); if (n8 == -255) continue; int n9 = n8; nArray[n9] = nArray[n9] - n2; } return arrayList; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.MemoryManagementAlgorithms; import java.util.ArrayList; class BestFitCPU extends MemoryManagementAlgorithms { BestFitCPU() { } @Override public ArrayList fitProcess(int[] nArray, int[] nArray2) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); int n = nArray2.length; for (int i = 0; i < n; ++i) { int n2; int n3 = n2 = nArray2[i]; int[] nArray3 = nArray; int[] nArray4 = nArray; int n4 = -1; int n5 = nArray4.length; for (int j = 0; j < n5; ++j) { int n6 = nArray4[j]; if (n6 <= n4) continue; n4 = n6; } int n7 = n4; n4 = -255; for (n5 = 0; n5 < nArray3.length; ++n5) { if (nArray3[n5] - n3 >= n7 || nArray3[n5] - n3 < 0) continue; n7 = nArray3[n5] - n3; n4 = n5; } int n8 = n4; arrayList.add(n8); if (n8 == -255) continue; int n9 = n8; nArray[n9] = nArray[n9] - n2; } return arrayList; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.Collections; public class BinaryAddition { public char sum(char c, char c2, char c3) { int n = 0; if (c == '1') { ++n; } if (c2 == '1') { ++n; } if (c3 == '1') { ++n; } if (n % 2 == 0) { return '0'; } return '1'; } public char carry(char c, char c2, char c3) { int n = 0; if (c == '1') { ++n; } if (c2 == '1') { ++n; } if (c3 == '1') { ++n; } if (n >= 2) { return '1'; } return '0'; } public String addBinary(String object, String object2) { int n = Math.max(((String)object).length(), ((String)object2).length()); object = String.join((CharSequence)\"\", Collections.nCopies(n - ((String)object).length(), \"0\")) + (String)object; object2 = String.join((CharSequence)\"\", Collections.nCopies(n - ((String)object2).length(), \"0\")) + (String)object2; StringBuilder stringBuilder = new StringBuilder(); char c = '0'; --n; while (n >= 0) { char c2 = this.sum(((String)object).charAt(n), ((String)object2).charAt(n), c); c = this.carry(((String)object).charAt(n), ((String)object2).charAt(n), c); stringBuilder.append(c2); --n; } if (c == '1') { stringBuilder.append('1'); } return stringBuilder.reverse().toString(); } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.Collections; /** * BinaryAddition class to perform binary addition of two binary strings. */ public class BinaryAddition { /** * Computes the sum of two binary characters and a carry. * @param a First binary character ('0' or '1'). * @param b Second binary character ('0' or '1'). * @param carry The carry from the previous operation ('0' or '1'). * @return The sum as a binary character ('0' or '1'). */ public char sum(char a, char b, char carry) { int count = 0; if (a == '1') { count++; } if (b == '1') { count++; } if (carry == '1') { count++; } return count % 2 == 0 ? '0' : '1'; } /** * Computes the carry for the next higher bit from two binary characters and a carry. * @param a First binary character ('0' or '1'). * @param b Second binary character ('0' or '1'). * @param carry The carry from the previous operation ('0' or '1'). * @return The carry for the next bit ('0' or '1'). */ public char carry(char a, char b, char carry) { int count = 0; if (a == '1') { count++; } if (b == '1') { count++; } if (carry == '1') { count++; } return count >= 2 ? '1' : '0'; } /** * Adds two binary strings and returns their sum as a binary string. * @param a First binary string. * @param b Second binary string. * @return Binary string representing the sum of the two binary inputs. */ public String addBinary(String a, String b) { // Padding the shorter string with leading zeros int maxLength = Math.max(a.length(), b.length()); a = String.join(\"\", Collections.nCopies(maxLength - a.length(), \"0\")) + a; b = String.join(\"\", Collections.nCopies(maxLength - b.length(), \"0\")) + b; StringBuilder result = new StringBuilder(); char carry = '0'; // Iterating over the binary strings from the least significant to the most significant bit for (int i = maxLength - 1; i >= 0; i--) { char sum = sum(a.charAt(i), b.charAt(i), carry); carry = carry(a.charAt(i), b.charAt(i), carry); result.append(sum); } // If there's a remaining carry, append it if (carry == '1') { result.append('1'); } // Reverse the result as we constructed it from the least significant bit return result.reverse().toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; public class BinaryExponentiation { public static long calculatePower(long l, long l2) { while (l2 != 0L) { if (l2 % 2L == 1L) { long l3 = l; return l3 * BinaryExponentiation.calculatePower(l3, l2 - 1L); } long l4 = l; l2 /= 2L; l = l4 * l4; } return 1L; } }", "deobfuscated_code": "package com.thealgorithms.divideandconquer; // Java Program to Implement Binary Exponentiation (power in log n) // Reference Link: https://en.wikipedia.org/wiki/Exponentiation_by_squaring /* * Binary Exponentiation is a method to calculate a to the power of b. * It is used to calculate a^n in O(log n) time. * * Reference: * https://iq.opengenus.org/binary-exponentiation/ */ public class BinaryExponentiation { // recursive function to calculate a to the power of b public static long calculatePower(long x, long y) { // Base Case if (y == 0) { return 1; } if (y % 2 == 1) { // odd power return x * calculatePower(x, y - 1); } return calculatePower(x * x, y / 2); // even power } // iterative function to calculate a to the power of b long power(long n, long m) { long power = n; long sum = 1; while (m > 0) { if ((m & 1) == 1) { sum *= power; } power = power * power; m = m >> 1; } return sum; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class BinaryInsertionSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { for (int i = 1; i < comparableArray.length; ++i) { int n; Comparable comparable = comparableArray[i]; int n2 = 0; int n3 = i - 1; while (n2 <= n3) { n = n2 + n3 >>> 1; if (SortUtils.less(comparable, comparableArray[n])) { n3 = n - 1; continue; } n2 = n + 1; } for (n = i; n >= n2 + 1; --n) { comparableArray[n] = comparableArray[n - 1]; } comparableArray[n2] = comparable; } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * BinaryInsertionSort class implements the SortAlgorithm interface using the binary insertion sort technique. * Binary Insertion Sort improves upon the simple insertion sort by using binary search to find the appropriate * location to insert the new element, reducing the number of comparisons in the insertion step. */ public class BinaryInsertionSort implements SortAlgorithm { /** * Sorts the given array using the Binary Insertion Sort algorithm. * * @param <T> the type of elements in the array, which must implement the Comparable interface * @param array the array to be sorted * @return the sorted array */ public <T extends Comparable<T>> T[] sort(T[] array) { for (int i = 1; i < array.length; i++) { final T temp = array[i]; int low = 0; int high = i - 1; while (low <= high) { final int mid = (low + high) >>> 1; if (SortUtils.less(temp, array[mid])) { high = mid - 1; } else { low = mid + 1; } } for (int j = i; j >= low + 1; j--) { array[j] = array[j - 1]; } array[low] = temp; } return array; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class BinaryPalindromeCheck { private BinaryPalindromeCheck() { } public static boolean isBinaryPalindrome(int n) { int n2; int n3 = 0; for (n2 = n; n2 > 0; n2 >>= 1) { n3 <<= 1; n3 |= n2 & 1; } n2 = n3; return n == n2; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class contains a method to check if the binary representation of a number is a palindrome. * <p> * A binary palindrome is a number whose binary representation is the same when read from left to right and right to left. * For example, the number 9 has a binary representation of 1001, which is a palindrome. * The number 10 has a binary representation of 1010, which is not a palindrome. * </p> * * @author Hardvan */ public final class BinaryPalindromeCheck { private BinaryPalindromeCheck() { } /** * Checks if the binary representation of a number is a palindrome. * * @param x The number to check. * @return True if the binary representation is a palindrome, otherwise false. */ public static boolean isBinaryPalindrome(int x) { int reversed = reverseBits(x); return x == reversed; } /** * Helper function to reverse all the bits of an integer. * * @param x The number to reverse the bits of. * @return The number with reversed bits. */ private static int reverseBits(int x) { int result = 0; while (x > 0) { result <<= 1; result |= (x & 1); x >>= 1; } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class BinaryPow { private BinaryPow() { } public static int binPow(int n, int n2) { int n3 = 1; while (n2 > 0) { if ((n2 & 1) == 1) { n3 *= n; } int n4 = n; n = n4 * n4; n2 >>>= 1; } return n3; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class BinaryPow { private BinaryPow() { } /** * Calculate a^p using binary exponentiation * [Binary-Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html) * * @param a the base for exponentiation * @param p the exponent - must be greater than 0 * @return a^p */ public static int binPow(int a, int p) { int res = 1; while (p > 0) { if ((p & 1) == 1) { res = res * a; } a = a * a; p >>>= 1; } return res; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; class BinarySearch implements SearchAlgorithm { BinarySearch() { } @Override public int find(Comparable[] comparableArray, Comparable comparable) { return this.a(comparableArray, comparable, 0, comparableArray.length - 1); } private int a(Comparable[] comparableArray, Comparable comparable, int n, int n2) { while (n2 >= n) { int n3 = n + n2 >>> 1; int n4 = comparable.compareTo(comparableArray[n3]); if (n4 == 0) { return n3; } if (n4 < 0) { n2 = n3 - 1; continue; } n = n3 + 1; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; /** * Binary search is one of the most popular algorithms The algorithm finds the * position of a target value within a sorted array * * <p> * Worst-case performance O(log n) Best-case performance O(1) Average * performance O(log n) Worst-case space complexity O(1) * * @author Varun Upadhyay (https://github.com/varunu28) * @author Podshivalov Nikita (https://github.com/nikitap492) * @see SearchAlgorithm * @see IterativeBinarySearch */ class BinarySearch implements SearchAlgorithm { /** * @param array is an array where the element should be found * @param key is an element which should be found * @param <T> is any comparable type * @return index of the element */ @Override public <T extends Comparable<T>> int find(T[] array, T key) { return search(array, key, 0, array.length - 1); } /** * This method implements the Generic Binary Search * * @param array The array to make the binary search * @param key The number you are looking for * @param left The lower bound * @param right The upper bound * @return the location of the key */ private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) { if (right < left) { return -1; // this means that the key not found } // find median int median = (left + right) >>> 1; int comp = key.compareTo(array[median]); if (comp == 0) { return median; } else if (comp < 0) { return search(array, key, left, median - 1); } else { return search(array, key, median + 1, right); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; public final class BinarySearch2dArray { private BinarySearch2dArray() { } }", "deobfuscated_code": "package com.thealgorithms.searches; /** * This class provides a method to search for a target value in a 2D sorted * array. * The search is performed using a combination of binary search on rows and * columns. * The 2D array must be strictly sorted in both rows and columns. * * The algorithm works by: * 1. Performing a binary search on the middle column of the 2D array. * 2. Depending on the value found, it eliminates rows above or below the middle * element. * 3. After finding or eliminating rows, it further applies binary search in the * relevant columns. */ public final class BinarySearch2dArray { private BinarySearch2dArray() { } /** * Performs a binary search on a 2D sorted array to find the target value. * The array must be sorted in ascending order in both rows and columns. * * @param arr The 2D array to search in. * @param target The value to search for. * @return An array containing the row and column indices of the target, or [-1, * -1] if the target is not found. */ static int[] binarySearch(int[][] arr, int target) { int rowCount = arr.length; int colCount = arr[0].length; // Edge case: If there's only one row, search that row directly. if (rowCount == 1) { return binarySearch(arr, target, 0, 0, colCount); } // Set initial boundaries for binary search on rows. int startRow = 0; int endRow = rowCount - 1; int midCol = colCount / 2; // Middle column index for comparison. // Perform binary search on rows based on the middle column. while (startRow < endRow - 1) { int midRow = startRow + (endRow - startRow) / 2; // If the middle element matches the target, return its position. if (arr[midRow][midCol] == target) { return new int[] {midRow, midCol}; } // If the middle element is smaller than the target, discard the upper half. else if (arr[midRow][midCol] < target) { startRow = midRow; } // If the middle element is larger than the target, discard the lower half. else { endRow = midRow; } } // If the target wasn't found during the row search, check the middle column of // startRow and endRow. if (arr[startRow][midCol] == target) { return new int[] {startRow, midCol}; } if (arr[endRow][midCol] == target) { return new int[] {endRow, midCol}; } // If target is smaller than the element in the left of startRow, perform a // binary search on the left of startRow. if (target <= arr[startRow][midCol - 1]) { return binarySearch(arr, target, startRow, 0, midCol - 1); } // If target is between midCol and the last column of startRow, perform a binary // search on that part of the row. if (target >= arr[startRow][midCol + 1] && target <= arr[startRow][colCount - 1]) { return binarySearch(arr, target, startRow, midCol + 1, colCount - 1); } // If target is smaller than the element in the left of endRow, perform a binary // search on the left of endRow. if (target <= arr[endRow][midCol - 1]) { return binarySearch(arr, target, endRow, 0, midCol - 1); } else { // Otherwise, search on the right of endRow. return binarySearch(arr, target, endRow, midCol + 1, colCount - 1); } } /** * Performs a binary search on a specific row of the 2D array. * * @param arr The 2D array to search in. * @param target The value to search for. * @param row The row index where the target will be searched. * @param colStart The starting column index for the search. * @param colEnd The ending column index for the search. * @return An array containing the row and column indices of the target, or [-1, * -1] if the target is not found. */ static int[] binarySearch(int[][] arr, int target, int row, int colStart, int colEnd) { // Perform binary search within the specified column range. while (colStart <= colEnd) { int midIndex = colStart + (colEnd - colStart) / 2; // If the middle element matches the target, return its position. if (arr[row][midIndex] == target) { return new int[] {row, midIndex}; } // If the middle element is smaller than the target, move to the right half. else if (arr[row][midIndex] < target) { colStart = midIndex + 1; } // If the middle element is larger than the target, move to the left half. else { colEnd = midIndex - 1; } } return new int[] {-1, -1}; // Target not found } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; final class BinaryToDecimal { private BinaryToDecimal() { } public static long binaryToDecimal(long l) { long l2 = 0L; long l3 = 0L; while (l != 0L) { long l4 = l % 10L; if (l4 > 1L) { throw new IllegalArgumentException(\"Incorrect binary digit: \" + l4); } l2 += (long)((double)l4 * Math.pow(2.0, l3++)); l /= 10L; } return l2; } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * This class converts a Binary number to a Decimal number */ final class BinaryToDecimal { private static final int BINARY_BASE = 2; private BinaryToDecimal() { } /** * Converts a binary number to its decimal equivalent. * * @param binaryNumber The binary number to convert. * @return The decimal equivalent of the binary number. * @throws IllegalArgumentException If the binary number contains digits other than 0 and 1. */ public static long binaryToDecimal(long binaryNumber) { long decimalValue = 0; long power = 0; while (binaryNumber != 0) { long digit = binaryNumber % 10; if (digit > 1) { throw new IllegalArgumentException(\"Incorrect binary digit: \" + digit); } decimalValue += (long) (digit * Math.pow(BINARY_BASE, power++)); binaryNumber /= 10; } return decimalValue; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.util.HashMap; public final class BinaryToHexadecimal { private BinaryToHexadecimal() { } public static String binToHex(int n) { int n2; HashMap<Integer, String> hashMap = new HashMap<Integer, String>(); for (n2 = 0; n2 < 10; ++n2) { hashMap.put(n2, String.valueOf(n2)); } for (n2 = 10; n2 <= 15; ++n2) { hashMap.put(n2, String.valueOf((char)(n2 + 65 - 10))); } StringBuilder stringBuilder = new StringBuilder(); while (n != 0) { int n3 = 0; for (int i = 0; i < 4; ++i) { int n4 = n % 10; if (n4 > 1) { throw new IllegalArgumentException(\"Incorrect binary digit: \" + n4); } n /= 10; n3 += (int)((double)n4 * Math.pow(2.0, i)); } stringBuilder.insert(0, (String)hashMap.get(n3)); } if (!stringBuilder.isEmpty()) { return stringBuilder.toString(); } return \"0\"; } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.util.HashMap; import java.util.Map; /** * Converts any Binary Number to a Hexadecimal Number * * @author Nishita Aggarwal */ public final class BinaryToHexadecimal { private static final int BITS_IN_HEX_DIGIT = 4; private static final int BASE_BINARY = 2; private static final int BASE_DECIMAL = 10; private static final int HEX_START_DECIMAL = 10; private static final int HEX_END_DECIMAL = 15; private BinaryToHexadecimal() { } /** * Converts a binary number to a hexadecimal number. * * @param binary The binary number to convert. * @return The hexadecimal representation of the binary number. * @throws IllegalArgumentException If the binary number contains digits other than 0 and 1. */ public static String binToHex(int binary) { Map<Integer, String> hexMap = initializeHexMap(); StringBuilder hex = new StringBuilder(); while (binary != 0) { int decimalValue = 0; for (int i = 0; i < BITS_IN_HEX_DIGIT; i++) { int currentBit = binary % BASE_DECIMAL; if (currentBit > 1) { throw new IllegalArgumentException(\"Incorrect binary digit: \" + currentBit); } binary /= BASE_DECIMAL; decimalValue += (int) (currentBit * Math.pow(BASE_BINARY, i)); } hex.insert(0, hexMap.get(decimalValue)); } return !hex.isEmpty() ? hex.toString() : \"0\"; } /** * Initializes the hexadecimal map with decimal to hexadecimal mappings. * * @return The initialized map containing mappings from decimal numbers to hexadecimal digits. */ private static Map<Integer, String> initializeHexMap() { Map<Integer, String> hexMap = new HashMap<>(); for (int i = 0; i < BASE_DECIMAL; i++) { hexMap.put(i, String.valueOf(i)); } for (int i = HEX_START_DECIMAL; i <= HEX_END_DECIMAL; i++) { hexMap.put(i, String.valueOf((char) ('A' + i - HEX_START_DECIMAL))); } return hexMap; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class BinaryToOctal { private BinaryToOctal() { } public static String convertBinaryToOctal(int n) { if (n == 0) { return \"0\"; } if (!String.valueOf(n).matches(\"[01]+\")) { throw new IllegalArgumentException(\"Input is not a valid binary number.\"); } StringBuilder stringBuilder = new StringBuilder(); int n2 = 1; while (n != 0) { int n3 = 0; for (int i = 0; i < 3 && n != 0; ++i) { int n4 = n % 10; n /= 10; n3 += n4 * n2; n2 <<= 1; } stringBuilder.insert(0, n3); n2 = 1; } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.conversions; public final class BinaryToOctal { private static final int BITS_PER_OCTAL_DIGIT = 3; private static final int BINARY_BASE = 2; private static final int DECIMAL_BASE = 10; private BinaryToOctal() { } /** * This method converts a binary number to an octal number. * * @param binary The binary number * @return The octal number * @throws IllegalArgumentException if the input is not a valid binary number */ public static String convertBinaryToOctal(int binary) { if (binary == 0) { return \"0\"; } if (!String.valueOf(binary).matches(\"[01]+\")) { throw new IllegalArgumentException(\"Input is not a valid binary number.\"); } StringBuilder octal = new StringBuilder(); int currentBit; int bitValueMultiplier = 1; while (binary != 0) { int octalDigit = 0; for (int i = 0; i < BITS_PER_OCTAL_DIGIT && binary != 0; i++) { currentBit = binary % DECIMAL_BASE; binary /= DECIMAL_BASE; octalDigit += currentBit * bitValueMultiplier; bitValueMultiplier *= BINARY_BASE; } octal.insert(0, octalDigit); bitValueMultiplier = 1; // Reset multiplier for the next group } return octal.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class BinaryTree$Node { public int data; public BinaryTree$Node left; public BinaryTree$Node right; public BinaryTree$Node parent; BinaryTree$Node(int n) { this.data = n; this.left = null; this.right = null; this.parent = null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class BinaryTree$Node { public int data; public BinaryTree$Node left; public BinaryTree$Node right; public BinaryTree$Node parent; BinaryTree$Node(int n) { this.data = n; this.left = null; this.right = null; this.parent = null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.LinkedList; public class BinaryTree { private BinaryTree$Node a; public BinaryTree() { this.a = null; } public BinaryTree(BinaryTree$Node binaryTree$Node) { this.a = binaryTree$Node; } public BinaryTree$Node find(int n) { BinaryTree$Node binaryTree$Node = this.a; while (binaryTree$Node != null) { if (n < binaryTree$Node.data) { if (binaryTree$Node.left == null) { return binaryTree$Node; } binaryTree$Node = binaryTree$Node.left; continue; } if (n > binaryTree$Node.data) { if (binaryTree$Node.right == null) { return binaryTree$Node; } binaryTree$Node = binaryTree$Node.right; continue; } return binaryTree$Node; } return null; } public void put(int n) { BinaryTree$Node binaryTree$Node = new BinaryTree$Node(n); if (this.a == null) { this.a = binaryTree$Node; return; } BinaryTree$Node binaryTree$Node2 = this.find(n); if (n < binaryTree$Node2.data) { binaryTree$Node2.left = binaryTree$Node; binaryTree$Node2.left.parent = binaryTree$Node2; return; } binaryTree$Node2.right = binaryTree$Node; binaryTree$Node2.right.parent = binaryTree$Node2; } public boolean remove(int n) { BinaryTree$Node binaryTree$Node = this.find(n); if (binaryTree$Node.data != n) { return false; } if (binaryTree$Node.right == null && binaryTree$Node.left == null) { if (binaryTree$Node == this.a) { this.a = null; } else if (binaryTree$Node.parent.data < binaryTree$Node.data) { binaryTree$Node.parent.right = null; } else { binaryTree$Node.parent.left = null; } return true; } if (binaryTree$Node.left != null && binaryTree$Node.right != null) { BinaryTree$Node binaryTree$Node2 = this.findSuccessor(binaryTree$Node); this.findSuccessor(binaryTree$Node).left = binaryTree$Node.left; binaryTree$Node2.left.parent = binaryTree$Node2; if (binaryTree$Node2.parent != binaryTree$Node) { if (binaryTree$Node2.right != null) { binaryTree$Node2.right.parent = binaryTree$Node2.parent; binaryTree$Node2.parent.left = binaryTree$Node2.right; } else { binaryTree$Node2.parent.left = null; } binaryTree$Node2.right = binaryTree$Node.right; binaryTree$Node2.right.parent = binaryTree$Node2; } if (binaryTree$Node == this.a) { binaryTree$Node2.parent = null; this.a = binaryTree$Node2; } else { binaryTree$Node2.parent = binaryTree$Node.parent; if (binaryTree$Node.parent.data < binaryTree$Node.data) { binaryTree$Node.parent.right = binaryTree$Node2; } else { binaryTree$Node.parent.left = binaryTree$Node2; } } return true; } if (binaryTree$Node.right != null) { if (binaryTree$Node == this.a) { this.a = binaryTree$Node.right; return true; } binaryTree$Node.right.parent = binaryTree$Node.parent; if (binaryTree$Node.data < binaryTree$Node.parent.data) { binaryTree$Node.parent.left = binaryTree$Node.right; } else { binaryTree$Node.parent.right = binaryTree$Node.right; } } else { if (binaryTree$Node == this.a) { this.a = binaryTree$Node.left; return true; } binaryTree$Node.left.parent = binaryTree$Node.parent; if (binaryTree$Node.data < binaryTree$Node.parent.data) { binaryTree$Node.parent.left = binaryTree$Node.left; } else { binaryTree$Node.parent.right = binaryTree$Node.left; } } return true; } public BinaryTree$Node findSuccessor(BinaryTree$Node binaryTree$Node) { if (binaryTree$Node.right == null) { return binaryTree$Node; } BinaryTree$Node binaryTree$Node2 = binaryTree$Node.right; binaryTree$Node = binaryTree$Node.right; while (binaryTree$Node2 != null) { binaryTree$Node = binaryTree$Node2; binaryTree$Node2 = binaryTree$Node2.left; } return binaryTree$Node; } public BinaryTree$Node getRoot() { return this.a; } public void inOrder(BinaryTree$Node binaryTree$Node) { if (binaryTree$Node != null) { this.inOrder(binaryTree$Node.left); System.out.print(binaryTree$Node.data + \" \"); this.inOrder(binaryTree$Node.right); } } public void preOrder(BinaryTree$Node binaryTree$Node) { if (binaryTree$Node != null) { System.out.print(binaryTree$Node.data + \" \"); this.preOrder(binaryTree$Node.left); this.preOrder(binaryTree$Node.right); } } public void postOrder(BinaryTree$Node binaryTree$Node) { if (binaryTree$Node != null) { this.postOrder(binaryTree$Node.left); this.postOrder(binaryTree$Node.right); System.out.print(binaryTree$Node.data + \" \"); } } public void bfs(BinaryTree$Node binaryTree$Node) { LinkedList<BinaryTree$Node> linkedList = new LinkedList<BinaryTree$Node>(); if (binaryTree$Node != null) { linkedList.add(binaryTree$Node); } while (!linkedList.isEmpty()) { binaryTree$Node = (BinaryTree$Node)linkedList.remove(); System.out.print(binaryTree$Node.data + \" \"); if (binaryTree$Node.right != null) { linkedList.add(binaryTree$Node.right); } if (binaryTree$Node.left == null) continue; linkedList.add(binaryTree$Node.left); } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.LinkedList; import java.util.Queue; /* * This entire class is used to build a Binary Tree data structure. There is the * Node Class and the Tree Class, both explained below. */ /** * A binary tree is a data structure in which an element has two * successors(children). The left child is usually smaller than the parent, and * the right child is usually bigger. * * @author Unknown */ public class BinaryTree { /** * This class implements the nodes that will go on the Binary Tree. They * consist of the data in them, the node to the left, the node to the right, * and the parent from which they came from. * * @author Unknown */ static class Node { /** * Data for the node */ public int data; /** * The Node to the left of this one */ public Node left; /** * The Node to the right of this one */ public Node right; /** * The parent of this node */ public Node parent; /** * Constructor of Node * * @param value Value to put in the node */ Node(int value) { data = value; left = null; right = null; parent = null; } } /** * The root of the Binary Tree */ private Node root; /** * Constructor */ public BinaryTree() { root = null; } /** * Parameterized Constructor */ public BinaryTree(Node root) { this.root = root; } /** * Method to find a Node with a certain value * * @param key Value being looked for * @return The node if it finds it, otherwise returns the parent */ public Node find(int key) { Node current = root; while (current != null) { if (key < current.data) { if (current.left == null) { return current; // The key isn't exist, returns the parent } current = current.left; } else if (key > current.data) { if (current.right == null) { return current; } current = current.right; } else { // If you find the value return it return current; } } return null; } /** * Inserts certain value into the Binary Tree * * @param value Value to be inserted */ public void put(int value) { Node newNode = new Node(value); if (root == null) { root = newNode; } else { // This will return the soon to be parent of the value you're inserting Node parent = find(value); // This if/else assigns the new node to be either the left or right child of the parent if (value < parent.data) { parent.left = newNode; parent.left.parent = parent; } else { parent.right = newNode; parent.right.parent = parent; } } } /** * Deletes a given value from the Binary Tree * * @param value Value to be deleted * @return If the value was deleted */ public boolean remove(int value) { // temp is the node to be deleted Node temp = find(value); // If the value doesn't exist if (temp.data != value) { return false; } // No children if (temp.right == null && temp.left == null) { if (temp == root) { root = null; } // This if/else assigns the new node to be either the left or right child of the // parent else if (temp.parent.data < temp.data) { temp.parent.right = null; } else { temp.parent.left = null; } return true; } // Two children else if (temp.left != null && temp.right != null) { Node successor = findSuccessor(temp); // The left tree of temp is made the left tree of the successor successor.left = temp.left; successor.left.parent = successor; // If the successor has a right child, the child's grandparent is it's new parent if (successor.parent != temp) { if (successor.right != null) { successor.right.parent = successor.parent; successor.parent.left = successor.right; } else { successor.parent.left = null; } successor.right = temp.right; successor.right.parent = successor; } if (temp == root) { successor.parent = null; root = successor; } // If you're not deleting the root else { successor.parent = temp.parent; // This if/else assigns the new node to be either the left or right child of the // parent if (temp.parent.data < temp.data) { temp.parent.right = successor; } else { temp.parent.left = successor; } } return true; } // One child else { // If it has a right child if (temp.right != null) { if (temp == root) { root = temp.right; return true; } temp.right.parent = temp.parent; // Assigns temp to left or right child if (temp.data < temp.parent.data) { temp.parent.left = temp.right; } else { temp.parent.right = temp.right; } } // If it has a left child else { if (temp == root) { root = temp.left; return true; } temp.left.parent = temp.parent; // Assigns temp to left or right side if (temp.data < temp.parent.data) { temp.parent.left = temp.left; } else { temp.parent.right = temp.left; } } return true; } } /** * This method finds the Successor to the Node given. Move right once and go * left down the tree as far as you can * * @param n Node that you want to find the Successor of * @return The Successor of the node */ public Node findSuccessor(Node n) { if (n.right == null) { return n; } Node current = n.right; Node parent = n.right; while (current != null) { parent = current; current = current.left; } return parent; } /** * Returns the root of the Binary Tree * * @return the root of the Binary Tree */ public Node getRoot() { return root; } /** * Prints leftChild - root - rightChild This is the equivalent of a depth * first search * * @param localRoot The local root of the binary tree */ public void inOrder(Node localRoot) { if (localRoot != null) { inOrder(localRoot.left); System.out.print(localRoot.data + \" \"); inOrder(localRoot.right); } } /** * Prints root - leftChild - rightChild * * @param localRoot The local root of the binary tree */ public void preOrder(Node localRoot) { if (localRoot != null) { System.out.print(localRoot.data + \" \"); preOrder(localRoot.left); preOrder(localRoot.right); } } /** * Prints leftChild - rightChild - root * * @param localRoot The local root of the binary tree */ public void postOrder(Node localRoot) { if (localRoot != null) { postOrder(localRoot.left); postOrder(localRoot.right); System.out.print(localRoot.data + \" \"); } } /** * Prints the tree in a breadth first search order This is similar to * pre-order traversal, but instead of being implemented with a stack (or * recursion), it is implemented with a queue * * @param localRoot The local root of the binary tree */ public void bfs(Node localRoot) { // Create a queue for the order of the nodes Queue<Node> queue = new LinkedList<>(); // If the give root is null, then we don't add to the queue // and won't do anything if (localRoot != null) { queue.add(localRoot); } // Continue until the queue is empty while (!queue.isEmpty()) { // Get the next node on the queue to visit localRoot = queue.remove(); // Print the data from the node we are visiting System.out.print(localRoot.data + \" \"); // Add the children to the queue if not null if (localRoot.right != null) { queue.add(localRoot.right); } if (localRoot.left != null) { queue.add(localRoot.left); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class BinomialCoefficient { private BinomialCoefficient() { } public static int binomialCoefficient(int n, int n2) { if (n2 > n) { return 0; } if (n2 == 0 || n2 == n) { return 1; } return BinomialCoefficient.binomialCoefficient(n - 1, n2 - 1) + BinomialCoefficient.binomialCoefficient(n - 1, n2); } }", "deobfuscated_code": "package com.thealgorithms.maths; /* * Java program for Binomial Cofficients * Binomial Cofficients: A binomial cofficient C(n,k) gives number ways * in which k objects can be chosen from n objects. * Wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient * * Author: Akshay Dubey (https://github.com/itsAkshayDubey) * * */ public final class BinomialCoefficient { private BinomialCoefficient() { } /** * This method returns the number of ways in which k objects can be chosen from n objects * * @param totalObjects Total number of objects * @param numberOfObjects Number of objects to be chosen from total_objects * @return number of ways in which no_of_objects objects can be chosen from total_objects * objects */ public static int binomialCoefficient(int totalObjects, int numberOfObjects) { // Base Case if (numberOfObjects > totalObjects) { return 0; } // Base Case if (numberOfObjects == 0 || numberOfObjects == totalObjects) { return 1; } // Recursive Call return (binomialCoefficient(totalObjects - 1, numberOfObjects - 1) + binomialCoefficient(totalObjects - 1, numberOfObjects)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.Arrays; public final class BipartiteGraphDFS { private BipartiteGraphDFS() { } private static boolean a(int n, ArrayList arrayList, int[] nArray, int n2) { if (nArray[n2] == -1) { nArray[n2] = 1; } for (Integer n3 : (ArrayList)arrayList.get(n2)) { if (nArray[n3] == -1) { nArray[n3.intValue()] = 1 - nArray[n2]; if (BipartiteGraphDFS.a(n, arrayList, nArray, n3)) continue; return false; } if (nArray[n3] != nArray[n2]) continue; return false; } return true; } public static boolean isBipartite(int n, ArrayList arrayList) { int[] nArray = new int[n + 1]; Arrays.fill(nArray, -1); for (int i = 0; i < n; ++i) { if (nArray[i] != -1 || BipartiteGraphDFS.a(n, arrayList, nArray, i)) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.Arrays; /** * This class provides a method to check if a given undirected graph is bipartite using Depth-First Search (DFS). * A bipartite graph is a graph whose vertices can be divided into two disjoint sets such that no two vertices * within the same set are adjacent. In other words, all edges must go between the two sets. * * The implementation leverages DFS to attempt to color the graph using two colors. If we can color the graph such * that no two adjacent vertices have the same color, the graph is bipartite. * * Example: * Input (Adjacency Matrix): * {{0, 1, 0, 1}, * {1, 0, 1, 0}, * {0, 1, 0, 1}, * {1, 0, 1, 0}} * * Output: YES (This graph is bipartite) * * Input (Adjacency Matrix): * {{0, 1, 1, 0}, * {1, 0, 1, 0}, * {1, 1, 0, 1}, * {0, 0, 1, 0}} * * Output: NO (This graph is not bipartite) */ public final class BipartiteGraphDFS { private BipartiteGraphDFS() { } /** * Helper method to perform DFS and check if the graph is bipartite. * * During DFS traversal, this method attempts to color each vertex in such a way * that no two adjacent vertices share the same color. * * @param v Number of vertices in the graph * @param adj Adjacency list of the graph where each index i contains a list of adjacent vertices * @param color Array to store the color assigned to each vertex (-1 indicates uncolored) * @param node Current vertex being processed * @return True if the graph (or component of the graph) is bipartite, otherwise false */ private static boolean bipartite(int v, ArrayList<ArrayList<Integer>> adj, int[] color, int node) { if (color[node] == -1) { color[node] = 1; } for (Integer it : adj.get(node)) { if (color[it] == -1) { color[it] = 1 - color[node]; if (!bipartite(v, adj, color, it)) { return false; } } else if (color[it] == color[node]) { return false; } } return true; } /** * Method to check if the graph is bipartite. * * @param v Number of vertices in the graph * @param adj Adjacency list of the graph * @return True if the graph is bipartite, otherwise false */ public static boolean isBipartite(int v, ArrayList<ArrayList<Integer>> adj) { int[] color = new int[v + 1]; Arrays.fill(color, -1); for (int i = 0; i < v; i++) { if (color[i] == -1) { if (!bipartite(v, adj, color, i)) { return false; } } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.SingleBitOperations; public final class BitSwap { private BitSwap() { } public static int bitSwap(int n, int n2, int n3) { if (n2 < 0 || n2 >= 32 || n3 < 0 || n3 >= 32) { throw new IllegalArgumentException(\"Bit positions must be between 0 and 31\"); } if (SingleBitOperations.getBit(n, n2) != SingleBitOperations.getBit(n, n3)) { n ^= 1 << n2 ^ 1 << n3; } return n; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * Utility class for performing bit-swapping operations on integers. * This class cannot be instantiated. */ public final class BitSwap { private BitSwap() { } /** * Swaps two bits at specified positions in an integer. * * @param data The input integer whose bits need to be swapped * @param posA The position of the first bit (0-based, from least significant) * @param posB The position of the second bit (0-based, from least significant) * @return The modified value with swapped bits * @throws IllegalArgumentException if either position is negative or  32 */ public static int bitSwap(int data, final int posA, final int posB) { if (posA < 0 || posA >= Integer.SIZE || posB < 0 || posB >= Integer.SIZE) { throw new IllegalArgumentException(\"Bit positions must be between 0 and 31\"); } if (SingleBitOperations.getBit(data, posA) != SingleBitOperations.getBit(data, posB)) { data ^= (1 << posA) ^ (1 << posB); } return data; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; enum BitonicSort$Direction { DESCENDING, ASCENDING; }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; enum BitonicSort$Direction { DESCENDING, ASCENDING; }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.BitonicSort$Direction; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; import java.util.Arrays; import java.util.function.BiPredicate; public class BitonicSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { int n; if (comparableArray.length == 0) { return comparableArray; } int n2 = comparableArray.length; int n3 = 0; int n4 = n2; if ((n4 & n4 - 1) == 0) { n = n2; } else { while (n2 != 0) { n2 >>= 1; ++n3; } n = 1 << n3; } n3 = n; Object[] objectArray = Arrays.copyOf(comparableArray, n3); Object object = comparableArray; object = Arrays.stream(comparableArray).max(Comparable::compareTo).orElseThrow(); Arrays.fill(objectArray, comparableArray.length, n3, object); this.a((Comparable[])objectArray, 0, n3, BitonicSort$Direction.ASCENDING); return (Comparable[])Arrays.copyOf(objectArray, comparableArray.length); } private void a(Comparable[] comparableArray, int n, int n2, BitonicSort$Direction bitonicSort$Direction) { if (n2 > 1) { int n3 = n2 / 2; this.a(comparableArray, n, n3, BitonicSort$Direction.ASCENDING); this.a(comparableArray, n + n3, n2 - n3, BitonicSort$Direction.DESCENDING); this.b(comparableArray, n, n2, bitonicSort$Direction); } } private void b(Comparable[] comparableArray, int n, int n2, BitonicSort$Direction bitonicSort$Direction) { while (n2 > 1) { int n3 = n2 / 2; BiPredicate<Comparable, Comparable> biPredicate = bitonicSort$Direction == BitonicSort$Direction.ASCENDING ? (comparable, comparable2) -> SortUtils.less(comparable, comparable2) : (comparable, comparable2) -> SortUtils.greater(comparable, comparable2); for (int i = n; i < n + n3; ++i) { if (biPredicate.test(comparableArray[i], comparableArray[i + n3])) continue; int n4 = i; SortUtils.swap(comparableArray, n4, n4 + n3); } this.b(comparableArray, n, n3, bitonicSort$Direction); n2 -= n3; n += n3; } } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.Arrays; import java.util.function.BiPredicate; /** * BitonicSort class implements the SortAlgorithm interface using the bitonic sort technique. */ public class BitonicSort implements SortAlgorithm { private enum Direction { DESCENDING, ASCENDING, } /** * Sorts the given array using the Bitonic Sort algorithm. * * @param <T> the type of elements in the array, which must implement the Comparable interface * @param array the array to be sorted * @return the sorted array */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length == 0) { return array; } final int paddedSize = nextPowerOfTwo(array.length); T[] paddedArray = Arrays.copyOf(array, paddedSize); // Fill the padded part with a maximum value final T maxValue = max(array); Arrays.fill(paddedArray, array.length, paddedSize, maxValue); bitonicSort(paddedArray, 0, paddedSize, Direction.ASCENDING); return Arrays.copyOf(paddedArray, array.length); } private <T extends Comparable<T>> void bitonicSort(final T[] array, final int low, final int cnt, final Direction direction) { if (cnt > 1) { final int k = cnt / 2; // Sort first half in ascending order bitonicSort(array, low, k, Direction.ASCENDING); // Sort second half in descending order bitonicSort(array, low + k, cnt - k, Direction.DESCENDING); // Merge the whole sequence in ascending order bitonicMerge(array, low, cnt, direction); } } /** * Merges the bitonic sequence in the specified direction. * * @param <T> the type of elements in the array, which must be Comparable * @param array the array containing the bitonic sequence to be merged * @param low the starting index of the sequence to be merged * @param cnt the number of elements in the sequence to be merged * @param direction the direction of sorting */ private <T extends Comparable<T>> void bitonicMerge(T[] array, int low, int cnt, Direction direction) { if (cnt > 1) { final int k = cnt / 2; final BiPredicate<T, T> areSorted = (direction == Direction.ASCENDING) ? (a, b) -> SortUtils.less(a, b) : (a, b) -> SortUtils.greater(a, b); for (int i = low; i < low + k; i++) { if (!areSorted.test(array[i], array[i + k])) { SortUtils.swap(array, i, i + k); } } bitonicMerge(array, low, k, direction); bitonicMerge(array, low + k, cnt - k, direction); } } /** * Finds the next power of two greater than or equal to the given number. * * @param n the number * @return the next power of two */ private static int nextPowerOfTwo(int n) { int count = 0; // First n in the below condition is for the case where n is 0 if ((n & (n - 1)) == 0) { return n; } while (n != 0) { n >>= 1; count += 1; } return 1 << count; } /** * Finds the maximum element in the given array. * * @param <T> the type of elements in the array, which must implement the Comparable interface * @param array the array to be searched * @return the maximum element in the array * @throws IllegalArgumentException if the array is null or empty */ private static <T extends Comparable<T>> T max(final T[] array) { return Arrays.stream(array).max(Comparable::compareTo).orElseThrow(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.bloomfilter; class BloomFilter$Hash { private final int a; BloomFilter$Hash(int n) { this.a = n; } public int compute(Object object) { object = String.valueOf(object); int n = 0; char[] cArray = ((String)object).toCharArray(); object = cArray; int n2 = cArray.length; for (int i = 0; i < n2; ++i) { Object object2 = object[i]; n += object2; } return this.a * n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.bloomfilter; class BloomFilter$Hash { private final int a; BloomFilter$Hash(int n) { this.a = n; } public int compute(Object object) { object = String.valueOf(object); int n = 0; char[] cArray = ((String)object).toCharArray(); object = cArray; int n2 = cArray.length; for (int i = 0; i < n2; ++i) { Object object2 = object[i]; n += object2; } return this.a * n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.bloomfilter; import com.thealgorithms.datastructures.bloomfilter.BloomFilter$Hash; import java.util.BitSet; public class BloomFilter { private final int a; private final BitSet b; private final BloomFilter$Hash[] c; public BloomFilter(int n, int n2) { if (n <= 0 || n2 <= 0) { throw new IllegalArgumentException(\"Number of hash functions and bit array size must be greater than 0\"); } this.a = n; this.b = new BitSet(n2); this.c = new BloomFilter$Hash[n]; BloomFilter bloomFilter = this; for (n2 = 0; n2 < bloomFilter.a; ++n2) { bloomFilter.c[n2] = new BloomFilter$Hash(n2); } } public void insert(Object object) { BloomFilter$Hash[] bloomFilter$HashArray = this.c; int n = this.c.length; for (int i = 0; i < n; ++i) { BloomFilter$Hash bloomFilter$Hash = bloomFilter$HashArray[i]; int n2 = Math.abs(bloomFilter$Hash.compute(object) % this.b.size()); this.b.set(n2); } } public boolean contains(Object object) { BloomFilter$Hash[] bloomFilter$HashArray = this.c; int n = this.c.length; for (int i = 0; i < n; ++i) { BloomFilter$Hash bloomFilter$Hash = bloomFilter$HashArray[i]; int n2 = Math.abs(bloomFilter$Hash.compute(object) % this.b.size()); if (this.b.get(n2)) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.bloomfilter; import java.util.BitSet; /** * A generic BloomFilter implementation for probabilistic membership checking. * <p> * Bloom filters are space-efficient data structures that provide a fast way to test whether an * element is a member of a set. They may produce false positives, indicating an element is * in the set when it is not, but they will never produce false negatives. * </p> * * @param <T> The type of elements to be stored in the Bloom filter. */ @SuppressWarnings(\"rawtypes\") public class BloomFilter<T> { private final int numberOfHashFunctions; private final BitSet bitArray; private final Hash<T>[] hashFunctions; /** * Constructs a BloomFilter with a specified number of hash functions and bit array size. * * @param numberOfHashFunctions the number of hash functions to use * @param bitArraySize the size of the bit array, which determines the capacity of the filter * @throws IllegalArgumentException if numberOfHashFunctions or bitArraySize is less than 1 */ @SuppressWarnings(\"unchecked\") public BloomFilter(int numberOfHashFunctions, int bitArraySize) { if (numberOfHashFunctions < 1 || bitArraySize < 1) { throw new IllegalArgumentException(\"Number of hash functions and bit array size must be greater than 0\"); } this.numberOfHashFunctions = numberOfHashFunctions; this.bitArray = new BitSet(bitArraySize); this.hashFunctions = new Hash[numberOfHashFunctions]; initializeHashFunctions(); } /** * Initializes the hash functions with unique indices to ensure different hashing. */ private void initializeHashFunctions() { for (int i = 0; i < numberOfHashFunctions; i++) { hashFunctions[i] = new Hash<>(i); } } /** * Inserts an element into the Bloom filter. * <p> * This method hashes the element using all defined hash functions and sets the corresponding * bits in the bit array. * </p> * * @param key the element to insert into the Bloom filter */ public void insert(T key) { for (Hash<T> hash : hashFunctions) { int position = Math.abs(hash.compute(key) % bitArray.size()); bitArray.set(position); } } /** * Checks if an element might be in the Bloom filter. * <p> * This method checks the bits at the positions computed by each hash function. If any of these * bits are not set, the element is definitely not in the filter. If all bits are set, the element * might be in the filter. * </p> * * @param key the element to check for membership in the Bloom filter * @return {@code true} if the element might be in the Bloom filter, {@code false} if it is definitely not */ public boolean contains(T key) { for (Hash<T> hash : hashFunctions) { int position = Math.abs(hash.compute(key) % bitArray.size()); if (!bitArray.get(position)) { return false; } } return true; } /** * Inner class representing a hash function used by the Bloom filter. * <p> * Each instance of this class represents a different hash function based on its index. * </p> * * @param <T> The type of elements to be hashed. */ private static class Hash<T> { private final int index; /** * Constructs a Hash function with a specified index. * * @param index the index of this hash function, used to create a unique hash */ Hash(int index) { this.index = index; } /** * Computes the hash of the given key. * <p> * The hash value is calculated by multiplying the index of the hash function * with the ASCII sum of the string representation of the key. * </p> * * @param key the element to hash * @return the computed hash value */ public int compute(T key) { return index * asciiString(String.valueOf(key)); } /** * Computes the ASCII value sum of the characters in a string. * <p> * This method iterates through each character of the string and accumulates * their ASCII values to produce a single integer value. * </p> * * @param word the string to compute * @return the sum of ASCII values of the characters in the string */ private int asciiString(String word) { int sum = 0; for (char c : word.toCharArray()) { sum += c; } return sum; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; public class Blowfish { private String[][] a = new String[][]{{\"d1310ba6\", \"98dfb5ac\", \"2ffd72db\", \"d01adfb7\", \"b8e1afed\", \"6a267e96\", \"ba7c9045\", \"f12c7f99\", \"24a19947\", \"b3916cf7\", \"0801f2e2\", \"858efc16\", \"636920d8\", \"71574e69\", \"a458fea3\", \"f4933d7e\", \"0d95748f\", \"728eb658\", \"718bcd58\", \"82154aee\", \"7b54a41d\", \"c25a59b5\", \"9c30d539\", \"2af26013\", \"c5d1b023\", \"286085f0\", \"ca417918\", \"b8db38ef\", \"8e79dcb0\", \"603a180e\", \"6c9e0e8b\", \"b01e8a3e\", \"d71577c1\", \"bd314b27\", \"78af2fda\", \"55605c60\", \"e65525f3\", \"aa55ab94\", \"57489862\", \"63e81440\", \"55ca396a\", \"2aab10b6\", \"b4cc5c34\", \"1141e8ce\", \"a15486af\", \"7c72e993\", \"b3ee1411\", \"636fbc2a\", \"2ba9c55d\", \"741831f6\", \"ce5c3e16\", \"9b87931e\", \"afd6ba33\", \"6c24cf5c\", \"7a325381\", \"28958677\", \"3b8f4898\", \"6b4bb9af\", \"c4bfe81b\", \"66282193\", \"61d809cc\", \"fb21a991\", \"487cac60\", \"5dec8032\", \"ef845d5d\", \"e98575b1\", \"dc262302\", \"eb651b88\", \"23893e81\", \"d396acc5\", \"0f6d6ff3\", \"83f44239\", \"2e0b4482\", \"a4842004\", \"69c8f04a\", \"9e1f9b5e\", \"21c66842\", \"f6e96c9a\", \"670c9c61\", \"abd388f0\", \"6a51a0d2\", \"d8542f68\", \"960fa728\", \"ab5133a3\", \"6eef0b6c\", \"137a3be4\", \"ba3bf050\", \"7efb2a98\", \"a1f1651d\", \"39af0176\", \"66ca593e\", \"82430e88\", \"8cee8619\", \"456f9fb4\", \"7d84a5c3\", \"3b8b5ebe\", \"e06f75d8\", \"85c12073\", \"401a449f\", \"56c16aa6\", \"4ed3aa62\", \"363f7706\", \"1bfedf72\", \"429b023d\", \"37d0d724\", \"d00a1248\", \"db0fead3\", \"49f1c09b\", \"075372c9\", \"80991b7b\", \"25d479d8\", \"f6e8def7\", \"e3fe501a\", \"b6794c3b\", \"976ce0bd\", \"04c006ba\", \"c1a94fb6\", \"409f60c4\", \"5e5c9ec2\", \"196a2463\", \"68fb6faf\", \"3e6c53b5\", \"1339b2eb\", \"3b52ec6f\", \"6dfc511f\", \"9b30952c\", \"cc814544\", \"af5ebd09\", \"bee3d004\", \"de334afd\", \"660f2807\", \"192e4bb3\", \"c0cba857\", \"45c8740f\", \"d20b5f39\", \"b9d3fbdb\", \"5579c0bd\", \"1a60320a\", \"d6a100c6\", \"402c7279\", \"679f25fe\", \"fb1fa3cc\", \"8ea5e9f8\", \"db3222f8\", \"3c7516df\", \"fd616b15\", \"2f501ec8\", \"ad0552ab\", \"323db5fa\", \"fd238760\", \"53317b48\", \"3e00df82\", \"9e5c57bb\", \"ca6f8ca0\", \"1a87562e\", \"df1769db\", \"d542a8f6\", \"287effc3\", \"ac6732c6\", \"8c4f5573\", \"695b27b0\", \"bbca58c8\", \"e1ffa35d\", \"b8f011a0\", \"10fa3d98\", \"fd2183b8\", \"4afcb56c\", \"2dd1d35b\", \"9a53e479\", \"b6f84565\", \"d28e49bc\", \"4bfb9790\", \"e1ddf2da\", \"a4cb7e33\", \"62fb1341\", \"cee4c6e8\", \"ef20cada\", \"36774c01\", \"d07e9efe\", \"2bf11fb4\", \"95dbda4d\", \"ae909198\", \"eaad8e71\", \"6b93d5a0\", \"d08ed1d0\", \"afc725e0\", \"8e3c5b2f\", \"8e7594b7\", \"8ff6e2fb\", \"f2122b64\", \"8888b812\", \"900df01c\", \"4fad5ea0\", \"688fc31c\", \"d1cff191\", \"b3a8c1ad\", \"2f2f2218\", \"be0e1777\", \"ea752dfe\", \"8b021fa1\", \"e5a0cc0f\", \"b56f74e8\", \"18acf3d6\", \"ce89e299\", \"b4a84fe0\", \"fd13e0b7\", \"7cc43b81\", \"d2ada8d9\", \"165fa266\", \"80957705\", \"93cc7314\", \"211a1477\", \"e6ad2065\", \"77b5fa86\", \"c75442f5\", \"fb9d35cf\", \"ebcdaf0c\", \"7b3e89a0\", \"d6411bd3\", \"ae1e7e49\", \"00250e2d\", \"2071b35e\", \"226800bb\", \"57b8e0af\", \"2464369b\", \"f009b91e\", \"5563911d\", \"59dfa6aa\", \"78c14389\", \"d95a537f\", \"207d5ba2\", \"02e5b9c5\", \"83260376\", \"6295cfa9\", \"11c81968\", \"4e734a41\", \"b3472dca\", \"7b14a94a\", \"1b510052\", \"9a532915\", \"d60f573f\", \"bc9bc6e4\", \"2b60a476\", \"81e67400\", \"08ba6fb5\", \"571be91f\", \"f296ec6b\", \"2a0dd915\", \"b6636521\", \"e7b9f9b6\", \"ff34052e\", \"c5855664\", \"53b02d5d\", \"a99f8fa1\", \"08ba4799\", \"6e85076a\"}, {\"4b7a70e9\", \"b5b32944\", \"db75092e\", \"c4192623\", \"ad6ea6b0\", \"49a7df7d\", \"9cee60b8\", \"8fedb266\", \"ecaa8c71\", \"699a17ff\", \"5664526c\", \"c2b19ee1\", \"193602a5\", \"75094c29\", \"a0591340\", \"e4183a3e\", \"3f54989a\", \"5b429d65\", \"6b8fe4d6\", \"99f73fd6\", \"a1d29c07\", \"efe830f5\", \"4d2d38e6\", \"f0255dc1\", \"4cdd2086\", \"8470eb26\", \"6382e9c6\", \"021ecc5e\", \"09686b3f\", \"3ebaefc9\", \"3c971814\", \"6b6a70a1\", \"687f3584\", \"52a0e286\", \"b79c5305\", \"aa500737\", \"3e07841c\", \"7fdeae5c\", \"8e7d44ec\", \"5716f2b8\", \"b03ada37\", \"f0500c0d\", \"f01c1f04\", \"0200b3ff\", \"ae0cf51a\", \"3cb574b2\", \"25837a58\", \"dc0921bd\", \"d19113f9\", \"7ca92ff6\", \"94324773\", \"22f54701\", \"3ae5e581\", \"37c2dadc\", \"c8b57634\", \"9af3dda7\", \"a9446146\", \"0fd0030e\", \"ecc8c73e\", \"a4751e41\", \"e238cd99\", \"3bea0e2f\", \"3280bba1\", \"183eb331\", \"4e548b38\", \"4f6db908\", \"6f420d03\", \"f60a04bf\", \"2cb81290\", \"24977c79\", \"5679b072\", \"bcaf89af\", \"de9a771f\", \"d9930810\", \"b38bae12\", \"dccf3f2e\", \"5512721f\", \"2e6b7124\", \"501adde6\", \"9f84cd87\", \"7a584718\", \"7408da17\", \"bc9f9abc\", \"e94b7d8c\", \"ec7aec3a\", \"db851dfa\", \"63094366\", \"c464c3d2\", \"ef1c1847\", \"3215d908\", \"dd433b37\", \"24c2ba16\", \"12a14d43\", \"2a65c451\", \"50940002\", \"133ae4dd\", \"71dff89e\", \"10314e55\", \"81ac77d6\", \"5f11199b\", \"043556f1\", \"d7a3c76b\", \"3c11183b\", \"5924a509\", \"f28fe6ed\", \"97f1fbfa\", \"9ebabf2c\", \"1e153c6e\", \"86e34570\", \"eae96fb1\", \"860e5e0a\", \"5a3e2ab3\", \"771fe71c\", \"4e3d06fa\", \"2965dcb9\", \"99e71d0f\", \"803e89d6\", \"5266c825\", \"2e4cc978\", \"9c10b36a\", \"c6150eba\", \"94e2ea78\", \"a5fc3c53\", \"1e0a2df4\", \"f2f74ea7\", \"361d2b3d\", \"1939260f\", \"19c27960\", \"5223a708\", \"f71312b6\", \"ebadfe6e\", \"eac31f66\", \"e3bc4595\", \"a67bc883\", \"b17f37d1\", \"018cff28\", \"c332ddef\", \"be6c5aa5\", \"65582185\", \"68ab9802\", \"eecea50f\", \"db2f953b\", \"2aef7dad\", \"5b6e2f84\", \"1521b628\", \"29076170\", \"ecdd4775\", \"619f1510\", \"13cca830\", \"eb61bd96\", \"0334fe1e\", \"aa0363cf\", \"b5735c90\", \"4c70a239\", \"d59e9e0b\", \"cbaade14\", \"eecc86bc\", \"60622ca7\", \"9cab5cab\", \"b2f3846e\", \"648b1eaf\", \"19bdf0ca\", \"a02369b9\", \"655abb50\", \"40685a32\", \"3c2ab4b3\", \"319ee9d5\", \"c021b8f7\", \"9b540b19\", \"875fa099\", \"95f7997e\", \"623d7da8\", \"f837889a\", \"97e32d77\", \"11ed935f\", \"16681281\", \"0e358829\", \"c7e61fd6\", \"96dedfa1\", \"7858ba99\", \"57f584a5\", \"1b227263\", \"9b83c3ff\", \"1ac24696\", \"cdb30aeb\", \"532e3054\", \"8fd948e4\", \"6dbc3128\", \"58ebf2ef\", \"34c6ffea\", \"fe28ed61\", \"ee7c3c73\", \"5d4a14d9\", \"e864b7e3\", \"42105d14\", \"203e13e0\", \"45eee2b6\", \"a3aaabea\", \"db6c4f15\", \"facb4fd0\", \"c742f442\", \"ef6abbb5\", \"654f3b1d\", \"41cd2105\", \"d81e799e\", \"86854dc7\", \"e44b476a\", \"3d816250\", \"cf62a1f2\", \"5b8d2646\", \"fc8883a0\", \"c1c7b6a3\", \"7f1524c3\", \"69cb7492\", \"47848a0b\", \"5692b285\", \"095bbf00\", \"ad19489d\", \"1462b174\", \"23820e00\", \"58428d2a\", \"0c55f5ea\", \"1dadf43e\", \"233f7061\", \"3372f092\", \"8d937e41\", \"d65fecf1\", \"6c223bdb\", \"7cde3759\", \"cbee7460\", \"4085f2a7\", \"ce77326e\", \"a6078084\", \"19f8509e\", \"e8efd855\", \"61d99735\", \"a969a7aa\", \"c50c06c2\", \"5a04abfc\", \"800bcadc\", \"9e447a2e\", \"c3453484\", \"fdd56705\", \"0e1e9ec9\", \"db73dbd3\", \"105588cd\", \"675fda79\", \"e3674340\", \"c5c43465\", \"713e38d8\", \"3d28f89e\", \"f16dff20\", \"153e21e7\", \"8fb03d4a\", \"e6e39f2b\", \"db83adf7\"}, {\"e93d5a68\", \"948140f7\", \"f64c261c\", \"94692934\", \"411520f7\", \"7602d4f7\", \"bcf46b2e\", \"d4a20068\", \"d4082471\", \"3320f46a\", \"43b7d4b7\", \"500061af\", \"1e39f62e\", \"97244546\", \"14214f74\", \"bf8b8840\", \"4d95fc1d\", \"96b591af\", \"70f4ddd3\", \"66a02f45\", \"bfbc09ec\", \"03bd9785\", \"7fac6dd0\", \"31cb8504\", \"96eb27b3\", \"55fd3941\", \"da2547e6\", \"abca0a9a\", \"28507825\", \"530429f4\", \"0a2c86da\", \"e9b66dfb\", \"68dc1462\", \"d7486900\", \"680ec0a4\", \"27a18dee\", \"4f3ffea2\", \"e887ad8c\", \"b58ce006\", \"7af4d6b6\", \"aace1e7c\", \"d3375fec\", \"ce78a399\", \"406b2a42\", \"20fe9e35\", \"d9f385b9\", \"ee39d7ab\", \"3b124e8b\", \"1dc9faf7\", \"4b6d1856\", \"26a36631\", \"eae397b2\", \"3a6efa74\", \"dd5b4332\", \"6841e7f7\", \"ca7820fb\", \"fb0af54e\", \"d8feb397\", \"454056ac\", \"ba489527\", \"55533a3a\", \"20838d87\", \"fe6ba9b7\", \"d096954b\", \"55a867bc\", \"a1159a58\", \"cca92963\", \"99e1db33\", \"a62a4a56\", \"3f3125f9\", \"5ef47e1c\", \"9029317c\", \"fdf8e802\", \"04272f70\", \"80bb155c\", \"05282ce3\", \"95c11548\", \"e4c66d22\", \"48c1133f\", \"c70f86dc\", \"07f9c9ee\", \"41041f0f\", \"404779a4\", \"5d886e17\", \"325f51eb\", \"d59bc0d1\", \"f2bcc18f\", \"41113564\", \"257b7834\", \"602a9c60\", \"dff8e8a3\", \"1f636c1b\", \"0e12b4c2\", \"02e1329e\", \"af664fd1\", \"cad18115\", \"6b2395e0\", \"333e92e1\", \"3b240b62\", \"eebeb922\", \"85b2a20e\", \"e6ba0d99\", \"de720c8c\", \"2da2f728\", \"d0127845\", \"95b794fd\", \"647d0862\", \"e7ccf5f0\", \"5449a36f\", \"877d48fa\", \"c39dfd27\", \"f33e8d1e\", \"0a476341\", \"992eff74\", \"3a6f6eab\", \"f4f8fd37\", \"a812dc60\", \"a1ebddf8\", \"991be14c\", \"db6e6b0d\", \"c67b5510\", \"6d672c37\", \"2765d43b\", \"dcd0e804\", \"f1290dc7\", \"cc00ffa3\", \"b5390f92\", \"690fed0b\", \"667b9ffb\", \"cedb7d9c\", \"a091cf0b\", \"d9155ea3\", \"bb132f88\", \"515bad24\", \"7b9479bf\", \"763bd6eb\", \"37392eb3\", \"cc115979\", \"8026e297\", \"f42e312d\", \"6842ada7\", \"c66a2b3b\", \"12754ccc\", \"782ef11c\", \"6a124237\", \"b79251e7\", \"06a1bbe6\", \"4bfb6350\", \"1a6b1018\", \"11caedfa\", \"3d25bdd8\", \"e2e1c3c9\", \"44421659\", \"0a121386\", \"d90cec6e\", \"d5abea2a\", \"64af674e\", \"da86a85f\", \"bebfe988\", \"64e4c3fe\", \"9dbc8057\", \"f0f7c086\", \"60787bf8\", \"6003604d\", \"d1fd8346\", \"f6381fb0\", \"7745ae04\", \"d736fccc\", \"83426b33\", \"f01eab71\", \"b0804187\", \"3c005e5f\", \"77a057be\", \"bde8ae24\", \"55464299\", \"bf582e61\", \"4e58f48f\", \"f2ddfda2\", \"f474ef38\", \"8789bdc2\", \"5366f9c3\", \"c8b38e74\", \"b475f255\", \"46fcd9b9\", \"7aeb2661\", \"8b1ddf84\", \"846a0e79\", \"915f95e2\", \"466e598e\", \"20b45770\", \"8cd55591\", \"c902de4c\", \"b90bace1\", \"bb8205d0\", \"11a86248\", \"7574a99e\", \"b77f19b6\", \"e0a9dc09\", \"662d09a1\", \"c4324633\", \"e85a1f02\", \"09f0be8c\", \"4a99a025\", \"1d6efe10\", \"1ab93d1d\", \"0ba5a4df\", \"a186f20f\", \"2868f169\", \"dcb7da83\", \"573906fe\", \"a1e2ce9b\", \"4fcd7f52\", \"50115e01\", \"a70683fa\", \"a002b5c4\", \"0de6d027\", \"9af88c27\", \"773f8641\", \"c3604c06\", \"61a806b5\", \"f0177a28\", \"c0f586e0\", \"006058aa\", \"30dc7d62\", \"11e69ed7\", \"2338ea63\", \"53c2dd94\", \"c2c21634\", \"bbcbee56\", \"90bcb6de\", \"ebfc7da1\", \"ce591d76\", \"6f05e409\", \"4b7c0188\", \"39720a3d\", \"7c927c24\", \"86e3725f\", \"724d9db9\", \"1ac15bb4\", \"d39eb8fc\", \"ed545578\", \"08fca5b5\", \"d83d7cd3\", \"4dad0fc4\", \"1e50ef5e\", \"b161e6f8\", \"a28514d9\", \"6c51133c\", \"6fd5c7e7\", \"56e14ec4\", \"362abfce\", \"ddc6c837\", \"d79a3234\", \"92638212\", \"670efa8e\", \"406000e0\"}, {\"3a39ce37\", \"d3faf5cf\", \"abc27737\", \"5ac52d1b\", \"5cb0679e\", \"4fa33742\", \"d3822740\", \"99bc9bbe\", \"d5118e9d\", \"bf0f7315\", \"d62d1c7e\", \"c700c47b\", \"b78c1b6b\", \"21a19045\", \"b26eb1be\", \"6a366eb4\", \"5748ab2f\", \"bc946e79\", \"c6a376d2\", \"6549c2c8\", \"530ff8ee\", \"468dde7d\", \"d5730a1d\", \"4cd04dc6\", \"2939bbdb\", \"a9ba4650\", \"ac9526e8\", \"be5ee304\", \"a1fad5f0\", \"6a2d519a\", \"63ef8ce2\", \"9a86ee22\", \"c089c2b8\", \"43242ef6\", \"a51e03aa\", \"9cf2d0a4\", \"83c061ba\", \"9be96a4d\", \"8fe51550\", \"ba645bd6\", \"2826a2f9\", \"a73a3ae1\", \"4ba99586\", \"ef5562e9\", \"c72fefd3\", \"f752f7da\", \"3f046f69\", \"77fa0a59\", \"80e4a915\", \"87b08601\", \"9b09e6ad\", \"3b3ee593\", \"e990fd5a\", \"9e34d797\", \"2cf0b7d9\", \"022b8b51\", \"96d5ac3a\", \"017da67d\", \"d1cf3ed6\", \"7c7d2d28\", \"1f9f25cf\", \"adf2b89b\", \"5ad6b472\", \"5a88f54c\", \"e029ac71\", \"e019a5e6\", \"47b0acfd\", \"ed93fa9b\", \"e8d3c48d\", \"283b57cc\", \"f8d56629\", \"79132e28\", \"785f0191\", \"ed756055\", \"f7960e44\", \"e3d35e8c\", \"15056dd4\", \"88f46dba\", \"03a16125\", \"0564f0bd\", \"c3eb9e15\", \"3c9057a2\", \"97271aec\", \"a93a072a\", \"1b3f6d9b\", \"1e6321f5\", \"f59c66fb\", \"26dcf319\", \"7533d928\", \"b155fdf5\", \"03563482\", \"8aba3cbb\", \"28517711\", \"c20ad9f8\", \"abcc5167\", \"ccad925f\", \"4de81751\", \"3830dc8e\", \"379d5862\", \"9320f991\", \"ea7a90c2\", \"fb3e7bce\", \"5121ce64\", \"774fbe32\", \"a8b6e37e\", \"c3293d46\", \"48de5369\", \"6413e680\", \"a2ae0810\", \"dd6db224\", \"69852dfd\", \"09072166\", \"b39a460a\", \"6445c0dd\", \"586cdecf\", \"1c20c8ae\", \"5bbef7dd\", \"1b588d40\", \"ccd2017f\", \"6bb4e3bb\", \"dda26a7e\", \"3a59ff45\", \"3e350a44\", \"bcb4cdd5\", \"72eacea8\", \"fa6484bb\", \"8d6612ae\", \"bf3c6f47\", \"d29be463\", \"542f5d9e\", \"aec2771b\", \"f64e6370\", \"740e0d8d\", \"e75b1357\", \"f8721671\", \"af537d5d\", \"4040cb08\", \"4eb4e2cc\", \"34d2466a\", \"0115af84\", \"e1b00428\", \"95983a1d\", \"06b89fb4\", \"ce6ea048\", \"6f3f3b82\", \"3520ab82\", \"011a1d4b\", \"277227f8\", \"611560b1\", \"e7933fdc\", \"bb3a792b\", \"344525bd\", \"a08839e1\", \"51ce794b\", \"2f32c9b7\", \"a01fbac9\", \"e01cc87e\", \"bcc7d1f6\", \"cf0111c3\", \"a1e8aac7\", \"1a908749\", \"d44fbd9a\", \"d0dadecb\", \"d50ada38\", \"0339c32a\", \"c6913667\", \"8df9317c\", \"e0b12b4f\", \"f79e59b7\", \"43f5bb3a\", \"f2d519ff\", \"27d9459c\", \"bf97222c\", \"15e6fc2a\", \"0f91fc71\", \"9b941525\", \"fae59361\", \"ceb69ceb\", \"c2a86459\", \"12baa8d1\", \"b6c1075e\", \"e3056a0c\", \"10d25065\", \"cb03a442\", \"e0ec6e0e\", \"1698db3b\", \"4c98a0be\", \"3278e964\", \"9f1f9532\", \"e0d392df\", \"d3a0342b\", \"8971f21e\", \"1b0a7441\", \"4ba3348c\", \"c5be7120\", \"c37632d8\", \"df359f8d\", \"9b992f2e\", \"e60b6f47\", \"0fe3f11d\", \"e54cda54\", \"1edad891\", \"ce6279cf\", \"cd3e7e6f\", \"1618b166\", \"fd2c1d05\", \"848fd2c5\", \"f6fb2299\", \"f523f357\", \"a6327623\", \"93a83531\", \"56cccd02\", \"acf08162\", \"5a75ebb5\", \"6e163697\", \"88d273cc\", \"de966292\", \"81b949d0\", \"4c50901b\", \"71c65614\", \"e6c6c7bd\", \"327a140a\", \"45e1d006\", \"c3f27b9a\", \"c9aa53fd\", \"62a80f00\", \"bb25bfe2\", \"35bdd2f6\", \"71126905\", \"b2040222\", \"b6cbcf7c\", \"cd769c2b\", \"53113ec0\", \"1640e3d3\", \"38abbd60\", \"2547adf0\", \"ba38209c\", \"f746ce76\", \"77afa1c5\", \"20756060\", \"85cbfe4e\", \"8ae88dd8\", \"7aaaf9b0\", \"4cf9aa7e\", \"1948c25c\", \"02fb8a8c\", \"01c36ae4\", \"d6ebe1f9\", \"90d4f869\", \"a65cdea0\", \"3f09252d\", \"c208e69f\", \"b74e6132\", \"ce77e25b\", \"578fdfe3\", \"3ac372e6\"}}; private String[] b = new String[]{\"243f6a88\", \"85a308d3\", \"13198a2e\", \"03707344\", \"a4093822\", \"299f31d0\", \"082efa98\", \"ec4e6c89\", \"452821e6\", \"38d01377\", \"be5466cf\", \"34e90c6c\", \"c0ac29b7\", \"c97c50dd\", \"3f84d5b5\", \"b5470917\", \"9216d5d9\", \"8979fb1b\"}; private long c = 0x100000000L; }", "deobfuscated_code": "package com.thealgorithms.ciphers; /* * Java program for Blowfish Algorithm * Wikipedia: https://en.wikipedia.org/wiki/Blowfish_(cipher) * * Author: Akshay Dubey (https://github.com/itsAkshayDubey) * * */ public class Blowfish { // Initializing substitution boxes String[][] sBox = { { \"d1310ba6\", \"98dfb5ac\", \"2ffd72db\", \"d01adfb7\", \"b8e1afed\", \"6a267e96\", \"ba7c9045\", \"f12c7f99\", \"24a19947\", \"b3916cf7\", \"0801f2e2\", \"858efc16\", \"636920d8\", \"71574e69\", \"a458fea3\", \"f4933d7e\", \"0d95748f\", \"728eb658\", \"718bcd58\", \"82154aee\", \"7b54a41d\", \"c25a59b5\", \"9c30d539\", \"2af26013\", \"c5d1b023\", \"286085f0\", \"ca417918\", \"b8db38ef\", \"8e79dcb0\", \"603a180e\", \"6c9e0e8b\", \"b01e8a3e\", \"d71577c1\", \"bd314b27\", \"78af2fda\", \"55605c60\", \"e65525f3\", \"aa55ab94\", \"57489862\", \"63e81440\", \"55ca396a\", \"2aab10b6\", \"b4cc5c34\", \"1141e8ce\", \"a15486af\", \"7c72e993\", \"b3ee1411\", \"636fbc2a\", \"2ba9c55d\", \"741831f6\", \"ce5c3e16\", \"9b87931e\", \"afd6ba33\", \"6c24cf5c\", \"7a325381\", \"28958677\", \"3b8f4898\", \"6b4bb9af\", \"c4bfe81b\", \"66282193\", \"61d809cc\", \"fb21a991\", \"487cac60\", \"5dec8032\", \"ef845d5d\", \"e98575b1\", \"dc262302\", \"eb651b88\", \"23893e81\", \"d396acc5\", \"0f6d6ff3\", \"83f44239\", \"2e0b4482\", \"a4842004\", \"69c8f04a\", \"9e1f9b5e\", \"21c66842\", \"f6e96c9a\", \"670c9c61\", \"abd388f0\", \"6a51a0d2\", \"d8542f68\", \"960fa728\", \"ab5133a3\", \"6eef0b6c\", \"137a3be4\", \"ba3bf050\", \"7efb2a98\", \"a1f1651d\", \"39af0176\", \"66ca593e\", \"82430e88\", \"8cee8619\", \"456f9fb4\", \"7d84a5c3\", \"3b8b5ebe\", \"e06f75d8\", \"85c12073\", \"401a449f\", \"56c16aa6\", \"4ed3aa62\", \"363f7706\", \"1bfedf72\", \"429b023d\", \"37d0d724\", \"d00a1248\", \"db0fead3\", \"49f1c09b\", \"075372c9\", \"80991b7b\", \"25d479d8\", \"f6e8def7\", \"e3fe501a\", \"b6794c3b\", \"976ce0bd\", \"04c006ba\", \"c1a94fb6\", \"409f60c4\", \"5e5c9ec2\", \"196a2463\", \"68fb6faf\", \"3e6c53b5\", \"1339b2eb\", \"3b52ec6f\", \"6dfc511f\", \"9b30952c\", \"cc814544\", \"af5ebd09\", \"bee3d004\", \"de334afd\", \"660f2807\", \"192e4bb3\", \"c0cba857\", \"45c8740f\", \"d20b5f39\", \"b9d3fbdb\", \"5579c0bd\", \"1a60320a\", \"d6a100c6\", \"402c7279\", \"679f25fe\", \"fb1fa3cc\", \"8ea5e9f8\", \"db3222f8\", \"3c7516df\", \"fd616b15\", \"2f501ec8\", \"ad0552ab\", \"323db5fa\", \"fd238760\", \"53317b48\", \"3e00df82\", \"9e5c57bb\", \"ca6f8ca0\", \"1a87562e\", \"df1769db\", \"d542a8f6\", \"287effc3\", \"ac6732c6\", \"8c4f5573\", \"695b27b0\", \"bbca58c8\", \"e1ffa35d\", \"b8f011a0\", \"10fa3d98\", \"fd2183b8\", \"4afcb56c\", \"2dd1d35b\", \"9a53e479\", \"b6f84565\", \"d28e49bc\", \"4bfb9790\", \"e1ddf2da\", \"a4cb7e33\", \"62fb1341\", \"cee4c6e8\", \"ef20cada\", \"36774c01\", \"d07e9efe\", \"2bf11fb4\", \"95dbda4d\", \"ae909198\", \"eaad8e71\", \"6b93d5a0\", \"d08ed1d0\", \"afc725e0\", \"8e3c5b2f\", \"8e7594b7\", \"8ff6e2fb\", \"f2122b64\", \"8888b812\", \"900df01c\", \"4fad5ea0\", \"688fc31c\", \"d1cff191\", \"b3a8c1ad\", \"2f2f2218\", \"be0e1777\", \"ea752dfe\", \"8b021fa1\", \"e5a0cc0f\", \"b56f74e8\", \"18acf3d6\", \"ce89e299\", \"b4a84fe0\", \"fd13e0b7\", \"7cc43b81\", \"d2ada8d9\", \"165fa266\", \"80957705\", \"93cc7314\", \"211a1477\", \"e6ad2065\", \"77b5fa86\", \"c75442f5\", \"fb9d35cf\", \"ebcdaf0c\", \"7b3e89a0\", \"d6411bd3\", \"ae1e7e49\", \"00250e2d\", \"2071b35e\", \"226800bb\", \"57b8e0af\", \"2464369b\", \"f009b91e\", \"5563911d\", \"59dfa6aa\", \"78c14389\", \"d95a537f\", \"207d5ba2\", \"02e5b9c5\", \"83260376\", \"6295cfa9\", \"11c81968\", \"4e734a41\", \"b3472dca\", \"7b14a94a\", \"1b510052\", \"9a532915\", \"d60f573f\", \"bc9bc6e4\", \"2b60a476\", \"81e67400\", \"08ba6fb5\", \"571be91f\", \"f296ec6b\", \"2a0dd915\", \"b6636521\", \"e7b9f9b6\", \"ff34052e\", \"c5855664\", \"53b02d5d\", \"a99f8fa1\", \"08ba4799\", \"6e85076a\", }, { \"4b7a70e9\", \"b5b32944\", \"db75092e\", \"c4192623\", \"ad6ea6b0\", \"49a7df7d\", \"9cee60b8\", \"8fedb266\", \"ecaa8c71\", \"699a17ff\", \"5664526c\", \"c2b19ee1\", \"193602a5\", \"75094c29\", \"a0591340\", \"e4183a3e\", \"3f54989a\", \"5b429d65\", \"6b8fe4d6\", \"99f73fd6\", \"a1d29c07\", \"efe830f5\", \"4d2d38e6\", \"f0255dc1\", \"4cdd2086\", \"8470eb26\", \"6382e9c6\", \"021ecc5e\", \"09686b3f\", \"3ebaefc9\", \"3c971814\", \"6b6a70a1\", \"687f3584\", \"52a0e286\", \"b79c5305\", \"aa500737\", \"3e07841c\", \"7fdeae5c\", \"8e7d44ec\", \"5716f2b8\", \"b03ada37\", \"f0500c0d\", \"f01c1f04\", \"0200b3ff\", \"ae0cf51a\", \"3cb574b2\", \"25837a58\", \"dc0921bd\", \"d19113f9\", \"7ca92ff6\", \"94324773\", \"22f54701\", \"3ae5e581\", \"37c2dadc\", \"c8b57634\", \"9af3dda7\", \"a9446146\", \"0fd0030e\", \"ecc8c73e\", \"a4751e41\", \"e238cd99\", \"3bea0e2f\", \"3280bba1\", \"183eb331\", \"4e548b38\", \"4f6db908\", \"6f420d03\", \"f60a04bf\", \"2cb81290\", \"24977c79\", \"5679b072\", \"bcaf89af\", \"de9a771f\", \"d9930810\", \"b38bae12\", \"dccf3f2e\", \"5512721f\", \"2e6b7124\", \"501adde6\", \"9f84cd87\", \"7a584718\", \"7408da17\", \"bc9f9abc\", \"e94b7d8c\", \"ec7aec3a\", \"db851dfa\", \"63094366\", \"c464c3d2\", \"ef1c1847\", \"3215d908\", \"dd433b37\", \"24c2ba16\", \"12a14d43\", \"2a65c451\", \"50940002\", \"133ae4dd\", \"71dff89e\", \"10314e55\", \"81ac77d6\", \"5f11199b\", \"043556f1\", \"d7a3c76b\", \"3c11183b\", \"5924a509\", \"f28fe6ed\", \"97f1fbfa\", \"9ebabf2c\", \"1e153c6e\", \"86e34570\", \"eae96fb1\", \"860e5e0a\", \"5a3e2ab3\", \"771fe71c\", \"4e3d06fa\", \"2965dcb9\", \"99e71d0f\", \"803e89d6\", \"5266c825\", \"2e4cc978\", \"9c10b36a\", \"c6150eba\", \"94e2ea78\", \"a5fc3c53\", \"1e0a2df4\", \"f2f74ea7\", \"361d2b3d\", \"1939260f\", \"19c27960\", \"5223a708\", \"f71312b6\", \"ebadfe6e\", \"eac31f66\", \"e3bc4595\", \"a67bc883\", \"b17f37d1\", \"018cff28\", \"c332ddef\", \"be6c5aa5\", \"65582185\", \"68ab9802\", \"eecea50f\", \"db2f953b\", \"2aef7dad\", \"5b6e2f84\", \"1521b628\", \"29076170\", \"ecdd4775\", \"619f1510\", \"13cca830\", \"eb61bd96\", \"0334fe1e\", \"aa0363cf\", \"b5735c90\", \"4c70a239\", \"d59e9e0b\", \"cbaade14\", \"eecc86bc\", \"60622ca7\", \"9cab5cab\", \"b2f3846e\", \"648b1eaf\", \"19bdf0ca\", \"a02369b9\", \"655abb50\", \"40685a32\", \"3c2ab4b3\", \"319ee9d5\", \"c021b8f7\", \"9b540b19\", \"875fa099\", \"95f7997e\", \"623d7da8\", \"f837889a\", \"97e32d77\", \"11ed935f\", \"16681281\", \"0e358829\", \"c7e61fd6\", \"96dedfa1\", \"7858ba99\", \"57f584a5\", \"1b227263\", \"9b83c3ff\", \"1ac24696\", \"cdb30aeb\", \"532e3054\", \"8fd948e4\", \"6dbc3128\", \"58ebf2ef\", \"34c6ffea\", \"fe28ed61\", \"ee7c3c73\", \"5d4a14d9\", \"e864b7e3\", \"42105d14\", \"203e13e0\", \"45eee2b6\", \"a3aaabea\", \"db6c4f15\", \"facb4fd0\", \"c742f442\", \"ef6abbb5\", \"654f3b1d\", \"41cd2105\", \"d81e799e\", \"86854dc7\", \"e44b476a\", \"3d816250\", \"cf62a1f2\", \"5b8d2646\", \"fc8883a0\", \"c1c7b6a3\", \"7f1524c3\", \"69cb7492\", \"47848a0b\", \"5692b285\", \"095bbf00\", \"ad19489d\", \"1462b174\", \"23820e00\", \"58428d2a\", \"0c55f5ea\", \"1dadf43e\", \"233f7061\", \"3372f092\", \"8d937e41\", \"d65fecf1\", \"6c223bdb\", \"7cde3759\", \"cbee7460\", \"4085f2a7\", \"ce77326e\", \"a6078084\", \"19f8509e\", \"e8efd855\", \"61d99735\", \"a969a7aa\", \"c50c06c2\", \"5a04abfc\", \"800bcadc\", \"9e447a2e\", \"c3453484\", \"fdd56705\", \"0e1e9ec9\", \"db73dbd3\", \"105588cd\", \"675fda79\", \"e3674340\", \"c5c43465\", \"713e38d8\", \"3d28f89e\", \"f16dff20\", \"153e21e7\", \"8fb03d4a\", \"e6e39f2b\", \"db83adf7\", }, { \"e93d5a68\", \"948140f7\", \"f64c261c\", \"94692934\", \"411520f7\", \"7602d4f7\", \"bcf46b2e\", \"d4a20068\", \"d4082471\", \"3320f46a\", \"43b7d4b7\", \"500061af\", \"1e39f62e\", \"97244546\", \"14214f74\", \"bf8b8840\", \"4d95fc1d\", \"96b591af\", \"70f4ddd3\", \"66a02f45\", \"bfbc09ec\", \"03bd9785\", \"7fac6dd0\", \"31cb8504\", \"96eb27b3\", \"55fd3941\", \"da2547e6\", \"abca0a9a\", \"28507825\", \"530429f4\", \"0a2c86da\", \"e9b66dfb\", \"68dc1462\", \"d7486900\", \"680ec0a4\", \"27a18dee\", \"4f3ffea2\", \"e887ad8c\", \"b58ce006\", \"7af4d6b6\", \"aace1e7c\", \"d3375fec\", \"ce78a399\", \"406b2a42\", \"20fe9e35\", \"d9f385b9\", \"ee39d7ab\", \"3b124e8b\", \"1dc9faf7\", \"4b6d1856\", \"26a36631\", \"eae397b2\", \"3a6efa74\", \"dd5b4332\", \"6841e7f7\", \"ca7820fb\", \"fb0af54e\", \"d8feb397\", \"454056ac\", \"ba489527\", \"55533a3a\", \"20838d87\", \"fe6ba9b7\", \"d096954b\", \"55a867bc\", \"a1159a58\", \"cca92963\", \"99e1db33\", \"a62a4a56\", \"3f3125f9\", \"5ef47e1c\", \"9029317c\", \"fdf8e802\", \"04272f70\", \"80bb155c\", \"05282ce3\", \"95c11548\", \"e4c66d22\", \"48c1133f\", \"c70f86dc\", \"07f9c9ee\", \"41041f0f\", \"404779a4\", \"5d886e17\", \"325f51eb\", \"d59bc0d1\", \"f2bcc18f\", \"41113564\", \"257b7834\", \"602a9c60\", \"dff8e8a3\", \"1f636c1b\", \"0e12b4c2\", \"02e1329e\", \"af664fd1\", \"cad18115\", \"6b2395e0\", \"333e92e1\", \"3b240b62\", \"eebeb922\", \"85b2a20e\", \"e6ba0d99\", \"de720c8c\", \"2da2f728\", \"d0127845\", \"95b794fd\", \"647d0862\", \"e7ccf5f0\", \"5449a36f\", \"877d48fa\", \"c39dfd27\", \"f33e8d1e\", \"0a476341\", \"992eff74\", \"3a6f6eab\", \"f4f8fd37\", \"a812dc60\", \"a1ebddf8\", \"991be14c\", \"db6e6b0d\", \"c67b5510\", \"6d672c37\", \"2765d43b\", \"dcd0e804\", \"f1290dc7\", \"cc00ffa3\", \"b5390f92\", \"690fed0b\", \"667b9ffb\", \"cedb7d9c\", \"a091cf0b\", \"d9155ea3\", \"bb132f88\", \"515bad24\", \"7b9479bf\", \"763bd6eb\", \"37392eb3\", \"cc115979\", \"8026e297\", \"f42e312d\", \"6842ada7\", \"c66a2b3b\", \"12754ccc\", \"782ef11c\", \"6a124237\", \"b79251e7\", \"06a1bbe6\", \"4bfb6350\", \"1a6b1018\", \"11caedfa\", \"3d25bdd8\", \"e2e1c3c9\", \"44421659\", \"0a121386\", \"d90cec6e\", \"d5abea2a\", \"64af674e\", \"da86a85f\", \"bebfe988\", \"64e4c3fe\", \"9dbc8057\", \"f0f7c086\", \"60787bf8\", \"6003604d\", \"d1fd8346\", \"f6381fb0\", \"7745ae04\", \"d736fccc\", \"83426b33\", \"f01eab71\", \"b0804187\", \"3c005e5f\", \"77a057be\", \"bde8ae24\", \"55464299\", \"bf582e61\", \"4e58f48f\", \"f2ddfda2\", \"f474ef38\", \"8789bdc2\", \"5366f9c3\", \"c8b38e74\", \"b475f255\", \"46fcd9b9\", \"7aeb2661\", \"8b1ddf84\", \"846a0e79\", \"915f95e2\", \"466e598e\", \"20b45770\", \"8cd55591\", \"c902de4c\", \"b90bace1\", \"bb8205d0\", \"11a86248\", \"7574a99e\", \"b77f19b6\", \"e0a9dc09\", \"662d09a1\", \"c4324633\", \"e85a1f02\", \"09f0be8c\", \"4a99a025\", \"1d6efe10\", \"1ab93d1d\", \"0ba5a4df\", \"a186f20f\", \"2868f169\", \"dcb7da83\", \"573906fe\", \"a1e2ce9b\", \"4fcd7f52\", \"50115e01\", \"a70683fa\", \"a002b5c4\", \"0de6d027\", \"9af88c27\", \"773f8641\", \"c3604c06\", \"61a806b5\", \"f0177a28\", \"c0f586e0\", \"006058aa\", \"30dc7d62\", \"11e69ed7\", \"2338ea63\", \"53c2dd94\", \"c2c21634\", \"bbcbee56\", \"90bcb6de\", \"ebfc7da1\", \"ce591d76\", \"6f05e409\", \"4b7c0188\", \"39720a3d\", \"7c927c24\", \"86e3725f\", \"724d9db9\", \"1ac15bb4\", \"d39eb8fc\", \"ed545578\", \"08fca5b5\", \"d83d7cd3\", \"4dad0fc4\", \"1e50ef5e\", \"b161e6f8\", \"a28514d9\", \"6c51133c\", \"6fd5c7e7\", \"56e14ec4\", \"362abfce\", \"ddc6c837\", \"d79a3234\", \"92638212\", \"670efa8e\", \"406000e0\", }, { \"3a39ce37\", \"d3faf5cf\", \"abc27737\", \"5ac52d1b\", \"5cb0679e\", \"4fa33742\", \"d3822740\", \"99bc9bbe\", \"d5118e9d\", \"bf0f7315\", \"d62d1c7e\", \"c700c47b\", \"b78c1b6b\", \"21a19045\", \"b26eb1be\", \"6a366eb4\", \"5748ab2f\", \"bc946e79\", \"c6a376d2\", \"6549c2c8\", \"530ff8ee\", \"468dde7d\", \"d5730a1d\", \"4cd04dc6\", \"2939bbdb\", \"a9ba4650\", \"ac9526e8\", \"be5ee304\", \"a1fad5f0\", \"6a2d519a\", \"63ef8ce2\", \"9a86ee22\", \"c089c2b8\", \"43242ef6\", \"a51e03aa\", \"9cf2d0a4\", \"83c061ba\", \"9be96a4d\", \"8fe51550\", \"ba645bd6\", \"2826a2f9\", \"a73a3ae1\", \"4ba99586\", \"ef5562e9\", \"c72fefd3\", \"f752f7da\", \"3f046f69\", \"77fa0a59\", \"80e4a915\", \"87b08601\", \"9b09e6ad\", \"3b3ee593\", \"e990fd5a\", \"9e34d797\", \"2cf0b7d9\", \"022b8b51\", \"96d5ac3a\", \"017da67d\", \"d1cf3ed6\", \"7c7d2d28\", \"1f9f25cf\", \"adf2b89b\", \"5ad6b472\", \"5a88f54c\", \"e029ac71\", \"e019a5e6\", \"47b0acfd\", \"ed93fa9b\", \"e8d3c48d\", \"283b57cc\", \"f8d56629\", \"79132e28\", \"785f0191\", \"ed756055\", \"f7960e44\", \"e3d35e8c\", \"15056dd4\", \"88f46dba\", \"03a16125\", \"0564f0bd\", \"c3eb9e15\", \"3c9057a2\", \"97271aec\", \"a93a072a\", \"1b3f6d9b\", \"1e6321f5\", \"f59c66fb\", \"26dcf319\", \"7533d928\", \"b155fdf5\", \"03563482\", \"8aba3cbb\", \"28517711\", \"c20ad9f8\", \"abcc5167\", \"ccad925f\", \"4de81751\", \"3830dc8e\", \"379d5862\", \"9320f991\", \"ea7a90c2\", \"fb3e7bce\", \"5121ce64\", \"774fbe32\", \"a8b6e37e\", \"c3293d46\", \"48de5369\", \"6413e680\", \"a2ae0810\", \"dd6db224\", \"69852dfd\", \"09072166\", \"b39a460a\", \"6445c0dd\", \"586cdecf\", \"1c20c8ae\", \"5bbef7dd\", \"1b588d40\", \"ccd2017f\", \"6bb4e3bb\", \"dda26a7e\", \"3a59ff45\", \"3e350a44\", \"bcb4cdd5\", \"72eacea8\", \"fa6484bb\", \"8d6612ae\", \"bf3c6f47\", \"d29be463\", \"542f5d9e\", \"aec2771b\", \"f64e6370\", \"740e0d8d\", \"e75b1357\", \"f8721671\", \"af537d5d\", \"4040cb08\", \"4eb4e2cc\", \"34d2466a\", \"0115af84\", \"e1b00428\", \"95983a1d\", \"06b89fb4\", \"ce6ea048\", \"6f3f3b82\", \"3520ab82\", \"011a1d4b\", \"277227f8\", \"611560b1\", \"e7933fdc\", \"bb3a792b\", \"344525bd\", \"a08839e1\", \"51ce794b\", \"2f32c9b7\", \"a01fbac9\", \"e01cc87e\", \"bcc7d1f6\", \"cf0111c3\", \"a1e8aac7\", \"1a908749\", \"d44fbd9a\", \"d0dadecb\", \"d50ada38\", \"0339c32a\", \"c6913667\", \"8df9317c\", \"e0b12b4f\", \"f79e59b7\", \"43f5bb3a\", \"f2d519ff\", \"27d9459c\", \"bf97222c\", \"15e6fc2a\", \"0f91fc71\", \"9b941525\", \"fae59361\", \"ceb69ceb\", \"c2a86459\", \"12baa8d1\", \"b6c1075e\", \"e3056a0c\", \"10d25065\", \"cb03a442\", \"e0ec6e0e\", \"1698db3b\", \"4c98a0be\", \"3278e964\", \"9f1f9532\", \"e0d392df\", \"d3a0342b\", \"8971f21e\", \"1b0a7441\", \"4ba3348c\", \"c5be7120\", \"c37632d8\", \"df359f8d\", \"9b992f2e\", \"e60b6f47\", \"0fe3f11d\", \"e54cda54\", \"1edad891\", \"ce6279cf\", \"cd3e7e6f\", \"1618b166\", \"fd2c1d05\", \"848fd2c5\", \"f6fb2299\", \"f523f357\", \"a6327623\", \"93a83531\", \"56cccd02\", \"acf08162\", \"5a75ebb5\", \"6e163697\", \"88d273cc\", \"de966292\", \"81b949d0\", \"4c50901b\", \"71c65614\", \"e6c6c7bd\", \"327a140a\", \"45e1d006\", \"c3f27b9a\", \"c9aa53fd\", \"62a80f00\", \"bb25bfe2\", \"35bdd2f6\", \"71126905\", \"b2040222\", \"b6cbcf7c\", \"cd769c2b\", \"53113ec0\", \"1640e3d3\", \"38abbd60\", \"2547adf0\", \"ba38209c\", \"f746ce76\", \"77afa1c5\", \"20756060\", \"85cbfe4e\", \"8ae88dd8\", \"7aaaf9b0\", \"4cf9aa7e\", \"1948c25c\", \"02fb8a8c\", \"01c36ae4\", \"d6ebe1f9\", \"90d4f869\", \"a65cdea0\", \"3f09252d\", \"c208e69f\", \"b74e6132\", \"ce77e25b\", \"578fdfe3\", \"3ac372e6\", }, }; // Initializing subkeys with digits of pi String[] subKeys = { \"243f6a88\", \"85a308d3\", \"13198a2e\", \"03707344\", \"a4093822\", \"299f31d0\", \"082efa98\", \"ec4e6c89\", \"452821e6\", \"38d01377\", \"be5466cf\", \"34e90c6c\", \"c0ac29b7\", \"c97c50dd\", \"3f84d5b5\", \"b5470917\", \"9216d5d9\", \"8979fb1b\", }; // Initializing modVal to 2^32 long modVal = 4294967296L; /** * This method returns binary representation of the hexadecimal number passed as parameter * * @param hex Number for which binary representation is required * @return String object which is a binary representation of the hex number passed as parameter */ private String hexToBin(String hex) { StringBuilder binary = new StringBuilder(); long num; String binary4B; int n = hex.length(); for (int i = 0; i < n; i++) { num = Long.parseUnsignedLong(hex.charAt(i) + \"\", 16); binary4B = Long.toBinaryString(num); binary4B = \"0000\" + binary4B; binary4B = binary4B.substring(binary4B.length() - 4); binary.append(binary4B); } return binary.toString(); } /** * This method returns hexadecimal representation of the binary number passed as parameter * * @param binary Number for which hexadecimal representation is required * @return String object which is a hexadecimal representation of the binary number passed as * parameter */ private String binToHex(String binary) { long num = Long.parseUnsignedLong(binary, 2); StringBuilder hex = new StringBuilder(Long.toHexString(num)); while (hex.length() < (binary.length() / 4)) { hex.insert(0, \"0\"); } return hex.toString(); } /** * This method returns a string obtained by XOR-ing two strings of same length passed a method * parameters * * @param String a and b are string objects which will be XORed and are to be of same length * @return String object obtained by XOR operation on String a and String b * */ private String xor(String a, String b) { a = hexToBin(a); b = hexToBin(b); StringBuilder ans = new StringBuilder(); for (int i = 0; i < a.length(); i++) { ans.append((char) (((a.charAt(i) - '0') ^ (b.charAt(i) - '0')) + '0')); } ans = new StringBuilder(binToHex(ans.toString())); return ans.toString(); } /** * This method returns addition of two hexadecimal numbers passed as parameters and moded with * 2^32 * * @param String a and b are hexadecimal numbers * @return String object which is a is addition that is then moded with 2^32 of hex numbers * passed as parameters */ private String addBin(String a, String b) { String ans = \"\"; long n1 = Long.parseUnsignedLong(a, 16); long n2 = Long.parseUnsignedLong(b, 16); n1 = (n1 + n2) % modVal; ans = Long.toHexString(n1); ans = \"00000000\" + ans; return ans.substring(ans.length() - 8); } /*F-function splits the 32-bit input into four 8-bit quarters and uses the quarters as input to the S-boxes. The S-boxes accept 8-bit input and produce 32-bit output. The outputs are added modulo 232 and XORed to produce the final 32-bit output */ private String f(String plainText) { String[] a = new String[4]; String ans = \"\"; for (int i = 0; i < 8; i += 2) { // column number for S-box is a 8-bit value long col = Long.parseUnsignedLong(hexToBin(plainText.substring(i, i + 2)), 2); a[i / 2] = sBox[i / 2][(int) col]; } ans = addBin(a[0], a[1]); ans = xor(ans, a[2]); ans = addBin(ans, a[3]); return ans; } // generate subkeys private void keyGenerate(String key) { int j = 0; for (int i = 0; i < subKeys.length; i++) { // XOR-ing 32-bit parts of the key with initial subkeys subKeys[i] = xor(subKeys[i], key.substring(j, j + 8)); j = (j + 8) % key.length(); } } // round function private String round(int time, String plainText) { String left; String right; left = plainText.substring(0, 8); right = plainText.substring(8, 16); left = xor(left, subKeys[time]); // output from F function String fOut = f(left); right = xor(fOut, right); // swap left and right return right + left; } /** * This method returns cipher text for the plaintext passed as the first parameter generated * using the key passed as the second parameter * * @param String plainText is the text which is to be encrypted * @param String key is the key which is to be used for generating cipher text * @return String cipherText is the encrypted value */ String encrypt(String plainText, String key) { // generating key keyGenerate(key); for (int i = 0; i < 16; i++) { plainText = round(i, plainText); } // postprocessing String right = plainText.substring(0, 8); String left = plainText.substring(8, 16); right = xor(right, subKeys[16]); left = xor(left, subKeys[17]); return left + right; } /** * This method returns plaintext for the ciphertext passed as the first parameter decoded * using the key passed as the second parameter * * @param String ciphertext is the text which is to be decrypted * @param String key is the key which is to be used for generating cipher text * @return String plainText is the decrypted text */ String decrypt(String cipherText, String key) { // generating key keyGenerate(key); for (int i = 17; i > 1; i--) { cipherText = round(i, cipherText); } // postprocessing String right = cipherText.substring(0, 8); String left = cipherText.substring(8, 16); right = xor(right, subKeys[1]); left = xor(left, subKeys[0]); return left + right; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class BoardPath { private BoardPath() { } public static int bpR(int n, int n2) { if (n == n2) { return 1; } if (n > n2) { return 0; } int n3 = 0; for (int i = 1; i <= 6; ++i) { n3 += BoardPath.bpR(n + i, n2); } return n3; } public static int bpRS(int n, int n2, int[] nArray) { if (n == n2) { return 1; } if (n > n2) { return 0; } if (nArray[n] != 0) { return nArray[n]; } int n3 = 0; for (int i = 1; i <= 6; ++i) { n3 += BoardPath.bpRS(n + i, n2, nArray); } nArray[n] = n3; return n3; } public static int bpIS(int n, int n2, int[] nArray) { nArray[n2] = 1; for (int i = n2 - 1; i >= 0; --i) { int n3 = 0; for (int j = 1; j <= 6 && j + i <= n2; ++j) { n3 += nArray[i + j]; } nArray[i] = n3; } return nArray[n]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; public final class BoardPath { private BoardPath() { } /** * Recursive solution without memoization * * @param start - the current position * @param end - the target position * @return the number of ways to reach the end from the start */ public static int bpR(int start, int end) { if (start == end) { return 1; } else if (start > end) { return 0; } int count = 0; for (int dice = 1; dice <= 6; dice++) { count += bpR(start + dice, end); } return count; } /** * Recursive solution with memoization * * @param curr - the current position * @param end - the target position * @param strg - memoization array * @return the number of ways to reach the end from the start */ public static int bpRS(int curr, int end, int[] strg) { if (curr == end) { return 1; } else if (curr > end) { return 0; } if (strg[curr] != 0) { return strg[curr]; } int count = 0; for (int dice = 1; dice <= 6; dice++) { count += bpRS(curr + dice, end, strg); } strg[curr] = count; return count; } /** * Iterative solution with tabulation * * @param curr - the current position (always starts from 0) * @param end - the target position * @param strg - memoization array * @return the number of ways to reach the end from the start */ public static int bpIS(int curr, int end, int[] strg) { strg[end] = 1; for (int i = end - 1; i >= 0; i--) { int count = 0; for (int dice = 1; dice <= 6 && dice + i <= end; dice++) { count += strg[i + dice]; } strg[i] = count; } return strg[curr]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; import java.util.Random; public class BogoSort implements SortAlgorithm { private static final Random a = new Random(); @Override public Comparable[] sort(Comparable[] comparableArray) { block0: while (true) { boolean bl; int n; Object[] objectArray; block3: { objectArray = comparableArray; for (n = 0; n < objectArray.length - 1; ++n) { if (!SortUtils.less(objectArray[n + 1], objectArray[n])) continue; bl = false; break block3; } bl = true; } if (bl) break; objectArray = comparableArray; n = comparableArray.length; int n2 = 0; while (true) { if (n2 >= objectArray.length) continue block0; int n3 = n2 + a.nextInt(n - n2); SortUtils.swap(objectArray, n3, n2); ++n2; } break; } return comparableArray; } public static void main(String[] objectArray) { objectArray = new Integer[]{4, 23, 6, 78, 1, 54, 231, 9, 12}; BogoSort bogoSort = new BogoSort(); SortUtils.a((Integer[])bogoSort.sort((Comparable[])objectArray)); objectArray = new String[]{\"c\", \"a\", \"e\", \"b\", \"d\"}; SortUtils.a((String[])bogoSort.sort((Comparable[])objectArray)); } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.Random; /** * @author Podshivalov Nikita (https://github.com/nikitap492) * @see SortAlgorithm */ public class BogoSort implements SortAlgorithm { private static final Random RANDOM = new Random(); private static <T extends Comparable<T>> boolean isSorted(T[] array) { for (int i = 0; i < array.length - 1; i++) { if (SortUtils.less(array[i + 1], array[i])) { return false; } } return true; } // Randomly shuffles the array private static <T> void nextPermutation(T[] array) { int length = array.length; for (int i = 0; i < array.length; i++) { int randomIndex = i + RANDOM.nextInt(length - i); SortUtils.swap(array, randomIndex, i); } } public <T extends Comparable<T>> T[] sort(T[] array) { while (!isSorted(array)) { nextPermutation(array); } return array; } // Driver Program public static void main(String[] args) { // Integer Input Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12}; BogoSort bogoSort = new BogoSort(); // print a sorted array SortUtils.print(bogoSort.sort(integers)); // String Input String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"}; SortUtils.print(bogoSort.sort(strings)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$BooleanGate; import java.util.List; class BooleanAlgebraGates$ANDGate implements BooleanAlgebraGates$BooleanGate { BooleanAlgebraGates$ANDGate() { } @Override public boolean evaluate(List object) { object = object.iterator(); while (object.hasNext()) { boolean bl = (Boolean)object.next(); if (bl) continue; return false; } return true; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$BooleanGate; import java.util.List; class BooleanAlgebraGates$ANDGate implements BooleanAlgebraGates$BooleanGate { BooleanAlgebraGates$ANDGate() { } @Override public boolean evaluate(List object) { object = object.iterator(); while (object.hasNext()) { boolean bl = (Boolean)object.next(); if (bl) continue; return false; } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import java.util.List; interface BooleanAlgebraGates$BooleanGate { public boolean evaluate(List var1); }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import java.util.List; interface BooleanAlgebraGates$BooleanGate { public boolean evaluate(List var1); }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$ANDGate; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$BooleanGate; import java.util.List; class BooleanAlgebraGates$NANDGate implements BooleanAlgebraGates$BooleanGate { BooleanAlgebraGates$NANDGate() { } @Override public boolean evaluate(List list) { return !new BooleanAlgebraGates$ANDGate().evaluate(list); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$ANDGate; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$BooleanGate; import java.util.List; class BooleanAlgebraGates$NANDGate implements BooleanAlgebraGates$BooleanGate { BooleanAlgebraGates$NANDGate() { } @Override public boolean evaluate(List list) { return !new BooleanAlgebraGates$ANDGate().evaluate(list); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$BooleanGate; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$ORGate; import java.util.List; class BooleanAlgebraGates$NORGate implements BooleanAlgebraGates$BooleanGate { BooleanAlgebraGates$NORGate() { } @Override public boolean evaluate(List list) { return !new BooleanAlgebraGates$ORGate().evaluate(list); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$BooleanGate; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$ORGate; import java.util.List; class BooleanAlgebraGates$NORGate implements BooleanAlgebraGates$BooleanGate { BooleanAlgebraGates$NORGate() { } @Override public boolean evaluate(List list) { return !new BooleanAlgebraGates$ORGate().evaluate(list); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; class BooleanAlgebraGates$NOTGate { BooleanAlgebraGates$NOTGate() { } public boolean evaluate(boolean bl) { return !bl; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; class BooleanAlgebraGates$NOTGate { BooleanAlgebraGates$NOTGate() { } public boolean evaluate(boolean bl) { return !bl; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$BooleanGate; import java.util.List; class BooleanAlgebraGates$ORGate implements BooleanAlgebraGates$BooleanGate { BooleanAlgebraGates$ORGate() { } @Override public boolean evaluate(List object) { object = object.iterator(); while (object.hasNext()) { boolean bl = (Boolean)object.next(); if (!bl) continue; return true; } return false; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$BooleanGate; import java.util.List; class BooleanAlgebraGates$ORGate implements BooleanAlgebraGates$BooleanGate { BooleanAlgebraGates$ORGate() { } @Override public boolean evaluate(List object) { object = object.iterator(); while (object.hasNext()) { boolean bl = (Boolean)object.next(); if (!bl) continue; return true; } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$BooleanGate; import java.util.List; class BooleanAlgebraGates$XORGate implements BooleanAlgebraGates$BooleanGate { BooleanAlgebraGates$XORGate() { } @Override public boolean evaluate(List object) { boolean bl = false; object = object.iterator(); while (object.hasNext()) { boolean bl2 = (Boolean)object.next(); bl ^= bl2; } return bl; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import com.thealgorithms.bitmanipulation.BooleanAlgebraGates$BooleanGate; import java.util.List; class BooleanAlgebraGates$XORGate implements BooleanAlgebraGates$BooleanGate { BooleanAlgebraGates$XORGate() { } @Override public boolean evaluate(List object) { boolean bl = false; object = object.iterator(); while (object.hasNext()) { boolean bl2 = (Boolean)object.next(); bl ^= bl2; } return bl; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class BooleanAlgebraGates { private BooleanAlgebraGates() { } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; import java.util.List; /** * Implements various Boolean algebra gates (AND, OR, NOT, XOR, NAND, NOR) */ public final class BooleanAlgebraGates { private BooleanAlgebraGates() { // Prevent instantiation } /** * Represents a Boolean gate that takes multiple inputs and returns a result. */ interface BooleanGate { /** * Evaluates the gate with the given inputs. * * @param inputs The input values for the gate. * @return The result of the evaluation. */ boolean evaluate(List<Boolean> inputs); } /** * AND Gate implementation. * Returns true if all inputs are true; otherwise, false. */ static class ANDGate implements BooleanGate { @Override public boolean evaluate(List<Boolean> inputs) { for (boolean input : inputs) { if (!input) { return false; } } return true; } } /** * OR Gate implementation. * Returns true if at least one input is true; otherwise, false. */ static class ORGate implements BooleanGate { @Override public boolean evaluate(List<Boolean> inputs) { for (boolean input : inputs) { if (input) { return true; } } return false; } } /** * NOT Gate implementation (Unary operation). * Negates a single input value. */ static class NOTGate { /** * Evaluates the negation of the input. * * @param input The input value to be negated. * @return The negated value. */ public boolean evaluate(boolean input) { return !input; } } /** * XOR Gate implementation. * Returns true if an odd number of inputs are true; otherwise, false. */ static class XORGate implements BooleanGate { @Override public boolean evaluate(List<Boolean> inputs) { boolean result = false; for (boolean input : inputs) { result ^= input; } return result; } } /** * NAND Gate implementation. * Returns true if at least one input is false; otherwise, false. */ static class NANDGate implements BooleanGate { @Override public boolean evaluate(List<Boolean> inputs) { return !new ANDGate().evaluate(inputs); // Equivalent to negation of AND } } /** * NOR Gate implementation. * Returns true if all inputs are false; otherwise, false. */ static class NORGate implements BooleanGate { @Override public boolean evaluate(List<Boolean> inputs) { return !new ORGate().evaluate(inputs); // Equivalent to negation of OR } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class BoruvkaAlgorithm$BoruvkaState { }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class BoruvkaAlgorithm$BoruvkaState { }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class BoruvkaAlgorithm$Component { }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class BoruvkaAlgorithm$Component { }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class BoruvkaAlgorithm$Edge { }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class BoruvkaAlgorithm$Edge { }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class BoruvkaAlgorithm$Graph { }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class BoruvkaAlgorithm$Graph { }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; final class BoruvkaAlgorithm { private BoruvkaAlgorithm() { } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.List; /** * Boruvka's algorithm to find Minimum Spanning Tree * (https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm) * * @author itakurah (https://github.com/itakurah) */ final class BoruvkaAlgorithm { private BoruvkaAlgorithm() { } /** * Represents an edge in the graph */ static class Edge { final int src; final int dest; final int weight; Edge(final int src, final int dest, final int weight) { this.src = src; this.dest = dest; this.weight = weight; } } /** * Represents the graph */ static class Graph { final int vertex; final List<Edge> edges; /** * Constructor for the graph * * @param vertex number of vertices * @param edges list of edges */ Graph(final int vertex, final List<Edge> edges) { if (vertex < 0) { throw new IllegalArgumentException(\"Number of vertices must be positive\"); } if (edges == null || edges.isEmpty()) { throw new IllegalArgumentException(\"Edges list must not be null or empty\"); } for (final var edge : edges) { checkEdgeVertices(edge.src, vertex); checkEdgeVertices(edge.dest, vertex); } this.vertex = vertex; this.edges = edges; } } /** * Represents a subset for Union-Find operations */ private static class Component { int parent; int rank; Component(final int parent, final int rank) { this.parent = parent; this.rank = rank; } } /** * Represents the state of Union-Find components and the result list */ private static class BoruvkaState { List<Edge> result; Component[] components; final Graph graph; BoruvkaState(final Graph graph) { this.result = new ArrayList<>(); this.components = initializeComponents(graph); this.graph = graph; } /** * Adds the cheapest edges to the result list and performs Union operation on the subsets. * * @param cheapest Array containing the cheapest edge for each subset. */ void merge(final Edge[] cheapest) { for (int i = 0; i < graph.vertex; ++i) { if (cheapest[i] != null) { final var component1 = find(components, cheapest[i].src); final var component2 = find(components, cheapest[i].dest); if (component1 != component2) { result.add(cheapest[i]); union(components, component1, component2); } } } } /** * Checks if there are more edges to add to the result list * * @return true if there are more edges to add, false otherwise */ boolean hasMoreEdgesToAdd() { return result.size() < graph.vertex - 1; } /** * Computes the cheapest edges for each subset in the Union-Find structure. * * @return an array containing the cheapest edge for each subset. */ private Edge[] computeCheapestEdges() { Edge[] cheapest = new Edge[graph.vertex]; for (final var edge : graph.edges) { final var set1 = find(components, edge.src); final var set2 = find(components, edge.dest); if (set1 != set2) { if (cheapest[set1] == null || edge.weight < cheapest[set1].weight) { cheapest[set1] = edge; } if (cheapest[set2] == null || edge.weight < cheapest[set2].weight) { cheapest[set2] = edge; } } } return cheapest; } /** * Initializes subsets for Union-Find * * @param graph the graph * @return the initialized subsets */ private static Component[] initializeComponents(final Graph graph) { Component[] components = new Component[graph.vertex]; for (int v = 0; v < graph.vertex; ++v) { components[v] = new Component(v, 0); } return components; } } /** * Finds the parent of the subset using path compression * * @param components array of subsets * @param i index of the subset * @return the parent of the subset */ static int find(final Component[] components, final int i) { if (components[i].parent != i) { components[i].parent = find(components, components[i].parent); } return components[i].parent; } /** * Performs the Union operation for Union-Find * * @param components array of subsets * @param x index of the first subset * @param y index of the second subset */ static void union(Component[] components, final int x, final int y) { final int xroot = find(components, x); final int yroot = find(components, y); if (components[xroot].rank < components[yroot].rank) { components[xroot].parent = yroot; } else if (components[xroot].rank > components[yroot].rank) { components[yroot].parent = xroot; } else { components[yroot].parent = xroot; components[xroot].rank++; } } /** * Boruvka's algorithm to find the Minimum Spanning Tree * * @param graph the graph * @return list of edges in the Minimum Spanning Tree */ static List<Edge> boruvkaMST(final Graph graph) { var boruvkaState = new BoruvkaState(graph); while (boruvkaState.hasMoreEdgesToAdd()) { final var cheapest = boruvkaState.computeCheapestEdges(); boruvkaState.merge(cheapest); } return boruvkaState.result; } /** * Checks if the edge vertices are in a valid range * * @param vertex the vertex to check * @param upperBound the upper bound for the vertex range */ private static void checkEdgeVertices(final int vertex, final int upperBound) { if (vertex < 0 || vertex >= upperBound) { throw new IllegalArgumentException(\"Edge vertex out of range\"); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class BoundaryFill { private BoundaryFill() { } public static int getPixel(int[][] nArray, int n, int n2) { return nArray[n][n2]; } public static void putPixel(int[][] nArray, int n, int n2, int n3) { nArray[n][n2] = n3; } public static void boundaryFill(int[][] nArray, int n, int n2, int n3, int n4) { while (n >= 0 && n2 >= 0 && BoundaryFill.getPixel(nArray, n, n2) != n3 && BoundaryFill.getPixel(nArray, n, n2) != n4) { BoundaryFill.putPixel(nArray, n, n2, n3); BoundaryFill.boundaryFill(nArray, n + 1, n2, n3, n4); BoundaryFill.boundaryFill(nArray, n - 1, n2, n3, n4); BoundaryFill.boundaryFill(nArray, n, n2 + 1, n3, n4); BoundaryFill.boundaryFill(nArray, n, n2 - 1, n3, n4); BoundaryFill.boundaryFill(nArray, n + 1, n2 - 1, n3, n4); BoundaryFill.boundaryFill(nArray, n - 1, n2 + 1, n3, n4); BoundaryFill.boundaryFill(nArray, n + 1, n2 + 1, n3, n4); --n2; --n; } } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Java program for Boundary fill algorithm. * @author Akshay Dubey (https://github.com/itsAkshayDubey) */ public final class BoundaryFill { private BoundaryFill() { } /** * Get the color at the given co-odrinates of a 2D image * * @param image The image to be filled * @param xCoordinate The x co-ordinate of which color is to be obtained * @param yCoordinate The y co-ordinate of which color is to be obtained */ public static int getPixel(int[][] image, int xCoordinate, int yCoordinate) { return image[xCoordinate][yCoordinate]; } /** * Put the color at the given co-odrinates of a 2D image * * @param image The image to be filed * @param xCoordinate The x co-ordinate at which color is to be filled * @param yCoordinate The y co-ordinate at which color is to be filled */ public static void putPixel(int[][] image, int xCoordinate, int yCoordinate, int newColor) { image[xCoordinate][yCoordinate] = newColor; } /** * Fill the 2D image with new color * * @param image The image to be filed * @param xCoordinate The x co-ordinate at which color is to be filled * @param yCoordinate The y co-ordinate at which color is to be filled * @param newColor The new color which to be filled in the image * @param boundaryColor The old color which is to be replaced in the image */ public static void boundaryFill(int[][] image, int xCoordinate, int yCoordinate, int newColor, int boundaryColor) { if (xCoordinate >= 0 && yCoordinate >= 0 && getPixel(image, xCoordinate, yCoordinate) != newColor && getPixel(image, xCoordinate, yCoordinate) != boundaryColor) { putPixel(image, xCoordinate, yCoordinate, newColor); boundaryFill(image, xCoordinate + 1, yCoordinate, newColor, boundaryColor); boundaryFill(image, xCoordinate - 1, yCoordinate, newColor, boundaryColor); boundaryFill(image, xCoordinate, yCoordinate + 1, newColor, boundaryColor); boundaryFill(image, xCoordinate, yCoordinate - 1, newColor, boundaryColor); boundaryFill(image, xCoordinate + 1, yCoordinate - 1, newColor, boundaryColor); boundaryFill(image, xCoordinate - 1, yCoordinate + 1, newColor, boundaryColor); boundaryFill(image, xCoordinate + 1, yCoordinate + 1, newColor, boundaryColor); boundaryFill(image, xCoordinate - 1, yCoordinate - 1, newColor, boundaryColor); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; public final class BoundaryTraversal { private BoundaryTraversal() { } public static List boundaryTraversal(BinaryTree$Node object) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); if (object == null) { return arrayList; } if (!BoundaryTraversal.a((BinaryTree$Node)object)) { arrayList.add(((BinaryTree$Node)object).data); } ArrayList<Integer> arrayList2 = arrayList; BinaryTree$Node binaryTree$Node = object; BinaryTree$Node binaryTree$Node2 = binaryTree$Node.left; if (binaryTree$Node2 == null && binaryTree$Node.right != null) { binaryTree$Node2 = binaryTree$Node.right; } while (binaryTree$Node2 != null) { if (!BoundaryTraversal.a(binaryTree$Node2)) { arrayList2.add(binaryTree$Node2.data); } if (binaryTree$Node2.left != null) { binaryTree$Node2 = binaryTree$Node2.left; continue; } if (binaryTree$Node2.right == null) break; binaryTree$Node2 = binaryTree$Node2.right; } BoundaryTraversal.a((BinaryTree$Node)object, arrayList); arrayList2 = arrayList; binaryTree$Node = object; binaryTree$Node2 = binaryTree$Node.right; object = new ArrayList(); if (binaryTree$Node2 == null || binaryTree$Node.left != null) { while (binaryTree$Node2 != null) { if (!BoundaryTraversal.a(binaryTree$Node2)) { object.add(binaryTree$Node2.data); } if (binaryTree$Node2.right != null) { binaryTree$Node2 = binaryTree$Node2.right; continue; } if (binaryTree$Node2.left == null) break; binaryTree$Node2 = binaryTree$Node2.left; } for (int i = object.size() - 1; i >= 0; --i) { arrayList2.add((Integer)object.get(i)); } } return arrayList; } private static void a(BinaryTree$Node binaryTree$Node, List list) { while (binaryTree$Node != null) { if (BoundaryTraversal.a(binaryTree$Node)) { list.add(binaryTree$Node.data); return; } BoundaryTraversal.a(binaryTree$Node.left, list); binaryTree$Node = binaryTree$Node.right; } return; } private static boolean a(BinaryTree$Node binaryTree$Node) { return binaryTree$Node.left == null && binaryTree$Node.right == null; } public static List iterativeBoundaryTraversal(BinaryTree$Node binaryTree$Node) { BinaryTree$Node binaryTree$Node2; ArrayList<Integer> arrayList = new ArrayList<Integer>(); if (binaryTree$Node == null) { return arrayList; } if (!BoundaryTraversal.a(binaryTree$Node)) { arrayList.add(binaryTree$Node.data); } if ((binaryTree$Node2 = binaryTree$Node.left) == null && binaryTree$Node.right != null) { binaryTree$Node2 = binaryTree$Node.right; } while (binaryTree$Node2 != null) { if (!BoundaryTraversal.a(binaryTree$Node2)) { arrayList.add(binaryTree$Node2.data); } binaryTree$Node2 = binaryTree$Node2.left != null ? binaryTree$Node2.left : binaryTree$Node2.right; } BoundaryTraversal.a(binaryTree$Node, arrayList); binaryTree$Node2 = binaryTree$Node.right; LinkedList<Integer> linkedList = new LinkedList<Integer>(); if (binaryTree$Node2 != null && binaryTree$Node.left == null) { return arrayList; } while (binaryTree$Node2 != null) { if (!BoundaryTraversal.a(binaryTree$Node2)) { linkedList.push(binaryTree$Node2.data); } binaryTree$Node2 = binaryTree$Node2.right != null ? binaryTree$Node2.right : binaryTree$Node2.left; } while (!linkedList.isEmpty()) { arrayList.add((Integer)linkedList.pop()); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayList; import java.util.Deque; import java.util.LinkedList; import java.util.List; /** * BoundaryTraversal * <p> * Start with the Root: * Add the root node to the boundary list. * Traverse the Left Boundary (Excluding Leaf Nodes): * Move down the left side of the tree, adding each non-leaf node to the boundary list. * If a node has a left child, go left; otherwise, go right. * Visit All Leaf Nodes: * Traverse the tree and add all leaf nodes to the boundary list, from left to right. * Traverse the Right Boundary (Excluding Leaf Nodes) in Reverse Order: * Move up the right side of the tree, adding each non-leaf node to a temporary list. * If a node has a right child, go right; otherwise, go left. * Reverse the temporary list and add it to the boundary list. * Combine and Output: * The final boundary list contains the root, left boundary, leaf nodes, and reversed right boundary in that order. */ public final class BoundaryTraversal { private BoundaryTraversal() { } // Main function for boundary traversal, returns a list of boundary nodes in order public static List<Integer> boundaryTraversal(BinaryTree.Node root) { List<Integer> result = new ArrayList<>(); if (root == null) { return result; } // Add root node if it's not a leaf node if (!isLeaf(root)) { result.add(root.data); } // Add left boundary addLeftBoundary(root, result); // Add leaf nodes addLeaves(root, result); // Add right boundary addRightBoundary(root, result); return result; } // Adds the left boundary, including nodes that have no left child but have a right child private static void addLeftBoundary(BinaryTree.Node node, List<Integer> result) { BinaryTree.Node cur = node.left; // If there is no left child but there is a right child, treat the right child as part of the left boundary if (cur == null && node.right != null) { cur = node.right; } while (cur != null) { if (!isLeaf(cur)) { result.add(cur.data); // Add non-leaf nodes to result } if (cur.left != null) { cur = cur.left; // Move to the left child } else if (cur.right != null) { cur = cur.right; // If left child is null, move to the right child } else { break; // Stop if there are no children } } } // Adds leaf nodes (nodes without children) private static void addLeaves(BinaryTree.Node node, List<Integer> result) { if (node == null) { return; } if (isLeaf(node)) { result.add(node.data); // Add leaf node } else { addLeaves(node.left, result); // Recur for left subtree addLeaves(node.right, result); // Recur for right subtree } } // Adds the right boundary, excluding leaf nodes private static void addRightBoundary(BinaryTree.Node node, List<Integer> result) { BinaryTree.Node cur = node.right; List<Integer> temp = new ArrayList<>(); // If no right boundary is present and there is no left subtree, skip if (cur != null && node.left == null) { return; } while (cur != null) { if (!isLeaf(cur)) { temp.add(cur.data); // Store non-leaf nodes temporarily } if (cur.right != null) { cur = cur.right; // Move to the right child } else if (cur.left != null) { cur = cur.left; // If right child is null, move to the left child } else { break; // Stop if there are no children } } // Add the right boundary nodes in reverse order for (int i = temp.size() - 1; i >= 0; i--) { result.add(temp.get(i)); } } // Checks if a node is a leaf node private static boolean isLeaf(BinaryTree.Node node) { return node.left == null && node.right == null; } // Iterative boundary traversal public static List<Integer> iterativeBoundaryTraversal(BinaryTree.Node root) { List<Integer> result = new ArrayList<>(); if (root == null) { return result; } // Add root node if it's not a leaf node if (!isLeaf(root)) { result.add(root.data); } // Handle the left boundary BinaryTree.Node cur = root.left; if (cur == null && root.right != null) { cur = root.right; } while (cur != null) { if (!isLeaf(cur)) { result.add(cur.data); // Add non-leaf nodes to result } cur = (cur.left != null) ? cur.left : cur.right; // Prioritize left child, move to right if left is null } // Add leaf nodes addLeaves(root, result); // Handle the right boundary using a stack (reverse order) cur = root.right; Deque<Integer> stack = new LinkedList<>(); if (cur != null && root.left == null) { return result; } while (cur != null) { if (!isLeaf(cur)) { stack.push(cur.data); // Temporarily store right boundary nodes in a stack } cur = (cur.right != null) ? cur.right : cur.left; // Prioritize right child, move to left if right is null } // Add the right boundary nodes from the stack to maintain the correct order while (!stack.isEmpty()) { result.add(stack.pop()); } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.Point; class BoundingBox { public Point center; public double halfWidth; BoundingBox(Point point, double d) { this.center = point; this.halfWidth = d; } public boolean containsPoint(Point point) { return point.x >= this.center.x - this.halfWidth && point.x <= this.center.x + this.halfWidth && point.y >= this.center.y - this.halfWidth && point.y <= this.center.y + this.halfWidth; } public boolean intersectsBoundingBox(BoundingBox boundingBox) { return boundingBox.center.x - boundingBox.halfWidth <= this.center.x + this.halfWidth && boundingBox.center.x + boundingBox.halfWidth >= this.center.x - this.halfWidth && boundingBox.center.y - boundingBox.halfWidth <= this.center.y + this.halfWidth && boundingBox.center.y + boundingBox.halfWidth >= this.center.y - this.halfWidth; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.Point; class BoundingBox { public Point center; public double halfWidth; BoundingBox(Point point, double d) { this.center = point; this.halfWidth = d; } public boolean containsPoint(Point point) { return point.x >= this.center.x - this.halfWidth && point.x <= this.center.x + this.halfWidth && point.y >= this.center.y - this.halfWidth && point.y <= this.center.y + this.halfWidth; } public boolean intersectsBoundingBox(BoundingBox boundingBox) { return boundingBox.center.x - boundingBox.halfWidth <= this.center.x + this.halfWidth && boundingBox.center.x + boundingBox.halfWidth >= this.center.x - this.halfWidth && boundingBox.center.y - boundingBox.halfWidth <= this.center.y + this.halfWidth && boundingBox.center.y + boundingBox.halfWidth >= this.center.y - this.halfWidth; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; public class BoyerMoore { private final int a; private final int[] b; private final String c; public BoyerMoore(String string) { int n; this.c = string; this.a = 256; this.b = new int[this.a]; for (n = 0; n < this.a; ++n) { this.b[n] = -1; } for (n = 0; n < string.length(); ++n) { this.b[string.charAt((int)n)] = n; } } public int search(String string) { int n; if (this.c.isEmpty()) { return 0; } int n2 = this.c.length(); int n3 = string.length(); for (int i = 0; i <= n3 - n2; i += n) { n = 0; for (int j = n2 - 1; j >= 0; --j) { char c = string.charAt(i + j); char c2 = this.c.charAt(j); if (c2 == c) continue; n = Math.max(1, j - this.b[c]); break; } if (n != 0) continue; return i; } return -1; } public static int staticSearch(String string, String string2) { return new BoyerMoore(string2).search(string); } }", "deobfuscated_code": "package com.thealgorithms.searches; /** * Boyer-Moore string search algorithm. * Efficient algorithm for substring search. * https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm */ public class BoyerMoore { private final int radix; // Radix (number of possible characters) private final int[] right; // Bad character rule table private final String pattern; public BoyerMoore(String pat) { this.pattern = pat; this.radix = 256; this.right = new int[radix]; for (int c = 0; c < radix; c++) { right[c] = -1; } for (int j = 0; j < pat.length(); j++) { right[pat.charAt(j)] = j; } } public int search(String text) { if (pattern.isEmpty()) { return 0; } int m = pattern.length(); int n = text.length(); int skip; for (int i = 0; i <= n - m; i += skip) { skip = 0; for (int j = m - 1; j >= 0; j--) { char txtChar = text.charAt(i + j); char patChar = pattern.charAt(j); if (patChar != txtChar) { skip = Math.max(1, j - right[txtChar]); break; } } if (skip == 0) { return i; // Match found } } return -1; // No match } public static int staticSearch(String text, String pattern) { return new BoyerMoore(pattern).search(text); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.datastructures.Node; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Optional; import java.util.Set; public class BreadthFirstSearch { private final List a = new ArrayList(); private final Set b = new HashSet(); public Optional search(Node object, Object object2) { if (object == null) { return Optional.empty(); } this.a.add(((Node)object).getValue()); this.b.add(((Node)object).getValue()); if (((Node)object).getValue() == object2) { return Optional.of(object); } object = new ArrayDeque(((Node)object).getChildren()); while (!object.isEmpty()) { Node node = (Node)object.poll(); Object object3 = node.getValue(); if (this.b.contains(object3)) continue; this.a.add(object3); this.b.add(object3); if (object3 == object2 || object2 != null && object2.equals(object3)) { return Optional.of(node); } object.addAll(node.getChildren()); } return Optional.empty(); } public List getVisited() { return this.a; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.datastructures.Node; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Optional; import java.util.Queue; import java.util.Set; /** * Breadth-First Search implementation for tree/graph traversal. * @author caos321 * @co-author @manishraj27 * @see <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Breadth-first search</a> */ public class BreadthFirstSearch<T> { private final List<T> visited = new ArrayList<>(); private final Set<T> visitedSet = new HashSet<>(); /** * Performs a breadth-first search to find a node with the given value. * * @param root The root node to start the search from * @param value The value to search for * @return Optional containing the found node, or empty if not found */ public Optional<Node<T>> search(final Node<T> root, final T value) { if (root == null) { return Optional.empty(); } visited.add(root.getValue()); visitedSet.add(root.getValue()); if (root.getValue() == value) { return Optional.of(root); } Queue<Node<T>> queue = new ArrayDeque<>(root.getChildren()); while (!queue.isEmpty()) { final Node<T> current = queue.poll(); T currentValue = current.getValue(); if (visitedSet.contains(currentValue)) { continue; } visited.add(currentValue); visitedSet.add(currentValue); if (currentValue == value || (value != null && value.equals(currentValue))) { return Optional.of(current); } queue.addAll(current.getChildren()); } return Optional.empty(); } /** * Returns the list of nodes in the order they were visited. * * @return List containing the visited nodes */ public List<T> getVisited() { return visited; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.geometry; import java.awt.Point; import java.util.ArrayList; import java.util.List; public final class BresenhamLine { private BresenhamLine() { } public static List findLine(int n, int n2, int n3, int n4) { ArrayList<Point> arrayList = new ArrayList<Point>(); int n5 = Math.abs(n3 - n); int n6 = Math.abs(n4 - n2); int n7 = n < n3 ? 1 : -1; int n8 = n2 < n4 ? 1 : -1; int n9 = n5 - n6; while (true) { arrayList.add(new Point(n, n2)); if (n == n3 && n2 == n4) break; int n10 = n9 << 1; if (n10 > -n6) { n9 -= n6; n += n7; } if (n10 >= n5) continue; n9 += n5; n2 += n8; } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.geometry; import java.awt.Point; import java.util.ArrayList; import java.util.List; /** * The {@code BresenhamLine} class implements the Bresenham's line algorithm, * which is an efficient way to determine the points of a straight line * between two given points in a 2D space. * * <p>This algorithm uses integer arithmetic to calculate the points, * making it suitable for rasterization in computer graphics.</p> * * For more information, please visit {@link https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm} */ public final class BresenhamLine { private BresenhamLine() { // Private constructor to prevent instantiation. } /** * Finds the list of points that form a straight line between two endpoints. * * @param x0 the x-coordinate of the starting point * @param y0 the y-coordinate of the starting point * @param x1 the x-coordinate of the ending point * @param y1 the y-coordinate of the ending point * @return a {@code List<Point>} containing all points on the line */ public static List<Point> findLine(int x0, int y0, int x1, int y1) { List<Point> line = new ArrayList<>(); // Calculate differences and steps for each axis int dx = Math.abs(x1 - x0); // Change in x int dy = Math.abs(y1 - y0); // Change in y int sx = (x0 < x1) ? 1 : -1; // Step in x direction int sy = (y0 < y1) ? 1 : -1; // Step in y direction int err = dx - dy; // Initial error term // Loop until we reach the endpoint while (true) { line.add(new Point(x0, y0)); // Add current point to the line // Check if we've reached the endpoint if (x0 == x1 && y0 == y1) { break; // Exit loop if endpoint is reached } // Calculate error term doubled for decision making final int e2 = err * 2; // Adjust x coordinate if necessary if (e2 > -dy) { err -= dy; // Update error term x0 += sx; // Move to next point in x direction } // Adjust y coordinate if necessary if (e2 < dx) { err += dx; // Update error term y0 += sy; // Move to next point in y direction } } return line; // Return the list of points forming the line } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Scanner; public final class BrianKernighanAlgorithm { private BrianKernighanAlgorithm() { } public static void main(String[] object) { object = new Scanner(System.in); int n = ((Scanner)object).nextInt(); int n2 = 0; while (n != 0) { int n3 = n; n = n3 & n3 - 1; ++n2; } n = n2; System.out.println(n); ((Scanner)object).close(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Scanner; /** * @author Nishita Aggarwal * <p> * Brian Kernighans Algorithm * <p> * algorithm to count the number of set bits in a given number * <p> * Subtraction of 1 from a number toggles all the bits (from right to left) till * the rightmost set bit(including the rightmost set bit). So if we subtract a * number by 1 and do bitwise & with itself i.e. (n & (n-1)), we unset the * rightmost set bit. * <p> * If we do n & (n-1) in a loop and count the no of times loop executes we get * the set bit count. * <p> * <p> * Time Complexity: O(logn) */ public final class BrianKernighanAlgorithm { private BrianKernighanAlgorithm() { } /** * @param num: number in which we count the set bits * @return int: Number of set bits */ static int countSetBits(int num) { int cnt = 0; while (num != 0) { num = num & (num - 1); cnt++; } return cnt; } /** * @param args : command line arguments */ public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = sc.nextInt(); int setBitCount = countSetBits(num); System.out.println(setBitCount); sc.close(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class BruteForceKnapsack { private BruteForceKnapsack() { } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * A naive recursive implementation of the 0-1 Knapsack problem. * * <p>The 0-1 Knapsack problem is a classic optimization problem where you are * given a set of items, each with a weight and a value, and a knapsack with a * fixed capacity. The goal is to determine the maximum value that can be * obtained by selecting a subset of the items such that the total weight does * not exceed the knapsack's capacity. Each item can either be included (1) or * excluded (0), hence the name \"0-1\" Knapsack.</p> * * <p>This class provides a brute-force recursive approach to solving the * problem. It evaluates all possible combinations of items to find the optimal * solution, but this approach has exponential time complexity and is not * suitable for large input sizes.</p> * * <p><b>Time Complexity:</b> O(2^n), where n is the number of items.</p> * * <p><b>Space Complexity:</b> O(n), due to the recursive function call stack.</p> */ public final class BruteForceKnapsack { private BruteForceKnapsack() { } /** * Solves the 0-1 Knapsack problem using a recursive brute-force approach. * * @param w the total capacity of the knapsack * @param wt an array where wt[i] represents the weight of the i-th item * @param val an array where val[i] represents the value of the i-th item * @param n the number of items available for selection * @return the maximum value that can be obtained with the given capacity * * <p>The function uses recursion to explore all possible subsets of items. * For each item, it has two choices: either include it in the knapsack * (if it fits) or exclude it. It returns the maximum value obtainable * through these two choices.</p> * * <p><b>Base Cases:</b> * <ul> * <li>If no items are left (n == 0), the maximum value is 0.</li> * <li>If the knapsack's remaining capacity is 0 (w == 0), no more items can * be included, and the value is 0.</li> * </ul></p> * * <p><b>Recursive Steps:</b> * <ul> * <li>If the weight of the n-th item exceeds the current capacity, it is * excluded from the solution, and the function proceeds with the remaining * items.</li> * <li>Otherwise, the function considers two possibilities: include the n-th * item or exclude it, and returns the maximum value of these two scenarios.</li> * </ul></p> */ static int knapSack(int w, int[] wt, int[] val, int n) { if (n == 0 || w == 0) { return 0; } if (wt[n - 1] > w) { return knapSack(w, wt, val, n - 1); } else { return Math.max(knapSack(w, wt, val, n - 1), val[n - 1] + knapSack(w - wt[n - 1], wt, val, n - 1)); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; class BubbleSort implements SortAlgorithm { BubbleSort() { } @Override public Comparable[] sort(Comparable[] comparableArray) { int n = comparableArray.length; for (int i = 1; i < n; ++i) { boolean bl = false; for (int j = 0; j < n - i; ++j) { if (!SortUtils.greater(comparableArray[j], comparableArray[j + 1])) continue; int n2 = j; SortUtils.swap(comparableArray, n2, n2 + 1); bl = true; } if (!bl) break; } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * @author Varun Upadhyay (https://github.com/varunu28) * @author Podshivalov Nikita (https://github.com/nikitap492) * @see SortAlgorithm */ class BubbleSort implements SortAlgorithm { /** * Implements generic bubble sort algorithm. * * @param array the array to be sorted. * @param <T> the type of elements in the array. * @return the sorted array. */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { for (int i = 1, size = array.length; i < size; ++i) { boolean swapped = false; for (int j = 0; j < size - i; ++j) { if (SortUtils.greater(array[j], array[j + 1])) { SortUtils.swap(array, j, j + 1); swapped = true; } } if (!swapped) { break; } } return array; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class BubbleSortRecursive implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { BubbleSortRecursive.a(comparableArray, comparableArray.length); return comparableArray; } private static void a(Comparable[] comparableArray, int n) { while (true) { boolean bl = false; for (int i = 0; i < n - 1; ++i) { if (!SortUtils.greater(comparableArray[i], comparableArray[i + 1])) continue; int n2 = i; SortUtils.swap(comparableArray, n2, n2 + 1); bl = true; } if (!bl) break; --n; } } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * BubbleSort algorithm implemented using recursion */ public class BubbleSortRecursive implements SortAlgorithm { /** * @param array - an array should be sorted * @return sorted array */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { bubbleSort(array, array.length); return array; } /** * BubbleSort algorithm implements using recursion * * @param array array contains elements * @param len length of given array */ private static <T extends Comparable<T>> void bubbleSort(T[] array, int len) { boolean swapped = false; for (int i = 0; i < len - 1; ++i) { if (SortUtils.greater(array[i], array[i + 1])) { SortUtils.swap(array, i, i + 1); swapped = true; } } if (swapped) { bubbleSort(array, len - 1); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class BucketSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { int n; if (comparableArray.length == 0) { return comparableArray; } Object object = comparableArray; Object object2 = comparableArray[0]; Comparable[] comparableArray2 = object; int n2 = ((Comparable[])object).length; for (n = 0; n < n2; ++n) { object = comparableArray2[n]; if (!SortUtils.less((Comparable)object, (Comparable)object2)) continue; object2 = object; } Object object3 = object2; object = comparableArray; object2 = comparableArray[0]; comparableArray2 = object; n2 = comparableArray2.length; for (n = 0; n < n2; ++n) { object = comparableArray2[n]; if (!SortUtils.greater((Comparable)object, (Comparable)object2)) continue; object2 = object; } Object object4 = object2; int n3 = comparableArray.length; n3 = n = Math.max(n3 / 10, 1); object2 = new ArrayList(n3); for (int i = 0; i < n3; ++i) { object2.add(new ArrayList()); } Object object5 = object2; Object object6 = object3; object2 = object5; object3 = comparableArray; Object object7 = this; for (Comparable comparable : object3) { int n4 = n; Object object8 = object4; Object object9 = object6; Comparable comparable2 = comparable; double d = object8.compareTo(object9); double d2 = (double)comparable2.compareTo(object9) / d; int n5 = (int)(d2 * (double)(n4 - 1)); ((List)object2.get(n5)).add(comparable); } Comparable[] comparableArray3 = comparableArray; object7 = object5; int n6 = 0; object4 = object7.iterator(); while (object4.hasNext()) { List list = (List)object4.next(); Collections.sort(list); for (Comparable comparable : list) { comparableArray3[n6++] = comparable; } } return comparableArray3; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.Collections; import java.util.List; /** * BucketSort class provides a method to sort an array of elements using the Bucket Sort algorithm * and implements the SortAlgorithm interface. */ public class BucketSort implements SortAlgorithm { // Constant that defines the divisor for determining the number of buckets private static final int BUCKET_DIVISOR = 10; @Override public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length == 0) { return array; } T min = findMin(array); T max = findMax(array); int numberOfBuckets = calculateNumberOfBuckets(array.length); List<List<T>> buckets = initializeBuckets(numberOfBuckets); distributeElementsIntoBuckets(array, buckets, min, max, numberOfBuckets); return concatenateBuckets(buckets, array); } /** * Calculates the number of buckets to use based on the size of the array. * * @param arrayLength the length of the array * @return the number of buckets */ private int calculateNumberOfBuckets(final int arrayLength) { return Math.max(arrayLength / BUCKET_DIVISOR, 1); } /** * Initializes a list of empty buckets. * * @param numberOfBuckets the number of buckets to initialize * @param <T> the type of elements to be sorted * @return a list of empty buckets */ private <T extends Comparable<T>> List<List<T>> initializeBuckets(int numberOfBuckets) { List<List<T>> buckets = new ArrayList<>(numberOfBuckets); for (int i = 0; i < numberOfBuckets; i++) { buckets.add(new ArrayList<>()); } return buckets; } /** * Distributes elements from the array into the appropriate buckets. * * @param array the array of elements to distribute * @param buckets the list of buckets * @param min the minimum value in the array * @param max the maximum value in the array * @param numberOfBuckets the total number of buckets * @param <T> the type of elements in the array */ private <T extends Comparable<T>> void distributeElementsIntoBuckets(T[] array, List<List<T>> buckets, final T min, final T max, final int numberOfBuckets) { for (final T element : array) { int bucketIndex = hash(element, min, max, numberOfBuckets); buckets.get(bucketIndex).add(element); } } /** * Concatenates the sorted buckets back into the original array. * * @param buckets the list of sorted buckets * @param array the original array * @param <T> the type of elements in the array * @return the sorted array */ private <T extends Comparable<T>> T[] concatenateBuckets(Iterable<List<T>> buckets, T[] array) { int index = 0; for (List<T> bucket : buckets) { Collections.sort(bucket); for (T element : bucket) { array[index++] = element; } } return array; } /** * The method computes the index of the bucket in which a given element should be placed. * This is done by \"normalizing\" the element within the range of the array's minimum (min) and maximum (max) values, * and then mapping this normalized value to a specific bucket index. * * @param element the element of the array * @param min the minimum value in the array * @param max the maximum value in the array * @param numberOfBuckets the total number of buckets * @param <T> the type of elements in the array * @return the index of the bucket */ private <T extends Comparable<T>> int hash(final T element, final T min, final T max, final int numberOfBuckets) { double range = max.compareTo(min); double normalizedValue = element.compareTo(min) / range; return (int) (normalizedValue * (numberOfBuckets - 1)); } private <T extends Comparable<T>> T findMin(T[] array) { T min = array[0]; for (T element : array) { if (SortUtils.less(element, min)) { min = element; } } return min; } private <T extends Comparable<T>> T findMax(T[] array) { T max = array[0]; for (T element : array) { if (SortUtils.greater(element, max)) { max = element; } } return max; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.io; import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; public class BufferedReader { private int a; private final byte[] b; private int c = 0; private int d = 0; private boolean e = false; private InputStream f; public BufferedReader(byte[] byArray) { this(new ByteArrayInputStream(byArray)); } public BufferedReader(InputStream inputStream) { this(inputStream, 5); } public BufferedReader(InputStream inputStream, int n) { this.f = inputStream; if (inputStream.available() == -1) { throw new IOException(\"Empty or already closed stream provided\"); } this.a = n; this.b = new byte[n]; } public int read() { if (this.b()) { if (this.e) { return -1; } this.c(); } return this.b[this.c++] & 0xFF; } public int available() { int n = this.f.available(); if (this.b()) { return n; } return this.d - this.c + n; } public int peek() { return this.peek(1); } public int peek(int n) { int n2 = this.available(); if (n >= n2) { throw new IOException(\"Out of range, available %d, but trying with %d\".formatted(n2, n)); } this.a(); if (n >= this.a) { throw new IllegalAccessError(\"Cannot peek %s, maximum upto %s (Buffer Limit)\".formatted(n, this.a)); } return this.b[n]; } private void a() { int n = this.c; int n2 = 0; while (n < this.a) { this.b[n2] = this.b[n]; ++n; ++n2; } this.d -= this.c; this.c = 0; this.d(); } public byte[] readBlock() { this.a(); byte[] byArray = new byte[this.a]; if (this.d >= 0) { System.arraycopy(this.b, 0, byArray, 0, this.a); } this.c(); return byArray; } private boolean b() { return this.d == 0 || this.c == this.a; } private void c() { this.c = 0; this.d = 0; this.d(); } private void d() { this.e(); while (this.d < this.a) { int n = this.f.read(); if (n == -1) { this.e = true; this.a = this.d; } this.b[this.d++] = (byte)n; } } private void e() { if (this.f == null) { throw new IllegalStateException(\"Input Stream already closed!\"); } } public void close() { if (this.f != null) { try { this.f.close(); return; } finally { this.f = null; } } } }", "deobfuscated_code": "package com.thealgorithms.io; import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; /** * Mimics the actions of the Original buffered reader * implements other actions, such as peek(n) to lookahead, * block() to read a chunk of size {BUFFER SIZE} * <p> * Author: Kumaraswamy B.G (Xoma Dev) */ public class BufferedReader { private static final int DEFAULT_BUFFER_SIZE = 5; /** * The maximum number of bytes the buffer can hold. * Value is changed when encountered Eof to not * cause overflow read of 0 bytes */ private int bufferSize; private final byte[] buffer; /** * posRead -> indicates the next byte to read */ private int posRead = 0; private int bufferPos = 0; private boolean foundEof = false; private InputStream input; public BufferedReader(byte[] input) throws IOException { this(new ByteArrayInputStream(input)); } public BufferedReader(InputStream input) throws IOException { this(input, DEFAULT_BUFFER_SIZE); } public BufferedReader(InputStream input, int bufferSize) throws IOException { this.input = input; if (input.available() == -1) { throw new IOException(\"Empty or already closed stream provided\"); } this.bufferSize = bufferSize; buffer = new byte[bufferSize]; } /** * Reads a single byte from the stream */ public int read() throws IOException { if (needsRefill()) { if (foundEof) { return -1; } // the buffer is empty, or the buffer has // been completely read and needs to be refilled refill(); } return buffer[posRead++] & 0xff; // read and un-sign it } /** * Number of bytes not yet been read */ public int available() throws IOException { int available = input.available(); if (needsRefill()) { // since the block is already empty, // we have no responsibility yet return available; } return bufferPos - posRead + available; } /** * Returns the next character */ public int peek() throws IOException { return peek(1); } /** * Peeks and returns a value located at next {n} */ public int peek(int n) throws IOException { int available = available(); if (n >= available) { throw new IOException(\"Out of range, available %d, but trying with %d\".formatted(available, n)); } pushRefreshData(); if (n >= bufferSize) { throw new IllegalAccessError(\"Cannot peek %s, maximum upto %s (Buffer Limit)\".formatted(n, bufferSize)); } return buffer[n]; } /** * Removes the already read bytes from the buffer * in-order to make space for new bytes to be filled up. * <p> * This may also do the job to read first time data (the whole buffer is empty) */ private void pushRefreshData() throws IOException { for (int i = posRead, j = 0; i < bufferSize; i++, j++) { buffer[j] = buffer[i]; } bufferPos -= posRead; posRead = 0; // fill out the spaces that we've // emptied justRefill(); } /** * Reads one complete block of size {bufferSize} * if found eof, the total length of an array will * be that of what's available * * @return a completed block */ public byte[] readBlock() throws IOException { pushRefreshData(); byte[] cloned = new byte[bufferSize]; // arraycopy() function is better than clone() if (bufferPos >= 0) { System.arraycopy(buffer, 0, cloned, 0, // important to note that, bufferSize does not stay constant // once the class is defined. See justRefill() function bufferSize); } // we assume that already a chunk // has been read refill(); return cloned; } private boolean needsRefill() { return bufferPos == 0 || posRead == bufferSize; } private void refill() throws IOException { posRead = 0; bufferPos = 0; justRefill(); } private void justRefill() throws IOException { assertStreamOpen(); // try to fill in the maximum we can until // we reach EOF while (bufferPos < bufferSize) { int read = input.read(); if (read == -1) { // reached end-of-file, no more data left // to be read foundEof = true; // rewrite the BUFFER_SIZE, to know that we've reached // EOF when requested refill bufferSize = bufferPos; } buffer[bufferPos++] = (byte) read; } } private void assertStreamOpen() { if (input == null) { throw new IllegalStateException(\"Input Stream already closed!\"); } } public void close() throws IOException { if (input != null) { try { input.close(); } finally { input = null; } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; public final class CRC16 { private CRC16() { } public static void main(String[] stringArray) { System.out.println(CRC16.crc16(\"Hello World!\")); } public static String crc16(String object) { int n = 65535; byte[] byArray = ((String)object).getBytes(); object = byArray; object = byArray; int n2 = byArray.length; for (int i = 0; i < n2; ++i) { Object object2 = object[i]; for (int j = 0; j < 8; ++j) { boolean bl = (object2 >> 7 - j & 1) == 1; boolean bl2 = (n >> 15 & 1) == 1; n <<= 1; if (!(bl2 ^ bl)) continue; n ^= 0x1021; } } return Integer.toHexString(n &= 0xFFFF).toUpperCase(); } }", "deobfuscated_code": "package com.thealgorithms.others; /** * Generates a crc16 checksum for a given string */ public final class CRC16 { private CRC16() { } public static void main(String[] args) { System.out.println(crc16(\"Hello World!\")); } public static String crc16(String message) { int crc = 0xFFFF; // initial value int polynomial = 0x1021; // 0001 0000 0010 0001 (0, 5, 12) byte[] bytes = message.getBytes(); for (byte b : bytes) { for (int i = 0; i < 8; i++) { boolean bit = ((b >> (7 - i) & 1) == 1); boolean c15 = ((crc >> 15 & 1) == 1); crc <<= 1; if (c15 ^ bit) { crc ^= polynomial; } } } crc &= 0xffff; return Integer.toHexString(crc).toUpperCase(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.BitSet; public final class CRC32 { private CRC32() { } public static void main(String[] stringArray) { System.out.println(Integer.toHexString(CRC32.crc32(\"Hello World\"))); } public static int crc32(String string) { return CRC32.crc32(string.getBytes()); } public static int crc32(byte[] byArray) { BitSet bitSet = BitSet.valueOf(byArray); int n = -1; for (int i = 0; i < byArray.length << 3; ++i) { if ((n >>> 31 & 1) != (bitSet.get(i) ? 1 : 0)) { n = n << 1 ^ 0x4C11DB7; continue; } n <<= 1; } n = Integer.reverse(n); return ~n; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.BitSet; /** * Generates a crc32 checksum for a given string or byte array */ public final class CRC32 { private CRC32() { } public static void main(String[] args) { System.out.println(Integer.toHexString(crc32(\"Hello World\"))); } public static int crc32(String str) { return crc32(str.getBytes()); } public static int crc32(byte[] data) { BitSet bitSet = BitSet.valueOf(data); int crc32 = 0xFFFFFFFF; // initial value for (int i = 0; i < data.length * 8; i++) { if (((crc32 >>> 31) & 1) != (bitSet.get(i) ? 1 : 0)) { crc32 = (crc32 << 1) ^ 0x04C11DB7; // xor with polynomial } else { crc32 = (crc32 << 1); } } crc32 = Integer.reverse(crc32); // result reflect return crc32 ^ 0xFFFFFFFF; // final xor value } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.ArrayList; import java.util.Iterator; import java.util.Random; import java.util.concurrent.ThreadLocalRandom; public class CRCAlgorithm { private int a; private int b; private int c; private int d; private int e; private double f; private boolean g = false; private ArrayList h = new ArrayList(); private ArrayList i; private Random j; public CRCAlgorithm(String string, int n, double d) { this.e = n; this.i = new ArrayList(); for (n = 0; n < string.length(); ++n) { this.i.add(Character.getNumericValue(string.charAt(n))); } this.j = new Random(); this.a = 0; this.b = 0; this.c = 0; this.d = 0; this.f = d; } public int getWrongMess() { return this.b; } public int getWrongMessCaught() { return this.c; } public int getWrongMessNotCaught() { return this.d; } public int getCorrectMess() { return this.a; } public void refactor() { this.g = false; this.h = new ArrayList(); } public void generateRandomMess() { for (int i = 0; i < this.e; ++i) { int n = ThreadLocalRandom.current().nextInt(0, 2); this.h.add(n); } } public void divideMessageWithP(boolean bl) { int n; ArrayList<Integer> arrayList = new ArrayList<Integer>(); ArrayList arrayList2 = (ArrayList)this.h.clone(); if (!bl) { for (n = 0; n < this.i.size() - 1; ++n) { arrayList2.add(0); } } while (!arrayList2.isEmpty()) { while (arrayList.size() < this.i.size() && !arrayList2.isEmpty()) { arrayList.add((Integer)arrayList2.get(0)); arrayList2.remove(0); } if (arrayList.size() != this.i.size()) continue; for (n = 0; n < this.i.size(); ++n) { if (arrayList.get(n) == this.i.get(n)) { arrayList.set(n, 0); continue; } arrayList.set(n, 1); } for (n = 0; n < arrayList.size() && (Integer)arrayList.get(n) != 1; ++n) { arrayList.remove(0); } } ArrayList arrayList3 = (ArrayList)arrayList.clone(); if (!bl) { this.h.addAll(arrayList3); return; } if (arrayList3.contains(1) && this.g) { ++this.c; return; } if (!arrayList3.contains(1) && this.g) { ++this.d; return; } if (!this.g) { ++this.a; } } public void changeMess() { Iterator iterator = this.h.iterator(); while (iterator.hasNext()) { int n = (Integer)iterator.next(); double d = this.j.nextDouble(); while (d < 0.0 || d > 1.0) { d = this.j.nextDouble(); } if (!(d < this.f)) continue; this.g = true; if (n == 1) { this.h.set(this.h.indexOf(n), 0); continue; } this.h.set(this.h.indexOf(n), 1); } if (this.g) { ++this.b; } } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.ArrayList; import java.util.Random; import java.util.concurrent.ThreadLocalRandom; /** * @author dimgrichr */ @SuppressWarnings(\"unchecked\") public class CRCAlgorithm { private int correctMess; private int wrongMess; private int wrongMessCaught; private int wrongMessNotCaught; private int messSize; private double ber; private boolean messageChanged; private ArrayList<Integer> message; private ArrayList<Integer> p; private Random randomGenerator; /** * The algorithm's main constructor. The most significant variables, used in * the algorithm, are set in their initial values. * * @param str The binary number P, in a string form, which is used by the * CRC algorithm * @param size The size of every transmitted message * @param ber The Bit Error Rate */ public CRCAlgorithm(String str, int size, double ber) { messageChanged = false; message = new ArrayList<>(); messSize = size; p = new ArrayList<>(); for (int i = 0; i < str.length(); i++) { p.add(Character.getNumericValue(str.charAt(i))); } randomGenerator = new Random(); correctMess = 0; wrongMess = 0; wrongMessCaught = 0; wrongMessNotCaught = 0; this.ber = ber; } /** * Returns the counter wrongMess * * @return wrongMess, the number of Wrong Messages */ public int getWrongMess() { return wrongMess; } /** * Returns the counter wrongMessCaught * * @return wrongMessCaught, the number of wrong messages, which are caught * by the CRC algoriithm */ public int getWrongMessCaught() { return wrongMessCaught; } /** * Returns the counter wrongMessNotCaught * * @return wrongMessNotCaught, the number of wrong messages, which are not * caught by the CRC algorithm */ public int getWrongMessNotCaught() { return wrongMessNotCaught; } /** * Returns the counter correctMess * * @return correctMess, the number of the Correct Messages */ public int getCorrectMess() { return correctMess; } /** * Resets some of the object's values, used on the main function, so that it * can be re-used, in order not to waste too much memory and time, by * creating new objects. */ public void refactor() { messageChanged = false; message = new ArrayList<>(); } /** * Random messages, consisted of 0's and 1's, are generated, so that they * can later be transmitted */ public void generateRandomMess() { for (int i = 0; i < messSize; i++) { int x = ThreadLocalRandom.current().nextInt(0, 2); message.add(x); } } /** * The most significant part of the CRC algorithm. The message is divided by * P, so the dividedMessage ArrayList<Integer> is created. If check == true, * the dividedMessaage is examined, in order to see if it contains any 1's. * If it does, the message is considered to be wrong by the receiver,so the * variable wrongMessCaught changes. If it does not, it is accepted, so one * of the variables correctMess, wrongMessNotCaught, changes. If check == * false, the diviided Message is added at the end of the ArrayList<integer> * message. * * @param check the variable used to determine, if the message is going to * be checked from the receiver if true, it is checked otherwise, it is not */ public void divideMessageWithP(boolean check) { ArrayList<Integer> x = new ArrayList<>(); ArrayList<Integer> k = (ArrayList<Integer>) message.clone(); if (!check) { for (int i = 0; i < p.size() - 1; i++) { k.add(0); } } while (!k.isEmpty()) { while (x.size() < p.size() && !k.isEmpty()) { x.add(k.get(0)); k.remove(0); } if (x.size() == p.size()) { for (int i = 0; i < p.size(); i++) { if (x.get(i) == p.get(i)) { x.set(i, 0); } else { x.set(i, 1); } } for (int i = 0; i < x.size() && x.get(i) != 1; i++) { x.remove(0); } } } ArrayList<Integer> dividedMessage = (ArrayList<Integer>) x.clone(); if (!check) { message.addAll(dividedMessage); } else { if (dividedMessage.contains(1) && messageChanged) { wrongMessCaught++; } else if (!dividedMessage.contains(1) && messageChanged) { wrongMessNotCaught++; } else if (!messageChanged) { correctMess++; } } } /** * Once the message is transmitted, some of it's elements, is possible to * change from 1 to 0, or from 0 to 1, because of the Bit Error Rate (ber). * For every element of the message, a random double number is created. If * that number is smaller than ber, then the spesific element changes. On * the other hand, if it's bigger than ber, it does not. Based on these * changes. the boolean variable messageChanged, gets the value: true, or * false. */ public void changeMess() { for (int y : message) { double x = randomGenerator.nextDouble(); while (x < 0.0000 || x > 1.00000) { x = randomGenerator.nextDouble(); } if (x < ber) { messageChanged = true; if (y == 1) { message.set(message.indexOf(y), 0); } else { message.set(message.indexOf(y), 1); } } } if (messageChanged) { wrongMess++; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; public class Caesar { public String encode(String string, int n) { StringBuilder stringBuilder = new StringBuilder(); n = (char)(n % 26); int n2 = string.length(); for (int i = 0; i < n2; ++i) { int n3 = string.charAt(i); if (Caesar.a((char)n3)) { stringBuilder.append((char)((n3 = (char)(n3 + n)) > 90 ? n3 - 26 : n3)); continue; } if (Caesar.b((char)n3)) { stringBuilder.append((char)((n3 = (char)(n3 + n)) > 122 ? n3 - 26 : n3)); continue; } stringBuilder.append((char)n3); } return stringBuilder.toString(); } public String decode(String string, int n) { StringBuilder stringBuilder = new StringBuilder(); n = (char)(n % 26); int n2 = string.length(); for (int i = 0; i < n2; ++i) { int n3 = string.charAt(i); if (Caesar.a((char)n3)) { stringBuilder.append((char)((n3 = (char)(n3 - n)) < 65 ? n3 + 26 : n3)); continue; } if (Caesar.b((char)n3)) { stringBuilder.append((char)((n3 = (char)(n3 - n)) < 97 ? n3 + 26 : n3)); continue; } stringBuilder.append((char)n3); } return stringBuilder.toString(); } private static boolean a(char c) { return c >= 'A' && c <= 'Z'; } private static boolean b(char c) { return c >= 'a' && c <= 'z'; } public String[] bruteforce(String string) { String[] stringArray = new String[27]; for (int i = 0; i <= 26; ++i) { stringArray[i] = this.decode(string, i); } return stringArray; } }", "deobfuscated_code": "package com.thealgorithms.ciphers; /** * A Java implementation of Caesar Cipher. /It is a type of substitution cipher * in which each letter in the plaintext is replaced by a letter some fixed * number of positions down the alphabet. / * * @author FAHRI YARDIMCI * @author khalil2535 */ public class Caesar { private static char normalizeShift(final int shift) { return (char) (shift % 26); } /** * Encrypt text by shifting every Latin char by add number shift for ASCII * Example : A + 1 -> B * * @return Encrypted message */ public String encode(String message, int shift) { StringBuilder encoded = new StringBuilder(); final char shiftChar = normalizeShift(shift); final int length = message.length(); for (int i = 0; i < length; i++) { // int current = message.charAt(i); //using char to shift characters because // ascii // is in-order latin alphabet char current = message.charAt(i); // Java law : char + int = char if (isCapitalLatinLetter(current)) { current += shiftChar; encoded.append((char) (current > 'Z' ? current - 26 : current)); // 26 = number of latin letters } else if (isSmallLatinLetter(current)) { current += shiftChar; encoded.append((char) (current > 'z' ? current - 26 : current)); // 26 = number of latin letters } else { encoded.append(current); } } return encoded.toString(); } /** * Decrypt message by shifting back every Latin char to previous the ASCII * Example : B - 1 -> A * * @return message */ public String decode(String encryptedMessage, int shift) { StringBuilder decoded = new StringBuilder(); final char shiftChar = normalizeShift(shift); final int length = encryptedMessage.length(); for (int i = 0; i < length; i++) { char current = encryptedMessage.charAt(i); if (isCapitalLatinLetter(current)) { current -= shiftChar; decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters } else if (isSmallLatinLetter(current)) { current -= shiftChar; decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters } else { decoded.append(current); } } return decoded.toString(); } /** * @return true if character is capital Latin letter or false for others */ private static boolean isCapitalLatinLetter(char c) { return c >= 'A' && c <= 'Z'; } /** * @return true if character is small Latin letter or false for others */ private static boolean isSmallLatinLetter(char c) { return c >= 'a' && c <= 'z'; } /** * @return string array which contains all the possible decoded combination. */ public String[] bruteforce(String encryptedMessage) { String[] listOfAllTheAnswers = new String[27]; for (int i = 0; i <= 26; i++) { listOfAllTheAnswers[i] = decode(encryptedMessage, i); } return listOfAllTheAnswers; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import java.util.Scanner; public final class CatalanNumber { private CatalanNumber() { } public static void main(String[] object) { object = new Scanner(System.in); System.out.println(\"Enter the number n to find nth Catalan number (n <= 50)\"); int n = ((Scanner)object).nextInt(); long[] lArray = new long[n + 1]; long[] lArray2 = lArray; lArray[0] = 1L; lArray2[1] = 1L; for (int i = 2; i <= n; ++i) { lArray2[i] = 0L; for (int j = 0; j < i; ++j) { int n2 = i; lArray2[n2] = lArray2[n2] + lArray2[j] * lArray2[i - j - 1]; } } System.out.println(n + \"th Catalan number is \" + lArray2[n]); ((Scanner)object).close(); } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.Scanner; /** * This file contains an implementation of finding the nth CATALAN NUMBER using * dynamic programming : <a href=\"https://en.wikipedia.org/wiki/Catalan_number\">Wikipedia</a> * * Time Complexity: O(n^2) Space Complexity: O(n) * * @author <a href=\"https://github.com/amritesh19\">AMRITESH ANAND</a> */ public final class CatalanNumber { private CatalanNumber() { } /** * This method finds the nth Catalan number * * @param n input n which determines the nth Catalan number n should be less * than equal to 50 as 50th Catalan number is 6,533,841,209,031,609,592 for * n > 50, BigInteger class should be used instead long * * @return catalanArray[n] the nth Catalan number */ static long findNthCatalan(int n) { // Array to store the results of subproblems i.e Catalan numbers from [1...n-1] long[] catalanArray = new long[n + 1]; // Initialising C = 1 and C = 1 catalanArray[0] = 1; catalanArray[1] = 1; /* * The Catalan numbers satisfy the recurrence relation C=1 and Cn =  * (Ci * Cn-1-i), i = 0 to n-1 , n > 0 */ for (int i = 2; i <= n; i++) { catalanArray[i] = 0; for (int j = 0; j < i; j++) { catalanArray[i] += catalanArray[j] * catalanArray[i - j - 1]; } } return catalanArray[n]; } // Main method public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"Enter the number n to find nth Catalan number (n <= 50)\"); int n = sc.nextInt(); System.out.println(n + \"th Catalan number is \" + findNthCatalan(n)); sc.close(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class CatalanNumbers { private CatalanNumbers() { } public static long catalan(int n) { if (n < 0) { throw new IllegalArgumentException(\"Index must be non-negative\"); } return CatalanNumbers.a(2 * n) / (CatalanNumbers.a(n + 1) * CatalanNumbers.a(n)); } private static long a(int n) { if (n == 0 || n == 1) { return 1L; } long l = 1L; for (int i = 2; i <= n; ++i) { l *= (long)i; } return l; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Calculate Catalan Numbers */ public final class CatalanNumbers { private CatalanNumbers() { } /** * Calculate the nth Catalan number using a recursive formula. * * @param n the index of the Catalan number to compute * @return the nth Catalan number */ public static long catalan(final int n) { if (n < 0) { throw new IllegalArgumentException(\"Index must be non-negative\"); } return factorial(2 * n) / (factorial(n + 1) * factorial(n)); } /** * Calculate the factorial of a number. * * @param n the number to compute the factorial for * @return the factorial of n */ private static long factorial(final int n) { if (n == 0 || n == 1) { return 1; } long result = 1; for (int i = 2; i <= n; i++) { result *= i; } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class Ceil { private Ceil() { } public static double ceil(double d) { if (Double.isNaN(d) || Double.isInfinite(d) || d == 0.0 || d < -2.147483648E9 || d > 2.147483647E9) { return d; } if (d < 0.0 && d > -1.0) { return -0.0; } long l = (long)d; if (d > 0.0 && d != (double)l) { return (double)l + 1.0; } return l; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Utility class to compute the ceiling of a given number. */ public final class Ceil { private Ceil() { } /** * Returns the smallest double value that is greater than or equal to the input. * Equivalent to mathematical x (ceiling function). * * @param number the number to ceil * @return the smallest double greater than or equal to {@code number} */ public static double ceil(double number) { if (Double.isNaN(number) || Double.isInfinite(number) || number == 0.0 || number < Integer.MIN_VALUE || number > Integer.MAX_VALUE) { return number; } if (number < 0.0 && number > -1.0) { return -0.0; } long intPart = (long) number; if (number > 0 && number != intPart) { return intPart + 1.0; } else { return intPart; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; public final class CeilInBinarySearchTree { private CeilInBinarySearchTree() { } public static BinaryTree$Node getCeil(BinaryTree$Node binaryTree$Node, int n) { while (true) { if (binaryTree$Node == null) { return null; } if (binaryTree$Node.data == n) { return binaryTree$Node; } if (binaryTree$Node.data >= n) break; binaryTree$Node = binaryTree$Node.right; } BinaryTree$Node binaryTree$Node2 = CeilInBinarySearchTree.getCeil(binaryTree$Node.left, n); if (binaryTree$Node2 == null) { return binaryTree$Node; } return binaryTree$Node2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree.Node; /** * Problem Statement Ceil value for any number x in a collection is a number y * which is either equal to x or the least greater number than x. * * Problem: Given a binary search tree containing positive integer values. Find * ceil value for a given key in O(lg(n)) time. In case if it is not present * return -1. * * Ex.1. [30,20,40,10,25,35,50] represents level order traversal of a binary * search tree. Find ceil for 10. Answer: 20 * * Ex.2. [30,20,40,10,25,35,50] represents level order traversal of a binary * search tree. Find ceil for 22 Answer: 25 * * Ex.2. [30,20,40,10,25,35,50] represents level order traversal of a binary * search tree. Find ceil for 52 Answer: -1 * * Solution 1: Brute Force Solution: Do an inorder traversal and save result * into an array. Iterate over the array to get an element equal to or greater * than current key. Time Complexity: O(n) Space Complexity: O(n) for auxillary * array to save inorder representation of tree. * <p> * <p> * Solution 2: Brute Force Solution: Do an inorder traversal and save result * into an array.Since array is sorted do a binary search over the array to get * an element equal to or greater than current key. Time Complexity: O(n) for * traversal of tree and O(lg(n)) for binary search in array. Total = O(n) Space * Complexity: O(n) for auxillary array to save inorder representation of tree. * <p> * <p> * Solution 3: Optimal We can do a DFS search on given tree in following * fashion. i) if root is null then return null because then ceil doesn't exist * ii) If key is lesser than root value than ceil will be in right subtree so * call recursively on right subtree iii) if key is greater than current root, * then either a) the root is ceil b) ceil is in left subtree: call for left * subtree. If left subtree returns a non-null value then that will be ceil * otherwise the root is ceil */ public final class CeilInBinarySearchTree { private CeilInBinarySearchTree() { } public static Node getCeil(Node root, int key) { if (root == null) { return null; } // if root value is same as key than root is the ceiling if (root.data == key) { return root; } // if root value is lesser than key then ceil must be in right subtree if (root.data < key) { return getCeil(root.right, key); } // if root value is greater than key then ceil can be in left subtree or if // it is not in left subtree then current node will be ceil Node result = getCeil(root.left, key); // if result is null it means that there is no ceil in children subtrees // and the root is the ceil otherwise the returned node is the ceil. return result == null ? root : result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Stack; public final class CelebrityFinder { private CelebrityFinder() { } public static int findCelebrity(int[][] nArray) { int n; int n2; Stack<Integer> stack = new Stack<Integer>(); for (n2 = 0; n2 < nArray.length; ++n2) { stack.push(n2); } while (stack.size() > 1) { n2 = (Integer)stack.pop(); if (nArray[n2][n = ((Integer)stack.pop()).intValue()] == 1) { stack.push(n); continue; } stack.push(n2); } n2 = (Integer)stack.pop(); for (n = 0; n < nArray.length; ++n) { if (n == n2 || nArray[n2][n] != 1 && nArray[n][n2] != 0) continue; return -1; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; /** * Solves the celebrity problem using a stack-based algorithm. * * <p>Celebrity is someone known by everyone but doesn't know anyone else. * <p>Applications: Graph theory and social network analysis. * * @author Hardvan */ public final class CelebrityFinder { private CelebrityFinder() { } /** * Finds the celebrity in the given party matrix using a stack-based algorithm. * * @param party A 2D matrix where party[i][j] is 1 if i knows j, otherwise 0. * @return The index of the celebrity, or -1 if there is no celebrity. */ public static int findCelebrity(int[][] party) { // Push all people onto the stack Stack<Integer> stack = new Stack<>(); for (int i = 0; i < party.length; i++) { stack.push(i); } // Find the potential celebrity by comparing pairs while (stack.size() > 1) { int person1 = stack.pop(); int person2 = stack.pop(); if (party[person1][person2] == 1) { stack.push(person2); // person1 knows person2, so person2 might be the celebrity } else { stack.push(person1); // person1 doesn't know person2, so person1 might be the celebrity } } // Verify the candidate int candidate = stack.pop(); for (int i = 0; i < party.length; i++) { if (i != candidate && (party[candidate][i] == 1 || party[i][candidate] == 0)) { return -1; } } return candidate; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class CharactersSame { private CharactersSame() { } public static boolean isAllCharactersSame(String string) { if (string.isEmpty()) { return true; } char c = string.charAt(0); for (int i = 1; i < string.length(); ++i) { if (string.charAt(i) == c) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.strings; public final class CharactersSame { private CharactersSame() { } /** * Checks if all characters in the string are the same. * * @param s the string to check * @return {@code true} if all characters in the string are the same or if the string is empty, otherwise {@code false} */ public static boolean isAllCharactersSame(String s) { if (s.isEmpty()) { return true; // Empty strings can be considered as having \"all the same characters\" } char firstChar = s.charAt(0); for (int i = 1; i < s.length(); i++) { if (s.charAt(i) != firstChar) { return false; } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; public final class CheckBinaryTreeIsValidBST { private CheckBinaryTreeIsValidBST() { } public static boolean isBST(BinaryTree$Node binaryTree$Node) { return CheckBinaryTreeIsValidBST.a(binaryTree$Node, Integer.MIN_VALUE, Integer.MAX_VALUE); } private static boolean a(BinaryTree$Node binaryTree$Node, int n, int n2) { if (binaryTree$Node == null) { return true; } if (binaryTree$Node.data < n || binaryTree$Node.data > n2) { return false; } return CheckBinaryTreeIsValidBST.a(binaryTree$Node.left, n, binaryTree$Node.data - 1) && CheckBinaryTreeIsValidBST.a(binaryTree$Node.right, binaryTree$Node.data + 1, n2); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; /** * This code recursively validates whether given Binary Search Tree (BST) is balanced or not. * Trees with only distinct values are supported. * Key points: * 1. According to the definition of a BST, each node in a tree must be in range [min, max], * where 'min' and 'max' values represent the child nodes (left, right). * 2. The smallest possible node value is Integer.MIN_VALUE, the biggest - Integer.MAX_VALUE. */ public final class CheckBinaryTreeIsValidBST { private CheckBinaryTreeIsValidBST() { } public static boolean isBST(BinaryTree.Node root) { return isBSTUtil(root, Integer.MIN_VALUE, Integer.MAX_VALUE); } private static boolean isBSTUtil(BinaryTree.Node node, int min, int max) { // empty tree is a BST if (node == null) { return true; } if (node.data < min || node.data > max) { return false; } return (isBSTUtil(node.left, min, node.data - 1) && isBSTUtil(node.right, node.data + 1, max)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.HashMap; import java.util.Stack; public final class CheckIfBinaryTreeBalanced { private CheckIfBinaryTreeBalanced() { } public static boolean isBalancedRecursive(BinaryTree$Node binaryTree$Node) { if (binaryTree$Node == null) { return true; } boolean[] blArray = new boolean[1]; boolean[] blArray2 = blArray; blArray[0] = true; CheckIfBinaryTreeBalanced.a(binaryTree$Node, 0, blArray2); return blArray2[0]; } private static int a(BinaryTree$Node binaryTree$Node, int n, boolean[] blArray) { int n2; if (binaryTree$Node == null || !blArray[0]) { return 0; } int n3 = CheckIfBinaryTreeBalanced.a(binaryTree$Node.left, n + 1, blArray); if (Math.abs(n3 - (n2 = CheckIfBinaryTreeBalanced.a(binaryTree$Node.right, n + 1, blArray))) > 1) { blArray[0] = false; } return Math.max(n3, n2) + 1; } public static boolean isBalancedIterative(BinaryTree$Node binaryTree$Node) { if (binaryTree$Node == null) { return true; } boolean bl = true; Stack<BinaryTree$Node> stack = new Stack<BinaryTree$Node>(); BinaryTree$Node binaryTree$Node2 = null; HashMap<BinaryTree$Node, Integer> hashMap = new HashMap<BinaryTree$Node, Integer>(); while ((!stack.isEmpty() || binaryTree$Node != null) && bl) { if (binaryTree$Node != null) { stack.push(binaryTree$Node); binaryTree$Node = binaryTree$Node.left; continue; } binaryTree$Node = (BinaryTree$Node)stack.peek(); if (binaryTree$Node.right == null || binaryTree$Node.right == binaryTree$Node2) { int n = 0; int n2 = 0; if (binaryTree$Node.left != null) { n = (Integer)hashMap.get(binaryTree$Node.left); } if (binaryTree$Node.right != null) { n2 = (Integer)hashMap.get(binaryTree$Node.right); } if (Math.abs(n2 - n) > 1) { bl = false; } hashMap.put(binaryTree$Node, Math.max(n2, n) + 1); stack.pop(); binaryTree$Node2 = binaryTree$Node; binaryTree$Node = null; continue; } binaryTree$Node = binaryTree$Node.right; } return bl; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.HashMap; import java.util.Stack; /** * This class will check if a BinaryTree is balanced. A balanced binary tree is * defined as a binary tree where the difference in height between the left and * right subtree of each node differs by at most one. * <p> * This can be done in both an iterative and recursive fashion. Below, * `isBalancedRecursive()` is implemented in a recursive fashion, and * `isBalancedIterative()` is implemented in an iterative fashion. * * @author [Ian Cowan](<a href=\"https://github.com/iccowan\">Git-Ian Cowan</a>) */ public final class CheckIfBinaryTreeBalanced { private CheckIfBinaryTreeBalanced() { } /** * Recursive is BT balanced implementation * * @param root The binary tree to check if balanced */ public static boolean isBalancedRecursive(BinaryTree.Node root) { if (root == null) { return true; } // Create an array of length 1 to keep track of our balance // Default to true. We use an array, so we have an efficient mutable object boolean[] isBalanced = new boolean[1]; isBalanced[0] = true; // Check for balance and return whether we are balanced isBalancedRecursive(root, 0, isBalanced); return isBalanced[0]; } /** * Private helper method to keep track of the depth and balance during * recursion. We effectively perform a modified post-order traversal where * we are looking at the heights of both children of each node in the tree * * @param node The current node to explore * @param depth The current depth of the node * @param isBalanced The array of length 1 keeping track of our balance */ private static int isBalancedRecursive(BinaryTree.Node node, int depth, boolean[] isBalanced) { // If the node is null, we should not explore it and the height is 0 // If the tree is already not balanced, might as well stop because we // can't make it balanced now! if (node == null || !isBalanced[0]) { return 0; } // Visit the left and right children, incrementing their depths by 1 int leftHeight = isBalancedRecursive(node.left, depth + 1, isBalanced); int rightHeight = isBalancedRecursive(node.right, depth + 1, isBalanced); // If the height of either of the left or right subtrees differ by more // than 1, we cannot be balanced if (Math.abs(leftHeight - rightHeight) > 1) { isBalanced[0] = false; } // The height of our tree is the maximum of the heights of the left // and right subtrees plus one return Math.max(leftHeight, rightHeight) + 1; } /** * Iterative is BT balanced implementation */ public static boolean isBalancedIterative(BinaryTree.Node root) { if (root == null) { return true; } // Default that we are balanced and our algo will prove it wrong boolean isBalanced = true; // Create a stack for our post order traversal Stack<BinaryTree.Node> nodeStack = new Stack<>(); // For post order traversal, we'll have to keep track of where we // visited last BinaryTree.Node lastVisited = null; // Create a HashMap to keep track of the subtree heights for each node HashMap<BinaryTree.Node, Integer> subtreeHeights = new HashMap<>(); // We begin at the root of the tree BinaryTree.Node node = root; // We loop while: // - the node stack is empty and the node we explore is null // AND // - the tree is still balanced while (!(nodeStack.isEmpty() && node == null) && isBalanced) { // If the node is not null, we push it to the stack and continue // to the left if (node != null) { nodeStack.push(node); node = node.left; // Once we hit a node that is null, we are as deep as we can go // to the left } else { // Find the last node we put on the stack node = nodeStack.peek(); // If the right child of the node has either been visited or // is null, we visit this node if (node.right == null || node.right == lastVisited) { // We assume the left and right heights are 0 int leftHeight = 0; int rightHeight = 0; // If the right and left children are not null, we must // have already explored them and have a height // for them so let's get that if (node.left != null) { leftHeight = subtreeHeights.get(node.left); } if (node.right != null) { rightHeight = subtreeHeights.get(node.right); } // If the difference in the height of the right subtree // and left subtree differs by more than 1, we cannot be // balanced if (Math.abs(rightHeight - leftHeight) > 1) { isBalanced = false; } // The height of the subtree containing this node is the // max of the left and right subtree heights plus 1 subtreeHeights.put(node, Math.max(rightHeight, leftHeight) + 1); // We've now visited this node, so we pop it from the stack nodeStack.pop(); lastVisited = node; // Current visiting node is now null node = null; // If the right child node of this node has not been visited // and is not null, we need to get that child node on the stack } else { node = node.right; } } } // Return whether the tree is balanced return isBalanced; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; public final class CheckTreeIsSymmetric { private CheckTreeIsSymmetric() { } public static boolean isSymmetric(BinaryTree$Node binaryTree$Node) { if (binaryTree$Node == null) { return true; } return CheckTreeIsSymmetric.a(binaryTree$Node.left, binaryTree$Node.right); } private static boolean a(BinaryTree$Node binaryTree$Node, BinaryTree$Node binaryTree$Node2) { if (binaryTree$Node == null && binaryTree$Node2 == null) { return true; } if (CheckTreeIsSymmetric.b(binaryTree$Node, binaryTree$Node2)) { return false; } return CheckTreeIsSymmetric.a(binaryTree$Node.right, binaryTree$Node2.left) && CheckTreeIsSymmetric.a(binaryTree$Node.left, binaryTree$Node2.right); } private static boolean b(BinaryTree$Node binaryTree$Node, BinaryTree$Node binaryTree$Node2) { return binaryTree$Node == null || binaryTree$Node2 == null || binaryTree$Node.data != binaryTree$Node2.data; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree.Node; /** * Check if a binary tree is symmetric or not. * A binary tree is a symmetric tree if the left and right subtree of root are mirror image. * Below is a symmetric tree * 1 * / \\ * 2 2 * / \\ / \\ * 3 4 4 3 * * Below is not symmetric because values is different in last level * 1 * / \\ * 2 2 * / \\ / \\ * 3 5 4 3 * <p> * Approach: * Recursively check for left and right subtree of root * 1. left subtrees root's values should be equal right subtree's root value * 2. recursively check with left subtrees' left child VS right subtree's right child AND * left subtree's right child VS right subtree left child * Complexity * 1. Time: O(n) * 2. Space: O(lg(n)) for height of tree * * @author kumanoit on 10/10/22 IST 12:52 AM */ public final class CheckTreeIsSymmetric { private CheckTreeIsSymmetric() { } public static boolean isSymmetric(Node root) { if (root == null) { return true; } return isSymmetric(root.left, root.right); } private static boolean isSymmetric(Node leftSubtreeRoot, Node rightSubtreeRoot) { if (leftSubtreeRoot == null && rightSubtreeRoot == null) { return true; } if (isInvalidSubtree(leftSubtreeRoot, rightSubtreeRoot)) { return false; } return isSymmetric(leftSubtreeRoot.right, rightSubtreeRoot.left) && isSymmetric(leftSubtreeRoot.left, rightSubtreeRoot.right); } private static boolean isInvalidSubtree(Node leftSubtreeRoot, Node rightSubtreeRoot) { return leftSubtreeRoot == null || rightSubtreeRoot == null || leftSubtreeRoot.data != rightSubtreeRoot.data; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.Set; public final class CheckVowels { private static final Set a = Set.of(Character.valueOf('a'), Character.valueOf('e'), Character.valueOf('i'), Character.valueOf('o'), Character.valueOf('u')); private CheckVowels() { } public static boolean hasVowels(String object) { if (object == null || ((String)object).isEmpty()) { return false; } char[] cArray = ((String)object).toLowerCase().toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object2 = object[i]; if (!a.contains(Character.valueOf((char)object2))) continue; return true; } return false; } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.Set; /** * Vowel Count is a system whereby character strings are placed in order based * on the position of the characters in the conventional ordering of an * alphabet. Wikipedia: https://en.wikipedia.org/wiki/Alphabetical_order */ public final class CheckVowels { private static final Set<Character> VOWELS = Set.of('a', 'e', 'i', 'o', 'u'); private CheckVowels() { } /** * Checks if a string contains any vowels. * * @param input a string to check * @return {@code true} if the given string contains at least one vowel, otherwise {@code false} */ public static boolean hasVowels(String input) { if (input == null || input.isEmpty()) { return false; } for (char c : input.toLowerCase().toCharArray()) { if (VOWELS.contains(c)) { return true; } } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.Iterator; import java.util.List; public final class ChineseRemainderTheorem { private ChineseRemainderTheorem() { } public static int solveCRT(List list, List list2) { int n; int n2 = 1; int n3 = 0; Iterator iterator = list2.iterator(); while (iterator.hasNext()) { n = (Integer)iterator.next(); n2 *= n; } for (int i = 0; i < list2.size(); ++i) { int n4; n = n2 / (Integer)list2.get(i); int n5 = (Integer)list2.get(i); int n6 = n; int n7 = n5; int n8 = 0; int n9 = 1; if (n5 == 1) { n4 = 0; } else { while (n6 > 1) { int n10 = n6 / n5; int n11 = n5; n5 = n6 % n5; n6 = n11; n11 = n8; n8 = n9 - n10 * n8; n9 = n11; } if (n9 < 0) { n9 += n7; } n4 = n9; } n6 = n4; n3 += (Integer)list.get(i) * n * n6; } if ((n3 %= n2) < 0) { n3 += n2; } return n3; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.List; /** * @brief Implementation of the Chinese Remainder Theorem (CRT) algorithm * @details * The Chinese Remainder Theorem (CRT) is used to solve systems of * simultaneous congruences. Given several pairwise coprime moduli * and corresponding remainders, the algorithm finds the smallest * positive solution. */ public final class ChineseRemainderTheorem { private ChineseRemainderTheorem() { } /** * @brief Solves the Chinese Remainder Theorem problem. * @param remainders The list of remainders. * @param moduli The list of pairwise coprime moduli. * @return The smallest positive solution that satisfies all the given congruences. */ public static int solveCRT(List<Integer> remainders, List<Integer> moduli) { int product = 1; int result = 0; // Calculate the product of all moduli for (int mod : moduli) { product *= mod; } // Apply the formula for each congruence for (int i = 0; i < moduli.size(); i++) { int partialProduct = product / moduli.get(i); int inverse = modInverse(partialProduct, moduli.get(i)); result += remainders.get(i) * partialProduct * inverse; } // Adjust result to be the smallest positive solution result = result % product; if (result < 0) { result += product; } return result; } /** * @brief Computes the modular inverse of a number with respect to a modulus using * the Extended Euclidean Algorithm. * @param a The number for which to find the inverse. * @param m The modulus. * @return The modular inverse of a modulo m. */ private static int modInverse(int a, int m) { int m0 = m; int x0 = 0; int x1 = 1; if (m == 1) { return 0; } while (a > 1) { int q = a / m; int t = m; // m is remainder now, process same as Euclid's algorithm m = a % m; a = t; t = x0; x0 = x1 - q * x0; x1 = t; } // Make x1 positive if (x1 < 0) { x1 += m0; } return x1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; final class CircleLinkedList$Node { CircleLinkedList$Node a; Object b; private CircleLinkedList$Node(Object object, CircleLinkedList$Node circleLinkedList$Node) { this.b = object; this.a = circleLinkedList$Node; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; final class CircleLinkedList$Node { CircleLinkedList$Node a; Object b; private CircleLinkedList$Node(Object object, CircleLinkedList$Node circleLinkedList$Node) { this.b = object; this.a = circleLinkedList$Node; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.CircleLinkedList$Node; public class CircleLinkedList { private int a = 0; private CircleLinkedList$Node b = null; private CircleLinkedList$Node c = this.b = new CircleLinkedList$Node(null, this.b); public int getSize() { return this.a; } public void append(Object object) { if (object == null) { throw new NullPointerException(\"Cannot add null element to the list\"); } if (this.c == null) { this.b.a = this.c = new CircleLinkedList$Node(object, this.b); } else { this.c = this.c.a = new CircleLinkedList$Node(object, this.b); } ++this.a; } public String toString() { if (this.a == 0) { return \"[]\"; } StringBuilder stringBuilder = new StringBuilder(\"[ \"); CircleLinkedList$Node circleLinkedList$Node = this.b.a; while (circleLinkedList$Node != this.b) { stringBuilder.append(circleLinkedList$Node.b); if (circleLinkedList$Node.a != this.b) { stringBuilder.append(\", \"); } circleLinkedList$Node = circleLinkedList$Node.a; } stringBuilder.append(\" ]\"); return stringBuilder.toString(); } public Object remove(int n) { if (n >= this.a || n < 0) { throw new IndexOutOfBoundsException(\"Position out of bounds\"); } CircleLinkedList$Node circleLinkedList$Node = this.b; for (int i = 1; i <= n; ++i) { circleLinkedList$Node = circleLinkedList$Node.a; } CircleLinkedList$Node circleLinkedList$Node2 = circleLinkedList$Node.a; Object object = circleLinkedList$Node2.b; circleLinkedList$Node.a = circleLinkedList$Node2.a; if (circleLinkedList$Node2 == this.c) { this.c = circleLinkedList$Node; } --this.a; return object; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; /** * This class is a circular singly linked list implementation. In a circular linked list, * the last node points back to the first node, creating a circular chain. * * <p>This implementation includes basic operations such as appending elements * to the end, removing elements from a specified position, and converting * the list to a string representation. * * @param <E> the type of elements held in this list */ @SuppressWarnings(\"rawtypes\") public class CircleLinkedList<E> { /** * A static nested class representing a node in the circular linked list. * * @param <E> the type of element stored in the node */ static final class Node<E> { Node<E> next; E value; private Node(E value, Node<E> next) { this.value = value; this.next = next; } } private int size; Node<E> head = null; private Node<E> tail; /** * Initializes a new circular linked list. A dummy head node is used for simplicity, * pointing initially to itself to ensure the list is never empty. */ public CircleLinkedList() { head = new Node<>(null, head); tail = head; size = 0; } /** * Returns the current size of the list. * * @return the number of elements in the list */ public int getSize() { return size; } /** * Appends a new element to the end of the list. Throws a NullPointerException if * a null value is provided. * * @param value the value to append to the list * @throws NullPointerException if the value is null */ public void append(E value) { if (value == null) { throw new NullPointerException(\"Cannot add null element to the list\"); } if (tail == null) { tail = new Node<>(value, head); head.next = tail; } else { tail.next = new Node<>(value, head); tail = tail.next; } size++; } /** * Returns a string representation of the list in the format \"[ element1, element2, ... ]\". * An empty list is represented as \"[]\". * * @return the string representation of the list */ public String toString() { if (size == 0) { return \"[]\"; } StringBuilder sb = new StringBuilder(\"[ \"); Node<E> current = head.next; while (current != head) { sb.append(current.value); if (current.next != head) { sb.append(\", \"); } current = current.next; } sb.append(\" ]\"); return sb.toString(); } /** * Removes and returns the element at the specified position in the list. * Throws an IndexOutOfBoundsException if the position is invalid. * * @param pos the position of the element to remove * @return the value of the removed element * @throws IndexOutOfBoundsException if the position is out of range */ public E remove(int pos) { if (pos >= size || pos < 0) { throw new IndexOutOfBoundsException(\"Position out of bounds\"); } Node<E> before = head; for (int i = 1; i <= pos; i++) { before = before.next; } Node<E> destroy = before.next; E saved = destroy.value; before.next = destroy.next; if (destroy == tail) { tail = before; } destroy = null; size--; return saved; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class CircleSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length == 0) { return comparableArray; } while (this.a(comparableArray, 0, comparableArray.length - 1)) { } return comparableArray; } private boolean a(Comparable[] comparableArray, int n, int n2) { int n3; boolean bl = false; if (n == n2) { return false; } int n4 = n; for (n3 = n2; n4 < n3; ++n4, --n3) { if (!SortUtils.greater(comparableArray[n4], comparableArray[n3])) continue; SortUtils.swap(comparableArray, n4, n3); bl = true; } if (n4 == n3 && SortUtils.greater(comparableArray[n4], comparableArray[n3 + 1])) { SortUtils.swap(comparableArray, n4, n3 + 1); bl = true; } n4 = n + (n2 - n) / 2; n = this.a(comparableArray, n, n4) ? 1 : 0; boolean bl2 = this.a(comparableArray, n4 + 1, n2); return bl || n != 0 || bl2; } }", "deobfuscated_code": "package com.thealgorithms.sorts; public class CircleSort implements SortAlgorithm { /* This method implements the circle sort * @param array The array to be sorted */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length == 0) { return array; } while (doSort(array, 0, array.length - 1)) { } return array; } /** * Recursively sorts the array in a circular manner by comparing elements * from the start and end of the current segment. * * @param <T> The type of elements in the array, which must be comparable * @param array The array to be sorted * @param left The left boundary of the current segment being sorted * @param right The right boundary of the current segment being sorted * @return true if any elements were swapped during the sort; false otherwise */ private <T extends Comparable<T>> boolean doSort(final T[] array, final int left, final int right) { boolean swapped = false; if (left == right) { return false; } int low = left; int high = right; while (low < high) { if (SortUtils.greater(array[low], array[high])) { SortUtils.swap(array, low, high); swapped = true; } low++; high--; } if (low == high && SortUtils.greater(array[low], array[high + 1])) { SortUtils.swap(array, low, high + 1); swapped = true; } final int mid = left + (right - left) / 2; final boolean leftHalfSwapped = doSort(array, left, mid); final boolean rightHalfSwapped = doSort(array, mid + 1, right); return swapped || leftHalfSwapped || rightHalfSwapped; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.buffers; class CircularBuffer$CircularPointer { private int a = 0; private final int b; CircularBuffer$CircularPointer(int n, int n2) { this.b = n2; } public int getAndIncrement() { int n = this.a; this.a = (this.a + 1) % this.b; return n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.buffers; class CircularBuffer$CircularPointer { private int a = 0; private final int b; CircularBuffer$CircularPointer(int n, int n2) { this.b = n2; } public int getAndIncrement() { int n = this.a; this.a = (this.a + 1) % this.b; return n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.buffers; import com.thealgorithms.datastructures.buffers.CircularBuffer$CircularPointer; import java.util.concurrent.atomic.AtomicInteger; public class CircularBuffer { private final Object[] a; private final CircularBuffer$CircularPointer b; private final CircularBuffer$CircularPointer c; private final AtomicInteger d = new AtomicInteger(0); public CircularBuffer(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Buffer size must be positive\"); } this.a = new Object[n]; this.b = new CircularBuffer$CircularPointer(0, n); this.c = new CircularBuffer$CircularPointer(0, n); } public boolean isEmpty() { return this.d.get() == 0; } public boolean isFull() { return this.d.get() == this.a.length; } public Object get() { if (this.isEmpty()) { return null; } Object object = this.a[this.c.getAndIncrement()]; this.d.decrementAndGet(); return object; } public boolean put(Object object) { if (object == null) { throw new IllegalArgumentException(\"Null items are not allowed\"); } boolean bl = this.isEmpty(); if (this.isFull()) { this.c.getAndIncrement(); } else { this.d.incrementAndGet(); } this.a[this.b.getAndIncrement()] = object; return bl; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.buffers; import java.util.concurrent.atomic.AtomicInteger; /** * The {@code CircularBuffer} class implements a generic circular (or ring) buffer. * A circular buffer is a fixed-size data structure that operates in a FIFO (First In, First Out) manner. * The buffer allows you to overwrite old data when the buffer is full and efficiently use limited memory. * When the buffer is full, adding a new item will overwrite the oldest data. * * @param <Item> The type of elements stored in the circular buffer. */ @SuppressWarnings(\"unchecked\") public class CircularBuffer<Item> { private final Item[] buffer; private final CircularPointer putPointer; private final CircularPointer getPointer; private final AtomicInteger size = new AtomicInteger(0); /** * Constructor to initialize the circular buffer with a specified size. * * @param size The size of the circular buffer. * @throws IllegalArgumentException if the size is zero or negative. */ public CircularBuffer(int size) { if (size <= 0) { throw new IllegalArgumentException(\"Buffer size must be positive\"); } // noinspection unchecked this.buffer = (Item[]) new Object[size]; this.putPointer = new CircularPointer(0, size); this.getPointer = new CircularPointer(0, size); } /** * Checks if the circular buffer is empty. * This method is based on the current size of the buffer. * * @return {@code true} if the buffer is empty, {@code false} otherwise. */ public boolean isEmpty() { return size.get() == 0; } /** * Checks if the circular buffer is full. * The buffer is considered full when its size equals its capacity. * * @return {@code true} if the buffer is full, {@code false} otherwise. */ public boolean isFull() { return size.get() == buffer.length; } /** * Retrieves and removes the item at the front of the buffer (FIFO). * This operation will move the {@code getPointer} forward. * * @return The item at the front of the buffer, or {@code null} if the buffer is empty. */ public Item get() { if (isEmpty()) { return null; } Item item = buffer[getPointer.getAndIncrement()]; size.decrementAndGet(); return item; } /** * Adds an item to the end of the buffer (FIFO). * If the buffer is full, this operation will overwrite the oldest data. * * @param item The item to be added. * @throws IllegalArgumentException if the item is null. * @return {@code true} if the item was successfully added, {@code false} if the buffer was full and the item overwrote existing data. */ public boolean put(Item item) { if (item == null) { throw new IllegalArgumentException(\"Null items are not allowed\"); } boolean wasEmpty = isEmpty(); if (isFull()) { getPointer.getAndIncrement(); // Move get pointer to discard oldest item } else { size.incrementAndGet(); } buffer[putPointer.getAndIncrement()] = item; return wasEmpty; } /** * The {@code CircularPointer} class is a helper class used to track the current index (pointer) * in the circular buffer. * The max value represents the capacity of the buffer. * The `CircularPointer` class ensures that the pointer automatically wraps around to 0 * when it reaches the maximum index. * This is achieved in the `getAndIncrement` method, where the pointer * is incremented and then taken modulo the maximum value (`max`). * This operation ensures that the pointer always stays within the bounds of the buffer. */ private static class CircularPointer { private int pointer; private final int max; /** * Constructor to initialize the circular pointer. * * @param pointer The initial position of the pointer. * @param max The maximum size (capacity) of the circular buffer. */ CircularPointer(int pointer, int max) { this.pointer = pointer; this.max = max; } /** * Increments the pointer by 1 and wraps it around to 0 if it reaches the maximum value. * This ensures the pointer always stays within the buffer's bounds. * * @return The current pointer value before incrementing. */ public int getAndIncrement() { int tmp = pointer; pointer = (pointer + 1) % max; return tmp; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.FFT$Complex; import com.thealgorithms.maths.FFTBluestein; import java.util.ArrayList; import java.util.Collection; public final class CircularConvolutionFFT { private CircularConvolutionFFT() { } private static void a(Collection collection, int n) { if (collection.size() < n) { n -= collection.size(); for (int i = 0; i < n; ++i) { collection.add(new FFT$Complex()); } } } public static ArrayList fftCircularConvolution(ArrayList arrayList, ArrayList arrayList2) { int n = Math.max(arrayList.size(), arrayList2.size()); CircularConvolutionFFT.a(arrayList, n); CircularConvolutionFFT.a(arrayList2, n); FFTBluestein.fftBluestein(arrayList, false); FFTBluestein.fftBluestein(arrayList2, false); ArrayList<FFT$Complex> arrayList3 = new ArrayList<FFT$Complex>(); for (int i = 0; i < arrayList.size(); ++i) { arrayList3.add(((FFT$Complex)arrayList.get(i)).multiply((FFT$Complex)arrayList2.get(i))); } FFTBluestein.fftBluestein(arrayList3, true); return arrayList3; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; import java.util.Collection; /** * Class for circular convolution of two discrete signals using the convolution * theorem. * * @author Ioannis Karavitsis * @version 1.0 */ public final class CircularConvolutionFFT { private CircularConvolutionFFT() { } /** * This method pads the signal with zeros until it reaches the new size. * * @param x The signal to be padded. * @param newSize The new size of the signal. */ private static void padding(Collection<FFT.Complex> x, int newSize) { if (x.size() < newSize) { int diff = newSize - x.size(); for (int i = 0; i < diff; i++) { x.add(new FFT.Complex()); } } } /** * Discrete circular convolution function. It uses the convolution theorem * for discrete signals: convolved = IDFT(DFT(a)*DFT(b)). Then we use the * FFT algorithm for faster calculations of the two DFTs and the final IDFT. * * <p> * More info: https://en.wikipedia.org/wiki/Convolution_theorem * * @param a The first signal. * @param b The other signal. * @return The convolved signal. */ public static ArrayList<FFT.Complex> fftCircularConvolution(ArrayList<FFT.Complex> a, ArrayList<FFT.Complex> b) { int convolvedSize = Math.max(a.size(), b.size()); // The two signals must have the same size equal to the bigger one padding(a, convolvedSize); // Zero padding the smaller signal padding(b, convolvedSize); /* Find the FFTs of both signal. Here we use the Bluestein algorithm because we want the FFT * to have the same length with the signal and not bigger */ FFTBluestein.fftBluestein(a, false); FFTBluestein.fftBluestein(b, false); ArrayList<FFT.Complex> convolved = new ArrayList<>(); for (int i = 0; i < a.size(); i++) { convolved.add(a.get(i).multiply(b.get(i))); // FFT(a)*FFT(b) } FFTBluestein.fftBluestein(convolved, true); // IFFT return convolved; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling.diskscheduling; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class CircularLookScheduling { private int a; private boolean b; private final int c; public CircularLookScheduling(int n, boolean bl, int n2) { this.a = n; this.b = bl; this.c = n2; } public List execute(List object) { ArrayList arrayList = new ArrayList(); ArrayList<Integer> arrayList2 = new ArrayList<Integer>(); ArrayList<Integer> arrayList3 = new ArrayList<Integer>(); object = object.iterator(); while (object.hasNext()) { int n = (Integer)object.next(); if (n < 0 || n >= this.c) continue; if (n > this.a) { arrayList2.add(n); continue; } if (n >= this.a) continue; arrayList3.add(n); } Collections.sort(arrayList2); Collections.sort(arrayList3); if (this.b) { arrayList.addAll(arrayList2); arrayList.addAll(arrayList3); } else { Collections.reverse(arrayList3); arrayList.addAll(arrayList3); Collections.reverse(arrayList2); arrayList.addAll(arrayList2); } if (!arrayList.isEmpty()) { ArrayList arrayList4 = arrayList; this.a = (Integer)arrayList4.get(arrayList4.size() - 1); } return arrayList; } public int getCurrentPosition() { return this.a; } public boolean isMovingUp() { return this.b; } }", "deobfuscated_code": "package com.thealgorithms.scheduling.diskscheduling; import java.util.ArrayList; import java.util.Collections; import java.util.List; /** * Circular Look Scheduling (C-LOOK) is a disk scheduling algorithm similar to * the C-SCAN algorithm but with a key difference. In C-LOOK, the disk arm also * moves in one direction to service requests, but instead of going all the way * to the end of the disk, it only goes as far as the furthest request in the * current direction. After servicing the last request in the current direction, * the arm immediately jumps back to the closest request on the other side without * moving to the disk's extreme ends. This reduces the unnecessary movement of the * disk arm, resulting in better performance compared to C-SCAN, while still * maintaining fair wait times for requests. */ public class CircularLookScheduling { private int currentPosition; private boolean movingUp; private final int maxCylinder; public CircularLookScheduling(int startPosition, boolean movingUp, int maxCylinder) { this.currentPosition = startPosition; this.movingUp = movingUp; this.maxCylinder = maxCylinder; } public List<Integer> execute(List<Integer> requests) { List<Integer> result = new ArrayList<>(); // Filter and sort valid requests in both directions List<Integer> upRequests = new ArrayList<>(); List<Integer> downRequests = new ArrayList<>(); for (int request : requests) { if (request >= 0 && request < maxCylinder) { if (request > currentPosition) { upRequests.add(request); } else if (request < currentPosition) { downRequests.add(request); } } } Collections.sort(upRequests); Collections.sort(downRequests); if (movingUp) { // Process all requests in the upward direction result.addAll(upRequests); // Jump to the lowest request and process all requests in the downward direction result.addAll(downRequests); } else { // Process all requests in the downward direction (in reverse order) Collections.reverse(downRequests); result.addAll(downRequests); // Jump to the highest request and process all requests in the upward direction (in reverse order) Collections.reverse(upRequests); result.addAll(upRequests); } // Update current position to the last processed request if (!result.isEmpty()) { currentPosition = result.get(result.size() - 1); } return result; } public int getCurrentPosition() { return currentPosition; } public boolean isMovingUp() { return movingUp; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; public class CircularQueue { private Object[] a; private int b; private int c; private final int d; private int e; public CircularQueue(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Size must be greater than 0\"); } this.a = new Object[n]; this.b = -1; this.c = -1; this.d = n; this.e = 0; } public boolean isEmpty() { return this.e == 0; } public boolean isFull() { return this.e == this.d; } public void enQueue(Object object) { if (this.isFull()) { throw new IllegalStateException(\"Queue is full\"); } if (this.isEmpty()) { this.c = 0; } this.b = (this.b + 1) % this.d; this.a[this.b] = object; ++this.e; } public Object deQueue() { if (this.isEmpty()) { throw new IllegalStateException(\"Queue is empty\"); } Object object = this.a[this.c]; this.a[this.c] = null; this.c = (this.c + 1) % this.d; --this.e; if (this.isEmpty()) { this.c = -1; this.b = -1; } return object; } public Object peek() { if (this.isEmpty()) { throw new IllegalStateException(\"Queue is empty\"); } return this.a[this.c]; } public void deleteQueue() { this.a = null; this.c = -1; this.b = -1; this.e = 0; } public int size() { return this.e; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.queues; /** * The CircularQueue class represents a generic circular queue data structure that uses an array to * store elements. This queue allows efficient utilization of space by wrapping around the array, * thus avoiding the need to shift elements during enqueue and dequeue operations. * * <p>When the queue reaches its maximum capacity, further enqueues will raise an exception. * Similarly, attempts to dequeue or peek from an empty queue will also result in an exception. * * <p>Reference: <a href=\"https://en.wikipedia.org/wiki/Circular_buffer\">Circular Buffer</a> * * <p>Usage Example: * <pre> * CircularQueue<Integer> queue = new CircularQueue<>(3); * queue.enQueue(1); * queue.enQueue(2); * queue.enQueue(3); * queue.deQueue(); // Removes 1 * queue.enQueue(4); // Wraps around and places 4 at the position of removed 1 * </pre> * * @param <T> the type of elements in this queue */ public class CircularQueue<T> { private T[] array; private int topOfQueue; private int beginningOfQueue; private final int size; private int currentSize; /** * Constructs a CircularQueue with a specified capacity. * * @param size the maximum number of elements this queue can hold * @throws IllegalArgumentException if the size is less than 1 */ @SuppressWarnings(\"unchecked\") public CircularQueue(int size) { if (size < 1) { throw new IllegalArgumentException(\"Size must be greater than 0\"); } this.array = (T[]) new Object[size]; this.topOfQueue = -1; this.beginningOfQueue = -1; this.size = size; this.currentSize = 0; } /** * Checks if the queue is empty. * * @return {@code true} if the queue is empty; {@code false} otherwise */ public boolean isEmpty() { return currentSize == 0; } /** * Checks if the queue is full. * * @return {@code true} if the queue has reached its maximum capacity; {@code false} otherwise */ public boolean isFull() { return currentSize == size; } /** * Adds a new element to the queue. If the queue is full, an exception is thrown. * * @param value the element to be added to the queue * @throws IllegalStateException if the queue is already full */ public void enQueue(T value) { if (isFull()) { throw new IllegalStateException(\"Queue is full\"); } if (isEmpty()) { beginningOfQueue = 0; } topOfQueue = (topOfQueue + 1) % size; array[topOfQueue] = value; currentSize++; } /** * Removes and returns the element at the front of the queue. * * @return the element at the front of the queue * @throws IllegalStateException if the queue is empty */ public T deQueue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty\"); } T removedValue = array[beginningOfQueue]; array[beginningOfQueue] = null; // Optional: Nullify to help garbage collection beginningOfQueue = (beginningOfQueue + 1) % size; currentSize--; if (isEmpty()) { beginningOfQueue = -1; topOfQueue = -1; } return removedValue; } /** * Returns the element at the front of the queue without removing it. * * @return the element at the front of the queue * @throws IllegalStateException if the queue is empty */ public T peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty\"); } return array[beginningOfQueue]; } /** * Deletes the entire queue by resetting all elements and pointers. */ public void deleteQueue() { array = null; beginningOfQueue = -1; topOfQueue = -1; currentSize = 0; } /** * Returns the current number of elements in the queue. * * @return the number of elements currently in the queue */ public int size() { return currentSize; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling.diskscheduling; import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.List; public class CircularScanScheduling { private int a; private boolean b; private final int c; public CircularScanScheduling(int n, boolean bl, int n2) { this.a = n; this.b = bl; this.c = n2; } public List execute(List arrayList) { if (arrayList.isEmpty()) { return new ArrayList(); } arrayList = new ArrayList(arrayList); Collections.sort(arrayList); ArrayList<Integer> arrayList2 = new ArrayList<Integer>(); if (this.b) { int n; Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) { n = (Integer)iterator.next(); if (n < this.a || n >= this.c) continue; arrayList2.add(n); } iterator = arrayList.iterator(); while (iterator.hasNext()) { n = (Integer)iterator.next(); if (n >= this.a) continue; arrayList2.add(n); } } else { int n; int n2; for (n2 = arrayList.size() - 1; n2 >= 0; --n2) { n = (Integer)arrayList.get(n2); if (n > this.a) continue; arrayList2.add(n); } for (n2 = arrayList.size() - 1; n2 >= 0; --n2) { n = (Integer)arrayList.get(n2); if (n <= this.a) continue; arrayList2.add(n); } } if (!arrayList2.isEmpty()) { ArrayList<Integer> arrayList3 = arrayList2; this.a = (Integer)arrayList3.get(arrayList3.size() - 1); } return arrayList2; } public int getCurrentPosition() { return this.a; } public boolean isMovingUp() { return this.b; } }", "deobfuscated_code": "package com.thealgorithms.scheduling.diskscheduling; import java.util.ArrayList; import java.util.Collections; import java.util.List; /** * Circular Scan Scheduling (C-SCAN) is a disk scheduling algorithm that * works by moving the disk arm in one direction to service requests until * it reaches the end of the disk. Once it reaches the end, instead of reversing * direction like in the SCAN algorithm, the arm moves back to the starting point * without servicing any requests. This ensures a more uniform wait time for all * requests, especially those near the disk edges. The algorithm then continues in * the same direction, making it effective for balancing service time across all disk sectors. */ public class CircularScanScheduling { private int currentPosition; private boolean movingUp; private final int diskSize; public CircularScanScheduling(int startPosition, boolean movingUp, int diskSize) { this.currentPosition = startPosition; this.movingUp = movingUp; this.diskSize = diskSize; } public List<Integer> execute(List<Integer> requests) { if (requests.isEmpty()) { return new ArrayList<>(); // Return empty list if there are no requests } List<Integer> sortedRequests = new ArrayList<>(requests); Collections.sort(sortedRequests); List<Integer> result = new ArrayList<>(); if (movingUp) { // Moving up: process requests >= current position for (int request : sortedRequests) { if (request >= currentPosition && request < diskSize) { result.add(request); } } // Jump to the smallest request and continue processing from the start for (int request : sortedRequests) { if (request < currentPosition) { result.add(request); } } } else { // Moving down: process requests <= current position in reverse order for (int i = sortedRequests.size() - 1; i >= 0; i--) { int request = sortedRequests.get(i); if (request <= currentPosition) { result.add(request); } } // Jump to the largest request and continue processing in reverse order for (int i = sortedRequests.size() - 1; i >= 0; i--) { int request = sortedRequests.get(i); if (request > currentPosition) { result.add(request); } } } // Set final position to the last request processed if (!result.isEmpty()) { currentPosition = result.get(result.size() - 1); } return result; } public int getCurrentPosition() { return currentPosition; } public boolean isMovingUp() { return movingUp; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class ClearLeftmostSetBit { private ClearLeftmostSetBit() { } public static int clearLeftmostSetBit(int n) { int n2 = 0; int n3 = n; while (n3 > 0) { n3 >>= 1; ++n2; } n2 = ~(1 << n2 - 1); return n & n2; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * ClearLeftmostSetBit class contains a method to clear the leftmost set bit of a number. * The leftmost set bit is the leftmost bit that is set to 1 in the binary representation of a number. * * Example: * 26 (11010) -> 10 (01010) * 1 (1) -> 0 (0) * 7 (111) -> 3 (011) * 6 (0110) -> 2 (0010) * * @author Hardvan */ public final class ClearLeftmostSetBit { private ClearLeftmostSetBit() { } /** * Clears the leftmost set bit (1) of a given number. * Step 1: Find the position of the leftmost set bit * Step 2: Create a mask with all bits set except for the leftmost set bit * Step 3: Clear the leftmost set bit using AND with the mask * * @param num The input number. * @return The number after clearing the leftmost set bit. */ public static int clearLeftmostSetBit(int num) { int pos = 0; int temp = num; while (temp > 0) { temp >>= 1; pos++; } int mask = ~(1 << (pos - 1)); return num & mask; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class ClimbingStairs { private ClimbingStairs() { } public static int numberOfWays(int n) { if (n == 1 || n == 0) { return n; } int n2 = 1; int n3 = 1; for (int i = 2; i <= n; ++i) { int n4 = n3 + n2; n2 = n3; n3 = n4; } return n3; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /* * A dynamic programming solution for the \"Climbing Stairs\" problem. * Returns the no. of distinct ways to climb to the top * of a staircase when you can climb either 1 or 2 steps at a time. * * For example, if there are 5 steps, the possible ways to climb the * staircase are: * 1. 1-1-1-1-1 * 2. 1-1-1-2 * 3. 1-2-1-1 * 4. 2-1-1-1 * 5. 2-2-1 * 6. 1-1-2-1 * 7. 1-2-2 * 8. 2-1-2 * Ans: 8 ways */ public final class ClimbingStairs { private ClimbingStairs() { } /** * Calculates the no. of distinct ways to climb a staircase with n steps. * * @param n the no. of steps in the staircase (non-negative integer) * @return the no. of distinct ways to climb to the top * - Returns 0 if n is 0 (no steps to climb). * - Returns 1 if n is 1 (only one way to climb). * - For n > 1, it returns the total no. of ways to climb. */ public static int numberOfWays(int n) { // Base case: if there are no steps or only one step, return n. if (n == 1 || n == 0) { return n; } int prev = 1; // Ways to reach the step before the current one (step 1) int curr = 1; // Ways to reach the current step (step 2) int next; // Total ways to reach the next step for (int i = 2; i <= n; i++) { // step 2 to n next = curr + prev; // Move the pointers to the next step prev = curr; curr = next; } return curr; // Ways to reach the nth step } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; public class ClosestPair$Location { double a; double b; ClosestPair$Location(double d, double d2) { this.a = d; this.b = d2; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; public class ClosestPair$Location { double a; double b; ClosestPair$Location(double d, double d2) { this.a = d; this.b = d2; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; import com.thealgorithms.divideandconquer.ClosestPair$Location; public final class ClosestPair { private int a = 12; private ClosestPair$Location[] b = new ClosestPair$Location[this.a]; private ClosestPair$Location c = null; private ClosestPair$Location d = null; private static double e = Double.MAX_VALUE; private static int f = 0; public static void setMinNum(double d) { e = d; } public static void setSecondCount(int n) { f = n; } private ClosestPair(int n) { } public final ClosestPair$Location[] createLocation(int n) { return new ClosestPair$Location[n]; } public final ClosestPair$Location buildLocation(double d, double d2) { return new ClosestPair$Location(d, d2); } public final int xPartition(ClosestPair$Location[] closestPair$LocationArray, int n, int n2) { ClosestPair$Location closestPair$Location = closestPair$LocationArray[n2]; int n3 = n - 1; for (int i = n; i <= n2 - 1; ++i) { if (!(closestPair$LocationArray[i].a <= closestPair$Location.a)) continue; ClosestPair$Location closestPair$Location2 = closestPair$LocationArray[++n3]; closestPair$LocationArray[n3] = closestPair$LocationArray[i]; closestPair$LocationArray[i] = closestPair$Location2; } ClosestPair$Location closestPair$Location3 = closestPair$LocationArray[++n3]; closestPair$LocationArray[n3] = closestPair$LocationArray[n2]; closestPair$LocationArray[n2] = closestPair$Location3; return n3; } public final int yPartition(ClosestPair$Location[] closestPair$LocationArray, int n, int n2) { ClosestPair$Location closestPair$Location = closestPair$LocationArray[n2]; int n3 = n - 1; for (int i = n; i <= n2 - 1; ++i) { if (!(closestPair$LocationArray[i].b <= closestPair$Location.b)) continue; ClosestPair$Location closestPair$Location2 = closestPair$LocationArray[++n3]; closestPair$LocationArray[n3] = closestPair$LocationArray[i]; closestPair$LocationArray[i] = closestPair$Location2; } ClosestPair$Location closestPair$Location3 = closestPair$LocationArray[++n3]; closestPair$LocationArray[n3] = closestPair$LocationArray[n2]; closestPair$LocationArray[n2] = closestPair$Location3; return n3; } public final void xQuickSort(ClosestPair$Location[] closestPair$LocationArray, int n, int n2) { while (n < n2) { int n3 = this.xPartition(closestPair$LocationArray, n, n2); this.xQuickSort(closestPair$LocationArray, n, n3 - 1); n = n3 + 1; } } public final void yQuickSort(ClosestPair$Location[] closestPair$LocationArray, int n, int n2) { while (n < n2) { int n3 = this.yPartition(closestPair$LocationArray, n, n2); this.yQuickSort(closestPair$LocationArray, n, n3 - 1); n = n3 + 1; } } public final double closestPair(ClosestPair$Location[] closestPair$LocationArray, int n) { ClosestPair$Location[] closestPair$LocationArray2 = new ClosestPair$Location[n]; System.arraycopy(closestPair$LocationArray, 0, closestPair$LocationArray2, 0, n); int n2 = n / 2; ClosestPair$Location[] closestPair$LocationArray3 = new ClosestPair$Location[n2]; ClosestPair$Location[] closestPair$LocationArray4 = new ClosestPair$Location[n - n2]; if (n <= 3) { return this.bruteForce(closestPair$LocationArray2); } System.arraycopy(closestPair$LocationArray2, 0, closestPair$LocationArray3, 0, n2); System.arraycopy(closestPair$LocationArray2, n2, closestPair$LocationArray4, 0, n - n2); double d = this.closestPair(closestPair$LocationArray3, n2); double d2 = this.closestPair(closestPair$LocationArray4, n - n2); double d3 = Math.min(d, d2); for (int i = 0; i < n; ++i) { double d4; double d5 = Math.abs(closestPair$LocationArray2[n2].a - closestPair$LocationArray2[i].a); if (d4 < d3) { ClosestPair.setSecondCount(f + 1); continue; } if (closestPair$LocationArray2[i].a > closestPair$LocationArray2[n2].a) break; } ClosestPair$Location[] closestPair$LocationArray5 = new ClosestPair$Location[f]; int n3 = 0; for (int i = 0; i < n; ++i) { double d6; double d7 = Math.abs(closestPair$LocationArray2[n2].a - closestPair$LocationArray2[i].a); if (d6 < d3) { closestPair$LocationArray5[n3] = closestPair$LocationArray2[i]; ++n3; continue; } if (closestPair$LocationArray2[i].a > closestPair$LocationArray2[n2].a) break; } this.yQuickSort(closestPair$LocationArray5, 0, f - 1); block2: for (int i = 0; i < f - 1; ++i) { for (n2 = i + 1; n2 < f; ++n2) { double d8; double d9; double d10 = Math.abs(closestPair$LocationArray5[i].a - closestPair$LocationArray5[n2].a); double d11 = Math.abs(closestPair$LocationArray5[i].b - closestPair$LocationArray5[n2].b); if (!(d9 < d3)) continue block2; double d12 = Math.sqrt(Math.pow(d10, 2.0) + Math.pow(d11, 2.0)); if (!(d8 < d3)) continue; d3 = d12; if (!(d12 < e)) continue; ClosestPair.setMinNum(d12); this.c = closestPair$LocationArray5[i]; this.d = closestPair$LocationArray5[n2]; } } ClosestPair.setSecondCount(0); return d3; } public final double bruteForce(ClosestPair$Location[] closestPair$LocationArray) { double d; double d2; double d3; double d4 = Double.MAX_VALUE; double d5 = 0.0; if (closestPair$LocationArray.length == 2) { double d6; d3 = closestPair$LocationArray[0].a - closestPair$LocationArray[1].a; d2 = closestPair$LocationArray[0].b - closestPair$LocationArray[1].b; d = Math.sqrt(Math.pow(d3, 2.0) + Math.pow(d2, 2.0)); if (d6 < e) { ClosestPair.setMinNum(d); } this.c = closestPair$LocationArray[0]; this.d = closestPair$LocationArray[1]; d5 = d; } if (closestPair$LocationArray.length == 3) { for (int i = 0; i < closestPair$LocationArray.length - 1; ++i) { for (int j = i + 1; j < closestPair$LocationArray.length; ++j) { double d7; d3 = closestPair$LocationArray[i].a - closestPair$LocationArray[j].a; d2 = closestPair$LocationArray[i].b - closestPair$LocationArray[j].b; d = Math.sqrt(Math.pow(d3, 2.0) + Math.pow(d2, 2.0)); if (!(d7 < d4)) continue; d4 = d; if (!(d < e)) continue; ClosestPair.setMinNum(d); this.c = closestPair$LocationArray[i]; this.d = closestPair$LocationArray[j]; } } d5 = d4; } return d5; } public static void main(String[] object) { object = new ClosestPair(12); ((ClosestPair)object).b[0] = ((ClosestPair)object).buildLocation(2.0, 3.0); ((ClosestPair)object).b[1] = ((ClosestPair)object).buildLocation(2.0, 16.0); ((ClosestPair)object).b[2] = ((ClosestPair)object).buildLocation(3.0, 9.0); ((ClosestPair)object).b[3] = ((ClosestPair)object).buildLocation(6.0, 3.0); ((ClosestPair)object).b[4] = ((ClosestPair)object).buildLocation(7.0, 7.0); ((ClosestPair)object).b[5] = ((ClosestPair)object).buildLocation(19.0, 4.0); ((ClosestPair)object).b[6] = ((ClosestPair)object).buildLocation(10.0, 11.0); ((ClosestPair)object).b[7] = ((ClosestPair)object).buildLocation(15.0, 2.0); ((ClosestPair)object).b[8] = ((ClosestPair)object).buildLocation(15.0, 19.0); ((ClosestPair)object).b[9] = ((ClosestPair)object).buildLocation(16.0, 11.0); ((ClosestPair)object).b[10] = ((ClosestPair)object).buildLocation(17.0, 13.0); ((ClosestPair)object).b[11] = ((ClosestPair)object).buildLocation(9.0, 12.0); System.out.println(\"Input data\"); System.out.println(\"Number of points: \" + ((ClosestPair)object).b.length); for (int i = 0; i < ((ClosestPair)object).b.length; ++i) { System.out.println(\"x: \" + ((ClosestPair)object).b[i].a + \", y: \" + ((ClosestPair)object).b[i].b); } Object object2 = object; ((ClosestPair)object2).xQuickSort(((ClosestPair)object2).b, 0, ((ClosestPair)object).b.length - 1); Object object3 = object; double d = ((ClosestPair)object3).closestPair(((ClosestPair)object3).b, ((ClosestPair)object).b.length); System.out.println(\"Output Data\"); System.out.println(\"(\" + ((ClosestPair)object).c.a + \", \" + ((ClosestPair)object).c.b + \")\"); System.out.println(\"(\" + ((ClosestPair)object).d.a + \", \" + ((ClosestPair)object).d.b + \")\"); System.out.println(\"Minimum Distance : \" + d); } }", "deobfuscated_code": "package com.thealgorithms.divideandconquer; /** * For a set of points in a coordinates system (10000 maximum), ClosestPair * class calculates the two closest points. */ public final class ClosestPair { /** * Number of points */ int numberPoints; /** * Input data, maximum 10000. */ Location[] array; /** * Minimum point coordinate. */ Location point1 = null; /** * Minimum point coordinate. */ Location point2 = null; /** * Minimum point length. */ private static double minNum = Double.MAX_VALUE; public static void setMinNum(double minNum) { ClosestPair.minNum = minNum; } public static void setSecondCount(int secondCount) { ClosestPair.secondCount = secondCount; } /** * secondCount */ private static int secondCount = 0; /** * Constructor. */ ClosestPair(int points) { numberPoints = points; array = new Location[numberPoints]; } /** * Location class is an auxiliary type to keep points coordinates. */ public static class Location { double x; double y; /** * @param xpar (IN Parameter) x coordinate <br> * @param ypar (IN Parameter) y coordinate <br> */ Location(final double xpar, final double ypar) { // Save x, y coordinates this.x = xpar; this.y = ypar; } } public Location[] createLocation(int numberValues) { return new Location[numberValues]; } public Location buildLocation(double x, double y) { return new Location(x, y); } /** * xPartition function: arrange x-axis. * * @param a (IN Parameter) array of points <br> * @param first (IN Parameter) first point <br> * @param last (IN Parameter) last point <br> * @return pivot index */ public int xPartition(final Location[] a, final int first, final int last) { Location pivot = a[last]; // pivot int i = first - 1; Location temp; // Temporarily store value for position transformation for (int j = first; j <= last - 1; j++) { if (a[j].x <= pivot.x) { // Less than or less than pivot i++; temp = a[i]; // array[i] <-> array[j] a[i] = a[j]; a[j] = temp; } } i++; temp = a[i]; // array[pivot] <-> array[i] a[i] = a[last]; a[last] = temp; return i; // pivot index } /** * yPartition function: arrange y-axis. * * @param a (IN Parameter) array of points <br> * @param first (IN Parameter) first point <br> * @param last (IN Parameter) last point <br> * @return pivot index */ public int yPartition(final Location[] a, final int first, final int last) { Location pivot = a[last]; // pivot int i = first - 1; Location temp; // Temporarily store value for position transformation for (int j = first; j <= last - 1; j++) { if (a[j].y <= pivot.y) { // Less than or less than pivot i++; temp = a[i]; // array[i] <-> array[j] a[i] = a[j]; a[j] = temp; } } i++; temp = a[i]; // array[pivot] <-> array[i] a[i] = a[last]; a[last] = temp; return i; // pivot index } /** * xQuickSort function: //x-axis Quick Sorting. * * @param a (IN Parameter) array of points <br> * @param first (IN Parameter) first point <br> * @param last (IN Parameter) last point <br> */ public void xQuickSort(final Location[] a, final int first, final int last) { if (first < last) { int q = xPartition(a, first, last); // pivot xQuickSort(a, first, q - 1); // Left xQuickSort(a, q + 1, last); // Right } } /** * yQuickSort function: //y-axis Quick Sorting. * * @param a (IN Parameter) array of points <br> * @param first (IN Parameter) first point <br> * @param last (IN Parameter) last point <br> */ public void yQuickSort(final Location[] a, final int first, final int last) { if (first < last) { int q = yPartition(a, first, last); // pivot yQuickSort(a, first, q - 1); // Left yQuickSort(a, q + 1, last); // Right } } /** * closestPair function: find closest pair. * * @param a (IN Parameter) array stored before divide <br> * @param indexNum (IN Parameter) number coordinates divideArray <br> * @return minimum distance <br> */ public double closestPair(final Location[] a, final int indexNum) { Location[] divideArray = new Location[indexNum]; System.arraycopy(a, 0, divideArray, 0, indexNum); // Copy previous array int divideX = indexNum / 2; // Intermediate value for divide Location[] leftArray = new Location[divideX]; // divide - left array // divide-right array Location[] rightArray = new Location[indexNum - divideX]; if (indexNum <= 3) { // If the number of coordinates is 3 or less return bruteForce(divideArray); } // divide-left array System.arraycopy(divideArray, 0, leftArray, 0, divideX); // divide-right array System.arraycopy(divideArray, divideX, rightArray, 0, indexNum - divideX); double minLeftArea; // Minimum length of left array double minRightArea; // Minimum length of right array double minValue; // Minimum lengt minLeftArea = closestPair(leftArray, divideX); // recursive closestPair minRightArea = closestPair(rightArray, indexNum - divideX); // window size (= minimum length) minValue = Math.min(minLeftArea, minRightArea); // Create window. Set the size for creating a window // and creating a new array for the coordinates in the window for (int i = 0; i < indexNum; i++) { double xGap = Math.abs(divideArray[divideX].x - divideArray[i].x); if (xGap < minValue) { ClosestPair.setSecondCount(secondCount + 1); // size of the array } else { if (divideArray[i].x > divideArray[divideX].x) { break; } } } // new array for coordinates in window Location[] firstWindow = new Location[secondCount]; int k = 0; for (int i = 0; i < indexNum; i++) { double xGap = Math.abs(divideArray[divideX].x - divideArray[i].x); if (xGap < minValue) { // if it's inside a window firstWindow[k] = divideArray[i]; // put in an array k++; } else { if (divideArray[i].x > divideArray[divideX].x) { break; } } } yQuickSort(firstWindow, 0, secondCount - 1); // Sort by y coordinates /* Coordinates in Window */ double length; // size comparison within window for (int i = 0; i < secondCount - 1; i++) { for (int j = (i + 1); j < secondCount; j++) { double xGap = Math.abs(firstWindow[i].x - firstWindow[j].x); double yGap = Math.abs(firstWindow[i].y - firstWindow[j].y); if (yGap < minValue) { length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2)); // If measured distance is less than current min distance if (length < minValue) { // Change minimum distance to current distance minValue = length; // Conditional for registering final coordinate if (length < minNum) { ClosestPair.setMinNum(length); point1 = firstWindow[i]; point2 = firstWindow[j]; } } } else { break; } } } ClosestPair.setSecondCount(0); return minValue; } /** * bruteForce function: When the number of coordinates is less than 3. * * @param arrayParam (IN Parameter) array stored before divide <br> * @return <br> */ public double bruteForce(final Location[] arrayParam) { double minValue = Double.MAX_VALUE; // minimum distance double length; double xGap; // Difference between x coordinates double yGap; // Difference between y coordinates double result = 0; if (arrayParam.length == 2) { // Difference between x coordinates xGap = (arrayParam[0].x - arrayParam[1].x); // Difference between y coordinates yGap = (arrayParam[0].y - arrayParam[1].y); // distance between coordinates length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2)); // Conditional statement for registering final coordinate if (length < minNum) { ClosestPair.setMinNum(length); } point1 = arrayParam[0]; point2 = arrayParam[1]; result = length; } if (arrayParam.length == 3) { for (int i = 0; i < arrayParam.length - 1; i++) { for (int j = (i + 1); j < arrayParam.length; j++) { // Difference between x coordinates xGap = (arrayParam[i].x - arrayParam[j].x); // Difference between y coordinates yGap = (arrayParam[i].y - arrayParam[j].y); // distance between coordinates length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2)); // If measured distance is less than current min distance if (length < minValue) { // Change minimum distance to current distance minValue = length; if (length < minNum) { // Registering final coordinate ClosestPair.setMinNum(length); point1 = arrayParam[i]; point2 = arrayParam[j]; } } } } result = minValue; } return result; // If only one point returns 0. } /** * main function: execute class. * * @param args (IN Parameter) <br> */ public static void main(final String[] args) { // Input data consists of one x-coordinate and one y-coordinate ClosestPair cp = new ClosestPair(12); cp.array[0] = cp.buildLocation(2, 3); cp.array[1] = cp.buildLocation(2, 16); cp.array[2] = cp.buildLocation(3, 9); cp.array[3] = cp.buildLocation(6, 3); cp.array[4] = cp.buildLocation(7, 7); cp.array[5] = cp.buildLocation(19, 4); cp.array[6] = cp.buildLocation(10, 11); cp.array[7] = cp.buildLocation(15, 2); cp.array[8] = cp.buildLocation(15, 19); cp.array[9] = cp.buildLocation(16, 11); cp.array[10] = cp.buildLocation(17, 13); cp.array[11] = cp.buildLocation(9, 12); System.out.println(\"Input data\"); System.out.println(\"Number of points: \" + cp.array.length); for (int i = 0; i < cp.array.length; i++) { System.out.println(\"x: \" + cp.array[i].x + \", y: \" + cp.array[i].y); } cp.xQuickSort(cp.array, 0, cp.array.length - 1); // Sorting by x value double result; // minimum distance result = cp.closestPair(cp.array, cp.array.length); // ClosestPair start // minimum distance coordinates and distance output System.out.println(\"Output Data\"); System.out.println(\"(\" + cp.point1.x + \", \" + cp.point1.y + \")\"); System.out.println(\"(\" + cp.point2.x + \", \" + cp.point2.y + \")\"); System.out.println(\"Minimum Distance : \" + result); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; class CocktailShakerSort implements SortAlgorithm { CocktailShakerSort() { } @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length == 0) { return comparableArray; } int n = 0; int n2 = comparableArray.length - 1; while (n < n2) { int n3; int n4 = n2; int n5 = n; Object[] objectArray = comparableArray; int n6 = n5; for (n3 = n5; n3 < n4; ++n3) { if (!SortUtils.less(objectArray[n3 + 1], objectArray[n3])) continue; int n7 = n3; SortUtils.swap(objectArray, n7, n7 + 1); n6 = n3; } n4 = n2 = n6; n5 = n; objectArray = comparableArray; n6 = n4; for (n3 = n4; n3 > n5; --n3) { if (!SortUtils.less((Comparable)objectArray[n3], (Comparable)objectArray[n3 - 1])) continue; SortUtils.swap(objectArray, n3 - 1, n3); n6 = n3; } n = n6; } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * CocktailShakerSort class implements the Cocktail Shaker Sort algorithm, * which is a bidirectional bubble sort. It sorts the array by passing * through it back and forth, progressively moving the largest elements * to the end and the smallest elements to the beginning. * * @author Mateus Bizzo (https://github.com/MattBizzo) * @author Podshivalov Nikita (https://github.com/nikitap492) */ class CocktailShakerSort implements SortAlgorithm { /** * Sorts the given array using the Cocktail Shaker Sort algorithm. * * @param <T> The type of elements in the array, which must be comparable * @param array The array to be sorted * @return The sorted array */ @Override public <T extends Comparable<T>> T[] sort(final T[] array) { if (array.length == 0) { return array; } int left = 0; int right = array.length - 1; while (left < right) { right = performForwardPass(array, left, right); left = performBackwardPass(array, left, right); } return array; } /** * Performs a forward pass through the array, moving larger elements to the end. * * @param <T> The type of elements in the array, which must be comparable * @param array The array being sorted * @param left The current left boundary of the sorting area * @param right The current right boundary of the sorting area * @return The index of the last swapped element during this pass */ private <T extends Comparable<T>> int performForwardPass(final T[] array, final int left, final int right) { int lastSwappedIndex = left; for (int i = left; i < right; i++) { if (SortUtils.less(array[i + 1], array[i])) { SortUtils.swap(array, i, i + 1); lastSwappedIndex = i; } } return lastSwappedIndex; } /** * Performs a backward pass through the array, moving smaller elements to the beginning. * * @param <T> The type of elements in the array, which must be comparable * @param array The array being sorted * @param left The current left boundary of the sorting area * @param right The current right boundary of the sorting area * @return The index of the last swapped element during this pass */ private <T extends Comparable<T>> int performBackwardPass(final T[] array, final int left, final int right) { int lastSwappedIndex = right; for (int i = right; i > left; i--) { if (SortUtils.less(array[i], array[i - 1])) { SortUtils.swap(array, i - 1, i); lastSwappedIndex = i; } } return lastSwappedIndex; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.lineclipping; import com.thealgorithms.lineclipping.utils.Line; import com.thealgorithms.lineclipping.utils.Point; public class CohenSutherland { private double a; private double b; private double c; private double d; public CohenSutherland(double d, double d2, double d3, double d4) { this.a = d; this.b = d2; this.c = d3; this.d = d4; } private int a(double d, double d2) { int n = 0; if (d < this.a) { n = 1; } else if (d > this.c) { n = 2; } if (d2 < this.b) { n |= 4; } else if (d2 > this.d) { n |= 8; } return n; } public Line cohenSutherlandClip(Line line) { double d = line.start.x; double d2 = line.start.y; double d3 = line.end.x; double d4 = line.end.y; int n = this.a(d, d2); int n2 = this.a(d3, d4); boolean bl = false; while (true) { if (n == 0 && n2 == 0) { bl = true; break; } if ((n & n2) != 0) break; double d5 = 0.0; double d6 = 0.0; int n3 = n != 0 ? n : n2; if ((n3 & 8) != 0) { d5 = d + (d3 - d) * (this.d - d2) / (d4 - d2); d6 = this.d; } else if ((n3 & 4) != 0) { d5 = d + (d3 - d) * (this.b - d2) / (d4 - d2); d6 = this.b; } else if ((n3 & 2) != 0) { d6 = d2 + (d4 - d2) * (this.c - d) / (d3 - d); d5 = this.c; } else if ((n3 & 1) != 0) { d6 = d2 + (d4 - d2) * (this.a - d) / (d3 - d); d5 = this.a; } if (n3 == n) { d = d5; d2 = d6; n = this.a(d, d2); continue; } d3 = d5; d4 = d6; n2 = this.a(d3, d4); } if (bl) { return new Line(new Point(d, d2), new Point(d3, d4)); } return null; } }", "deobfuscated_code": "package com.thealgorithms.lineclipping; import com.thealgorithms.lineclipping.utils.Line; import com.thealgorithms.lineclipping.utils.Point; /** * @author shikarisohan * @since 10/4/24 * Cohen-Sutherland Line Clipping Algorithm * * This algorithm is used to clip a line segment to a rectangular window. * It assigns a region code to each endpoint of the line segment, and * then efficiently determines whether the line segment is fully inside, * fully outside, or partially inside the window. * * Reference: * https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm * * Clipping window boundaries are defined as (xMin, yMin) and (xMax, yMax). * The algorithm computes the clipped line segment if it's partially or * fully inside the clipping window. */ public class CohenSutherland { // Region codes for the 9 regions private static final int INSIDE = 0; // 0000 private static final int LEFT = 1; // 0001 private static final int RIGHT = 2; // 0010 private static final int BOTTOM = 4; // 0100 private static final int TOP = 8; // 1000 // Define the clipping window double xMin; double yMin; double xMax; double yMax; public CohenSutherland(double xMin, double yMin, double xMax, double yMax) { this.xMin = xMin; this.yMin = yMin; this.xMax = xMax; this.yMax = yMax; } // Compute the region code for a point (x, y) private int computeCode(double x, double y) { int code = INSIDE; if (x < xMin) // to the left of rectangle { code |= LEFT; } else if (x > xMax) // to the right of rectangle { code |= RIGHT; } if (y < yMin) // below the rectangle { code |= BOTTOM; } else if (y > yMax) // above the rectangle { code |= TOP; } return code; } // Cohen-Sutherland algorithm to return the clipped line public Line cohenSutherlandClip(Line line) { double x1 = line.start.x; double y1 = line.start.y; double x2 = line.end.x; double y2 = line.end.y; int code1 = computeCode(x1, y1); int code2 = computeCode(x2, y2); boolean accept = false; while (true) { if ((code1 == 0) && (code2 == 0)) { // Both points are inside the rectangle accept = true; break; } else if ((code1 & code2) != 0) { // Both points are outside the rectangle in the same region break; } else { // Some segment of the line is inside the rectangle double x = 0; double y = 0; // Pick an endpoint that is outside the rectangle int codeOut = (code1 != 0) ? code1 : code2; // Find the intersection point using the line equation if ((codeOut & TOP) != 0) { // Point is above the rectangle x = x1 + (x2 - x1) * (yMax - y1) / (y2 - y1); y = yMax; } else if ((codeOut & BOTTOM) != 0) { // Point is below the rectangle x = x1 + (x2 - x1) * (yMin - y1) / (y2 - y1); y = yMin; } else if ((codeOut & RIGHT) != 0) { // Point is to the right of the rectangle y = y1 + (y2 - y1) * (xMax - x1) / (x2 - x1); x = xMax; } else if ((codeOut & LEFT) != 0) { // Point is to the left of the rectangle y = y1 + (y2 - y1) * (xMin - x1) / (x2 - x1); x = xMin; } // Replace the point outside the rectangle with the intersection point if (codeOut == code1) { x1 = x; y1 = y; code1 = computeCode(x1, y1); } else { x2 = x; y2 = y; code2 = computeCode(x2, y2); } } } if (accept) { return new Line(new Point(x1, y1), new Point(x2, y2)); } else { return null; // The line is fully rejected } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; public final class CoinChange { private CoinChange() { } public static ArrayList coinChangeProblem(int n) { Integer[] integerArray = new Integer[]{1, 2, 5, 10, 20, 50, 100, 500, 2000}; Arrays.sort(integerArray, Comparator.reverseOrder()); ArrayList<Integer> arrayList = new ArrayList<Integer>(); for (int i = 0; i < integerArray.length; ++i) { if (integerArray[i] > n) continue; while (integerArray[i] <= n) { arrayList.add(integerArray[i]); n -= integerArray[i].intValue(); } } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; // Problem Link : https://en.wikipedia.org/wiki/Change-making_problem public final class CoinChange { private CoinChange() { } // Function to solve the coin change problem public static ArrayList<Integer> coinChangeProblem(int amount) { // Define an array of coin denominations in descending order Integer[] coins = {1, 2, 5, 10, 20, 50, 100, 500, 2000}; // Sort the coin denominations in descending order Arrays.sort(coins, Comparator.reverseOrder()); ArrayList<Integer> ans = new ArrayList<>(); // List to store selected coins // Iterate through the coin denominations for (int i = 0; i < coins.length; i++) { // Check if the current coin denomination can be used to reduce the remaining amount if (coins[i] <= amount) { // Repeatedly subtract the coin denomination from the remaining amount while (coins[i] <= amount) { ans.add(coins[i]); // Add the coin to the list of selected coins amount -= coins[i]; // Update the remaining amount } } } return ans; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.ArrayList; import java.util.List; public class CollatzConjecture { public int nextNumber(int n) { if (n % 2 == 0) { return n / 2; } return 3 * n + 1; } public List collatzConjecture(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Must be a natural number\"); } ArrayList<Integer> arrayList = new ArrayList<Integer>(); arrayList.add(n); while (n != 1) { arrayList.add(this.nextNumber(n)); n = this.nextNumber(n); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; import java.util.List; /** * <a href=\"https://en.wikipedia.org/wiki/Collatz_conjecture\">...</a> */ public class CollatzConjecture { /** * Calculate the next number of the sequence. * * @param n current number of the sequence * @return next number of the sequence */ public int nextNumber(final int n) { if (n % 2 == 0) { return n / 2; } return 3 * n + 1; } /** * Calculate the Collatz sequence of any natural number. * * @param firstNumber starting number of the sequence * @return sequence of the Collatz Conjecture */ public List<Integer> collatzConjecture(int firstNumber) { if (firstNumber < 1) { throw new IllegalArgumentException(\"Must be a natural number\"); } ArrayList<Integer> result = new ArrayList<>(); result.add(firstNumber); while (firstNumber != 1) { result.add(nextNumber(firstNumber)); firstNumber = nextNumber(firstNumber); } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import java.awt.Color; public class ColorContrastRatio { public double getContrastRatio(Color color, Color color2) { double d; double d2 = this.getRelativeLuminance(color); if (d2 > (d = this.getRelativeLuminance(color2))) { return (d2 + 0.05) / (d + 0.05); } return (d + 0.05) / (d2 + 0.05); } public double getRelativeLuminance(Color color) { double d = this.getColor(color.getRed()); double d2 = this.getColor(color.getGreen()); double d3 = this.getColor(color.getBlue()); return d * 0.2126 + d2 * 0.7152 + d3 * 0.0722; } public double getColor(int n) { double d; double d2 = n; double d3 = d2 / 255.0; if (d <= 0.03928) { return d3 / 12.92; } return Math.pow((d3 + 0.055) / 1.055, 2.4); } }", "deobfuscated_code": "package com.thealgorithms.misc; import java.awt.Color; /** * @brief A Java implementation of the official W3 documented procedure to * calculate contrast ratio between colors on the web. This is used to calculate * the readability of a foreground color on top of a background color. * @since 2020-10-15 * @see <a href=\"https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-procedure\">Color Contrast Ratio</a> * @author [Seth Falco](https://github.com/SethFalco) */ public class ColorContrastRatio { /** * @brief Calculates the contrast ratio between two given colors. * @param a Any color, used to get the red, green, and blue values. * @param b Another color, which will be compared against the first color. * @return The contrast ratio between the two colors. */ public double getContrastRatio(Color a, Color b) { final double aColorLuminance = getRelativeLuminance(a); final double bColorLuminance = getRelativeLuminance(b); if (aColorLuminance > bColorLuminance) { return (aColorLuminance + 0.05) / (bColorLuminance + 0.05); } return (bColorLuminance + 0.05) / (aColorLuminance + 0.05); } /** * @brief Calculates the relative luminance of a given color. * @param color Any color, used to get the red, green, and blue values. * @return The relative luminance of the color. * @see <a href=\"https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\">More info on relative luminance.</a> */ public double getRelativeLuminance(Color color) { final double red = getColor(color.getRed()); final double green = getColor(color.getGreen()); final double blue = getColor(color.getBlue()); return 0.2126 * red + 0.7152 * green + 0.0722 * blue; } /** * @brief Calculates the final value for a color to be used in the relative luminance formula as described in step 1. * @param color8Bit 8-bit representation of a color component value. * @return Value for the provided color component to be used in the relative luminance formula. */ public double getColor(int color8Bit) { final double sRgb = getColorSRgb(color8Bit); return (sRgb <= 0.03928) ? sRgb / 12.92 : Math.pow((sRgb + 0.055) / 1.055, 2.4); } /** * @brief Calculates the Color sRGB value as denoted in step 1 of the procedure document. * @param color8Bit 8-bit representation of a color component value. * @return A percentile value of the color component. */ private double getColorSRgb(double color8Bit) { return color8Bit / 255.0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.util.Objects; public final class ColumnarTranspositionCipher { private static String a; private static Object[][] b; private static String c; public static final String ABECEDARIUM = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,.;:-@\"; private ColumnarTranspositionCipher() { } public static String encrypt(String objectArray, String charSequence) { int n; a = charSequence; charSequence = new StringBuilder(); for (n = 0; n < 256; ++n) { ((StringBuilder)charSequence).append((char)n); } c = ((StringBuilder)charSequence).toString(); b = ColumnarTranspositionCipher.a((String)objectArray); objectArray = ColumnarTranspositionCipher.a(b); charSequence = new StringBuilder(); for (n = 0; n < objectArray[0].length; ++n) { for (int i = 1; i < objectArray.length; ++i) { ((StringBuilder)charSequence).append(objectArray[i][n]); } } return ((StringBuilder)charSequence).toString(); } public static String encrypt(String objectArray, String charSequence, String string) { a = charSequence; c = Objects.requireNonNullElse(string, ABECEDARIUM); b = ColumnarTranspositionCipher.a((String)objectArray); objectArray = ColumnarTranspositionCipher.a(b); charSequence = new StringBuilder(); for (int i = 0; i < objectArray[0].length; ++i) { for (int j = 1; j < objectArray.length; ++j) { ((StringBuilder)charSequence).append(objectArray[j][i]); } } return ((StringBuilder)charSequence).toString(); } public static String decrypt() { StringBuilder stringBuilder = new StringBuilder(); for (int i = 1; i < b.length; ++i) { for (Object object : b[i]) { stringBuilder.append(object); } } return stringBuilder.toString().replaceAll(\"\\u2248\", \"\"); } private static Object[][] a(String object) { Object[][] objectArray = new Object[ColumnarTranspositionCipher.b((String)object) + 1][a.length()]; object = ((String)object).toCharArray(); objectArray[0] = ColumnarTranspositionCipher.a(); int n = 0; for (int i = 1; i < objectArray.length; ++i) { for (int j = 0; j < objectArray[i].length; ++j) { if (n < ((Object)object).length) { objectArray[i][j] = Character.valueOf((char)object[n]); ++n; continue; } objectArray[i][j] = Character.valueOf('\\u2248'); } } return objectArray; } private static int b(String string) { if (string.length() % a.length() != 0) { return string.length() / a.length() + 1; } return string.length() / a.length(); } private static Object[] a() { Object[] objectArray = new Object[a.length()]; for (int i = 0; i < objectArray.length; ++i) { int n = c.indexOf(a.charAt(i)); objectArray[i] = n >= 0 ? Integer.valueOf(n) : null; } return objectArray; } private static Object[][] a(Object[][] objectArray) { int n; Object[][] objectArray2 = new Object[objectArray.length][objectArray[0].length]; for (n = 0; n < objectArray2.length; ++n) { System.arraycopy(objectArray[n], 0, objectArray2[n], 0, objectArray2[n].length); } for (n = 0; n < objectArray2[0].length; ++n) { for (int i = n + 1; i < objectArray2[0].length; ++i) { if ((Integer)objectArray2[0][n] <= (Integer)objectArray[0][i]) continue; Object[] objectArray3 = ColumnarTranspositionCipher.a(objectArray2, objectArray2.length, n); ColumnarTranspositionCipher.a(objectArray2, i, n, objectArray3); } } return objectArray2; } private static Object[] a(Object[][] objectArray, int n, int n2) { Object[] objectArray2 = new Object[n]; for (int i = 0; i < n; ++i) { objectArray2[i] = objectArray[i][n2]; } return objectArray2; } private static void a(Object[][] objectArray, int n, int n2, Object[] objectArray2) { for (int i = 0; i < objectArray.length; ++i) { objectArray[i][n2] = objectArray[i][n]; objectArray[i][n] = objectArray2[i]; } } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.util.Objects; /** * Columnar Transposition Cipher Encryption and Decryption. * * @author <a href=\"https://github.com/freitzzz\">freitzzz</a> */ public final class ColumnarTranspositionCipher { private ColumnarTranspositionCipher() { } private static String keyword; private static Object[][] table; private static String abecedarium; public static final String ABECEDARIUM = \"abcdefghijklmnopqrstuvwxyzABCDEFG\" + \"HIJKLMNOPQRSTUVWXYZ0123456789,.;:-@\"; private static final String ENCRYPTION_FIELD = \"\"; private static final char ENCRYPTION_FIELD_CHAR = ''; /** * Encrypts a certain String with the Columnar Transposition Cipher Rule * * @param word Word being encrypted * @param keyword String with keyword being used * @return a String with the word encrypted by the Columnar Transposition * Cipher Rule */ public static String encrypt(final String word, final String keyword) { ColumnarTranspositionCipher.keyword = keyword; abecedariumBuilder(); table = tableBuilder(word); Object[][] sortedTable = sortTable(table); StringBuilder wordEncrypted = new StringBuilder(); for (int i = 0; i < sortedTable[0].length; i++) { for (int j = 1; j < sortedTable.length; j++) { wordEncrypted.append(sortedTable[j][i]); } } return wordEncrypted.toString(); } /** * Encrypts a certain String with the Columnar Transposition Cipher Rule * * @param word Word being encrypted * @param keyword String with keyword being used * @param abecedarium String with the abecedarium being used. null for * default one * @return a String with the word encrypted by the Columnar Transposition * Cipher Rule */ public static String encrypt(String word, String keyword, String abecedarium) { ColumnarTranspositionCipher.keyword = keyword; ColumnarTranspositionCipher.abecedarium = Objects.requireNonNullElse(abecedarium, ABECEDARIUM); table = tableBuilder(word); Object[][] sortedTable = sortTable(table); StringBuilder wordEncrypted = new StringBuilder(); for (int i = 0; i < sortedTable[0].length; i++) { for (int j = 1; j < sortedTable.length; j++) { wordEncrypted.append(sortedTable[j][i]); } } return wordEncrypted.toString(); } /** * Decrypts a certain encrypted String with the Columnar Transposition * Cipher Rule * * @return a String decrypted with the word encrypted by the Columnar * Transposition Cipher Rule */ public static String decrypt() { StringBuilder wordDecrypted = new StringBuilder(); for (int i = 1; i < table.length; i++) { for (Object item : table[i]) { wordDecrypted.append(item); } } return wordDecrypted.toString().replaceAll(ENCRYPTION_FIELD, \"\"); } /** * Builds a table with the word to be encrypted in rows by the Columnar * Transposition Cipher Rule * * @return An Object[][] with the word to be encrypted filled in rows and * columns */ private static Object[][] tableBuilder(String word) { Object[][] table = new Object[numberOfRows(word) + 1][keyword.length()]; char[] wordInChars = word.toCharArray(); // Fills in the respective numbers for the column table[0] = findElements(); int charElement = 0; for (int i = 1; i < table.length; i++) { for (int j = 0; j < table[i].length; j++) { if (charElement < wordInChars.length) { table[i][j] = wordInChars[charElement]; charElement++; } else { table[i][j] = ENCRYPTION_FIELD_CHAR; } } } return table; } /** * Determines the number of rows the table should have regarding the * Columnar Transposition Cipher Rule * * @return an int with the number of rows that the table should have in * order to respect the Columnar Transposition Cipher Rule. */ private static int numberOfRows(String word) { if (word.length() % keyword.length() != 0) { return (word.length() / keyword.length()) + 1; } else { return word.length() / keyword.length(); } } /** * @return charValues */ private static Object[] findElements() { Object[] charValues = new Object[keyword.length()]; for (int i = 0; i < charValues.length; i++) { int charValueIndex = abecedarium.indexOf(keyword.charAt(i)); charValues[i] = charValueIndex > -1 ? charValueIndex : null; } return charValues; } /** * @return tableSorted */ private static Object[][] sortTable(Object[][] table) { Object[][] tableSorted = new Object[table.length][table[0].length]; for (int i = 0; i < tableSorted.length; i++) { System.arraycopy(table[i], 0, tableSorted[i], 0, tableSorted[i].length); } for (int i = 0; i < tableSorted[0].length; i++) { for (int j = i + 1; j < tableSorted[0].length; j++) { if ((int) tableSorted[0][i] > (int) table[0][j]) { Object[] column = getColumn(tableSorted, tableSorted.length, i); switchColumns(tableSorted, j, i, column); } } } return tableSorted; } /** * @return columnArray */ private static Object[] getColumn(Object[][] table, int rows, int column) { Object[] columnArray = new Object[rows]; for (int i = 0; i < rows; i++) { columnArray[i] = table[i][column]; } return columnArray; } private static void switchColumns(Object[][] table, int firstColumnIndex, int secondColumnIndex, Object[] columnToSwitch) { for (int i = 0; i < table.length; i++) { table[i][secondColumnIndex] = table[i][firstColumnIndex]; table[i][firstColumnIndex] = columnToSwitch[i]; } } /** * Creates an abecedarium with all available ascii values. */ private static void abecedariumBuilder() { StringBuilder t = new StringBuilder(); for (int i = 0; i < 256; i++) { t.append((char) i); } abecedarium = t.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; class CombSort implements SortAlgorithm { CombSort() { } @Override public Comparable[] sort(Comparable[] comparableArray) { int n = comparableArray.length; int n2 = 1; while (n != 1 || n2 != 0) { n2 = n; n2 = (int)((double)n2 / 1.3); int n3 = n = Math.max(n2, 1); Object[] objectArray = comparableArray; int n4 = 0; for (int i = 0; i < objectArray.length - n3; ++i) { if (!SortUtils.less(objectArray[i + n3], objectArray[i])) continue; int n5 = i; SortUtils.swap(objectArray, n5, n5 + n3); n4 = 1; } n2 = n4; } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * Comb Sort algorithm implementation * * <p> * Best-case performance O(n * log(n)) Worst-case performance O(n ^ 2) * Worst-case space complexity O(1) * * <p> * Comb sort improves on bubble sort. * * @author Sandeep Roy (https://github.com/sandeeproy99) * @author Podshivalov Nikita (https://github.com/nikitap492) * @see BubbleSort * @see SortAlgorithm */ class CombSort implements SortAlgorithm { private static final double SHRINK_FACTOR = 1.3; /** * Method to find the next gap * * @param gap the current gap * @return the next gap value */ private int getNextGap(int gap) { gap = (int) (gap / SHRINK_FACTOR); return Math.max(gap, 1); } /** * Method to sort the array using CombSort * * @param arr the array to be sorted * @param <T> the type of elements in the array * @return the sorted array */ @Override public <T extends Comparable<T>> T[] sort(T[] arr) { int gap = arr.length; boolean swapped = true; while (gap != 1 || swapped) { gap = getNextGap(gap); swapped = performSwaps(arr, gap); } return arr; } /** * Method to perform the swapping of elements in the array based on the current gap * * @param arr the array to be sorted * @param gap the current gap * @param <T> the type of elements in the array * @return true if a swap occurred, false otherwise */ private <T extends Comparable<T>> boolean performSwaps(final T[] arr, final int gap) { boolean swapped = false; for (int i = 0; i < arr.length - gap; i++) { if (SortUtils.less(arr[i + gap], arr[i])) { SortUtils.swap(arr, i, i + gap); swapped = true; } } return swapped; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; import java.util.Arrays; import java.util.Collections; import java.util.LinkedList; import java.util.List; import java.util.TreeSet; public final class Combination { private Combination() { } public static List combination(Object[] objectArray, int n) { if (n < 0) { throw new IllegalArgumentException(\"The combination length cannot be negative.\"); } if (n == 0) { return Collections.emptyList(); } objectArray = (Object[])objectArray.clone(); Arrays.sort(objectArray); LinkedList linkedList = new LinkedList(); Combination.a(objectArray, n, 0, new TreeSet(), linkedList); return linkedList; } private static void a(Object[] objectArray, int n, int n2, TreeSet treeSet, List list) { if (n2 + n - treeSet.size() > objectArray.length) { return; } if (treeSet.size() == n - 1) { while (n2 < objectArray.length) { treeSet.add(objectArray[n2]); list.add(new TreeSet(treeSet)); treeSet.remove(objectArray[n2]); ++n2; } return; } while (n2 < objectArray.length) { treeSet.add(objectArray[n2]); Combination.a(objectArray, n, n2 + 1, treeSet, list); treeSet.remove(objectArray[n2]); ++n2; } } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.Arrays; import java.util.Collections; import java.util.LinkedList; import java.util.List; import java.util.TreeSet; /** * Finds all permutations of given array * @author Alan Piao (<a href=\"https://github.com/cpiao3\">git-Alan Piao</a>) */ public final class Combination { private Combination() { } /** * Find all combinations of given array using backtracking * @param arr the array. * @param n length of combination * @param <T> the type of elements in the array. * @return a list of all combinations of length n. If n == 0, return null. */ public static <T> List<TreeSet<T>> combination(T[] arr, int n) { if (n < 0) { throw new IllegalArgumentException(\"The combination length cannot be negative.\"); } if (n == 0) { return Collections.emptyList(); } T[] array = arr.clone(); Arrays.sort(array); List<TreeSet<T>> result = new LinkedList<>(); backtracking(array, n, 0, new TreeSet<T>(), result); return result; } /** * Backtrack all possible combinations of a given array * @param arr the array. * @param n length of the combination * @param index the starting index. * @param currSet set that tracks current combination * @param result the list contains all combination. * @param <T> the type of elements in the array. */ private static <T> void backtracking(T[] arr, int n, int index, TreeSet<T> currSet, List<TreeSet<T>> result) { if (index + n - currSet.size() > arr.length) { return; } if (currSet.size() == n - 1) { for (int i = index; i < arr.length; i++) { currSet.add(arr[i]); result.add(new TreeSet<>(currSet)); currSet.remove(arr[i]); } return; } for (int i = index; i < arr.length; i++) { currSet.add(arr[i]); backtracking(arr, n, i + 1, currSet, result); currSet.remove(arr[i]); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class Combinations { private Combinations() { } public static long factorial(int n) { if (n < 0) { throw new IllegalArgumentException(\"number is negative\"); } if (n == 0 || n == 1) { return 1L; } return (long)n * Combinations.factorial(n - 1); } public static long combinations(int n, int n2) { return Combinations.factorial(n) / (Combinations.factorial(n2) * Combinations.factorial(n - n2)); } public static long combinationsOptimized(int n, int n2) { if (n < 0 || n2 < 0) { throw new IllegalArgumentException(\"n or k can't be negative\"); } if (n < n2) { throw new IllegalArgumentException(\"n can't be smaller than k\"); } long l = 1L; for (int i = 0; i < n2; ++i) { l = (long)(n - i) * l / (long)(i + 1); } return l; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * @see <a href=\"https://en.wikipedia.org/wiki/Combination\">Combination</a> */ public final class Combinations { private Combinations() { } /** * Calculate of factorial * * @param n the number * @return factorial of given number */ public static long factorial(int n) { if (n < 0) { throw new IllegalArgumentException(\"number is negative\"); } return n == 0 || n == 1 ? 1 : n * factorial(n - 1); } /** * Calculate combinations * * @param n first number * @param k second number * @return combinations of given {@code n} and {@code k} */ public static long combinations(int n, int k) { return factorial(n) / (factorial(k) * factorial(n - k)); } /** * The above method can exceed limit of long (overflow) when factorial(n) is * larger than limits of long variable. Thus even if nCk is within range of * long variable above reason can lead to incorrect result. This is an * optimized version of computing combinations. Observations: nC(k + 1) = (n * - k) * nCk / (k + 1) We know the value of nCk when k = 1 which is nCk = n * Using this base value and above formula we can compute the next term * nC(k+1) * * @param n * @param k * @return nCk */ public static long combinationsOptimized(int n, int k) { if (n < 0 || k < 0) { throw new IllegalArgumentException(\"n or k can't be negative\"); } if (n < k) { throw new IllegalArgumentException(\"n can't be smaller than k\"); } // nC0 is always 1 long solution = 1; for (int i = 0; i < k; i++) { solution = (n - i) * solution / (i + 1); } return solution; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; class ComplexNumber { private Double a; private Double b; ComplexNumber(double d, double d2) { this.a = d; this.b = d2; } ComplexNumber(double d) { this.a = d; this.b = null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; class ComplexNumber { private Double a; private Double b; ComplexNumber(double d, double d2) { this.a = d; this.b = d2; } ComplexNumber(double d) { this.a = d; this.b = null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers.a5; import com.thealgorithms.ciphers.a5.BaseLFSR; import com.thealgorithms.ciphers.a5.LFSR; import java.util.ArrayList; import java.util.List; import java.util.TreeMap; public abstract class CompositeLFSR implements BaseLFSR { protected final List a = new ArrayList(); @Override public boolean clock() { CompositeLFSR compositeLFSR = this; TreeMap<Boolean, Integer> treeMap = new TreeMap<Boolean, Integer>(); treeMap.put(Boolean.FALSE, 0); treeMap.put(Boolean.TRUE, 0); compositeLFSR.a.forEach(lFSR -> treeMap.put(lFSR.getClockBit(), (Integer)treeMap.get(lFSR.getClockBit()) + 1)); boolean bl = (Integer)treeMap.get(Boolean.FALSE) <= (Integer)treeMap.get(Boolean.TRUE); boolean bl2 = false; for (LFSR lFSR2 : this.a) { bl2 ^= lFSR2.getLastBit(); if (lFSR2.getClockBit() != bl) continue; lFSR2.clock(); } return bl2; } }", "deobfuscated_code": "package com.thealgorithms.ciphers.a5; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.TreeMap; /** * The CompositeLFSR class represents a composite implementation of * Linear Feedback Shift Registers (LFSRs) for cryptographic purposes. * * <p> * This abstract class manages a collection of LFSR instances and * provides a mechanism for irregular clocking based on the * majority bit among the registers. It implements the BaseLFSR * interface, requiring subclasses to define specific LFSR behaviors. * </p> */ public abstract class CompositeLFSR implements BaseLFSR { protected final List<LFSR> registers = new ArrayList<>(); /** * Performs a clocking operation on the composite LFSR. * * <p> * This method determines the majority bit across all registers and * clocks each register based on its clock bit. If a register's * clock bit matches the majority bit, it is clocked (shifted). * The method also computes and returns the XOR of the last bits * of all registers. * </p> * * @return the XOR value of the last bits of all registers. */ @Override public boolean clock() { boolean majorityBit = getMajorityBit(); boolean result = false; for (var register : registers) { result ^= register.getLastBit(); if (register.getClockBit() == majorityBit) { register.clock(); } } return result; } /** * Calculates the majority bit among all registers. * * <p> * This private method counts the number of true and false clock bits * across all LFSR registers. It returns true if the count of true * bits is greater than or equal to the count of false bits; otherwise, * it returns false. * </p> * * @return true if the majority clock bits are true; false otherwise. */ private boolean getMajorityBit() { Map<Boolean, Integer> bitCount = new TreeMap<>(); bitCount.put(Boolean.FALSE, 0); bitCount.put(Boolean.TRUE, 0); registers.forEach(lfsr -> bitCount.put(lfsr.getClockBit(), bitCount.get(lfsr.getClockBit()) + 1)); return bitCount.get(Boolean.FALSE) <= bitCount.get(Boolean.TRUE); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.Graph; public final class ConnectedComponent { private ConnectedComponent() { } public static void main(String[] object) { object = new Graph(); ((Graph)object).addEdge(Character.valueOf('a'), Character.valueOf('b')); ((Graph)object).addEdge(Character.valueOf('a'), Character.valueOf('e')); ((Graph)object).addEdge(Character.valueOf('b'), Character.valueOf('e')); ((Graph)object).addEdge(Character.valueOf('b'), Character.valueOf('c')); ((Graph)object).addEdge(Character.valueOf('c'), Character.valueOf('d')); ((Graph)object).addEdge(Character.valueOf('d'), Character.valueOf('a')); ((Graph)object).addEdge(Character.valueOf('x'), Character.valueOf('y')); ((Graph)object).addEdge(Character.valueOf('x'), Character.valueOf('z')); ((Graph)object).addEdge(Character.valueOf('w'), Character.valueOf('w')); Graph graph = new Graph(); graph.addEdge(Integer.valueOf(1), Integer.valueOf(2)); graph.addEdge(Integer.valueOf(2), Integer.valueOf(3)); graph.addEdge(Integer.valueOf(2), Integer.valueOf(4)); graph.addEdge(Integer.valueOf(3), Integer.valueOf(5)); graph.addEdge(Integer.valueOf(7), Integer.valueOf(8)); graph.addEdge(Integer.valueOf(8), Integer.valueOf(10)); graph.addEdge(Integer.valueOf(10), Integer.valueOf(8)); System.out.println(\"Amount of different char-graphs: \" + ((Graph)object).countGraphs()); System.out.println(\"Amount of different int-graphs: \" + graph.countGraphs()); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.HashSet; import java.util.Set; /** * A class that counts the number of different connected components in a graph * * @author Lukas Keul, Florian Mercks */ class Graph<E extends Comparable<E>> { class Node { E name; Node(E name) { this.name = name; } } class Edge { Node startNode; Node endNode; Edge(Node startNode, Node endNode) { this.startNode = startNode; this.endNode = endNode; } } ArrayList<Edge> edgeList; ArrayList<Node> nodeList; Graph() { edgeList = new ArrayList<Edge>(); nodeList = new ArrayList<Node>(); } /** * Adds a new Edge to the graph. If the nodes aren't yet in nodeList, they * will be added to it. * * @param startNode the starting Node from the edge * @param endNode the ending Node from the edge */ public void addEdge(E startNode, E endNode) { Node start = null; Node end = null; for (Node node : nodeList) { if (startNode.compareTo(node.name) == 0) { start = node; } else if (endNode.compareTo(node.name) == 0) { end = node; } } if (start == null) { start = new Node(startNode); nodeList.add(start); } if (end == null) { end = new Node(endNode); nodeList.add(end); } edgeList.add(new Edge(start, end)); } /** * Main method used for counting the connected components. Iterates through * the array of nodes to do a depth first search to get all nodes of the * graph from the actual node. These nodes are added to the array * markedNodes and will be ignored if they are chosen in the nodeList. * * @return returns the amount of unconnected graphs */ public int countGraphs() { int count = 0; Set<Node> markedNodes = new HashSet<Node>(); for (Node n : nodeList) { if (markedNodes.add(n)) { markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>())); count++; } } return count; } /** * Implementation of depth first search. * * @param n the actual visiting node * @param visited A list of already visited nodes in the depth first search * @return returns a set of visited nodes */ public ArrayList<Node> depthFirstSearch(Node n, ArrayList<Node> visited) { visited.add(n); for (Edge e : edgeList) { if (e.startNode.equals(n) && !visited.contains(e.endNode)) { depthFirstSearch(e.endNode, visited); } } return visited; } } public final class ConnectedComponent { private ConnectedComponent() { } public static void main(String[] args) { Graph<Character> graphChars = new Graph<>(); // Graph 1 graphChars.addEdge('a', 'b'); graphChars.addEdge('a', 'e'); graphChars.addEdge('b', 'e'); graphChars.addEdge('b', 'c'); graphChars.addEdge('c', 'd'); graphChars.addEdge('d', 'a'); graphChars.addEdge('x', 'y'); graphChars.addEdge('x', 'z'); graphChars.addEdge('w', 'w'); Graph<Integer> graphInts = new Graph<>(); // Graph 2 graphInts.addEdge(1, 2); graphInts.addEdge(2, 3); graphInts.addEdge(2, 4); graphInts.addEdge(3, 5); graphInts.addEdge(7, 8); graphInts.addEdge(8, 10); graphInts.addEdge(10, 8); System.out.println(\"Amount of different char-graphs: \" + graphChars.countGraphs()); System.out.println(\"Amount of different int-graphs: \" + graphInts.countGraphs()); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.graph; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; public final class ConstrainedShortestPath$Graph$Edge extends Record { private final int a; private final int b; private final int c; private final int d; public ConstrainedShortestPath$Graph$Edge(int n, int n2, int n3, int n4) { this.a = n; this.b = n2; this.c = n3; this.d = n4; } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{ConstrainedShortestPath$Graph$Edge.class, \"from;to;cost;resource\", \"a\", \"b\", \"c\", \"d\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{ConstrainedShortestPath$Graph$Edge.class, \"from;to;cost;resource\", \"a\", \"b\", \"c\", \"d\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{ConstrainedShortestPath$Graph$Edge.class, \"from;to;cost;resource\", \"a\", \"b\", \"c\", \"d\"}, this, object); } public final int from() { return this.a; } public final int to() { return this.b; } public final int cost() { return this.c; } public final int resource() { return this.d; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.graph; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; public final class ConstrainedShortestPath$Graph$Edge extends Record { private final int a; private final int b; private final int c; private final int d; public ConstrainedShortestPath$Graph$Edge(int n, int n2, int n3, int n4) { this.a = n; this.b = n2; this.c = n3; this.d = n4; } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{ConstrainedShortestPath$Graph$Edge.class, \"from;to;cost;resource\", \"a\", \"b\", \"c\", \"d\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{ConstrainedShortestPath$Graph$Edge.class, \"from;to;cost;resource\", \"a\", \"b\", \"c\", \"d\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{ConstrainedShortestPath$Graph$Edge.class, \"from;to;cost;resource\", \"a\", \"b\", \"c\", \"d\"}, this, object); } public final int from() { return this.a; } public final int to() { return this.b; } public final int cost() { return this.c; } public final int resource() { return this.d; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.graph; import com.thealgorithms.graph.ConstrainedShortestPath$Graph$Edge; import java.util.ArrayList; import java.util.List; public class ConstrainedShortestPath$Graph { private List a = new ArrayList(); public ConstrainedShortestPath$Graph(int n) { for (int i = 0; i < n; ++i) { this.a.add(new ArrayList()); } } public void addEdge(int n, int n2, int n3, int n4) { ((List)this.a.get(n)).add(new ConstrainedShortestPath$Graph$Edge(n, n2, n3, n4)); } public List getEdges(int n) { return (List)this.a.get(n); } public int getNumNodes() { return this.a.size(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.graph; import com.thealgorithms.graph.ConstrainedShortestPath$Graph$Edge; import java.util.ArrayList; import java.util.List; public class ConstrainedShortestPath$Graph { private List a = new ArrayList(); public ConstrainedShortestPath$Graph(int n) { for (int i = 0; i < n; ++i) { this.a.add(new ArrayList()); } } public void addEdge(int n, int n2, int n3, int n4) { ((List)this.a.get(n)).add(new ConstrainedShortestPath$Graph$Edge(n, n2, n3, n4)); } public List getEdges(int n) { return (List)this.a.get(n); } public int getNumNodes() { return this.a.size(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.graph; import com.thealgorithms.graph.ConstrainedShortestPath$Graph; import com.thealgorithms.graph.ConstrainedShortestPath$Graph$Edge; import java.util.Arrays; public class ConstrainedShortestPath { private ConstrainedShortestPath$Graph a; private int b; public ConstrainedShortestPath(ConstrainedShortestPath$Graph constrainedShortestPath$Graph, int n) { this.a = constrainedShortestPath$Graph; this.b = n; } public int solve(int n, int n2) { int n3; int n4 = this.a.getNumNodes(); int[][] nArray = new int[this.b + 1][n4]; for (n3 = 0; n3 <= this.b; ++n3) { Arrays.fill(nArray[n3], Integer.MAX_VALUE); } nArray[0][n] = 0; for (n3 = 0; n3 <= this.b; ++n3) { for (n = 0; n < n4; ++n) { if (nArray[n3][n] == Integer.MAX_VALUE) continue; for (ConstrainedShortestPath$Graph$Edge constrainedShortestPath$Graph$Edge : this.a.getEdges(n)) { int n5 = constrainedShortestPath$Graph$Edge.to(); int n6 = constrainedShortestPath$Graph$Edge.cost(); int n7 = constrainedShortestPath$Graph$Edge.resource(); if (n3 + n7 > this.b) continue; nArray[n3 + n7][n5] = Math.min(nArray[n3 + n7][n5], nArray[n3][n] + n6); } } } n3 = Integer.MAX_VALUE; for (n = 0; n <= this.b; ++n) { n3 = Math.min(n3, nArray[n][n2]); } if (n3 == Integer.MAX_VALUE) { return -1; } return n3; } }", "deobfuscated_code": "package com.thealgorithms.graph; import java.util.ArrayList; import java.util.Arrays; import java.util.List; /** * This class implements a solution for the Constrained Shortest Path Problem (CSPP). * also known as Shortest Path Problem with Resource Constraints (SPPRC). * The goal is to find the shortest path between two nodes while ensuring that * the resource constraint is not exceeded. * * @author <a href=\"https://github.com/DenizAltunkapan\">Deniz Altunkapan</a> */ public class ConstrainedShortestPath { /** * Represents a graph using an adjacency list. * This graph is designed for the Constrained Shortest Path Problem (CSPP). */ public static class Graph { private List<List<Edge>> adjacencyList; public Graph(int numNodes) { adjacencyList = new ArrayList<>(); for (int i = 0; i < numNodes; i++) { adjacencyList.add(new ArrayList<>()); } } /** * Adds an edge to the graph. * @param from the starting node * @param to the ending node * @param cost the cost of the edge * @param resource the resource required to traverse the edge */ public void addEdge(int from, int to, int cost, int resource) { adjacencyList.get(from).add(new Edge(from, to, cost, resource)); } /** * Gets the edges that are adjacent to a given node. * @param node the node to get the edges for * @return the list of edges adjacent to the node */ public List<Edge> getEdges(int node) { return adjacencyList.get(node); } /** * Gets the number of nodes in the graph. * @return the number of nodes */ public int getNumNodes() { return adjacencyList.size(); } public record Edge(int from, int to, int cost, int resource) { } } private Graph graph; private int maxResource; /** * Constructs a CSPSolver with the given graph and maximum resource constraint. * * @param graph the graph representing the problem * @param maxResource the maximum allowable resource */ public ConstrainedShortestPath(Graph graph, int maxResource) { this.graph = graph; this.maxResource = maxResource; } /** * Solves the CSP to find the shortest path from the start node to the target node * without exceeding the resource constraint. * * @param start the starting node * @param target the target node * @return the minimum cost to reach the target node within the resource constraint, * or -1 if no valid path exists */ public int solve(int start, int target) { int numNodes = graph.getNumNodes(); int[][] dp = new int[maxResource + 1][numNodes]; // Initialize dp table with maximum values for (int i = 0; i <= maxResource; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); } dp[0][start] = 0; // Dynamic Programming: Iterate over resources and nodes for (int r = 0; r <= maxResource; r++) { for (int u = 0; u < numNodes; u++) { if (dp[r][u] == Integer.MAX_VALUE) { continue; } for (Graph.Edge edge : graph.getEdges(u)) { int v = edge.to(); int cost = edge.cost(); int resource = edge.resource(); if (r + resource <= maxResource) { dp[r + resource][v] = Math.min(dp[r + resource][v], dp[r][u] + cost); } } } } // Find the minimum cost to reach the target node int minCost = Integer.MAX_VALUE; for (int r = 0; r <= maxResource; r++) { minCost = Math.min(minCost, dp[r][target]); } return minCost == Integer.MAX_VALUE ? -1 : minCost; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.geometry; import com.thealgorithms.geometry.Point; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.TreeSet; public final class ConvexHull { private ConvexHull() { } private static boolean a(Point point, Point point2, Point point3) { int n = Point.orientation(point, point2, point3); if (n > 0) { return true; } if (n < 0) { return false; } return point3.compareTo(point) >= 0 && point3.compareTo(point2) <= 0; } public static List convexHullBruteForce(List list) { TreeSet treeSet = new TreeSet(Comparator.naturalOrder()); for (int i = 0; i < list.size() - 1; ++i) { for (int j = i + 1; j < list.size(); ++j) { boolean bl = true; boolean bl2 = ConvexHull.a((Point)list.get(i), (Point)list.get(j), (Point)list.get((i + 1) % list.size())); for (int k = 0; k < list.size(); ++k) { if (k == i || k == j || ConvexHull.a((Point)list.get(i), (Point)list.get(j), (Point)list.get(k)) == bl2) continue; bl = false; break; } if (!bl) continue; treeSet.add((Point)list.get(i)); treeSet.add((Point)list.get(j)); } } return new ArrayList(treeSet); } public static List convexHullRecursive(List list) { Collections.sort(list); HashSet<Point> hashSet = new HashSet<Point>(); Point point = (Point)list.get(0); List list2 = list; Point point2 = (Point)list2.get(list2.size() - 1); hashSet.add(point); hashSet.add(point2); ArrayList<Point> arrayList = new ArrayList<Point>(); ArrayList<Point> arrayList2 = new ArrayList<Point>(); for (int i = 1; i < list.size() - 1; ++i) { int n = Point.orientation(point, point2, (Point)list.get(i)); if (n > 0) { arrayList.add((Point)list.get(i)); continue; } if (n >= 0) continue; arrayList2.add((Point)list.get(i)); } ConvexHull.a(arrayList, point, point2, hashSet); ConvexHull.a(arrayList2, point2, point, hashSet); ArrayList arrayList3 = new ArrayList(hashSet); Collections.sort(arrayList3); return arrayList3; } private static void a(Collection arrayList, Point point, Point point2, Set set) { while (!arrayList.isEmpty()) { Point point3 = null; int n = Integer.MIN_VALUE; ArrayList<Point> arrayList2 = new ArrayList<Point>(); for (Point point4 : arrayList) { int n2 = Point.orientation(point, point2, point4); if (n2 <= 0) continue; arrayList2.add(point4); if (n2 <= n) continue; n = n2; point3 = point4; } if (point3 == null) break; ConvexHull.a(arrayList2, point, point3, set); set.add(point3); point = point3; arrayList = arrayList2; } } }", "deobfuscated_code": "package com.thealgorithms.geometry; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.TreeSet; /** * A class providing algorithms to compute the convex hull of a set of points * using brute-force and recursive methods. * * Convex hull: The smallest convex polygon that contains all the given points. * * Algorithms provided: * 1. Brute-Force Method * 2. Recursive (Divide-and-Conquer) Method * * @author Hardvan */ public final class ConvexHull { private ConvexHull() { } private static boolean checkPointOrientation(Point i, Point j, Point k) { int detK = Point.orientation(i, j, k); if (detK > 0) { return true; // pointsLeftOfIJ } else if (detK < 0) { return false; // pointsRightOfIJ } else { return k.compareTo(i) >= 0 && k.compareTo(j) <= 0; } } public static List<Point> convexHullBruteForce(List<Point> points) { Set<Point> convexSet = new TreeSet<>(Comparator.naturalOrder()); for (int i = 0; i < points.size() - 1; i++) { for (int j = i + 1; j < points.size(); j++) { boolean allPointsOnOneSide = true; boolean leftSide = checkPointOrientation(points.get(i), points.get(j), points.get((i + 1) % points.size())); for (int k = 0; k < points.size(); k++) { if (k != i && k != j && checkPointOrientation(points.get(i), points.get(j), points.get(k)) != leftSide) { allPointsOnOneSide = false; break; } } if (allPointsOnOneSide) { convexSet.add(points.get(i)); convexSet.add(points.get(j)); } } } return new ArrayList<>(convexSet); } public static List<Point> convexHullRecursive(List<Point> points) { Collections.sort(points); Set<Point> convexSet = new HashSet<>(); Point leftMostPoint = points.get(0); Point rightMostPoint = points.get(points.size() - 1); convexSet.add(leftMostPoint); convexSet.add(rightMostPoint); List<Point> upperHull = new ArrayList<>(); List<Point> lowerHull = new ArrayList<>(); for (int i = 1; i < points.size() - 1; i++) { int det = Point.orientation(leftMostPoint, rightMostPoint, points.get(i)); if (det > 0) { upperHull.add(points.get(i)); } else if (det < 0) { lowerHull.add(points.get(i)); } } constructHull(upperHull, leftMostPoint, rightMostPoint, convexSet); constructHull(lowerHull, rightMostPoint, leftMostPoint, convexSet); List<Point> result = new ArrayList<>(convexSet); Collections.sort(result); return result; } private static void constructHull(Collection<Point> points, Point left, Point right, Set<Point> convexSet) { if (!points.isEmpty()) { Point extremePoint = null; int extremePointDistance = Integer.MIN_VALUE; List<Point> candidatePoints = new ArrayList<>(); for (Point p : points) { int det = Point.orientation(left, right, p); if (det > 0) { candidatePoints.add(p); if (det > extremePointDistance) { extremePointDistance = det; extremePoint = p; } } } if (extremePoint != null) { constructHull(candidatePoints, left, extremePoint, convexSet); convexSet.add(extremePoint); constructHull(candidatePoints, extremePoint, right, convexSet); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class Convolution { private Convolution() { } public static double[] convolution(double[] dArray, double[] dArray2) { double[] dArray3 = new double[dArray.length + dArray2.length - 1]; for (int i = 0; i < dArray3.length; ++i) { double d = 0.0; int n = Math.max(0, i - dArray2.length + 1); int n2 = Math.min(i, dArray.length - 1); while (n <= n2) { d += dArray[n] * dArray2[i - n]; ++n; } dArray3[i] = d; } return dArray3; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Class for linear convolution of two discrete signals * * @author Ioannis Karavitsis * @version 1.0 */ public final class Convolution { private Convolution() { } /** * Discrete linear convolution function. Both input signals and the output * signal must start from 0. If you have a signal that has values before 0 * then shift it to start from 0. * * @param a The first discrete signal * @param b The second discrete signal * @return The convolved signal */ public static double[] convolution(double[] a, double[] b) { double[] convolved = new double[a.length + b.length - 1]; /* * Discrete convolution formula: * C[i] =  A[k] * B[i - k] * where k ranges over valid indices so that both A[k] and B[i-k] are in bounds. */ for (int i = 0; i < convolved.length; i++) { double sum = 0; int kStart = Math.max(0, i - b.length + 1); int kEnd = Math.min(i, a.length - 1); for (int k = kStart; k <= kEnd; k++) { sum += a[k] * b[i - k]; } convolved[i] = sum; } return convolved; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.FFT; import com.thealgorithms.maths.FFT$Complex; import java.util.ArrayList; import java.util.Collection; public final class ConvolutionFFT { private ConvolutionFFT() { } private static void a(Collection collection, int n) { if (collection.size() < n) { n -= collection.size(); for (int i = 0; i < n; ++i) { collection.add(new FFT$Complex()); } } } public static ArrayList convolutionFFT(ArrayList arrayList, ArrayList arrayList2) { int n = arrayList.size() + arrayList2.size() - 1; ConvolutionFFT.a(arrayList, n); ConvolutionFFT.a(arrayList2, n); FFT.fft(arrayList, false); FFT.fft(arrayList2, false); ArrayList<FFT$Complex> arrayList3 = new ArrayList<FFT$Complex>(); for (int i = 0; i < arrayList.size(); ++i) { arrayList3.add(((FFT$Complex)arrayList.get(i)).multiply((FFT$Complex)arrayList2.get(i))); } FFT.fft(arrayList3, true); arrayList3.subList(n, arrayList3.size()).clear(); return arrayList3; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; import java.util.Collection; /** * Class for linear convolution of two discrete signals using the convolution * theorem. * * @author Ioannis Karavitsis * @version 1.0 */ public final class ConvolutionFFT { private ConvolutionFFT() { } /** * This method pads the signal with zeros until it reaches the new size. * * @param x The signal to be padded. * @param newSize The new size of the signal. */ private static void padding(Collection<FFT.Complex> x, int newSize) { if (x.size() < newSize) { int diff = newSize - x.size(); for (int i = 0; i < diff; i++) { x.add(new FFT.Complex()); } } } /** * Discrete linear convolution function. It uses the convolution theorem for * discrete signals convolved: = IDFT(DFT(a)*DFT(b)). This is true for * circular convolution. In order to get the linear convolution of the two * signals we first pad the two signals to have the same size equal to the * convolved signal (a.size() + b.size() - 1). Then we use the FFT algorithm * for faster calculations of the two DFTs and the final IDFT. * * <p> * More info: https://en.wikipedia.org/wiki/Convolution_theorem * https://ccrma.stanford.edu/~jos/ReviewFourier/FFT_Convolution.html * * @param a The first signal. * @param b The other signal. * @return The convolved signal. */ public static ArrayList<FFT.Complex> convolutionFFT(ArrayList<FFT.Complex> a, ArrayList<FFT.Complex> b) { int convolvedSize = a.size() + b.size() - 1; // The size of the convolved signal padding(a, convolvedSize); // Zero padding both signals padding(b, convolvedSize); /* Find the FFTs of both signals (Note that the size of the FFTs will be bigger than the * convolvedSize because of the extra zero padding in FFT algorithm) */ FFT.fft(a, false); FFT.fft(b, false); ArrayList<FFT.Complex> convolved = new ArrayList<>(); for (int i = 0; i < a.size(); i++) { convolved.add(a.get(i).multiply(b.get(i))); // FFT(a)*FFT(b) } FFT.fft(convolved, true); // IFFT convolved.subList(convolvedSize, convolved.size()).clear(); // Remove the remaining zeros after the convolvedSize. These extra zeros came // from // paddingPowerOfTwo() method inside the fft() method. return convolved; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Arrays; public final class Conway { private static final StringBuilder a = new StringBuilder(); private Conway() { } public static String generateNextElement(String stringArray) { a.setLength(0); stringArray = stringArray.split(\"(?<=(.))(?!\\\\1)\"); Arrays.stream(stringArray).forEach(string -> a.append(string.length()).append(string.charAt(0))); return a.toString(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public final class Conway { private Conway() { } /* * This class will generate the conway sequence also known as the look and say sequence. * To generate a member of the sequence from the previous member, read off the digits of the *previous member, counting the number of digits in groups of the same digit. For example: 1 is *read off as \"one 1\" or 11. 11 is read off as \"two 1s\" or 21. 21 is read off as \"one 2, one 1\" *or 1211. 1211 is read off as \"one 1, one 2, two 1s\" or 111221. 111221 is read off as \"three *1s, two 2s, one 1\" or 312211. https://en.wikipedia.org/wiki/Look-and-say_sequence * */ private static final StringBuilder BUILDER = new StringBuilder(); protected static List<String> generateList(String originalString, int maxIteration) { List<String> numbers = new ArrayList<>(); for (int i = 0; i < maxIteration; i++) { originalString = generateNextElement(originalString); numbers.add(originalString); } return numbers; } public static String generateNextElement(String originalString) { BUILDER.setLength(0); String[] stp = originalString.split(\"(?<=(.))(?!\\\\1)\"); Arrays.stream(stp).forEach(s -> BUILDER.append(s.length()).append(s.charAt(0))); return BUILDER.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class CountChar { private CountChar() { } public static int countCharacters(String string) { if (string == null) { return 0; } return string.replaceAll(\"\\\\s\", \"\").length(); } }", "deobfuscated_code": "package com.thealgorithms.strings; public final class CountChar { private CountChar() { } /** * Counts the number of non-whitespace characters in the given string. * * @param str the input string to count the characters in * @return the number of non-whitespace characters in the specified string; * returns 0 if the input string is null */ public static int countCharacters(String str) { if (str == null) { return 0; } return str.replaceAll(\"\\\\s\", \"\").length(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class CountFriendsPairing { private CountFriendsPairing() { } public static boolean countFriendsPairing(int n, int[] nArray) { int n2; int[] nArray2 = new int[n + 1]; int[] nArray3 = nArray2; nArray2[0] = 1; for (n2 = 1; n2 < n; ++n2) { nArray3[n2] = 1 + nArray3[n2 - nArray3[nArray3[n2 - 1]]]; } for (n2 = 1; n2 < n; ++n2) { if (nArray[n2 - 1] == nArray3[n2]) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * @author <a href=\"https://github.com/siddhant2002\">Siddhant Swarup Mallick</a> * In mathematics, the Golomb sequence is a non-decreasing integer sequence where n-th term is equal * to number of times n appears in the sequence. * <a href=\"https://en.wikipedia.org/wiki/Golomb_sequence\">Wikipedia</a> * Program description - To find the Golomb sequence upto n */ public final class CountFriendsPairing { private CountFriendsPairing() { } public static boolean countFriendsPairing(int n, int[] a) { int[] dp = new int[n + 1]; // array of n+1 size is created dp[0] = 1; // since 1st index position value is fixed so it's marked as 1 for (int i = 1; i < n; i++) { dp[i] = 1 + dp[i - dp[dp[i - 1]]]; // formula for ith golomb sequence is dp(i) = 1 + dp(i  dp(dp(i - 1))) } for (int i = 1; i < n; i++) { if (a[i - 1] != dp[i]) { return false; // checks whether the calculated answer matches with the expected answer } } return true; // returns true if calculated answer matches with the expected answer } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class CountLeadingZeros { private CountLeadingZeros() { } public static int countLeadingZeros(int n) { if (n == 0) { return 32; } int n2 = 0; int n3 = Integer.MIN_VALUE; while ((n3 & n) == 0) { ++n2; n3 >>>= 1; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * CountLeadingZeros class contains a method to count the number of leading zeros in the binary representation of a number. * The number of leading zeros is the number of zeros before the leftmost 1 bit. * For example, the number 5 has 29 leading zeros in its 32-bit binary representation. * The number 0 has 32 leading zeros. * The number 1 has 31 leading zeros. * The number -1 has no leading zeros. * * @author Hardvan */ public final class CountLeadingZeros { private CountLeadingZeros() { } /** * Counts the number of leading zeros in the binary representation of a number. * Method: Keep shifting the mask to the right until the leftmost bit is 1. * The number of shifts is the number of leading zeros. * * @param num The input number. * @return The number of leading zeros. */ public static int countLeadingZeros(int num) { if (num == 0) { return 32; } int count = 0; int mask = 1 << 31; while ((mask & num) == 0) { count++; mask >>>= 1; } return count; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public class CountSetBits { public long countSetBits(long l) { long l2 = 0L; while (l > 0L) { ++l2; long l3 = l; l = l3 & l3 - 1L; } return l2; } public int lookupApproach(int n) { int n2; int[] nArray = new int[256]; int[] nArray2 = nArray; nArray[0] = 0; for (n2 = 1; n2 < 256; ++n2) { int n3 = n2; nArray2[n3] = (n3 & 1) + nArray2[n2 >> 1]; } n2 = 0; for (int i = 0; i < 4; ++i) { n2 += nArray2[n & 0xFF]; n >>= 8; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; public class CountSetBits { /** * The below algorithm is called as Brian Kernighan's algorithm * We can use Brian Kernighans algorithm to improve the above naive algorithms performance. The idea is to only consider the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the next rightmost bit. The expression n & (n-1) can be used to turn off the rightmost set bit of a number n. This works as the expression n-1 flips all the bits after the rightmost set bit of n, including the rightmost set bit itself. Therefore, n & (n-1) results in the last bit flipped of n. For example, consider number 52, which is 00110100 in binary, and has a total 3 bits set. 1st iteration of the loop: n = 52 00110100 & (n) 00110011 (n-1) ~~~~~~~~ 00110000 2nd iteration of the loop: n = 48 00110000 & (n) 00101111 (n-1) ~~~~~~~~ 00100000 3rd iteration of the loop: n = 32 00100000 & (n) 00011111 (n-1) ~~~~~~~~ 00000000 (n = 0) * @param num takes Long number whose number of set bit is to be found * @return the count of set bits in the binary equivalent */ public long countSetBits(long num) { long cnt = 0; while (num > 0) { cnt++; num &= (num - 1); } return cnt; } /** * This approach takes O(1) running time to count the set bits, but requires a pre-processing. * * So, we divide our 32-bit input into 8-bit chunks, with four chunks. We have 8 bits in each chunk. * * Then the range is from 0-255 (0 to 2^7). * So, we may need to count set bits from 0 to 255 in individual chunks. * * @param num takes a long number * @return the count of set bits in the binary equivalent */ public int lookupApproach(int num) { int[] table = new int[256]; table[0] = 0; for (int i = 1; i < 256; i++) { table[i] = (i & 1) + table[i >> 1]; // i >> 1 equals to i/2 } int res = 0; for (int i = 0; i < 4; i++) { res += table[num & 0xff]; num >>= 8; } return res; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SinglyLinkedList; import com.thealgorithms.datastructures.lists.SinglyLinkedListNode; public class CountSinglyLinkedListRecursion extends SinglyLinkedList { private int a(SinglyLinkedListNode singlyLinkedListNode) { if (singlyLinkedListNode == null) { return 0; } return 1 + this.a(singlyLinkedListNode.b); } @Override public int count() { CountSinglyLinkedListRecursion countSinglyLinkedListRecursion = this; return countSinglyLinkedListRecursion.a(countSinglyLinkedListRecursion.getHead()); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; /** * CountSinglyLinkedListRecursion extends a singly linked list to include a * recursive count method, which calculates the number of nodes in the list. */ public class CountSinglyLinkedListRecursion extends SinglyLinkedList { /** * Recursively calculates the number of nodes in the list. * * @param head the head node of the list segment being counted. * @return the count of nodes from the given head node onward. */ private int countRecursion(SinglyLinkedListNode head) { return head == null ? 0 : 1 + countRecursion(head.next); } /** * Returns the total number of nodes in the list by invoking the recursive * count helper method. * * @return the total node count in the list. */ @Override public int count() { return countRecursion(getHead()); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class CountWords { private CountWords() { } public static int wordCount(String string) { if (string == null || string.isEmpty()) { return 0; } return string.trim().split(\"\\\\s+\").length; } public static int secondaryWordCount(String object) { if (object == null) { return 0; } StringBuilder stringBuilder = new StringBuilder(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object2 = object[i]; if (!Character.isLetterOrDigit((char)object2) && !Character.isWhitespace((char)object2)) continue; stringBuilder.append((char)object2); } return CountWords.wordCount(stringBuilder.toString()); } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * @author Marcus */ public final class CountWords { private CountWords() { } /** * Counts the number of words in the input string. Words are defined as sequences of * characters separated by whitespace. * * @param s the input string * @return the number of words in the input string, or 0 if the string is null or empty */ public static int wordCount(String s) { if (s == null || s.isEmpty()) { return 0; } return s.trim().split(\"\\\\s+\").length; } /** * Removes all special characters from the input string, leaving only alphanumeric characters * and whitespace. * * @param s the input string * @return a string containing only alphanumeric characters and whitespace */ private static String removeSpecialCharacters(String s) { StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (Character.isLetterOrDigit(c) || Character.isWhitespace(c)) { sb.append(c); } } return sb.toString(); } /** * Counts the number of words in a sentence, ignoring all non-alphanumeric characters that do * not contribute to word formation. This method has a time complexity of O(n), where n is the * length of the input string. * * @param s the input string * @return the number of words in the input string, with special characters removed, or 0 if the string is null */ public static int secondaryWordCount(String s) { if (s == null) { return 0; } return wordCount(removeSpecialCharacters(s)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; public final class CountingInversions { private CountingInversions() { } public static int countInversions(int[] nArray) { return CountingInversions.a(nArray, 0, nArray.length - 1); } private static int a(int[] nArray, int n, int n2) { if (n >= n2) { return 0; } int n3 = n + (n2 - n) / 2; int n4 = 0 + CountingInversions.a(nArray, n, n3); n4 += CountingInversions.a(nArray, n3 + 1, n2); return n4 += CountingInversions.a(nArray, n, n3, n2); } private static int a(int[] nArray, int n, int n2, int n3) { int[] nArray2 = new int[n2 - n + 1]; int[] nArray3 = new int[n3 - n2]; System.arraycopy(nArray, n, nArray2, 0, n2 - n + 1); System.arraycopy(nArray, n2 + 1, nArray3, 0, n3 - n2); n3 = 0; int n4 = 0; int n5 = n; int n6 = 0; while (n3 < nArray2.length && n4 < nArray3.length) { if (nArray2[n3] <= nArray3[n4]) { nArray[n5++] = nArray2[n3++]; continue; } nArray[n5++] = nArray3[n4++]; n6 += n2 + 1 - n - n3; } while (n3 < nArray2.length) { nArray[n5++] = nArray2[n3++]; } while (n4 < nArray3.length) { nArray[n5++] = nArray3[n4++]; } return n6; } }", "deobfuscated_code": "package com.thealgorithms.divideandconquer; /** * A utility class for counting the number of inversions in an array. * <p> * An inversion is a pair (i, j) such that i < j and arr[i] > arr[j]. * This class implements a divide-and-conquer approach, similar to merge sort, * to count the number of inversions efficiently. * <p> * Time Complexity: O(n log n) * Space Complexity: O(n) (due to temporary arrays during merge step) * * <p>Applications: * - Used in algorithms related to sorting and permutation analysis. * - Helps in determining how far an array is from being sorted. * - Applicable in bioinformatics and signal processing. * * <p>This class cannot be instantiated, as it is intended to provide * only static utility methods. * * @author Hardvan */ public final class CountingInversions { private CountingInversions() { } /** * Counts the number of inversions in the given array. * * @param arr The input array of integers. * @return The total number of inversions in the array. */ public static int countInversions(int[] arr) { return mergeSortAndCount(arr, 0, arr.length - 1); } /** * Recursively divides the array into two halves, sorts them, and counts * the number of inversions. Uses a modified merge sort approach. * * @param arr The input array. * @param left The starting index of the current segment. * @param right The ending index of the current segment. * @return The number of inversions within the segment [left, right]. */ private static int mergeSortAndCount(int[] arr, int left, int right) { if (left >= right) { return 0; } int mid = left + (right - left) / 2; int inversions = 0; inversions += mergeSortAndCount(arr, left, mid); inversions += mergeSortAndCount(arr, mid + 1, right); inversions += mergeAndCount(arr, left, mid, right); return inversions; } /** * Merges two sorted subarrays and counts the cross-inversions between them. * A cross-inversion occurs when an element from the right subarray is * smaller than an element from the left subarray. * * @param arr The input array. * @param left The starting index of the first subarray. * @param mid The ending index of the first subarray and midpoint of the segment. * @param right The ending index of the second subarray. * @return The number of cross-inversions between the two subarrays. */ private static int mergeAndCount(int[] arr, int left, int mid, int right) { int[] leftArr = new int[mid - left + 1]; int[] rightArr = new int[right - mid]; System.arraycopy(arr, left, leftArr, 0, mid - left + 1); System.arraycopy(arr, mid + 1, rightArr, 0, right - mid); int i = 0; int j = 0; int k = left; int inversions = 0; while (i < leftArr.length && j < rightArr.length) { if (leftArr[i] <= rightArr[j]) { arr[k++] = leftArr[i++]; } else { arr[k++] = rightArr[j++]; inversions += mid + 1 - left - i; } } while (i < leftArr.length) { arr[k++] = leftArr[i++]; } while (j < rightArr.length) { arr[k++] = rightArr[j++]; } return inversions; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.Arrays; import java.util.IntSummaryStatistics; public final class CountingSort { private CountingSort() { } public static int[] sort(int[] nArray) { if (nArray.length == 0) { return nArray; } IntSummaryStatistics intSummaryStatistics = Arrays.stream(nArray).summaryStatistics(); int n = intSummaryStatistics.getMin(); int n2 = intSummaryStatistics.getMax() - n + 1; int n3 = n; int[] nArray2 = nArray; int[] nArray3 = new int[n2]; int[] nArray4 = nArray2; n2 = nArray2.length; for (int i = 0; i < n2; ++i) { int n4 = nArray4[i]; int n5 = n4 - n3; nArray3[n5] = nArray3[n5] + 1; } int[] nArray5 = nArray3; int[] nArray6 = nArray3; for (n3 = 1; n3 < nArray6.length; ++n3) { int n6 = n3; nArray6[n6] = nArray6[n6] + nArray6[n3 - 1]; } int[] nArray7 = nArray5; nArray5 = nArray; n3 = n; nArray6 = nArray7; nArray3 = new int[nArray5.length]; for (int i = nArray5.length - 1; i >= 0; --i) { nArray3[nArray6[nArray5[i] - n3] - 1] = nArray5[i]; int n7 = nArray5[i] - n3; nArray6[n7] = nArray6[n7] - 1; } return nArray3; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.Arrays; /** * A standard implementation of the Counting Sort algorithm for integer arrays. * This implementation has a time complexity of O(n + k), where n is the number * of elements in the input array and k is the range of the input. * It works only with integer arrays. * * The space complexity is O(k), where k is the range of the input integers. * * Note: This implementation handles negative integers as it * calculates the range based on the minimum and maximum values of the array. * */ public final class CountingSort { private CountingSort() { } /** * Sorts an array of integers using the Counting Sort algorithm. * * @param array the array to be sorted * @return the sorted array */ public static int[] sort(int[] array) { if (array.length == 0) { return array; } final var stats = Arrays.stream(array).summaryStatistics(); final int min = stats.getMin(); int[] count = computeHistogram(array, min, stats.getMax() - min + 1); toCumulative(count); return reconstructSorted(count, min, array); } private static int[] computeHistogram(final int[] array, final int shift, final int spread) { int[] res = new int[spread]; for (final var value : array) { res[value - shift]++; } return res; } private static void toCumulative(int[] count) { for (int i = 1; i < count.length; i++) { count[i] += count[i - 1]; } } private static int[] reconstructSorted(final int[] cumulativeCount, final int shift, final int[] array) { int[] res = new int[array.length]; for (int i = array.length - 1; i >= 0; i--) { res[cumulativeCount[array[i] - shift] - 1] = array[i]; cumulativeCount[array[i] - shift]--; } return res; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; final class CreateAndDetectLoop$Node { }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; final class CreateAndDetectLoop$Node { }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; public final class CreateAndDetectLoop { private CreateAndDetectLoop() { throw new UnsupportedOperationException(\"Utility class\"); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; /** * CreateAndDetectLoop provides utility methods for creating and detecting loops * (cycles) in a singly linked list. Loops in a linked list are created by * connecting the \"next\" pointer of one node to a previous node in the list, * forming a cycle. */ public final class CreateAndDetectLoop { /** * Private constructor to prevent instantiation of this utility class. */ private CreateAndDetectLoop() { throw new UnsupportedOperationException(\"Utility class\"); } /** * Node represents an individual element in the linked list, containing * data and a reference to the next node. */ static final class Node { int data; Node next; Node(int data) { this.data = data; next = null; } } /** * Creates a loop in a linked list by connecting the next pointer of a node * at a specified starting position (position2) to another node at a specified * destination position (position1). If either position is invalid, no loop * will be created. * * @param head the head node of the linked list * @param position1 the position in the list where the loop should end * @param position2 the position in the list where the loop should start */ static void createLoop(Node head, int position1, int position2) { if (position1 == 0 || position2 == 0) { return; } Node node1 = head; Node node2 = head; int count1 = 1; int count2 = 1; // Traverse to the node at position1 while (count1 < position1 && node1 != null) { node1 = node1.next; count1++; } // Traverse to the node at position2 while (count2 < position2 && node2 != null) { node2 = node2.next; count2++; } // If both nodes are valid, create the loop if (node1 != null && node2 != null) { node2.next = node1; } } /** * Detects the presence of a loop in the linked list using Floyd's cycle-finding * algorithm, also known as the \"tortoise and hare\" method. * * @param head the head node of the linked list * @return true if a loop is detected, false otherwise * @see <a href=\"https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare\"> * Floyd's Cycle Detection Algorithm</a> */ static boolean detectLoop(Node head) { Node sptr = head; Node fptr = head; while (fptr != null && fptr.next != null) { sptr = sptr.next; fptr = fptr.next.next; if (sptr == fptr) { return true; } } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.HashMap; import java.util.Map; public final class CreateBinaryTreeFromInorderPreorder { private CreateBinaryTreeFromInorderPreorder() { } public static BinaryTree$Node createTree(Integer[] integerArray, Integer[] integerArray2) { if (integerArray == null || integerArray2 == null) { return null; } return CreateBinaryTreeFromInorderPreorder.a(integerArray, integerArray2, 0, 0, integerArray2.length); } public static BinaryTree$Node createTreeOptimized(Integer[] integerArray, Integer[] integerArray2) { if (integerArray == null || integerArray2 == null) { return null; } HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>(); for (int i = 0; i < integerArray2.length; ++i) { hashMap.put(integerArray2[i], i); } return CreateBinaryTreeFromInorderPreorder.a(integerArray, hashMap, 0, 0, integerArray2.length); } private static BinaryTree$Node a(Integer[] integerArray, Integer[] integerArray2, int n, int n2, int n3) { if (n3 == 0) { return null; } BinaryTree$Node binaryTree$Node = new BinaryTree$Node(integerArray[n]); int n4 = n2; while (!integerArray[n].equals(integerArray2[n4])) { ++n4; } int n5 = n4 - n2; n3 = n3 - n5 - 1; binaryTree$Node.left = CreateBinaryTreeFromInorderPreorder.a(integerArray, integerArray2, n + 1, n2, n5); binaryTree$Node.right = CreateBinaryTreeFromInorderPreorder.a(integerArray, integerArray2, n + n5 + 1, n4 + 1, n3); return binaryTree$Node; } private static BinaryTree$Node a(Integer[] integerArray, Map map, int n, int n2, int n3) { if (n3 == 0) { return null; } BinaryTree$Node binaryTree$Node = new BinaryTree$Node(integerArray[n]); int n4 = (Integer)map.get(integerArray[n]); int n5 = n4 - n2; n3 = n3 - n5 - 1; binaryTree$Node.left = CreateBinaryTreeFromInorderPreorder.a(integerArray, map, n + 1, n2, n5); binaryTree$Node.right = CreateBinaryTreeFromInorderPreorder.a(integerArray, map, n + n5 + 1, n4 + 1, n3); return binaryTree$Node; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree.Node; import java.util.HashMap; import java.util.Map; /** * Approach: Naive Solution: Create root node from first value present in * preorder traversal. Look for the index of root node's value in inorder * traversal. That will tell total nodes present in left subtree and right * subtree. Based on that index create left and right subtree. Complexity: Time: * O(n^2) for each node there is iteration to find index in inorder array Space: * Stack size = O(height) = O(lg(n)) * <p> * Optimized Solution: Instead of iterating over inorder array to find index of * root value, create a hashmap and find out the index of root value. * Complexity: Time: O(n) hashmap reduced iteration to find index in inorder * array Space: O(n) space taken by hashmap */ public final class CreateBinaryTreeFromInorderPreorder { private CreateBinaryTreeFromInorderPreorder() { } public static Node createTree(final Integer[] preorder, final Integer[] inorder) { if (preorder == null || inorder == null) { return null; } return createTree(preorder, inorder, 0, 0, inorder.length); } public static Node createTreeOptimized(final Integer[] preorder, final Integer[] inorder) { if (preorder == null || inorder == null) { return null; } Map<Integer, Integer> inorderMap = new HashMap<>(); for (int i = 0; i < inorder.length; i++) { inorderMap.put(inorder[i], i); } return createTreeOptimized(preorder, inorderMap, 0, 0, inorder.length); } private static Node createTree(final Integer[] preorder, final Integer[] inorder, final int preStart, final int inStart, final int size) { if (size == 0) { return null; } Node root = new Node(preorder[preStart]); int i = inStart; while (!preorder[preStart].equals(inorder[i])) { i++; } int leftNodesCount = i - inStart; int rightNodesCount = size - leftNodesCount - 1; root.left = createTree(preorder, inorder, preStart + 1, inStart, leftNodesCount); root.right = createTree(preorder, inorder, preStart + leftNodesCount + 1, i + 1, rightNodesCount); return root; } private static Node createTreeOptimized(final Integer[] preorder, final Map<Integer, Integer> inorderMap, final int preStart, final int inStart, final int size) { if (size == 0) { return null; } Node root = new Node(preorder[preStart]); int i = inorderMap.get(preorder[preStart]); int leftNodesCount = i - inStart; int rightNodesCount = size - leftNodesCount - 1; root.left = createTreeOptimized(preorder, inorderMap, preStart + 1, inStart, leftNodesCount); root.right = createTreeOptimized(preorder, inorderMap, preStart + leftNodesCount + 1, i + 1, rightNodesCount); return root; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class CrossCorrelation { private CrossCorrelation() { } public static double[] crossCorrelation(double[] dArray, double[] dArray2) { double[] dArray3 = new double[dArray.length + dArray2.length - 1]; int n = dArray3.length; int n2 = dArray2.length; for (int i = 0; i < n; ++i) { dArray3[i] = 0.0; int n3 = Math.max(i - (dArray2.length - 1), 0); int n4 = Math.min(i, dArray.length - 1); if (i < dArray2.length) { --n2; } int n5 = 0; while (n3 <= n4) { int n6 = i; dArray3[n6] = dArray3[n6] + dArray[n3] * dArray2[n2 + n5]; ++n5; ++n3; } } return dArray3; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Class for linear cross-correlation of two discrete signals * * @author Athina-Frederiki Swinkels * @version 1.0 */ public final class CrossCorrelation { private CrossCorrelation() { } /** * Discrete linear cross-correlation function. * Input and output signals have starting index 0. * * @param x The first discrete signal * @param y The second discrete signal * @return The result of the cross-correlation of signals x,y. The result is also a signal. */ public static double[] crossCorrelation(double[] x, double[] y) { // The result signal's length is the sum of the input signals' lengths minus 1 double[] result = new double[x.length + y.length - 1]; int n = result.length; /* To find the cross-correlation between 2 discrete signals x & y, we start by \"placing\" the second signal y under the first signal x, shifted to the left so that the last value of y meets the first value of x and for every new position (i++) of the result signal, we shift y signal one position to the right, until the first y-value meets the last x-value. The result-value for each position is the sum of all x*y meeting values. Here's an example: x=[1,2,1,1] y=[1,1,2,1] i=0: [1,2,1,1] [1,1,2,1] result[0]=1*1=1 i=1: [1,2,1,1] [1,1,2,1] result[1]=1*2+2*1=4 i=2: [1,2,1,1] [1,1,2,1] result[2]=1*1+2*2+1*1=6 i=3: [1,2,1,1] [1,1,2,1] result[3]=1*1+2*1+1*2+1*1=6 i=4: [1,2,1,1] [1,1,2,1] result[4]=2*1+1*1+1*2=5 i=5: [1,2,1,1] [1,1,2,1] result[5]=1*1+1*1=2 i=1: [1,2,1,1] [1,1,2,1] result[6]=1*1=1 result=[1,4,6,6,5,2,1] To find the result[i] value for each i:0->n-1, the positions of x-signal in which the 2 signals meet are calculated: kMin<=k<=kMax. The variable 'yStart' indicates the starting index of y in each sum calculation. The variable 'count' increases the index of y-signal by 1, to move to the next value. */ int yStart = y.length; for (int i = 0; i < n; i++) { result[i] = 0; int kMin = Math.max(i - (y.length - 1), 0); int kMax = Math.min(i, x.length - 1); if (i < y.length) { yStart--; } int count = 0; for (int k = kMin; k <= kMax; k++) { result[i] += x[k] * y[yStart + count]; count++; } } // The calculated cross-correlation of x & y signals is returned here. return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.Collection; public final class CrosswordSolver { private CrosswordSolver() { } public static boolean isValid(char[][] cArray, String string, int n, int n2, boolean bl) { for (int i = 0; i < string.length(); ++i) { if (!(bl ? n + i >= cArray.length || cArray[n + i][n2] != ' ' : n2 + i >= cArray[0].length || cArray[n][n2 + i] != ' ')) continue; return false; } return true; } public static void placeWord(char[][] cArray, String string, int n, int n2, boolean bl) { for (int i = 0; i < string.length(); ++i) { if (bl) { cArray[n + i][n2] = string.charAt(i); continue; } cArray[n][n2 + i] = string.charAt(i); } } public static void removeWord(char[][] cArray, String string, int n, int n2, boolean bl) { for (int i = 0; i < string.length(); ++i) { if (bl) { cArray[n + i][n2] = 32; continue; } cArray[n][n2 + i] = 32; } } public static boolean solveCrossword(char[][] cArray, Collection arrayList) { arrayList = new ArrayList<String>(arrayList); for (int i = 0; i < cArray.length; ++i) { for (int j = 0; j < cArray[0].length; ++j) { if (cArray[i][j] != ' ') continue; for (String string : new ArrayList(arrayList)) { boolean[] blArray = new boolean[]{true, false}; int cfr_ignored_0 = blArray.length; for (int k = 0; k < 2; ++k) { boolean bl = blArray[k]; if (!CrosswordSolver.isValid(cArray, string, i, j, bl)) continue; CrosswordSolver.placeWord(cArray, string, i, j, bl); arrayList.remove(string); if (CrosswordSolver.solveCrossword(cArray, arrayList)) { return true; } arrayList.add(string); CrosswordSolver.removeWord(cArray, string, i, j, bl); } } return false; } } return true; } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.Collection; import java.util.List; /** * A class to solve a crossword puzzle using backtracking. * Example: * Input: * puzzle = { * {' ', ' ', ' '}, * {' ', ' ', ' '}, * {' ', ' ', ' '} * } * words = List.of(\"cat\", \"dog\") * * Output: * { * {'c', 'a', 't'}, * {' ', ' ', ' '}, * {'d', 'o', 'g'} * } */ public final class CrosswordSolver { private CrosswordSolver() { } /** * Checks if a word can be placed at the specified position in the crossword. * * @param puzzle The crossword puzzle represented as a 2D char array. * @param word The word to be placed. * @param row The row index where the word might be placed. * @param col The column index where the word might be placed. * @param vertical If true, the word is placed vertically; otherwise, horizontally. * @return true if the word can be placed, false otherwise. */ public static boolean isValid(char[][] puzzle, String word, int row, int col, boolean vertical) { for (int i = 0; i < word.length(); i++) { if (vertical) { if (row + i >= puzzle.length || puzzle[row + i][col] != ' ') { return false; } } else { if (col + i >= puzzle[0].length || puzzle[row][col + i] != ' ') { return false; } } } return true; } /** * Places a word at the specified position in the crossword. * * @param puzzle The crossword puzzle represented as a 2D char array. * @param word The word to be placed. * @param row The row index where the word will be placed. * @param col The column index where the word will be placed. * @param vertical If true, the word is placed vertically; otherwise, horizontally. */ public static void placeWord(char[][] puzzle, String word, int row, int col, boolean vertical) { for (int i = 0; i < word.length(); i++) { if (vertical) { puzzle[row + i][col] = word.charAt(i); } else { puzzle[row][col + i] = word.charAt(i); } } } /** * Removes a word from the specified position in the crossword. * * @param puzzle The crossword puzzle represented as a 2D char array. * @param word The word to be removed. * @param row The row index where the word is placed. * @param col The column index where the word is placed. * @param vertical If true, the word was placed vertically; otherwise, horizontally. */ public static void removeWord(char[][] puzzle, String word, int row, int col, boolean vertical) { for (int i = 0; i < word.length(); i++) { if (vertical) { puzzle[row + i][col] = ' '; } else { puzzle[row][col + i] = ' '; } } } /** * Solves the crossword puzzle using backtracking. * * @param puzzle The crossword puzzle represented as a 2D char array. * @param words The list of words to be placed. * @return true if the crossword is solved, false otherwise. */ public static boolean solveCrossword(char[][] puzzle, Collection<String> words) { // Create a mutable copy of the words list List<String> remainingWords = new ArrayList<>(words); for (int row = 0; row < puzzle.length; row++) { for (int col = 0; col < puzzle[0].length; col++) { if (puzzle[row][col] == ' ') { for (String word : new ArrayList<>(remainingWords)) { for (boolean vertical : new boolean[] {true, false}) { if (isValid(puzzle, word, row, col, vertical)) { placeWord(puzzle, word, row, col, vertical); remainingWords.remove(word); if (solveCrossword(puzzle, remainingWords)) { return true; } remainingWords.add(word); removeWord(puzzle, word, row, col, vertical); } } } return false; } } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; class CursorLinkedList$Node { Object a = null; int b; CursorLinkedList$Node(Object object, int n) { this.b = n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; class CursorLinkedList$Node { Object a = null; int b; CursorLinkedList$Node(Object object, int n) { this.b = n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.CursorLinkedList$Node; import java.util.Objects; public class CursorLinkedList { private final int a; private int b; private final CursorLinkedList$Node[] c = new CursorLinkedList$Node[100]; private int d; public CursorLinkedList() { for (int i = 0; i < 100; ++i) { this.c[i] = new CursorLinkedList$Node(null, i + 1); } this.c[99].b = 0; this.a = 0; this.d = 0; this.b = -1; } public void printList() { if (this.b != -1) { int n = this.b; while (n != -1) { Object object = this.c[n].a; System.out.println(object.toString()); n = this.c[n].b; } } } public int indexOf(Object object) { if (object == null) { throw new NullPointerException(\"Element cannot be null\"); } try { Objects.requireNonNull(object); CursorLinkedList$Node cursorLinkedList$Node = this.c[this.b]; for (int i = 0; i < this.d; ++i) { if (cursorLinkedList$Node.a.equals(object)) { return i; } cursorLinkedList$Node = this.c[cursorLinkedList$Node.b]; } } catch (Exception exception) { return -1; } return -1; } public Object get(int n) { if (n >= 0 && n < this.d) { int n2 = this.b; int n3 = 0; while (n2 != -1) { Object object = this.c[n2].a; if (n3 == n) { return object; } n2 = this.c[n2].b; ++n3; } } return null; } public void removeByIndex(int n) { if (n >= 0 && n < this.d) { Object object = this.get(n); this.remove(object); } } public void remove(Object object) { Objects.requireNonNull(object); Object object2 = this.c[this.b].a; int n = this.c[this.b].b; if (object2.equals(object)) { CursorLinkedList cursorLinkedList = this; cursorLinkedList.a(cursorLinkedList.b); this.b = n; } else { int n2 = this.b; n = this.c[n2].b; while (n != -1) { Object object3 = this.c[n].a; if (object3.equals(object)) { this.c[n2].b = this.c[n].b; this.a(n); break; } n2 = n; n = this.c[n2].b; } } --this.d; } private void a(int n) { CursorLinkedList$Node cursorLinkedList$Node = this.c[this.a]; int n2 = cursorLinkedList$Node.b; this.c[this.a].b = n; this.c[n].a = null; this.c[n].b = n2; } public void append(Object object) { Objects.requireNonNull(object); CursorLinkedList cursorLinkedList = this; int n = cursorLinkedList.c[cursorLinkedList.a].b; if (n == 0) { throw new OutOfMemoryError(); } cursorLinkedList.c[cursorLinkedList.a].b = cursorLinkedList.c[n].b; cursorLinkedList.c[n].b = -1; int n2 = n; this.c[n2].a = object; if (this.b == -1) { this.b = n2; } else { int n3 = this.b; while (this.c[n3].b != -1) { n3 = this.c[n3].b; } this.c[n3].b = n2; } this.c[n2].b = -1; ++this.d; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; import java.util.Objects; /** * CursorLinkedList is an array-based implementation of a singly linked list. * Each node in the array simulates a linked list node, storing an element and * the index of the next node. This structure allows for efficient list operations * without relying on traditional pointers. * * @param <T> the type of elements in this list */ @SuppressWarnings({\"rawtypes\", \"unchecked\"}) public class CursorLinkedList<T> { /** * Node represents an individual element in the list, containing the element * itself and a pointer (index) to the next node. */ private static class Node<T> { T element; int next; Node(T element, int next) { this.element = element; this.next = next; } } private final int os; private int head; private final Node<T>[] cursorSpace; private int count; private static final int CURSOR_SPACE_SIZE = 100; { // Initialize cursor space array and free list pointers cursorSpace = new Node[CURSOR_SPACE_SIZE]; for (int i = 0; i < CURSOR_SPACE_SIZE; i++) { cursorSpace[i] = new Node<>(null, i + 1); } cursorSpace[CURSOR_SPACE_SIZE - 1].next = 0; } /** * Constructs an empty CursorLinkedList with the default capacity. */ public CursorLinkedList() { os = 0; count = 0; head = -1; } /** * Prints all elements in the list in their current order. */ public void printList() { if (head != -1) { int start = head; while (start != -1) { T element = cursorSpace[start].element; System.out.println(element.toString()); start = cursorSpace[start].next; } } } /** * Finds the logical index of a specified element in the list. * * @param element the element to search for in the list * @return the logical index of the element, or -1 if not found * @throws NullPointerException if element is null */ public int indexOf(T element) { if (element == null) { throw new NullPointerException(\"Element cannot be null\"); } try { Objects.requireNonNull(element); Node<T> iterator = cursorSpace[head]; for (int i = 0; i < count; i++) { if (iterator.element.equals(element)) { return i; } iterator = cursorSpace[iterator.next]; } } catch (Exception e) { return -1; } return -1; } /** * Retrieves an element at a specified logical index in the list. * * @param position the logical index of the element * @return the element at the specified position, or null if index is out of bounds */ public T get(int position) { if (position >= 0 && position < count) { int start = head; int counter = 0; while (start != -1) { T element = cursorSpace[start].element; if (counter == position) { return element; } start = cursorSpace[start].next; counter++; } } return null; } /** * Removes the element at a specified logical index from the list. * * @param index the logical index of the element to remove */ public void removeByIndex(int index) { if (index >= 0 && index < count) { T element = get(index); remove(element); } } /** * Removes a specified element from the list. * * @param element the element to be removed * @throws NullPointerException if element is null */ public void remove(T element) { Objects.requireNonNull(element); T tempElement = cursorSpace[head].element; int tempNext = cursorSpace[head].next; if (tempElement.equals(element)) { free(head); head = tempNext; } else { int prevIndex = head; int currentIndex = cursorSpace[prevIndex].next; while (currentIndex != -1) { T currentElement = cursorSpace[currentIndex].element; if (currentElement.equals(element)) { cursorSpace[prevIndex].next = cursorSpace[currentIndex].next; free(currentIndex); break; } prevIndex = currentIndex; currentIndex = cursorSpace[prevIndex].next; } } count--; } /** * Allocates a new node index for storing an element. * * @return the index of the newly allocated node * @throws OutOfMemoryError if no space is available in cursor space */ private int alloc() { int availableNodeIndex = cursorSpace[os].next; if (availableNodeIndex == 0) { throw new OutOfMemoryError(); } cursorSpace[os].next = cursorSpace[availableNodeIndex].next; cursorSpace[availableNodeIndex].next = -1; return availableNodeIndex; } /** * Releases a node back to the free list. * * @param index the index of the node to release */ private void free(int index) { Node<T> osNode = cursorSpace[os]; int osNext = osNode.next; cursorSpace[os].next = index; cursorSpace[index].element = null; cursorSpace[index].next = osNext; } /** * Appends an element to the end of the list. * * @param element the element to append * @throws NullPointerException if element is null */ public void append(T element) { Objects.requireNonNull(element); int availableIndex = alloc(); cursorSpace[availableIndex].element = element; if (head == -1) { head = availableIndex; } else { int iterator = head; while (cursorSpace[iterator].next != -1) { iterator = cursorSpace[iterator].next; } cursorSpace[iterator].next = availableIndex; } cursorSpace[availableIndex].next = -1; count++; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.Scanner; class Cycle { private final int a; private int[][] b; private boolean[] c; private ArrayList d = new ArrayList(); Cycle() { int n; Scanner scanner = new Scanner(System.in); System.out.print(\"Enter the no. of nodes: \"); this.a = scanner.nextInt(); System.out.print(\"Enter the no. of Edges: \"); int n2 = scanner.nextInt(); this.b = new int[this.a][this.a]; this.c = new boolean[this.a]; for (n = 0; n < this.a; ++n) { this.c[n] = false; } System.out.println(\"Enter the details of each edges <Start Node> <End Node>\"); for (n = 0; n < n2; ++n) { int n3 = scanner.nextInt(); int n4 = scanner.nextInt(); this.b[n3][n4] = 1; } scanner.close(); } public void start() { for (int i = 0; i < this.a; ++i) { ArrayList arrayList = new ArrayList(); this.a(i, i, arrayList); for (int j = 0; j < this.a; ++j) { this.b[i][j] = 0; this.b[j][i] = 0; } } } private void a(Integer n, Integer n2, ArrayList arrayList) { arrayList.add(n2); this.c[n2.intValue()] = true; for (int i = 0; i < this.a; ++i) { if (this.b[n2][i] != 1) continue; if (i == n) { this.d.add(new ArrayList(arrayList)); continue; } if (this.c[i]) continue; this.a(n, i, arrayList); } if (arrayList.size() > 0) { ArrayList arrayList2 = arrayList; arrayList2.remove(arrayList2.size() - 1); } this.c[n2.intValue()] = false; } public void printAll() { for (int i = 0; i < this.d.size(); ++i) { for (int j = 0; j < ((ArrayList)this.d.get(i)).size(); ++j) { System.out.print(String.valueOf(((ArrayList)this.d.get(i)).get(j)) + \" -> \"); } System.out.println(((ArrayList)this.d.get(i)).get(0)); System.out.println(); } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.Scanner; class Cycle { private final int a; private int[][] b; private boolean[] c; private ArrayList d = new ArrayList(); Cycle() { int n; Scanner scanner = new Scanner(System.in); System.out.print(\"Enter the no. of nodes: \"); this.a = scanner.nextInt(); System.out.print(\"Enter the no. of Edges: \"); int n2 = scanner.nextInt(); this.b = new int[this.a][this.a]; this.c = new boolean[this.a]; for (n = 0; n < this.a; ++n) { this.c[n] = false; } System.out.println(\"Enter the details of each edges <Start Node> <End Node>\"); for (n = 0; n < n2; ++n) { int n3 = scanner.nextInt(); int n4 = scanner.nextInt(); this.b[n3][n4] = 1; } scanner.close(); } public void start() { for (int i = 0; i < this.a; ++i) { ArrayList arrayList = new ArrayList(); this.a(i, i, arrayList); for (int j = 0; j < this.a; ++j) { this.b[i][j] = 0; this.b[j][i] = 0; } } } private void a(Integer n, Integer n2, ArrayList arrayList) { arrayList.add(n2); this.c[n2.intValue()] = true; for (int i = 0; i < this.a; ++i) { if (this.b[n2][i] != 1) continue; if (i == n) { this.d.add(new ArrayList(arrayList)); continue; } if (this.c[i]) continue; this.a(n, i, arrayList); } if (arrayList.size() > 0) { ArrayList arrayList2 = arrayList; arrayList2.remove(arrayList2.size() - 1); } this.c[n2.intValue()] = false; } public void printAll() { for (int i = 0; i < this.d.size(); ++i) { for (int j = 0; j < ((ArrayList)this.d.get(i)).size(); ++j) { System.out.print(String.valueOf(((ArrayList)this.d.get(i)).get(j)) + \" -> \"); } System.out.println(((ArrayList)this.d.get(i)).get(0)); System.out.println(); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; class CycleSort implements SortAlgorithm { CycleSort() { } @Override public Comparable[] sort(Comparable[] comparableArray) { int n = comparableArray.length; block0: for (int i = 0; i <= n - 2; ++i) { Comparable comparable = comparableArray[i]; int n2 = CycleSort.a(comparableArray, i, comparable); if (n2 == i) continue; while (true) { comparable = this.a(comparableArray, comparable, n2); if (n2 == i) continue block0; n2 = CycleSort.a(comparableArray, i, comparable); } } return comparableArray; } private static int a(Comparable[] comparableArray, int n, Comparable comparable) { int n2 = n++; while (n < comparableArray.length) { if (SortUtils.less(comparableArray[n], comparable)) { ++n2; } ++n; } return n2; } private Comparable a(Comparable[] comparableArray, Comparable comparable, int n) { while (comparable.compareTo(comparableArray[n]) == 0) { ++n; } return CycleSort.b(comparableArray, n, comparable); } private static Comparable b(Comparable[] comparableArray, int n, Comparable comparable) { Comparable comparable2 = comparableArray[n]; comparableArray[n] = comparable; return comparable2; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * This class implements the cycle sort algorithm. * Cycle sort is an in-place sorting algorithm, unstable, and efficient for scenarios with limited memory usage. * @author Podshivalov Nikita (https://github.com/nikitap492) */ class CycleSort implements SortAlgorithm { /** * Sorts an array of comparable elements using the cycle sort algorithm. * * @param <T> The type of elements in the array, which must be comparable * @param array The array to be sorted * @return The sorted array */ @Override public <T extends Comparable<T>> T[] sort(final T[] array) { final int length = array.length; for (int cycleStart = 0; cycleStart <= length - 2; cycleStart++) { T item = array[cycleStart]; int pos = findPosition(array, cycleStart, item); if (pos == cycleStart) { continue; // Item is already in the correct position } item = placeItem(array, item, pos); // Rotate the rest of the cycle while (pos != cycleStart) { pos = findPosition(array, cycleStart, item); item = placeItem(array, item, pos); } } return array; } /** * Finds the correct position for the given item starting from cycleStart. * * @param <T> The type of elements in the array, which must be comparable * @param array The array to be sorted * @param cycleStart The starting index of the cycle * @param item The item whose position is to be found * @return The correct position of the item */ private <T extends Comparable<T>> int findPosition(final T[] array, final int cycleStart, final T item) { int pos = cycleStart; for (int i = cycleStart + 1; i < array.length; i++) { if (SortUtils.less(array[i], item)) { pos++; } } return pos; } /** * Places the item in its correct position, handling duplicates, and returns the displaced item. * * @param <T> The type of elements in the array, which must be comparable * @param array The array being sorted * @param item The item to be placed * @param pos The position where the item is to be placed * @return The displaced item */ private <T extends Comparable<T>> T placeItem(final T[] array, final T item, int pos) { while (item.compareTo(array[pos]) == 0) { pos++; } return replace(array, pos, item); } /** * Replaces an element in the array with the given item and returns the replaced item. * * @param <T> The type of elements in the array, which must be comparable * @param array The array in which the replacement will occur * @param pos The position at which the replacement will occur * @param item The item to be placed in the array * @return The replaced item */ private <T extends Comparable<T>> T replace(final T[] array, final int pos, final T item) { final T replacedItem = array[pos]; array[pos] = item; return replacedItem; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.Cycle; public final class Cycles { private Cycles() { } public static void main(String[] object) { object = new Cycle(); ((Cycle)object).start(); ((Cycle)object).printAll(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.Scanner; class Cycle { private final int nodes; private int[][] adjacencyMatrix; private boolean[] visited; ArrayList<ArrayList<Integer>> cycles = new ArrayList<ArrayList<Integer>>(); Cycle() { Scanner in = new Scanner(System.in); System.out.print(\"Enter the no. of nodes: \"); nodes = in.nextInt(); System.out.print(\"Enter the no. of Edges: \"); final int edges = in.nextInt(); adjacencyMatrix = new int[nodes][nodes]; visited = new boolean[nodes]; for (int i = 0; i < nodes; i++) { visited[i] = false; } System.out.println(\"Enter the details of each edges <Start Node> <End Node>\"); for (int i = 0; i < edges; i++) { int start; int end; start = in.nextInt(); end = in.nextInt(); adjacencyMatrix[start][end] = 1; } in.close(); } public void start() { for (int i = 0; i < nodes; i++) { ArrayList<Integer> temp = new ArrayList<>(); dfs(i, i, temp); for (int j = 0; j < nodes; j++) { adjacencyMatrix[i][j] = 0; adjacencyMatrix[j][i] = 0; } } } private void dfs(Integer start, Integer curr, ArrayList<Integer> temp) { temp.add(curr); visited[curr] = true; for (int i = 0; i < nodes; i++) { if (adjacencyMatrix[curr][i] == 1) { if (i == start) { cycles.add(new ArrayList<Integer>(temp)); } else { if (!visited[i]) { dfs(start, i, temp); } } } } if (temp.size() > 0) { temp.remove(temp.size() - 1); } visited[curr] = false; } public void printAll() { for (int i = 0; i < cycles.size(); i++) { for (int j = 0; j < cycles.get(i).size(); j++) { System.out.print(cycles.get(i).get(j) + \" -> \"); } System.out.println(cycles.get(i).get(0)); System.out.println(); } } } public final class Cycles { private Cycles() { } public static void main(String[] args) { Cycle c = new Cycle(); c.start(); c.printAll(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; public class DES { private String a; private final String[] b; private static final int[] c = new int[]{58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7}; private static final int[] d = new int[]{32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1}; private static final int[][] e = new int[][]{{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7}, {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8}, {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0}, {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}}; private static final int[][] f = new int[][]{{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10}, {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5}, {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15}, {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}}; private static final int[][] g = new int[][]{{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8}, {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1}, {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7}, {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}}; private static final int[][] h = new int[][]{{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15}, {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9}, {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4}, {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}}; private static final int[][] i = new int[][]{{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9}, {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6}, {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14}, {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}}; private static final int[][] j = new int[][]{{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11}, {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8}, {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6}, {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}}; private static final int[][] k = new int[][]{{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1}, {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6}, {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2}, {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}}; private static final int[][] l = new int[][]{{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7}, {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2}, {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8}, {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}; private static final int[][][] m = new int[][][]{e, f, g, h, i, j, k, l}; private static int[] n = new int[]{16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25}; private static int[] o = new int[]{40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25}; public String getKey() { return this.a; } public void setKey(String string) { String string2 = string; int n = string2.length(); if (n != 64) { throw new IllegalArgumentException(\"DES key must be supplied as a 64 character binary string\"); } this.a = string; } private static String a(String string, String string2) { int n = string.length(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < n; ++i) { int n2 = string.charAt(i) - 48; int n3 = string2.charAt(i) - 48; stringBuilder.append(n2 ^ n3); } return stringBuilder.toString(); } private static String a(String string, int n, char c) { int n2 = string.length(); StringBuilder stringBuilder = new StringBuilder(); n -= n2; for (n2 = 0; n2 < n; ++n2) { stringBuilder.append(c); } return stringBuilder.toString(); } private String a(String string, int n) { return DES.a(string, n, '0') + string; } private String a(String object, String[] stringArray) { Object object2; int n; StringBuilder stringBuilder = new StringBuilder(); for (n = 0; n < 64; ++n) { stringBuilder.append(((String)object).charAt(c[n] - 1)); } object = stringBuilder.substring(0, 32); String string = stringBuilder.substring(32); for (n = 0; n < 16; ++n) { int n2; object2 = string; String string2 = object; CharSequence charSequence = stringArray[n]; object = this; CharSequence charSequence2 = new StringBuilder(); for (n2 = 0; n2 < 48; ++n2) { ((StringBuilder)charSequence2).append(string.charAt(d[n2] - 1)); } string = DES.a(((StringBuilder)charSequence2).toString(), (String)charSequence); charSequence = new StringBuilder(); for (n2 = 0; n2 < 48; n2 += 6) { int n3 = n2; charSequence2 = string.substring(n3, n3 + 6); int n4 = (((String)charSequence2).charAt(0) - 48 << 1) + (((String)charSequence2).charAt(5) - 48); int n5 = (((String)charSequence2).charAt(1) - 48 << 3) + (((String)charSequence2).charAt(2) - 48 << 2) + (((String)charSequence2).charAt(3) - 48 << 1) + (((String)charSequence2).charAt(4) - 48); charSequence2 = ((DES)object).a(Integer.toBinaryString(m[n2 / 6][n4][n5]), 4); ((StringBuilder)charSequence).append((String)charSequence2); } charSequence2 = new StringBuilder(); for (n2 = 0; n2 < 32; ++n2) { ((StringBuilder)charSequence2).append(((StringBuilder)charSequence).charAt(DES.n[n2] - 1)); } string = DES.a(string2, ((StringBuilder)charSequence2).toString()); object = object2; } object2 = string + (String)object; stringBuilder.setLength(0); for (n = 0; n < 64; ++n) { stringBuilder.append(((String)object2).charAt(o[n] - 1)); } return stringBuilder.toString(); } public String encrypt(String object) { int n; StringBuilder stringBuilder = new StringBuilder(); int n2 = ((String)object).length(); if (n2 % 8 != 0) { n2 = n = n2 / 8 + 1 << 3; String string = object; object = this; String string2 = string; object = string2 + DES.a(string2, n, '\\u0000'); } for (int i = 0; i < n2; i += 8) { int n3 = i; String string = ((String)object).substring(n3, n3 + 8); StringBuilder stringBuilder2 = new StringBuilder(); byte[] byArray = string.getBytes(); for (n = 0; n < 8; ++n) { stringBuilder2.append(this.a(Integer.toBinaryString(byArray[n]), 8)); } stringBuilder.append(this.a(stringBuilder2.toString(), this.b)); } return stringBuilder.toString(); } public String decrypt(String string) { StringBuilder stringBuilder = new StringBuilder(); int n = string.length(); if (n % 64 != 0) { throw new IllegalArgumentException(\"Encrypted message should be a multiple of 64 characters in length\"); } for (int i = 0; i < n; i += 64) { int n2 = i; Object object = string.substring(n2, n2 + 64); Object[] objectArray = this.b; String string2 = object; object = this; String[] stringArray = new String[objectArray.length]; for (int j = 0; j < objectArray.length; ++j) { stringArray[j] = objectArray[objectArray.length - j - 1]; } string2 = ((DES)object).a(string2, stringArray); objectArray = new byte[8]; for (int j = 0; j < 64; j += 8) { int n3 = j; objectArray[j / 8] = (String)((byte)Integer.parseInt(string2.substring(n3, n3 + 8), 2)); } stringBuilder.append(new String((byte[])objectArray)); } return stringBuilder.toString().replace(\"\\u0000\", \"\"); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; /** * This class is build to demonstrate the application of the DES-algorithm * (https://en.wikipedia.org/wiki/Data_Encryption_Standard) on a plain English message. The supplied * key must be in form of a 64 bit binary String. */ public class DES { private String key; private final String[] subKeys; private void sanitize(String key) { int length = key.length(); if (length != 64) { throw new IllegalArgumentException(\"DES key must be supplied as a 64 character binary string\"); } } DES(String key) { sanitize(key); this.key = key; subKeys = getSubkeys(key); } public String getKey() { return this.key; } public void setKey(String key) { sanitize(key); this.key = key; } // Permutation table to convert initial 64-bit key to 56 bit key private static final int[] PC1 = {57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4}; // Lookup table used to shift the initial key, in order to generate the subkeys private static final int[] KEY_SHIFTS = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1}; // Table to convert the 56 bit subkeys to 48 bit subkeys private static final int[] PC2 = {14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32}; // Initial permutation of each 64 but message block private static final int[] IP = {58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7}; // Expansion table to convert right half of message blocks from 32 bits to 48 bits private static final int[] EXPANSION = {32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1}; // The eight substitution boxes are defined below private static final int[][] S1 = {{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7}, {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8}, {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0}, {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}}; private static final int[][] S2 = {{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10}, {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5}, {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15}, {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}}; private static final int[][] S3 = {{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8}, {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1}, {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7}, {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}}; private static final int[][] S4 = {{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15}, {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9}, {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4}, {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}}; private static final int[][] S5 = {{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9}, {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6}, {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14}, {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}}; private static final int[][] S6 = {{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11}, {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8}, {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6}, {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}}; private static final int[][] S7 = {{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1}, {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6}, {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2}, {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}}; private static final int[][] S8 = {{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7}, {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2}, {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8}, {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}; private static final int[][][] S = {S1, S2, S3, S4, S5, S6, S7, S8}; // Permutation table, used in the Feistel function post s-box usage static final int[] PERMUTATION = {16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25}; // Table used for final inversion of the message box after 16 rounds of Feistel Function static final int[] IP_INVERSE = {40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25}; private String[] getSubkeys(String originalKey) { StringBuilder permutedKey = new StringBuilder(); // Initial permutation of keys via pc1 int i; int j; for (i = 0; i < 56; i++) { permutedKey.append(originalKey.charAt(PC1[i] - 1)); } String[] subKeys = new String[16]; String initialPermutedKey = permutedKey.toString(); String c0 = initialPermutedKey.substring(0, 28); String d0 = initialPermutedKey.substring(28); // We will now operate on the left and right halves of the permutedKey for (i = 0; i < 16; i++) { String cN = c0.substring(KEY_SHIFTS[i]) + c0.substring(0, KEY_SHIFTS[i]); String dN = d0.substring(KEY_SHIFTS[i]) + d0.substring(0, KEY_SHIFTS[i]); subKeys[i] = cN + dN; c0 = cN; // Re-assign the values to create running permutation d0 = dN; } // Let us shrink the keys to 48 bits (well, characters here) using pc2 for (i = 0; i < 16; i++) { String key = subKeys[i]; permutedKey.setLength(0); for (j = 0; j < 48; j++) { permutedKey.append(key.charAt(PC2[j] - 1)); } subKeys[i] = permutedKey.toString(); } return subKeys; } private String xOR(String a, String b) { int i; int l = a.length(); StringBuilder xor = new StringBuilder(); for (i = 0; i < l; i++) { int firstBit = a.charAt(i) - 48; // 48 is '0' in ascii int secondBit = b.charAt(i) - 48; xor.append((firstBit ^ secondBit)); } return xor.toString(); } private String createPaddedString(String s, int desiredLength, char pad) { int i; int l = s.length(); StringBuilder paddedString = new StringBuilder(); int diff = desiredLength - l; for (i = 0; i < diff; i++) { paddedString.append(pad); } return paddedString.toString(); } private String pad(String s, int desiredLength) { return createPaddedString(s, desiredLength, '0') + s; } private String padLast(String s, int desiredLength) { return s + createPaddedString(s, desiredLength, '\\u0000'); } private String feistel(String messageBlock, String key) { int i; StringBuilder expandedKey = new StringBuilder(); for (i = 0; i < 48; i++) { expandedKey.append(messageBlock.charAt(EXPANSION[i] - 1)); } String mixedKey = xOR(expandedKey.toString(), key); StringBuilder substitutedString = new StringBuilder(); // Let us now use the s-boxes to transform each 6 bit (length here) block to 4 bits for (i = 0; i < 48; i += 6) { String block = mixedKey.substring(i, i + 6); int row = (block.charAt(0) - 48) * 2 + (block.charAt(5) - 48); int col = (block.charAt(1) - 48) * 8 + (block.charAt(2) - 48) * 4 + (block.charAt(3) - 48) * 2 + (block.charAt(4) - 48); String substitutedBlock = pad(Integer.toBinaryString(S[i / 6][row][col]), 4); substitutedString.append(substitutedBlock); } StringBuilder permutedString = new StringBuilder(); for (i = 0; i < 32; i++) { permutedString.append(substitutedString.charAt(PERMUTATION[i] - 1)); } return permutedString.toString(); } private String encryptBlock(String message, String[] keys) { StringBuilder permutedMessage = new StringBuilder(); int i; for (i = 0; i < 64; i++) { permutedMessage.append(message.charAt(IP[i] - 1)); } String e0 = permutedMessage.substring(0, 32); String f0 = permutedMessage.substring(32); // Iterate 16 times for (i = 0; i < 16; i++) { String eN = f0; // Previous Right block String fN = xOR(e0, feistel(f0, keys[i])); e0 = eN; f0 = fN; } String combinedBlock = f0 + e0; // Reverse the 16th block permutedMessage.setLength(0); for (i = 0; i < 64; i++) { permutedMessage.append(combinedBlock.charAt(IP_INVERSE[i] - 1)); } return permutedMessage.toString(); } // To decode, we follow the same process as encoding, but with reversed keys private String decryptBlock(String message, String[] keys) { String[] reversedKeys = new String[keys.length]; for (int i = 0; i < keys.length; i++) { reversedKeys[i] = keys[keys.length - i - 1]; } return encryptBlock(message, reversedKeys); } /** * @param message Message to be encrypted * @return The encrypted message, as a binary string */ public String encrypt(String message) { StringBuilder encryptedMessage = new StringBuilder(); int l = message.length(); int i; int j; if (l % 8 != 0) { int desiredLength = (l / 8 + 1) * 8; l = desiredLength; message = padLast(message, desiredLength); } for (i = 0; i < l; i += 8) { String block = message.substring(i, i + 8); StringBuilder bitBlock = new StringBuilder(); byte[] bytes = block.getBytes(); for (j = 0; j < 8; j++) { bitBlock.append(pad(Integer.toBinaryString(bytes[j]), 8)); } encryptedMessage.append(encryptBlock(bitBlock.toString(), subKeys)); } return encryptedMessage.toString(); } /** * @param message The encrypted string. Expects it to be a multiple of 64 bits, in binary format * @return The decrypted String, in plain English */ public String decrypt(String message) { StringBuilder decryptedMessage = new StringBuilder(); int l = message.length(); int i; int j; if (l % 64 != 0) { throw new IllegalArgumentException(\"Encrypted message should be a multiple of 64 characters in length\"); } for (i = 0; i < l; i += 64) { String block = message.substring(i, i + 64); String result = decryptBlock(block, subKeys); byte[] res = new byte[8]; for (j = 0; j < 64; j += 8) { res[j / 8] = (byte) Integer.parseInt(result.substring(j, j + 8), 2); } decryptedMessage.append(new String(res)); } return decryptedMessage.toString().replace(\"\\0\", \"\"); // Get rid of the null bytes used for padding } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; final class DP { private DP() { } public static long findWays(int n, int n2, int n3) { int n4; long[][] lArray = new long[n2 + 1][n3 + 1]; for (n4 = 1; n4 <= n && n4 <= n3; ++n4) { lArray[1][n4] = 1L; } for (n4 = 2; n4 <= n2; ++n4) { for (int i = 1; i <= n3; ++i) { for (int j = 1; j < i && j <= n; ++j) { long[] lArray2 = lArray[n4]; int n5 = i; lArray2[n5] = lArray2[n5] + lArray[n4 - 1][i - j]; } } } return lArray[n2][n3]; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; final class DP { private DP() { } public static long findWays(int n, int n2, int n3) { int n4; long[][] lArray = new long[n2 + 1][n3 + 1]; for (n4 = 1; n4 <= n && n4 <= n3; ++n4) { lArray[1][n4] = 1L; } for (n4 = 2; n4 <= n2; ++n4) { for (int i = 1; i <= n3; ++i) { for (int j = 1; j < i && j <= n; ++j) { long[] lArray2 = lArray[n4]; int n5 = i; lArray2[n5] = lArray2[n5] + lArray[n4 - 1][i - j]; } } } return lArray[n2][n3]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Objects; public final class Damm { private static final byte[][] a = new byte[][]{{0, 3, 1, 7, 5, 9, 8, 6, 4, 2}, {7, 0, 9, 2, 1, 5, 4, 8, 6, 3}, {4, 2, 0, 6, 8, 7, 1, 3, 5, 9}, {1, 7, 5, 0, 9, 8, 3, 4, 2, 6}, {6, 1, 2, 3, 0, 4, 5, 9, 7, 8}, {3, 6, 7, 4, 2, 0, 9, 5, 8, 1}, {5, 8, 6, 9, 7, 2, 0, 1, 3, 4}, {8, 9, 4, 5, 3, 6, 2, 0, 1, 7}, {9, 4, 3, 8, 6, 1, 7, 2, 0, 5}, {2, 5, 8, 1, 4, 3, 6, 7, 9, 0}}; private Damm() { } public static boolean dammCheck(String object) { Damm.b((String)object); object = Damm.c((String)object); int n = 0; for (Object object2 : object) { n = a[n][object2]; } return n == 0; } public static String addDammChecksum(String string) { Damm.b(string); int[] nArray = Damm.c(string); int n = 0; for (int n2 : nArray) { n = a[n][n2]; } return string + n; } public static void main(String[] object) { System.out.println(\"Damm algorithm usage examples:\"); object = \"5724\"; String string = \"5824\"; Damm.a((String)object); Damm.a(string); System.out.println(\"\\nCheck digit generation example:\"); object = \"572\"; object = \"572\"; string = Damm.addDammChecksum(\"572\"); System.out.println(\"Generate and add checksum to initial value '\" + (String)object + \"'. Result: '\" + string + \"'\"); } private static void a(String string) { String string2 = Damm.dammCheck(string) ? \"valid\" : \"not valid\"; System.out.println(\"Input '\" + string + \"' is \" + string2); } private static void b(String string) { Objects.requireNonNull(string); if (!string.matches(\"\\\\d+\")) { throw new IllegalArgumentException(\"Input '\" + string + \"' contains not only digits\"); } } private static int[] c(String string) { return string.chars().map(n -> Character.digit(n, 10)).toArray(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Objects; /** * Damm algorithm is a check digit algorithm that detects all single-digit * errors and all adjacent transposition errors. It was presented by H. Michael * Damm in 2004. Essential part of the algorithm is a quasigroup of order 10 * (i.e. having a 10  10 Latin square as the body of its operation table) with * the special feature of being weakly totally anti-symmetric. Damm revealed * several methods to create totally anti-symmetric quasigroups of order 10 and * gave some examples in his doctoral dissertation. * * @see <a href=\"https://en.wikipedia.org/wiki/Damm_algorithm\">Wiki. Damm * algorithm</a> */ public final class Damm { private Damm() { } /** * Weakly totally anti-symmetric quasigroup of order 10. This table is not * the only possible realisation of weak totally anti-symmetric quasigroup * but the most common one (taken from Damm doctoral dissertation). All * zeros lay on the diagonal because it simplifies the check digit * calculation. */ private static final byte[][] DAMM_TABLE = { {0, 3, 1, 7, 5, 9, 8, 6, 4, 2}, {7, 0, 9, 2, 1, 5, 4, 8, 6, 3}, {4, 2, 0, 6, 8, 7, 1, 3, 5, 9}, {1, 7, 5, 0, 9, 8, 3, 4, 2, 6}, {6, 1, 2, 3, 0, 4, 5, 9, 7, 8}, {3, 6, 7, 4, 2, 0, 9, 5, 8, 1}, {5, 8, 6, 9, 7, 2, 0, 1, 3, 4}, {8, 9, 4, 5, 3, 6, 2, 0, 1, 7}, {9, 4, 3, 8, 6, 1, 7, 2, 0, 5}, {2, 5, 8, 1, 4, 3, 6, 7, 9, 0}, }; /** * Check input digits by Damm algorithm. * * @param digits input to check * @return true if check was successful, false otherwise * @throws IllegalArgumentException if input parameter contains not only * digits * @throws NullPointerException if input is null */ public static boolean dammCheck(String digits) { checkInput(digits); int[] numbers = toIntArray(digits); int checksum = 0; for (int number : numbers) { checksum = DAMM_TABLE[checksum][number]; } return checksum == 0; } /** * Calculate check digit for initial digits and add it tho the last * position. * * @param initialDigits initial value * @return digits with the checksum in the last position * @throws IllegalArgumentException if input parameter contains not only * digits * @throws NullPointerException if input is null */ public static String addDammChecksum(String initialDigits) { checkInput(initialDigits); int[] numbers = toIntArray(initialDigits); int checksum = 0; for (int number : numbers) { checksum = DAMM_TABLE[checksum][number]; } return initialDigits + checksum; } public static void main(String[] args) { System.out.println(\"Damm algorithm usage examples:\"); var validInput = \"5724\"; var invalidInput = \"5824\"; checkAndPrint(validInput); checkAndPrint(invalidInput); System.out.println(\"\\nCheck digit generation example:\"); var input = \"572\"; generateAndPrint(input); } private static void checkAndPrint(String input) { String validationResult = Damm.dammCheck(input) ? \"valid\" : \"not valid\"; System.out.println(\"Input '\" + input + \"' is \" + validationResult); } private static void generateAndPrint(String input) { String result = addDammChecksum(input); System.out.println(\"Generate and add checksum to initial value '\" + input + \"'. Result: '\" + result + \"'\"); } private static void checkInput(String input) { Objects.requireNonNull(input); if (!input.matches(\"\\\\d+\")) { throw new IllegalArgumentException(\"Input '\" + input + \"' contains not only digits\"); } } private static int[] toIntArray(String string) { return string.chars().map(i -> Character.digit(i, 10)).toArray(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; class DarkSort { DarkSort() { } public Integer[] sort(Integer[] integerArray) { int n; int n2; if (integerArray == null || integerArray.length <= 1) { return integerArray; } Integer[] integerArray2 = integerArray; int n3 = integerArray[0]; int n4 = integerArray2.length; for (n2 = 0; n2 < n4; ++n2) { n = integerArray2[n2]; if (n <= n3) continue; n3 = n; } int n5 = n3; int[] nArray = new int[n5 + 1]; Integer[] integerArray3 = integerArray; n4 = integerArray.length; for (n2 = 0; n2 < n4; ++n2) { int n6 = n = integerArray3[n2].intValue(); nArray[n6] = nArray[n6] + 1; } int n7 = 0; for (n4 = 0; n4 < nArray.length; ++n4) { while (nArray[n4] > 0) { integerArray[n7++] = n4; int n8 = n4; nArray[n8] = nArray[n8] - 1; } } return integerArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * Dark Sort algorithm implementation. * * Dark Sort uses a temporary array to count occurrences of elements and * reconstructs the sorted array based on the counts. */ class DarkSort { /** * Sorts the array using the Dark Sort algorithm. * * @param unsorted the array to be sorted * @return sorted array */ public Integer[] sort(Integer[] unsorted) { if (unsorted == null || unsorted.length <= 1) { return unsorted; } int max = findMax(unsorted); // Find the maximum value in the array // Create a temporary array for counting occurrences int[] temp = new int[max + 1]; // Count occurrences of each element for (int value : unsorted) { temp[value]++; } // Reconstruct the sorted array int index = 0; for (int i = 0; i < temp.length; i++) { while (temp[i] > 0) { unsorted[index++] = i; temp[i]--; } } return unsorted; } /** * Helper method to find the maximum value in an array. * * @param arr the array * @return the maximum value */ private int findMax(Integer[] arr) { int max = arr[0]; for (int value : arr) { if (value > max) { max = value; } } return max; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.util.ArrayList; public final class DecimalToAnyBase { private DecimalToAnyBase() { } public static String convertToAnyBase(int n, int n2) { if (n2 < 2 || n2 > 36) { throw new IllegalArgumentException(\"Base must be between 2 and 36\"); } if (n == 0) { return \"0\"; } ArrayList<Character> arrayList = new ArrayList<Character>(); while (n > 0) { int n3 = n % n2; arrayList.add(Character.valueOf(n3 >= 0 && n3 <= 9 ? (char)(n3 + 48) : (char)(n3 + 65 - 10))); n /= n2; } StringBuilder stringBuilder = new StringBuilder(arrayList.size()); for (n2 = arrayList.size() - 1; n2 >= 0; --n2) { stringBuilder.append(arrayList.get(n2)); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.util.ArrayList; import java.util.List; /** * Class that provides methods to convert a decimal number to a string representation * in any specified base between 2 and 36. * * @author Varun Upadhyay (<a href=\"https://github.com/varunu28\">...</a>) */ public final class DecimalToAnyBase { private static final int MIN_BASE = 2; private static final int MAX_BASE = 36; private static final char ZERO_CHAR = '0'; private static final char A_CHAR = 'A'; private static final int DIGIT_OFFSET = 10; private DecimalToAnyBase() { } /** * Converts a decimal number to a string representation in the specified base. * For example, converting the decimal number 10 to base 2 would return \"1010\". * * @param decimal the decimal number to convert * @param base the base to convert to (must be between {@value #MIN_BASE} and {@value #MAX_BASE}) * @return the string representation of the number in the specified base * @throws IllegalArgumentException if the base is out of the supported range */ public static String convertToAnyBase(int decimal, int base) { if (base < MIN_BASE || base > MAX_BASE) { throw new IllegalArgumentException(\"Base must be between \" + MIN_BASE + \" and \" + MAX_BASE); } if (decimal == 0) { return String.valueOf(ZERO_CHAR); } List<Character> digits = new ArrayList<>(); while (decimal > 0) { digits.add(convertToChar(decimal % base)); decimal /= base; } StringBuilder result = new StringBuilder(digits.size()); for (int i = digits.size() - 1; i >= 0; i--) { result.append(digits.get(i)); } return result.toString(); } /** * Converts an integer value to its corresponding character in the specified base. * This method is used to convert values from 0 to 35 into their appropriate character representation. * For example, 0-9 are represented as '0'-'9', and 10-35 are represented as 'A'-'Z'. * * @param value the integer value to convert (should be less than the base value) * @return the character representing the value in the specified base */ private static char convertToChar(int value) { if (value >= 0 && value <= 9) { return (char) (ZERO_CHAR + value); } else { return (char) (A_CHAR + value - DIGIT_OFFSET); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Stack; public final class DecimalToAnyUsingStack { private static final char[] a = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}; private DecimalToAnyUsingStack() { } public static String convert(int n, int n2) { if (n < 0) { throw new IllegalArgumentException(\"Number must be non-negative.\"); } if (n2 < 2 || n2 > 16) { throw new IllegalArgumentException(String.format(\"Invalid radix: %d. Radix must be between 2 and 16.\", n2)); } if (n == 0) { return \"0\"; } Stack<Character> stack = new Stack<Character>(); while (n > 0) { stack.push(Character.valueOf(a[n % n2])); n /= n2; } StringBuilder stringBuilder = new StringBuilder(stack.size()); while (!stack.isEmpty()) { stringBuilder.append(stack.pop()); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; /** * Utility class for converting a non-negative decimal (base-10) integer * to its representation in another radix (base) between 2 and 16, inclusive. * * <p>This class uses a stack-based approach to reverse the digits obtained from * successive divisions by the target radix. * * <p>This class cannot be instantiated.</p> */ public final class DecimalToAnyUsingStack { private DecimalToAnyUsingStack() { } private static final char[] DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}; /** * Convert a decimal number to another radix. * * @param number the number to be converted * @param radix the radix * @return the number represented in the new radix as a String * @throws IllegalArgumentException if number is negative or radix is not between 2 and 16 inclusive */ public static String convert(int number, int radix) { if (number < 0) { throw new IllegalArgumentException(\"Number must be non-negative.\"); } if (radix < 2 || radix > 16) { throw new IllegalArgumentException(String.format(\"Invalid radix: %d. Radix must be between 2 and 16.\", radix)); } if (number == 0) { return \"0\"; } Stack<Character> digitStack = new Stack<>(); while (number > 0) { digitStack.push(DIGITS[number % radix]); number /= radix; } StringBuilder result = new StringBuilder(digitStack.size()); while (!digitStack.isEmpty()) { result.append(digitStack.pop()); } return result.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; final class DecimalToBinary { private DecimalToBinary() { } public static int convertUsingConventionalAlgorithm(int n) { int n2 = 0; int n3 = 1; while (n > 0) { int n4 = n % 2; n2 += n4 * n3; n3 *= 10; n /= 2; } return n2; } public static int convertUsingBitwiseAlgorithm(int n) { int n2 = 0; int n3 = 1; while (n > 0) { int n4 = n & 1; n2 += n4 * n3; n3 *= 10; n >>= 1; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * This class provides methods to convert a decimal number to a binary number. */ final class DecimalToBinary { private static final int BINARY_BASE = 2; private static final int DECIMAL_MULTIPLIER = 10; private DecimalToBinary() { } /** * Converts a decimal number to a binary number using a conventional algorithm. * @param decimalNumber the decimal number to convert * @return the binary representation of the decimal number */ public static int convertUsingConventionalAlgorithm(int decimalNumber) { int binaryNumber = 0; int position = 1; while (decimalNumber > 0) { int remainder = decimalNumber % BINARY_BASE; binaryNumber += remainder * position; position *= DECIMAL_MULTIPLIER; decimalNumber /= BINARY_BASE; } return binaryNumber; } /** * Converts a decimal number to a binary number using a bitwise algorithm. * @param decimalNumber the decimal number to convert * @return the binary representation of the decimal number */ public static int convertUsingBitwiseAlgorithm(int decimalNumber) { int binaryNumber = 0; int position = 1; while (decimalNumber > 0) { int leastSignificantBit = decimalNumber & 1; binaryNumber += leastSignificantBit * position; position *= DECIMAL_MULTIPLIER; decimalNumber >>= 1; } return binaryNumber; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; final class DecimalToHexadecimal { private static final char[] a = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}; private DecimalToHexadecimal() { } public static String decToHex(int n) { int n2; StringBuilder stringBuilder = new StringBuilder(8); for (int i = 7; i >= 0; --i) { int n3 = n & 0xF; stringBuilder.insert(0, a[n3]); n >>= 4; } String string = stringBuilder.toString().toLowerCase(); if (string == null || string.isEmpty()) { return string; } for (n2 = 0; n2 < string.length() && string.charAt(n2) == '0'; ++n2) { } if (n2 == string.length()) { return \"0\"; } return string.substring(n2); } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * This class provides a method to convert a decimal number to a hexadecimal string. */ final class DecimalToHexadecimal { private static final int SIZE_OF_INT_IN_HALF_BYTES = 8; private static final int NUMBER_OF_BITS_IN_HALF_BYTE = 4; private static final int HALF_BYTE_MASK = 0x0F; private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}; private DecimalToHexadecimal() { } /** * Converts a decimal number to a hexadecimal string. * @param decimal the decimal number to convert * @return the hexadecimal representation of the decimal number */ public static String decToHex(int decimal) { StringBuilder hexBuilder = new StringBuilder(SIZE_OF_INT_IN_HALF_BYTES); for (int i = SIZE_OF_INT_IN_HALF_BYTES - 1; i >= 0; --i) { int currentHalfByte = decimal & HALF_BYTE_MASK; hexBuilder.insert(0, HEX_DIGITS[currentHalfByte]); decimal >>= NUMBER_OF_BITS_IN_HALF_BYTE; } return removeLeadingZeros(hexBuilder.toString().toLowerCase()); } private static String removeLeadingZeros(String str) { if (str == null || str.isEmpty()) { return str; } int i = 0; while (i < str.length() && str.charAt(i) == '0') { i++; } return i == str.length() ? \"0\" : str.substring(i); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class DecimalToOctal { private DecimalToOctal() { } public static int convertToOctal(int n) { if (n < 0) { throw new IllegalArgumentException(\"Decimal number cannot be negative.\"); } int n2 = 0; int n3 = 1; while (n != 0) { int n4 = n % 8; n2 += n4 * n3; n /= 8; n3 *= 10; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * This class converts Decimal numbers to Octal Numbers */ public final class DecimalToOctal { private static final int OCTAL_BASE = 8; private static final int INITIAL_OCTAL_VALUE = 0; private static final int INITIAL_PLACE_VALUE = 1; private DecimalToOctal() { } /** * Converts a decimal number to its octal equivalent. * * @param decimal The decimal number to convert. * @return The octal equivalent as an integer. * @throws IllegalArgumentException if the decimal number is negative. */ public static int convertToOctal(int decimal) { if (decimal < 0) { throw new IllegalArgumentException(\"Decimal number cannot be negative.\"); } int octal = INITIAL_OCTAL_VALUE; int placeValue = INITIAL_PLACE_VALUE; while (decimal != 0) { int remainder = decimal % OCTAL_BASE; octal += remainder * placeValue; decimal /= OCTAL_BASE; placeValue *= 10; } return octal; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.datastructures.Node; import java.util.ArrayList; import java.util.List; import java.util.Optional; public class DepthFirstSearch { private final List a = new ArrayList(); public Optional recursiveSearch(Node node2, Integer n) { if (node2 == null) { return Optional.empty(); } this.a.add(node2.getValue()); if (node2.getValue().equals(n)) { return Optional.of(node2); } return node2.getChildren().stream().map(node -> this.recursiveSearch((Node)node, n)).flatMap(Optional::stream).findAny(); } public List getVisited() { return this.a; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.datastructures.Node; import java.util.ArrayList; import java.util.List; import java.util.Optional; /** * @author: caos321 * @date: 31 October 2021 (Sunday) * @wiki: https://en.wikipedia.org/wiki/Depth-first_search */ public class DepthFirstSearch<T> { private final List<T> visited = new ArrayList<>(); public Optional<Node<T>> recursiveSearch(final Node<T> node, final Integer value) { if (node == null) { return Optional.empty(); } visited.add(node.getValue()); if (node.getValue().equals(value)) { return Optional.of(node); } return node.getChildren().stream().map(v -> recursiveSearch(v, value)).flatMap(Optional::stream).findAny(); } public List<T> getVisited() { return visited; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; class Deque$DequeNode { Object a; Deque$DequeNode b = null; Deque$DequeNode c = null; Deque$DequeNode(Object object) { this.a = object; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; class Deque$DequeNode { Object a; Deque$DequeNode b = null; Deque$DequeNode c = null; Deque$DequeNode(Object object) { this.a = object; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; import com.thealgorithms.datastructures.queues.Deque$DequeNode; import java.util.NoSuchElementException; public class Deque { private Deque$DequeNode a = null; private Deque$DequeNode b = null; private int c = 0; public void addFirst(Object object) { object = new Deque$DequeNode(object); if (this.isEmpty()) { this.a = object; this.b = object; } else { ((Deque$DequeNode)object).b = this.a; this.a.c = object; this.a = object; } ++this.c; } public void addLast(Object object) { object = new Deque$DequeNode(object); if (this.b == null) { this.a = object; this.b = object; } else { ((Deque$DequeNode)object).c = this.b; this.b.b = object; this.b = object; } ++this.c; } public Object pollFirst() { if (this.a == null) { throw new NoSuchElementException(\"Deque is empty\"); } Object object = this.a.a; if (this.a == this.b) { this.a = null; this.b = null; } else { this.a = this.a.b; this.a.c = null; } --this.c; return object; } public Object pollLast() { if (this.b == null) { throw new NoSuchElementException(\"Deque is empty\"); } Object object = this.b.a; if (this.a == this.b) { this.a = null; this.b = null; } else { this.b = this.b.c; this.b.b = null; } --this.c; return object; } public Object peekFirst() { if (this.a != null) { return this.a.a; } return null; } public Object peekLast() { if (this.b != null) { return this.b.a; } return null; } public int size() { return this.c; } public boolean isEmpty() { return this.c == 0; } public String toString() { StringBuilder stringBuilder = new StringBuilder(\"Head -> \"); Deque$DequeNode deque$DequeNode = this.a; while (deque$DequeNode != null) { stringBuilder.append(deque$DequeNode.a); if (deque$DequeNode.b != null) { stringBuilder.append(\" <-> \"); } deque$DequeNode = deque$DequeNode.b; } stringBuilder.append(\" <- Tail\"); return stringBuilder.toString(); } public static void main(String[] object) { int n; object = new Deque(); for (n = 0; n < 42; ++n) { if ((double)n / 42.0 < 0.5) { ((Deque)object).addFirst(n); continue; } ((Deque)object).addLast(n); } System.out.println(object); System.out.println(\"Size: \" + ((Deque)object).size()); System.out.println(); ((Deque)object).pollFirst(); ((Deque)object).pollFirst(); ((Deque)object).pollLast(); System.out.println(object); System.out.println(\"Size: \" + ((Deque)object).size()); System.out.println(); n = ((Deque)object).size(); for (int i = 0; i < n; ++i) { int n2 = (double)i / 39.0 < 0.5 ? ((Integer)((Deque)object).pollFirst()).intValue() : ((Integer)((Deque)object).pollLast()).intValue(); System.out.println(\"Removing: \" + n2); } System.out.println(object); System.out.println(((Deque)object).size()); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.queues; import java.util.NoSuchElementException; /** * A [deque](https://en.wikipedia.org/wiki/Double-ended_queue) is short for a * double ended queue pronounced \"deck\" and sometimes referred to as a head-tail * linked list. A deque is a data structure based on a doubly linked list, but * only supports adding and removal of nodes from the beginning and the end of * the list. * * @author [Ian Cowan](https://github.com/iccowan) */ public class Deque<T> { /** * Node for the deque */ private static class DequeNode<S> { S val; DequeNode<S> next = null; DequeNode<S> prev = null; DequeNode(S val) { this.val = val; } } private DequeNode<T> head = null; private DequeNode<T> tail = null; private int size = 0; /** * Adds the specified value to the head of the deque * * @param val Value to add to the deque */ public void addFirst(T val) { DequeNode<T> newNode = new DequeNode<>(val); if (isEmpty()) { head = newNode; tail = newNode; } else { newNode.next = head; head.prev = newNode; head = newNode; } size++; } /** * Adds the specified value to the tail of the deque * * @param val Value to add to the deque */ public void addLast(T val) { DequeNode<T> newNode = new DequeNode<>(val); if (tail == null) { head = newNode; tail = newNode; } else { newNode.prev = tail; tail.next = newNode; tail = newNode; } size++; } /** * Removes and returns the first (head) value in the deque * * @return the value of the head of the deque * @throws NoSuchElementException if the deque is empty */ public T pollFirst() { if (head == null) { throw new NoSuchElementException(\"Deque is empty\"); } T oldHeadVal = head.val; if (head == tail) { head = null; tail = null; } else { head = head.next; head.prev = null; } size--; return oldHeadVal; } /** * Removes and returns the last (tail) value in the deque * * @return the value of the tail of the deque * @throws NoSuchElementException if the deque is empty */ public T pollLast() { if (tail == null) { throw new NoSuchElementException(\"Deque is empty\"); } T oldTailVal = tail.val; if (head == tail) { head = null; tail = null; } else { tail = tail.prev; tail.next = null; } size--; return oldTailVal; } /** * Returns the first (head) value of the deque WITHOUT removing * * @return the value of the head of the deque, or null if empty */ public T peekFirst() { return head != null ? head.val : null; } /** * Returns the last (tail) value of the deque WITHOUT removing * * @return the value of the tail of the deque, or null if empty */ public T peekLast() { return tail != null ? tail.val : null; } /** * Returns the size of the deque * * @return the size of the deque */ public int size() { return size; } /** * Returns whether or not the deque is empty * * @return whether or not the deque is empty */ public boolean isEmpty() { return size == 0; } /** * Returns a stringified deque in a pretty form: * * <p> * Head -> 1 <-> 2 <-> 3 <- Tail * * @return the stringified deque */ @Override public String toString() { StringBuilder dequeString = new StringBuilder(\"Head -> \"); DequeNode<T> currNode = head; while (currNode != null) { dequeString.append(currNode.val); if (currNode.next != null) { dequeString.append(\" <-> \"); } currNode = currNode.next; } dequeString.append(\" <- Tail\"); return dequeString.toString(); } public static void main(String[] args) { Deque<Integer> myDeque = new Deque<>(); for (int i = 0; i < 42; i++) { if (i / 42.0 < 0.5) { myDeque.addFirst(i); } else { myDeque.addLast(i); } } System.out.println(myDeque); System.out.println(\"Size: \" + myDeque.size()); System.out.println(); myDeque.pollFirst(); myDeque.pollFirst(); myDeque.pollLast(); System.out.println(myDeque); System.out.println(\"Size: \" + myDeque.size()); System.out.println(); int dequeSize = myDeque.size(); for (int i = 0; i < dequeSize; i++) { int removing = -1; if (i / 39.0 < 0.5) { removing = myDeque.pollFirst(); } else { removing = myDeque.pollLast(); } System.out.println(\"Removing: \" + removing); } System.out.println(myDeque); System.out.println(myDeque.size()); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class DeterminantOfMatrix { private DeterminantOfMatrix() { } }", "deobfuscated_code": "package com.thealgorithms.maths; /* * @author Ojasva Jain * Determinant of a Matrix Wikipedia link: https://en.wikipedia.org/wiki/Determinant */ public final class DeterminantOfMatrix { private DeterminantOfMatrix() { } /** * Calculates the determinant of a given matrix. * * @param a the input matrix * @param n the size of the matrix * @return the determinant of the matrix */ static int determinant(int[][] a, int n) { int det = 0; int sign = 1; int p = 0; int q = 0; if (n == 1) { det = a[0][0]; } else { int[][] b = new int[n - 1][n - 1]; for (int x = 0; x < n; x++) { p = 0; q = 0; for (int i = 1; i < n; i++) { for (int j = 0; j < n; j++) { if (j != x) { b[p][q++] = a[i][j]; if (q % (n - 1) == 0) { p++; q = 0; } } } } det = det + a[0][x] * determinant(b, n - 1) * sign; sign = -sign; } } return det; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.math.BigInteger; public final class DiffieHellman { private final BigInteger a; private final BigInteger b; private final BigInteger c; public DiffieHellman(BigInteger bigInteger, BigInteger bigInteger2, BigInteger bigInteger3) { if (bigInteger == null || bigInteger2 == null || bigInteger3 == null || bigInteger.signum() <= 0 || bigInteger2.signum() <= 0 || bigInteger3.signum() <= 0) { throw new IllegalArgumentException(\"Base, secret, and prime must be non-null and positive values.\"); } this.a = bigInteger; this.b = bigInteger2; this.c = bigInteger3; } public final BigInteger calculatePublicValue() { return this.a.modPow(this.b, this.c); } public final BigInteger calculateSharedSecret(BigInteger bigInteger) { if (bigInteger == null || bigInteger.signum() <= 0) { throw new IllegalArgumentException(\"Other public value must be non-null and positive.\"); } return bigInteger.modPow(this.b, this.c); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.math.BigInteger; public final class DiffieHellman { private final BigInteger base; private final BigInteger secret; private final BigInteger prime; // Constructor to initialize base, secret, and prime public DiffieHellman(BigInteger base, BigInteger secret, BigInteger prime) { // Check for non-null and positive values if (base == null || secret == null || prime == null || base.signum() <= 0 || secret.signum() <= 0 || prime.signum() <= 0) { throw new IllegalArgumentException(\"Base, secret, and prime must be non-null and positive values.\"); } this.base = base; this.secret = secret; this.prime = prime; } // Method to calculate public value (g^x mod p) public BigInteger calculatePublicValue() { // Returns g^x mod p return base.modPow(secret, prime); } // Method to calculate the shared secret key (otherPublic^secret mod p) public BigInteger calculateSharedSecret(BigInteger otherPublicValue) { if (otherPublicValue == null || otherPublicValue.signum() <= 0) { throw new IllegalArgumentException(\"Other public value must be non-null and positive.\"); } // Returns b^x mod p or a^y mod p return otherPublicValue.modPow(secret, prime); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class DigitSeparation { public List digitSeparationReverseOrder(long l) { ArrayList<Long> arrayList = new ArrayList<Long>(); if (l != 0L) { while (l != 0L) { arrayList.add(Math.abs(l % 10L)); l /= 10L; } } else { arrayList.add(0L); } return arrayList; } public List digitSeparationForwardOrder(long l) { List list = this.digitSeparationReverseOrder(l); Collections.reverse(list); return list; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.ArrayList; import java.util.Collections; import java.util.List; /** * This class provides methods to separate the digits of a large positive number into a list. */ public class DigitSeparation { public DigitSeparation() { } /** * Separates the digits of a large positive number into a list in reverse order. * @param largeNumber The large number to separate digits from. * @return A list of digits in reverse order. */ public List<Long> digitSeparationReverseOrder(long largeNumber) { List<Long> result = new ArrayList<>(); if (largeNumber != 0) { while (largeNumber != 0) { result.add(Math.abs(largeNumber % 10)); largeNumber = largeNumber / 10; } } else { result.add(0L); } return result; } /** * Separates the digits of a large positive number into a list in forward order. * @param largeNumber The large number to separate digits from. * @return A list of digits in forward order. */ public List<Long> digitSeparationForwardOrder(long largeNumber) { List<Long> result = this.digitSeparationReverseOrder(largeNumber); Collections.reverse(result); return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; final class DigitalRoot { private DigitalRoot() { } public static int digitalRoot(int n) { while (DigitalRoot.single(n) > 9) { n = DigitalRoot.single(n); } return DigitalRoot.single(n); } public static int single(int n) { if (n <= 9) { return n; } return n % 10 + DigitalRoot.single(n / 10); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * @author <a href=\"https://github.com/skmodi649\">Suraj Kumar Modi</a> * You are given a number n. You need to find the digital root of n. * DigitalRoot of a number is the recursive sum of its digits until we get a single digit number. * * Test Case 1: * Input: * n = 1 * Output: 1 * Explanation: Digital root of 1 is 1 * * Test Case 2: * Input: * n = 99999 * Output: 9 * Explanation: Sum of digits of 99999 is 45 * which is not a single digit number, hence * sum of digit of 45 is 9 which is a single * digit number. * Algorithm : * Step 1 : Define a method digitalRoot(int n) * Step 2 : Define another method single(int n) * Step 3 : digitalRoot(int n) method takes output of single(int n) as input * if(single(int n) <= 9) * return single(n) * else * return digitalRoot(single(n)) * Step 4 : single(int n) calculates the sum of digits of number n recursively * if(n<=9) * return n; * else * return (n%10) + (n/10) * Step 5 : In main method simply take n as input and then call digitalRoot(int n) function and * print the result */ final class DigitalRoot { private DigitalRoot() { } public static int digitalRoot(int n) { if (single(n) <= 9) { // If n is already single digit than simply call single method and // return the value return single(n); } else { return digitalRoot(single(n)); } } /** * Time Complexity: O((Number of Digits)^2) Auxiliary Space Complexity: * O(Number of Digits) Constraints: 1 <= n <= 10^7 */ // This function is used for finding the sum of the digits of number public static int single(int n) { if (n <= 9) { // if n becomes less than 10 than return n return n; } else { return (n % 10) + single(n / 10); // n % 10 for extracting digits one by one } } // n / 10 is the number obtained after removing the digit one by one // The Sum of digits is stored in the Stack memory and then finally returned }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.Graph; import com.thealgorithms.others.Graph$Edge; public final class Dijkstra { private static final Graph$Edge[] a = new Graph$Edge[]{new Graph$Edge(\"a\", \"b\", 7), new Graph$Edge(\"a\", \"c\", 9), new Graph$Edge(\"a\", \"f\", 14), new Graph$Edge(\"b\", \"c\", 10), new Graph$Edge(\"b\", \"d\", 15), new Graph$Edge(\"c\", \"d\", 11), new Graph$Edge(\"c\", \"f\", 2), new Graph$Edge(\"d\", \"e\", 6), new Graph$Edge(\"e\", \"f\", 9)}; private Dijkstra() { } public static void main(String[] object) { object = new Graph(a); ((Graph)object).dijkstra(\"a\"); ((Graph)object).printPath(\"e\"); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.HashMap; import java.util.Map; import java.util.NavigableSet; import java.util.TreeSet; /** * Dijkstra's algorithm,is a graph search algorithm that solves the * single-source shortest path problem for a graph with nonnegative edge path * costs, producing a shortest path tree. * * <p> * NOTE: The inputs to Dijkstra's algorithm are a directed and weighted graph * consisting of 2 or more nodes, generally represented by an adjacency matrix * or list, and a start node. * * <p> * Original source of code: * https://rosettacode.org/wiki/Dijkstra%27s_algorithm#Java Also most of the * comments are from RosettaCode. */ public final class Dijkstra { private Dijkstra() { } private static final Graph.Edge[] GRAPH = { // Distance from node \"a\" to node \"b\" is 7. // In the current Graph there is no way to move the other way (e,g, from \"b\" to \"a\"), // a new edge would be needed for that new Graph.Edge(\"a\", \"b\", 7), new Graph.Edge(\"a\", \"c\", 9), new Graph.Edge(\"a\", \"f\", 14), new Graph.Edge(\"b\", \"c\", 10), new Graph.Edge(\"b\", \"d\", 15), new Graph.Edge(\"c\", \"d\", 11), new Graph.Edge(\"c\", \"f\", 2), new Graph.Edge(\"d\", \"e\", 6), new Graph.Edge(\"e\", \"f\", 9), }; private static final String START = \"a\"; private static final String END = \"e\"; /** * main function Will run the code with \"GRAPH\" that was defined above. */ public static void main(String[] args) { Graph g = new Graph(GRAPH); g.dijkstra(START); g.printPath(END); // g.printAllPaths(); } } class Graph { // mapping of vertex names to Vertex objects, built from a set of Edges private final Map<String, Vertex> graph; /** * One edge of the graph (only used by Graph constructor) */ public static class Edge { public final String v1; public final String v2; public final int dist; Edge(String v1, String v2, int dist) { this.v1 = v1; this.v2 = v2; this.dist = dist; } } /** * One vertex of the graph, complete with mappings to neighbouring vertices */ public static class Vertex implements Comparable<Vertex> { public final String name; // MAX_VALUE assumed to be infinity public int dist = Integer.MAX_VALUE; public Vertex previous = null; public final Map<Vertex, Integer> neighbours = new HashMap<>(); Vertex(String name) { this.name = name; } private void printPath() { if (this == this.previous) { System.out.printf(\"%s\", this.name); } else if (this.previous == null) { System.out.printf(\"%s(unreached)\", this.name); } else { this.previous.printPath(); System.out.printf(\" -> %s(%d)\", this.name, this.dist); } } public int compareTo(Vertex other) { if (dist == other.dist) { return name.compareTo(other.name); } return Integer.compare(dist, other.dist); } @Override public boolean equals(Object object) { if (this == object) { return true; } if (object == null || getClass() != object.getClass()) { return false; } if (!super.equals(object)) { return false; } Vertex vertex = (Vertex) object; if (dist != vertex.dist) { return false; } if (name != null ? !name.equals(vertex.name) : vertex.name != null) { return false; } if (previous != null ? !previous.equals(vertex.previous) : vertex.previous != null) { return false; } return neighbours != null ? neighbours.equals(vertex.neighbours) : vertex.neighbours == null; } @Override public int hashCode() { int result = super.hashCode(); result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + dist; result = 31 * result + (previous != null ? previous.hashCode() : 0); result = 31 * result + (neighbours != null ? neighbours.hashCode() : 0); return result; } @Override public String toString() { return \"(\" + name + \", \" + dist + \")\"; } } /** * Builds a graph from a set of edges */ Graph(Edge[] edges) { graph = new HashMap<>(edges.length); // one pass to find all vertices for (Edge e : edges) { if (!graph.containsKey(e.v1)) { graph.put(e.v1, new Vertex(e.v1)); } if (!graph.containsKey(e.v2)) { graph.put(e.v2, new Vertex(e.v2)); } } // another pass to set neighbouring vertices for (Edge e : edges) { graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist); // graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an // undirected graph } } /** * Runs dijkstra using a specified source vertex */ public void dijkstra(String startName) { if (!graph.containsKey(startName)) { System.err.printf(\"Graph doesn't contain start vertex \\\"%s\\\"%n\", startName); return; } final Vertex source = graph.get(startName); NavigableSet<Vertex> q = new TreeSet<>(); // set-up vertices for (Vertex v : graph.values()) { v.previous = v == source ? source : null; v.dist = v == source ? 0 : Integer.MAX_VALUE; q.add(v); } dijkstra(q); } /** * Implementation of dijkstra's algorithm using a binary heap. */ private void dijkstra(final NavigableSet<Vertex> q) { Vertex u; Vertex v; while (!q.isEmpty()) { // vertex with shortest distance (first iteration will return source) u = q.pollFirst(); if (u.dist == Integer.MAX_VALUE) { break; // we can ignore u (and any other remaining vertices) since they are // unreachable } // look at distances to each neighbour for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) { v = a.getKey(); // the neighbour in this iteration final int alternateDist = u.dist + a.getValue(); if (alternateDist < v.dist) { // shorter path to neighbour found q.remove(v); v.dist = alternateDist; v.previous = u; q.add(v); } } } } /** * Prints a path from the source to the specified vertex */ public void printPath(String endName) { if (!graph.containsKey(endName)) { System.err.printf(\"Graph doesn't contain end vertex \\\"%s\\\"%n\", endName); return; } graph.get(endName).printPath(); System.out.println(); } /** * Prints the path from the source to every vertex (output order is not * guaranteed) */ public void printAllPaths() { for (Vertex v : graph.values()) { v.printPath(); System.out.println(); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.Arrays; public class DijkstraAlgorithm { private final int a; public DijkstraAlgorithm(int n) { this.a = n; } public int[] run(int[][] nArray, int n) { if (n < 0 || n >= this.a) { throw new IllegalArgumentException(\"Incorrect source\"); } int[] nArray2 = new int[this.a]; boolean[] blArray = new boolean[this.a]; Arrays.fill(nArray2, Integer.MAX_VALUE); Arrays.fill(blArray, false); nArray2[n] = 0; for (n = 0; n < this.a - 1; ++n) { boolean[] blArray2 = blArray; int[] nArray3 = nArray2; DijkstraAlgorithm dijkstraAlgorithm = this; int n2 = Integer.MAX_VALUE; int n3 = -1; for (int i = 0; i < dijkstraAlgorithm.a; ++i) { if (blArray2[i] || nArray3[i] > n2) continue; n2 = nArray3[i]; n3 = i; } int n4 = n3; blArray[n4] = true; for (int i = 0; i < this.a; ++i) { if (blArray[i] || nArray[n4][i] == 0 || nArray2[n4] == Integer.MAX_VALUE || nArray2[n4] + nArray[n4][i] >= nArray2[i]) continue; nArray2[i] = nArray2[n4] + nArray[n4][i]; } } int[] nArray4 = nArray2; DijkstraAlgorithm dijkstraAlgorithm = this; System.out.println(\"Vertex \\t Distance\"); for (int i = 0; i < dijkstraAlgorithm.a; ++i) { System.out.println(i + \" \\t \" + nArray4[i]); } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.Arrays; /** * Dijkstra's algorithm for finding the shortest path from a single source vertex to all other vertices in a graph. */ public class DijkstraAlgorithm { private final int vertexCount; /** * Constructs a Dijkstra object with the given number of vertices. * * @param vertexCount The number of vertices in the graph. */ public DijkstraAlgorithm(int vertexCount) { this.vertexCount = vertexCount; } /** * Executes Dijkstra's algorithm on the provided graph to find the shortest paths from the source vertex to all other vertices. * * The graph is represented as an adjacency matrix where {@code graph[i][j]} represents the weight of the edge from vertex {@code i} * to vertex {@code j}. A value of 0 indicates no edge exists between the vertices. * * @param graph The graph represented as an adjacency matrix. * @param source The source vertex. * @return An array where the value at each index {@code i} represents the shortest distance from the source vertex to vertex {@code i}. * @throws IllegalArgumentException if the source vertex is out of range. */ public int[] run(int[][] graph, int source) { if (source < 0 || source >= vertexCount) { throw new IllegalArgumentException(\"Incorrect source\"); } int[] distances = new int[vertexCount]; boolean[] processed = new boolean[vertexCount]; Arrays.fill(distances, Integer.MAX_VALUE); Arrays.fill(processed, false); distances[source] = 0; for (int count = 0; count < vertexCount - 1; count++) { int u = getMinDistanceVertex(distances, processed); processed[u] = true; for (int v = 0; v < vertexCount; v++) { if (!processed[v] && graph[u][v] != 0 && distances[u] != Integer.MAX_VALUE && distances[u] + graph[u][v] < distances[v]) { distances[v] = distances[u] + graph[u][v]; } } } printDistances(distances); return distances; } /** * Finds the vertex with the minimum distance value from the set of vertices that have not yet been processed. * * @param distances The array of current shortest distances from the source vertex. * @param processed The array indicating whether each vertex has been processed. * @return The index of the vertex with the minimum distance value. */ private int getMinDistanceVertex(int[] distances, boolean[] processed) { int min = Integer.MAX_VALUE; int minIndex = -1; for (int v = 0; v < vertexCount; v++) { if (!processed[v] && distances[v] <= min) { min = distances[v]; minIndex = v; } } return minIndex; } /** * Prints the shortest distances from the source vertex to all other vertices. * * @param distances The array of shortest distances. */ private void printDistances(int[] distances) { System.out.println(\"Vertex \\t Distance\"); for (int i = 0; i < vertexCount; i++) { System.out.println(i + \" \\t \" + distances[i]); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. * * Could not load the following classes: * org.apache.commons.lang3.tuple.Pair */ package com.thealgorithms.datastructures.graphs; import java.util.Arrays; import java.util.TreeSet; import org.apache.commons.lang3.tuple.Pair; public class DijkstraOptimizedAlgorithm { private final int a; public DijkstraOptimizedAlgorithm(int n) { this.a = n; } public int[] run(int[][] nArray, int n) { if (n < 0 || n >= this.a) { throw new IllegalArgumentException(\"Incorrect source\"); } int[] nArray2 = new int[this.a]; boolean[] blArray = new boolean[this.a]; TreeSet<Pair> treeSet = new TreeSet<Pair>(); Arrays.fill(nArray2, Integer.MAX_VALUE); Arrays.fill(blArray, false); nArray2[n] = 0; treeSet.add(Pair.of((Object)0, (Object)n)); while (!treeSet.isEmpty()) { Pair pair = (Pair)treeSet.iterator().next(); treeSet.remove(pair); n = (Integer)pair.getRight(); blArray[n] = true; for (int i = 0; i < this.a; ++i) { if (blArray[i] || nArray[n][i] == 0 || nArray2[n] == Integer.MAX_VALUE || nArray2[n] + nArray[n][i] >= nArray2[i]) continue; treeSet.remove(Pair.of((Object)nArray2[i], (Object)i)); nArray2[i] = nArray2[n] + nArray[n][i]; treeSet.add(Pair.of((Object)nArray2[i], (Object)i)); } } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.Arrays; import java.util.Set; import java.util.TreeSet; import org.apache.commons.lang3.tuple.Pair; /** * Dijkstra's algorithm for finding the shortest path from a single source vertex to all other vertices in a graph. */ public class DijkstraOptimizedAlgorithm { private final int vertexCount; /** * Constructs a Dijkstra object with the given number of vertices. * * @param vertexCount The number of vertices in the graph. */ public DijkstraOptimizedAlgorithm(int vertexCount) { this.vertexCount = vertexCount; } /** * Executes Dijkstra's algorithm on the provided graph to find the shortest paths from the source vertex to all other vertices. * * The graph is represented as an adjacency matrix where {@code graph[i][j]} represents the weight of the edge from vertex {@code i} * to vertex {@code j}. A value of 0 indicates no edge exists between the vertices. * * @param graph The graph represented as an adjacency matrix. * @param source The source vertex. * @return An array where the value at each index {@code i} represents the shortest distance from the source vertex to vertex {@code i}. * @throws IllegalArgumentException if the source vertex is out of range. */ public int[] run(int[][] graph, int source) { if (source < 0 || source >= vertexCount) { throw new IllegalArgumentException(\"Incorrect source\"); } int[] distances = new int[vertexCount]; boolean[] processed = new boolean[vertexCount]; Set<Pair<Integer, Integer>> unprocessed = new TreeSet<>(); Arrays.fill(distances, Integer.MAX_VALUE); Arrays.fill(processed, false); distances[source] = 0; unprocessed.add(Pair.of(0, source)); while (!unprocessed.isEmpty()) { Pair<Integer, Integer> distanceAndU = unprocessed.iterator().next(); unprocessed.remove(distanceAndU); int u = distanceAndU.getRight(); processed[u] = true; for (int v = 0; v < vertexCount; v++) { if (!processed[v] && graph[u][v] != 0 && distances[u] != Integer.MAX_VALUE && distances[u] + graph[u][v] < distances[v]) { unprocessed.remove(Pair.of(distances[v], v)); distances[v] = distances[u] + graph[u][v]; unprocessed.add(Pair.of(distances[v], v)); } } } return distances; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.disjointsetunion; import com.thealgorithms.datastructures.disjointsetunion.Node; public class DisjointSetUnion { public Node makeSet(Object object) { return new Node(object); } public Node findSet(Node node) { Node node2 = node; if (node2 != node2.parent) { node.parent = this.findSet(node.parent); } return node.parent; } public void unionSets(Node node, Node node2) { if ((node = this.findSet(node)) == (node2 = this.findSet(node2))) { return; } if (node.rank > node2.rank) { node2.parent = node; return; } if (node2.rank > node.rank) { node.parent = node2; return; } node2.parent = node; ++node.rank; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.disjointsetunion; /** * Disjoint Set Union (DSU), also known as Union-Find, is a data structure that tracks a set of elements * partitioned into disjoint (non-overlapping) subsets. It supports two primary operations efficiently: * * <ul> * <li>Find: Determine which subset a particular element belongs to.</li> * <li>Union: Merge two subsets into a single subset.</li> * </ul> * * @see <a href=\"https://en.wikipedia.org/wiki/Disjoint-set_data_structure\">Disjoint Set Union (Wikipedia)</a> */ public class DisjointSetUnion<T> { /** * Creates a new disjoint set containing the single specified element. * * @param value the element to be placed in a new singleton set * @return a node representing the new set */ public Node<T> makeSet(final T value) { return new Node<>(value); } /** * Finds and returns the representative (root) of the set containing the given node. * This method applies path compression to flatten the tree structure for future efficiency. * * @param node the node whose set representative is to be found * @return the representative (root) node of the set */ public Node<T> findSet(Node<T> node) { if (node != node.parent) { node.parent = findSet(node.parent); } return node.parent; } /** * Merges the sets containing the two given nodes. Union by rank is used to attach the smaller tree under the larger one. * If both sets have the same rank, one becomes the parent and its rank is incremented. * * @param x a node in the first set * @param y a node in the second set */ public void unionSets(Node<T> x, Node<T> y) { Node<T> rootX = findSet(x); Node<T> rootY = findSet(y); if (rootX == rootY) { return; // They are already in the same set } // Merging happens based on rank of node, this is done to avoid long chaining of nodes and reduce time // to find root of the component. Idea is to attach small components in big, instead of other way around. if (rootX.rank > rootY.rank) { rootY.parent = rootX; } else if (rootY.rank > rootX.rank) { rootX.parent = rootY; } else { rootY.parent = rootX; rootX.rank++; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class DistanceFormula { private DistanceFormula() { } public static double euclideanDistance(double d, double d2, double d3, double d4) { double d5 = Math.pow(d3 - d, 2.0); double d6 = Math.pow(d4 - d, 2.0); return Math.sqrt(d5 + d6); } public static double manhattanDistance(double d, double d2, double d3, double d4) { return Math.abs(d - d3) + Math.abs(d2 - d4); } public static int hammingDistance(int[] nArray, int[] nArray2) { int n = 0; if (nArray.length != nArray2.length) { return -1; } for (int i = 0; i < nArray.length; ++i) { n += Math.abs(nArray[i] - nArray2[i]); } return n; } public static double minkowskiDistance(double[] dArray, double[] dArray2, int n) { double d = 0.0; if (dArray.length != dArray2.length) { return -1.0; } for (int i = 0; i < dArray.length; ++i) { d += Math.abs(Math.pow(dArray[i] - dArray2[i], n)); } double d2 = d = Math.pow(d, 1.0 / (double)n); return d; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class DistanceFormula { private DistanceFormula() { } public static double euclideanDistance(double x1, double y1, double x2, double y2) { double dX = Math.pow(x2 - x1, 2); double dY = Math.pow(y2 - x1, 2); return Math.sqrt(dX + dY); } public static double manhattanDistance(double x1, double y1, double x2, double y2) { return Math.abs(x1 - x2) + Math.abs(y1 - y2); } public static int hammingDistance(int[] b1, int[] b2) { int d = 0; if (b1.length != b2.length) { return -1; // error, both arrays must have the same length } for (int i = 0; i < b1.length; i++) { d += Math.abs(b1[i] - b2[i]); } return d; } public static double minkowskiDistance(double[] p1, double[] p2, int p) { double d = 0; double distance = 0.0; if (p1.length != p2.length) { return -1; // error, both arrays must have the same length } for (int i = 0; i < p1.length; i++) { distance += Math.abs(Math.pow(p1[i] - p2[i], p)); } distance = Math.pow(distance, (double) 1 / p); d = distance; return d; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.Link; import com.thealgorithms.datastructures.lists.LinkOperations; public final class DoublyLinkedList { protected Link a; private Link b; private LinkOperations c; public DoublyLinkedList() { this.a = null; this.b = null; } public DoublyLinkedList(int[] nArray) { if (nArray == null) { throw new NullPointerException(); } int n = nArray.length; int n2 = 0; if (0 < n) { int cfr_ignored_0 = nArray[n2]; throw new NullPointerException(); } } public final boolean isEmpty() { return true; } public final void display() { System.out.println(); } public final void displayBackwards() { System.out.println(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; /** * This class implements a DoublyLinkedList. This is done using the classes * LinkedList and Link. * * <p> * A linked list is similar to an array, it holds values. However, links in a * linked list do not have indexes. With a linked list you do not need to * predetermine it's size as it grows and shrinks as it is edited. This is an * example of a double ended, doubly linked list. Each link references the next * link and the previous one. * * @author Unknown */ public final class DoublyLinkedList { /** * Head refers to the front of the list */ protected Link head; /** * Tail refers to the back of the list */ private Link tail; /** * Link Operations to perform operations on nodes of the list */ private LinkOperations linkOperations; /** * Default Constructor */ public DoublyLinkedList() { head = null; tail = null; } /** * Constructs a list containing the elements of the array * * @param array the array whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public DoublyLinkedList(int[] array) { if (array == null) { throw new NullPointerException(); } for (int i : array) { linkOperations.insertTail(i, this); } } /** * Returns true if list is empty * * @return true if list is empty */ public boolean isEmpty() { return (head == null); } /** * Prints contents of the list */ public void display() { // Prints contents of the list Link current = head; while (current != null) { current.displayLink(); current = current.next; } System.out.println(); } /** * Prints the contents of the list in reverse order */ public void displayBackwards() { Link current = tail; while (current != null) { current.displayLink(); current = current.previous; } System.out.println(); } } /** * This class is used to implement the nodes of the linked list. * * @author Unknown */ class Link { /** * Value of node */ public int value; /** * This points to the link in front of the new link */ public Link next; /** * This points to the link behind the new link */ public Link previous; /** * Constructor * * @param value Value of node */ Link(int value) { this.value = value; } /** * Displays the node */ public void displayLink() { System.out.print(value + \" \"); } /** * Main Method * * @param args Command line arguments */ public static void main(String[] args) { DoublyLinkedList myList = new DoublyLinkedList(); LinkOperations linkOperations = new LinkOperations(); linkOperations.insertHead(13, myList); linkOperations.insertHead(7, myList); linkOperations.insertHead(10, myList); myList.display(); // <-- 10(head) <--> 7 <--> 13(tail) --> myList.displayBackwards(); linkOperations.insertTail(11, myList); myList.display(); // <-- 10(head) <--> 7 <--> 13 <--> 11(tail) --> myList.displayBackwards(); linkOperations.deleteTail(); myList.display(); // <-- 10(head) <--> 7 <--> 13(tail) --> myList.displayBackwards(); linkOperations.delete(7); myList.display(); // <-- 10(head) <--> 13(tail) --> myList.displayBackwards(); linkOperations.insertOrdered(23, myList); linkOperations.insertOrdered(67, myList); linkOperations.insertOrdered(3, myList); myList.display(); // <-- 3(head) <--> 10 <--> 13 <--> 23 <--> 67(tail) --> linkOperations.insertElementByIndex(5, 1, myList); myList.display(); // <-- 3(head) <--> 5 <--> 10 <--> 13 <--> 23 <--> 67(tail) --> myList.displayBackwards(); linkOperations.reverse(); // <-- 67(head) <--> 23 <--> 13 <--> 10 <--> 5 <--> 3(tail) --> myList.display(); linkOperations.clearList(); myList.display(); myList.displayBackwards(); linkOperations.insertHead(20, myList); myList.display(); myList.displayBackwards(); } } /* * This class implements the operations of the Link nodes. */ class LinkOperations { /** * Head refers to the front of the list */ private Link head; /** * Tail refers to the back of the list */ private Link tail; /** * Size refers to the number of elements present in the list */ private int size; /** * Insert an element at the head * * @param x Element to be inserted */ public void insertHead(int x, DoublyLinkedList doublyLinkedList) { Link newLink = new Link(x); // Create a new link with a value attached to it if (doublyLinkedList.isEmpty()) { // Set the first element added to be the tail tail = newLink; } else { head.previous = newLink; // newLink <-- currenthead(head) } newLink.next = head; // newLink <--> currenthead(head) head = newLink; // newLink(head) <--> oldhead ++size; } /** * Insert an element at the tail * * @param x Element to be inserted */ public void insertTail(int x, DoublyLinkedList doublyLinkedList) { Link newLink = new Link(x); newLink.next = null; // currentTail(tail) newlink --> if (doublyLinkedList.isEmpty()) { // Check if there are no elements in list then it adds first element tail = newLink; head = tail; } else { tail.next = newLink; // currentTail(tail) --> newLink --> newLink.previous = tail; // currentTail(tail) <--> newLink --> tail = newLink; // oldTail <--> newLink(tail) --> } ++size; } /** * Insert an element at the index * * @param x Element to be inserted * @param index Index(from start) at which the element x to be inserted */ public void insertElementByIndex(int x, int index, DoublyLinkedList doublyLinkedList) { if (index > size) { throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size); } if (index == 0) { insertHead(x, doublyLinkedList); } else { if (index == size) { insertTail(x, doublyLinkedList); } else { Link newLink = new Link(x); Link previousLink = head; // for (int i = 1; i < index; i++) { // Loop to reach the index previousLink = previousLink.next; } // previousLink is the Link at index - 1 from start previousLink.next.previous = newLink; newLink.next = previousLink.next; newLink.previous = previousLink; previousLink.next = newLink; } } ++size; } /** * Delete the element at the head * * @return The new head */ public Link deleteHead() { Link temp = head; head = head.next; // oldHead <--> 2ndElement(head) if (head == null) { tail = null; } else { head.previous = null; // oldHead --> 2ndElement(head) nothing pointing at old head so // will be removed } --size; return temp; } /** * Delete the element at the tail * * @return The new tail */ public Link deleteTail() { Link temp = tail; tail = tail.previous; // 2ndLast(tail) <--> oldTail --> null if (tail == null) { head = null; } else { tail.next = null; // 2ndLast(tail) --> null } --size; return temp; } /** * Delete the element from somewhere in the list * * @param x element to be deleted * @return Link deleted */ public void delete(int x) { Link current = head; while (current.value != x) { // Find the position to delete if (current != tail) { current = current.next; } else { // If we reach the tail and the element is still not found throw new RuntimeException(\"The element to be deleted does not exist!\"); } } if (current == head) { deleteHead(); } else if (current == tail) { deleteTail(); } else { // Before: 1 <--> 2(current) <--> 3 current.previous.next = current.next; // 1 --> 3 current.next.previous = current.previous; // 1 <--> 3 } --size; } /** * Inserts element and reorders * * @param x Element to be added */ public void insertOrdered(int x, DoublyLinkedList doublyLinkedList) { Link newLink = new Link(x); Link current = head; while (current != null && x > current.value) { // Find the position to insert current = current.next; } if (current == head) { insertHead(x, doublyLinkedList); } else if (current == null) { insertTail(x, doublyLinkedList); } else { // Before: 1 <--> 2(current) <--> 3 newLink.previous = current.previous; // 1 <-- newLink current.previous.next = newLink; // 1 <--> newLink newLink.next = current; // 1 <--> newLink --> 2(current) <--> 3 current.previous = newLink; // 1 <--> newLink <--> 2(current) <--> 3 } ++size; } /** * Deletes the passed node from the current list * * @param z Element to be deleted */ public void deleteNode(Link z) { if (z.next == null) { deleteTail(); } else if (z == head) { deleteHead(); } else { // before <-- 1 <--> 2(z) <--> 3 --> z.previous.next = z.next; // 1 --> 3 z.next.previous = z.previous; // 1 <--> 3 } --size; } public void removeDuplicates(DoublyLinkedList l) { Link linkOne = l.head; while (linkOne.next != null) { // list is present Link linkTwo = linkOne.next; // second link for comparison while (linkTwo.next != null) { if (linkOne.value == linkTwo.value) { // if there are duplicates values then delete(linkTwo.value); // delete the link } linkTwo = linkTwo.next; // go to next link } linkOne = linkOne.next; // go to link link to iterate the whole list again } } /** * Reverses the list in place */ public void reverse() { // Keep references to the head and tail Link thisHead = this.head; Link thisTail = this.tail; // Flip the head and tail references this.head = thisTail; this.tail = thisHead; // While the link we're visiting is not null, flip the // next and previous links Link nextLink = thisHead; while (nextLink != null) { Link nextLinkNext = nextLink.next; Link nextLinkPrevious = nextLink.previous; nextLink.next = nextLinkPrevious; nextLink.previous = nextLinkNext; // Now, we want to go to the next link nextLink = nextLinkNext; } } /** * Clears List */ public void clearList() { head = null; tail = null; size = 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class DualPivotQuickSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length <= 1) { return comparableArray; } DualPivotQuickSort.a(comparableArray, 0, comparableArray.length - 1); return comparableArray; } private static void a(Comparable[] comparableArray, int n, int n2) { while (n < n2) { int[] nArray = DualPivotQuickSort.b(comparableArray, n, n2); DualPivotQuickSort.a(comparableArray, n, nArray[0] - 1); DualPivotQuickSort.a(comparableArray, nArray[0] + 1, nArray[1] - 1); n = nArray[1] + 1; } } private static int[] b(Comparable[] comparableArray, int n, int n2) { int n3; if (SortUtils.greater(comparableArray[n], comparableArray[n2])) { SortUtils.swap(comparableArray, n, n2); } Comparable comparable = comparableArray[n]; Comparable comparable2 = comparableArray[n2]; int n4 = n + 1; int n5 = n2 - 1; for (n3 = n + 1; n3 <= n5; ++n3) { if (SortUtils.less(comparableArray[n3], comparable)) { SortUtils.swap(comparableArray, n3, n4); ++n4; continue; } if (!SortUtils.a(comparableArray[n3], comparable2)) continue; while (n3 < n5 && SortUtils.greater(comparableArray[n5], comparable2)) { --n5; } SortUtils.swap(comparableArray, n3, n5); --n5; if (!SortUtils.less(comparableArray[n3], comparable)) continue; SortUtils.swap(comparableArray, n3, n4); ++n4; } SortUtils.swap(comparableArray, n, --n4); SortUtils.swap(comparableArray, n2, ++n5); return new int[]{n3, n5}; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * Dual Pivot Quick Sort Algorithm * * @author Debasish Biswas (https://github.com/debasishbsws) * * @see SortAlgorithm */ public class DualPivotQuickSort implements SortAlgorithm { /** * Sorts an array using the Dual Pivot QuickSort algorithm. * * @param array The array to be sorted * @param <T> The type of elements in the array, which must be comparable * @return The sorted array */ @Override public <T extends Comparable<T>> T[] sort(final T[] array) { if (array.length <= 1) { return array; } dualPivotQuicksort(array, 0, array.length - 1); return array; } /** * Recursively applies the Dual Pivot QuickSort algorithm to subarrays. * * @param array The array to be sorted * @param left The starting index of the subarray * @param right The ending index of the subarray * @param <T> The type of elements in the array, which must be comparable */ private static <T extends Comparable<T>> void dualPivotQuicksort(final T[] array, final int left, final int right) { if (left < right) { final int[] pivots = partition(array, left, right); dualPivotQuicksort(array, left, pivots[0] - 1); dualPivotQuicksort(array, pivots[0] + 1, pivots[1] - 1); dualPivotQuicksort(array, pivots[1] + 1, right); } } /** * Partitions the array into three parts using two pivots. * * @param array The array to be partitioned * @param left The starting index for partitioning * @param right The ending index for partitioning * @param <T> The type of elements in the array, which must be comparable * @return An array containing the indices of the two pivots */ private static <T extends Comparable<T>> int[] partition(final T[] array, int left, final int right) { if (SortUtils.greater(array[left], array[right])) { SortUtils.swap(array, left, right); } final T pivot1 = array[left]; final T pivot2 = array[right]; int pivot1End = left + 1; int low = left + 1; int high = right - 1; while (low <= high) { if (SortUtils.less(array[low], pivot1)) { SortUtils.swap(array, low, pivot1End); pivot1End++; } else if (SortUtils.greaterOrEqual(array[low], pivot2)) { while (low < high && SortUtils.greater(array[high], pivot2)) { high--; } SortUtils.swap(array, low, high); high--; if (SortUtils.less(array[low], pivot1)) { SortUtils.swap(array, low, pivot1End); pivot1End++; } } low++; } // Place the pivots in their correct positions pivot1End--; high++; SortUtils.swap(array, left, pivot1End); SortUtils.swap(array, right, high); // Return the indices of the pivots return new int[] {low, high}; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.SumOfDigits; public final class DudeneyNumber { private DudeneyNumber() { } public static boolean isDudeney(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Input must me positive.\"); } int n2 = (int)Math.round(Math.pow(n, 0.3333333333333333)); if (n2 * n2 * n2 != n) { return false; } return n2 == SumOfDigits.sumOfDigits(n); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * A number is said to be Dudeney if the sum of the digits, is the cube root of the entered number. * Example- Let the number be 512, its sum of digits is 5+1+2=8. The cube root of 512 is also 8. * Since, the sum of the digits is equal to the cube root of the entered number; * it is a Dudeney Number. */ public final class DudeneyNumber { private DudeneyNumber() { } // returns True if the number is a Dudeney number and False if it is not a Dudeney number. public static boolean isDudeney(final int n) { if (n <= 0) { throw new IllegalArgumentException(\"Input must me positive.\"); } // Calculating Cube Root final int cubeRoot = (int) Math.round(Math.pow(n, 1.0 / 3.0)); // If the number is not a perfect cube the method returns false. if (cubeRoot * cubeRoot * cubeRoot != n) { return false; } // If the cube root of the number is not equal to the sum of its digits, we return false. return cubeRoot == SumOfDigits.sumOfDigits(n); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Stack; public final class DuplicateBrackets { private DuplicateBrackets() { } public static boolean check(String string) { if (string == null) { throw new IllegalArgumentException(\"Input expression cannot be null.\"); } Stack<Character> stack = new Stack<Character>(); for (int i = 0; i < string.length(); ++i) { char c = string.charAt(i); if (c == ')') { if (stack.isEmpty() || ((Character)stack.peek()).charValue() == '(') { return true; } while (!stack.isEmpty() && ((Character)stack.peek()).charValue() != '(') { stack.pop(); } if (stack.isEmpty()) continue; stack.pop(); continue; } stack.push(Character.valueOf(c)); } return false; } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; /** * Class for detecting unnecessary or redundant brackets in a mathematical expression. * Assumes the expression is balanced (i.e., all opening brackets have matching closing brackets). */ public final class DuplicateBrackets { private DuplicateBrackets() { } /** * Checks for extra or redundant brackets in a given expression. * * @param expression the string representing the expression to be checked * @return true if there are extra or redundant brackets, false otherwise * @throws IllegalArgumentException if the input string is null */ public static boolean check(String expression) { if (expression == null) { throw new IllegalArgumentException(\"Input expression cannot be null.\"); } Stack<Character> stack = new Stack<>(); for (int i = 0; i < expression.length(); i++) { char ch = expression.charAt(i); if (ch == ')') { if (stack.isEmpty() || stack.peek() == '(') { return true; } while (!stack.isEmpty() && stack.peek() != '(') { stack.pop(); } if (!stack.isEmpty()) { stack.pop(); } } else { stack.push(ch); } } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class DutchNationalFlagSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { return DutchNationalFlagSort.a(comparableArray, comparableArray[(int)Math.ceil((double)comparableArray.length / 2.0) - 1]); } public Comparable[] sort(Comparable[] comparableArray, Comparable comparable) { return DutchNationalFlagSort.a(comparableArray, comparable); } private static Comparable[] a(Comparable[] comparableArray, Comparable comparable) { int n = 0; int n2 = 0; int n3 = comparableArray.length - 1; while (n2 <= n3) { if (SortUtils.less(comparableArray[n2], comparable)) { SortUtils.swap(comparableArray, n, n2); ++n2; ++n; continue; } if (SortUtils.greater(comparableArray[n2], comparable)) { SortUtils.swap(comparableArray, n2, n3); --n3; continue; } ++n2; } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * The Dutch National Flag Sort sorts a sequence of values into three permutations which are defined * by a value given as the indented middle. First permutation: values less than middle. Second * permutation: values equal middle. Third permutation: values greater than middle. If no indented * middle is given, this implementation will use a value from the given Array. This value is the one * positioned in the arrays' middle if the arrays' length is odd. If the arrays' length is even, the * value left to the middle will be used. More information and Pseudocode: * https://en.wikipedia.org/wiki/Dutch_national_flag_problem */ public class DutchNationalFlagSort implements SortAlgorithm { @Override public <T extends Comparable<T>> T[] sort(T[] array) { return dutchNationalFlagSort(array, array[(int) Math.ceil((array.length) / 2.0) - 1]); } public <T extends Comparable<T>> T[] sort(T[] array, T intendedMiddle) { return dutchNationalFlagSort(array, intendedMiddle); } private <T extends Comparable<T>> T[] dutchNationalFlagSort(final T[] array, final T intendedMiddle) { int i = 0; int j = 0; int k = array.length - 1; while (j <= k) { if (SortUtils.less(array[j], intendedMiddle)) { SortUtils.swap(array, i, j); j++; i++; } else if (SortUtils.greater(array[j], intendedMiddle)) { SortUtils.swap(array, j, k); k--; } else { j++; } } return array; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.dynamicarray; import com.thealgorithms.datastructures.dynamicarray.DynamicArray; import java.util.ConcurrentModificationException; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Objects; import java.util.function.Consumer; final class DynamicArray$DynamicArrayIterator implements Iterator { private int a; private int b; private /* synthetic */ DynamicArray c; DynamicArray$DynamicArrayIterator(DynamicArray dynamicArray) { this.c = dynamicArray; this.b = dynamicArray.b; } @Override public final boolean hasNext() { this.a(); return this.a < this.c.a; } public final Object next() { this.a(); if (this.a >= this.c.a) { throw new NoSuchElementException(); } return this.c.c[this.a++]; } @Override public final void remove() { if (this.a <= 0) { throw new IllegalStateException(\"Cannot remove element before calling next()\"); } this.a(); this.c.remove(--this.a); this.b = this.c.b; } private void a() { if (this.c.b != this.b) { throw new ConcurrentModificationException(); } } public final void forEachRemaining(Consumer consumer) { Objects.requireNonNull(consumer); while (this.hasNext()) { consumer.accept(this.next()); } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.dynamicarray; import com.thealgorithms.datastructures.dynamicarray.DynamicArray; import java.util.ConcurrentModificationException; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Objects; import java.util.function.Consumer; final class DynamicArray$DynamicArrayIterator implements Iterator { private int a; private int b; private /* synthetic */ DynamicArray c; DynamicArray$DynamicArrayIterator(DynamicArray dynamicArray) { this.c = dynamicArray; this.b = dynamicArray.b; } @Override public final boolean hasNext() { this.a(); return this.a < this.c.a; } public final Object next() { this.a(); if (this.a >= this.c.a) { throw new NoSuchElementException(); } return this.c.c[this.a++]; } @Override public final void remove() { if (this.a <= 0) { throw new IllegalStateException(\"Cannot remove element before calling next()\"); } this.a(); this.c.remove(--this.a); this.b = this.c.b; } private void a() { if (this.c.b != this.b) { throw new ConcurrentModificationException(); } } public final void forEachRemaining(Consumer consumer) { Objects.requireNonNull(consumer); while (this.hasNext()) { consumer.accept(this.next()); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.dynamicarray; import com.thealgorithms.datastructures.dynamicarray.DynamicArray$DynamicArrayIterator; import java.util.Arrays; import java.util.Iterator; import java.util.stream.Stream; import java.util.stream.StreamSupport; public class DynamicArray implements Iterable { private int a; private int b; private Object[] c; public DynamicArray(int n) { if (n < 0) { throw new IllegalArgumentException(\"Capacity cannot be negative.\"); } this.a = 0; this.b = 0; this.c = new Object[n]; } public DynamicArray() { this(16); } public void add(Object object) { DynamicArray dynamicArray = this; dynamicArray.a(dynamicArray.a + 1); this.c[this.a++] = object; ++this.b; } public void put(int n, Object object) { if (n < 0) { throw new IndexOutOfBoundsException(\"Index cannot be negative.\"); } this.a(n + 1); this.c[n] = object; if (n >= this.a) { this.a = n + 1; } ++this.b; } public Object get(int n) { if (n < 0 || n >= this.a) { throw new IndexOutOfBoundsException(\"Index: \" + n + \", Size: \" + this.a); } return this.c[n]; } public Object remove(int n) { if (n < 0 || n >= this.a) { throw new IndexOutOfBoundsException(\"Index: \" + n + \", Size: \" + this.a); } Object object = this.c[n]; int n2 = n; DynamicArray dynamicArray = this; int n3 = dynamicArray.a - n2 - 1; if (n3 > 0) { System.arraycopy(dynamicArray.c, n2 + 1, dynamicArray.c, n2, n3); } dynamicArray.c[--dynamicArray.a] = null; ++this.b; return object; } public int getSize() { return this.a; } public boolean isEmpty() { return this.a == 0; } public Stream stream() { return StreamSupport.stream(this.spliterator(), false); } private void a(int n) { if (n > this.c.length) { n = Math.max(this.c.length << 1, n); this.c = Arrays.copyOf(this.c, n); } } public String toString() { return Arrays.toString(Arrays.copyOf(this.c, this.a)); } public Iterator iterator() { return new DynamicArray$DynamicArrayIterator(this); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.dynamicarray; import java.util.Arrays; import java.util.ConcurrentModificationException; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Objects; import java.util.function.Consumer; import java.util.stream.Stream; import java.util.stream.StreamSupport; /** * This class implements a dynamic array, which can grow or shrink in size * as elements are added or removed. It provides an array-like interface * with methods to add, remove, and access elements, along with iterators * to traverse the elements. * * @param <E> the type of elements that this array can hold */ public class DynamicArray<E> implements Iterable<E> { private static final int DEFAULT_CAPACITY = 16; private int size; private int modCount; // Tracks structural modifications for iterator integrity private Object[] elements; /** * Constructs a new DynamicArray with the specified initial capacity. * * @param capacity the initial capacity of the array * @throws IllegalArgumentException if the specified capacity is negative */ public DynamicArray(final int capacity) { if (capacity < 0) { throw new IllegalArgumentException(\"Capacity cannot be negative.\"); } this.size = 0; this.modCount = 0; this.elements = new Object[capacity]; } /** * Constructs a new DynamicArray with a default initial capacity. */ public DynamicArray() { this(DEFAULT_CAPACITY); } /** * Adds an element to the end of the array. If the array is full, it * creates a new array with double the size to accommodate the new element. * * @param element the element to be added to the array */ public void add(final E element) { ensureCapacity(size + 1); elements[size++] = element; modCount++; // Increment modification count } /** * Places an element at the specified index, expanding capacity if necessary. * * @param index the index at which the element is to be placed * @param element the element to be inserted at the specified index * @throws IndexOutOfBoundsException if index is less than 0 or greater than or equal to the number of elements */ public void put(final int index, E element) { if (index < 0) { throw new IndexOutOfBoundsException(\"Index cannot be negative.\"); } ensureCapacity(index + 1); elements[index] = element; if (index >= size) { size = index + 1; } modCount++; // Increment modification count } /** * Retrieves the element at the specified index. * * @param index the index of the element to retrieve * @return the element at the specified index * @throws IndexOutOfBoundsException if index is less than 0 or greater than or equal to the current size */ @SuppressWarnings(\"unchecked\") public E get(final int index) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size); } return (E) elements[index]; } /** * Removes and returns the element at the specified index. * * @param index the index of the element to be removed * @return the element that was removed from the array * @throws IndexOutOfBoundsException if index is less than 0 or greater than or equal to the current size */ public E remove(final int index) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size); } @SuppressWarnings(\"unchecked\") E oldElement = (E) elements[index]; fastRemove(index); modCount++; // Increment modification count return oldElement; } /** * Returns the current number of elements in the array. * * @return the number of elements in the array */ public int getSize() { return size; } /** * Checks whether the array is empty. * * @return true if the array contains no elements, false otherwise */ public boolean isEmpty() { return size == 0; } /** * Returns a sequential stream with this collection as its source. * * @return a stream of the elements in the array */ public Stream<E> stream() { return StreamSupport.stream(spliterator(), false); } /** * Ensures that the array has enough capacity to hold the specified number of elements. * * @param minCapacity the minimum capacity required */ private void ensureCapacity(int minCapacity) { if (minCapacity > elements.length) { int newCapacity = Math.max(elements.length * 2, minCapacity); elements = Arrays.copyOf(elements, newCapacity); } } /** * Removes the element at the specified index without resizing the array. * This method shifts any subsequent elements to the left and clears the last element. * * @param index the index of the element to remove */ private void fastRemove(int index) { int numMoved = size - index - 1; if (numMoved > 0) { System.arraycopy(elements, index + 1, elements, index, numMoved); } elements[--size] = null; // Clear to let GC do its work } /** * Returns a string representation of the array, including only the elements that are currently stored. * * @return a string containing the elements in the array */ @Override public String toString() { return Arrays.toString(Arrays.copyOf(elements, size)); } /** * Returns an iterator over the elements in this array in proper sequence. * * @return an Iterator over the elements in the array */ @Override public Iterator<E> iterator() { return new DynamicArrayIterator(); } /** * Private iterator class for the DynamicArray. */ private final class DynamicArrayIterator implements Iterator<E> { private int cursor; private int expectedModCount; /** * Constructs a new iterator for the dynamic array. */ DynamicArrayIterator() { this.expectedModCount = modCount; } /** * Checks if there are more elements in the iteration. * * @return true if there are more elements, false otherwise */ @Override public boolean hasNext() { checkForComodification(); return cursor < size; } /** * Returns the next element in the iteration. * * @return the next element in the iteration * @throws NoSuchElementException if the iteration has no more elements */ @Override @SuppressWarnings(\"unchecked\") public E next() { checkForComodification(); if (cursor >= size) { throw new NoSuchElementException(); } return (E) elements[cursor++]; } /** * Removes the last element returned by this iterator. * * @throws IllegalStateException if the next method has not yet been called, or the remove method has already been called after the last call to the next method */ @Override public void remove() { if (cursor <= 0) { throw new IllegalStateException(\"Cannot remove element before calling next()\"); } checkForComodification(); DynamicArray.this.remove(--cursor); expectedModCount = modCount; } /** * Checks for concurrent modifications to the array during iteration. * * @throws ConcurrentModificationException if the array has been modified structurally */ private void checkForComodification() { if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } /** * Performs the given action for each remaining element in the iterator until all elements have been processed. * * @param action the action to be performed for each element * @throws NullPointerException if the specified action is null */ @Override public void forEachRemaining(Consumer<? super E> action) { Objects.requireNonNull(action); while (hasNext()) { action.accept(next()); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.math.BigInteger; public class ECC$ECPoint { private final BigInteger a; private final BigInteger b; public ECC$ECPoint(BigInteger bigInteger, BigInteger bigInteger2) { this.a = bigInteger; this.b = bigInteger2; } public BigInteger getX() { return this.a; } public BigInteger getY() { return this.b; } public String toString() { return \"ECPoint(x=\" + this.a.toString() + \", y=\" + this.b.toString() + \")\"; } public ECC$ECPoint add(ECC$ECPoint object, BigInteger bigInteger, BigInteger bigInteger2) { if (this.a.equals(BigInteger.ZERO) && this.b.equals(BigInteger.ZERO)) { return object; } if (((ECC$ECPoint)object).a.equals(BigInteger.ZERO) && ((ECC$ECPoint)object).b.equals(BigInteger.ZERO)) { return this; } bigInteger2 = this.equals(object) ? this.a.pow(2).multiply(BigInteger.valueOf(3L)).add(bigInteger2).multiply(this.b.multiply(BigInteger.valueOf(2L)).modInverse(bigInteger)).mod(bigInteger) : ((ECC$ECPoint)object).b.subtract(this.b).multiply(((ECC$ECPoint)object).a.subtract(this.a).modInverse(bigInteger)).mod(bigInteger); object = bigInteger2.pow(2).subtract(this.a).subtract(((ECC$ECPoint)object).a).mod(bigInteger); bigInteger = bigInteger2.multiply(this.a.subtract((BigInteger)object)).subtract(this.b).mod(bigInteger); return new ECC$ECPoint((BigInteger)object, bigInteger); } public ECC$ECPoint subtract(ECC$ECPoint eCC$ECPoint, BigInteger bigInteger, BigInteger bigInteger2) { eCC$ECPoint = new ECC$ECPoint(eCC$ECPoint.a, bigInteger.subtract(eCC$ECPoint.b)); return this.add(eCC$ECPoint, bigInteger, bigInteger2); } public ECC$ECPoint multiply(BigInteger bigInteger, BigInteger bigInteger2, BigInteger bigInteger3) { BigInteger bigInteger4 = BigInteger.ZERO; ECC$ECPoint eCC$ECPoint = new ECC$ECPoint(bigInteger4, bigInteger4); ECC$ECPoint eCC$ECPoint2 = this; while (bigInteger.signum() > 0) { if (bigInteger.testBit(0)) { eCC$ECPoint = eCC$ECPoint.add(eCC$ECPoint2, bigInteger2, bigInteger3); } ECC$ECPoint eCC$ECPoint3 = eCC$ECPoint2; eCC$ECPoint2 = eCC$ECPoint3.add(eCC$ECPoint3, bigInteger2, bigInteger3); bigInteger = bigInteger.shiftRight(1); } return eCC$ECPoint; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.math.BigInteger; public class ECC$ECPoint { private final BigInteger a; private final BigInteger b; public ECC$ECPoint(BigInteger bigInteger, BigInteger bigInteger2) { this.a = bigInteger; this.b = bigInteger2; } public BigInteger getX() { return this.a; } public BigInteger getY() { return this.b; } public String toString() { return \"ECPoint(x=\" + this.a.toString() + \", y=\" + this.b.toString() + \")\"; } public ECC$ECPoint add(ECC$ECPoint object, BigInteger bigInteger, BigInteger bigInteger2) { if (this.a.equals(BigInteger.ZERO) && this.b.equals(BigInteger.ZERO)) { return object; } if (((ECC$ECPoint)object).a.equals(BigInteger.ZERO) && ((ECC$ECPoint)object).b.equals(BigInteger.ZERO)) { return this; } bigInteger2 = this.equals(object) ? this.a.pow(2).multiply(BigInteger.valueOf(3L)).add(bigInteger2).multiply(this.b.multiply(BigInteger.valueOf(2L)).modInverse(bigInteger)).mod(bigInteger) : ((ECC$ECPoint)object).b.subtract(this.b).multiply(((ECC$ECPoint)object).a.subtract(this.a).modInverse(bigInteger)).mod(bigInteger); object = bigInteger2.pow(2).subtract(this.a).subtract(((ECC$ECPoint)object).a).mod(bigInteger); bigInteger = bigInteger2.multiply(this.a.subtract((BigInteger)object)).subtract(this.b).mod(bigInteger); return new ECC$ECPoint((BigInteger)object, bigInteger); } public ECC$ECPoint subtract(ECC$ECPoint eCC$ECPoint, BigInteger bigInteger, BigInteger bigInteger2) { eCC$ECPoint = new ECC$ECPoint(eCC$ECPoint.a, bigInteger.subtract(eCC$ECPoint.b)); return this.add(eCC$ECPoint, bigInteger, bigInteger2); } public ECC$ECPoint multiply(BigInteger bigInteger, BigInteger bigInteger2, BigInteger bigInteger3) { BigInteger bigInteger4 = BigInteger.ZERO; ECC$ECPoint eCC$ECPoint = new ECC$ECPoint(bigInteger4, bigInteger4); ECC$ECPoint eCC$ECPoint2 = this; while (bigInteger.signum() > 0) { if (bigInteger.testBit(0)) { eCC$ECPoint = eCC$ECPoint.add(eCC$ECPoint2, bigInteger2, bigInteger3); } ECC$ECPoint eCC$ECPoint3 = eCC$ECPoint2; eCC$ECPoint2 = eCC$ECPoint3.add(eCC$ECPoint3, bigInteger2, bigInteger3); bigInteger = bigInteger.shiftRight(1); } return eCC$ECPoint; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import com.thealgorithms.ciphers.ECC$ECPoint; import java.math.BigInteger; import java.security.SecureRandom; public class ECC$EllipticCurve { private final BigInteger a; private final BigInteger b; private final BigInteger c; private final ECC$ECPoint d; public ECC$EllipticCurve(BigInteger bigInteger, BigInteger bigInteger2, BigInteger bigInteger3, ECC$ECPoint eCC$ECPoint) { this.a = bigInteger; this.b = bigInteger2; this.c = bigInteger3; this.d = eCC$ECPoint; } public ECC$EllipticCurve(int n) { SecureRandom secureRandom = new SecureRandom(); this.c = BigInteger.probablePrime(n, secureRandom); this.a = new BigInteger(n, secureRandom); this.b = new BigInteger(n, secureRandom); this.d = new ECC$ECPoint(BigInteger.valueOf(4L), BigInteger.valueOf(8L)); } public ECC$ECPoint getBasePoint() { return this.d; } public BigInteger getP() { return this.c; } public BigInteger getA() { return this.a; } public BigInteger getB() { return this.b; } public int getFieldSize() { return this.c.bitLength(); } public ECC$ECPoint encodeMessage(BigInteger bigInteger) { BigInteger bigInteger2 = bigInteger; return new ECC$ECPoint(bigInteger2, bigInteger2); } public BigInteger decodeMessage(ECC$ECPoint eCC$ECPoint) { return eCC$ECPoint.getX(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import com.thealgorithms.ciphers.ECC$ECPoint; import java.math.BigInteger; import java.security.SecureRandom; public class ECC$EllipticCurve { private final BigInteger a; private final BigInteger b; private final BigInteger c; private final ECC$ECPoint d; public ECC$EllipticCurve(BigInteger bigInteger, BigInteger bigInteger2, BigInteger bigInteger3, ECC$ECPoint eCC$ECPoint) { this.a = bigInteger; this.b = bigInteger2; this.c = bigInteger3; this.d = eCC$ECPoint; } public ECC$EllipticCurve(int n) { SecureRandom secureRandom = new SecureRandom(); this.c = BigInteger.probablePrime(n, secureRandom); this.a = new BigInteger(n, secureRandom); this.b = new BigInteger(n, secureRandom); this.d = new ECC$ECPoint(BigInteger.valueOf(4L), BigInteger.valueOf(8L)); } public ECC$ECPoint getBasePoint() { return this.d; } public BigInteger getP() { return this.c; } public BigInteger getA() { return this.a; } public BigInteger getB() { return this.b; } public int getFieldSize() { return this.c.bitLength(); } public ECC$ECPoint encodeMessage(BigInteger bigInteger) { BigInteger bigInteger2 = bigInteger; return new ECC$ECPoint(bigInteger2, bigInteger2); } public BigInteger decodeMessage(ECC$ECPoint eCC$ECPoint) { return eCC$ECPoint.getX(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import com.thealgorithms.ciphers.ECC$ECPoint; import com.thealgorithms.ciphers.ECC$EllipticCurve; import java.io.Serializable; import java.math.BigInteger; import java.security.SecureRandom; import java.util.Random; public class ECC { private BigInteger a; private ECC$ECPoint b; private ECC$EllipticCurve c; private ECC$ECPoint d; public ECC(int n) { this.generateKeys(n); } public ECC$EllipticCurve getCurve() { return this.c; } public void setCurve(ECC$EllipticCurve eCC$EllipticCurve) { this.c = eCC$EllipticCurve; } public BigInteger getPrivateKey() { return this.a; } public void setPrivateKey(BigInteger bigInteger) { this.a = bigInteger; } public ECC$ECPoint[] encrypt(String object) { object = new BigInteger(((String)object).getBytes()); Serializable serializable = new SecureRandom(); serializable = new BigInteger(this.c.getFieldSize(), (Random)serializable); ECC$ECPoint eCC$ECPoint = this.d.multiply((BigInteger)serializable, this.c.getP(), this.c.getA()); object = this.b.multiply((BigInteger)serializable, this.c.getP(), this.c.getA()).add(this.c.encodeMessage((BigInteger)object), this.c.getP(), this.c.getA()); return new ECC$ECPoint[]{eCC$ECPoint, object}; } public String decrypt(ECC$ECPoint[] object) { ECC$ECPoint eCC$ECPoint = object[0]; object = object[1]; object = ((ECC$ECPoint)object).subtract(eCC$ECPoint.multiply(this.a, this.c.getP(), this.c.getA()), this.c.getP(), this.c.getA()); object = this.c.decodeMessage((ECC$ECPoint)object); return new String(((BigInteger)object).toByteArray()); } public final void generateKeys(int n) { SecureRandom secureRandom = new SecureRandom(); this.c = new ECC$EllipticCurve(n); this.d = this.c.getBasePoint(); this.a = new BigInteger(n, secureRandom); this.b = this.d.multiply(this.a, this.c.getP(), this.c.getA()); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.math.BigInteger; import java.security.SecureRandom; /** * ECC - Elliptic Curve Cryptography * Elliptic Curve Cryptography is a public-key cryptography method that uses the algebraic structure of * elliptic curves over finite fields. ECC provides a higher level of security with smaller key sizes compared * to other public-key methods like RSA, making it particularly suitable for environments where computational * resources are limited, such as mobile devices and embedded systems. * * This class implements elliptic curve cryptography, providing encryption and decryption * functionalities based on public and private key pairs. * * @author xuyang */ public class ECC { private BigInteger privateKey; // Private key used for decryption private ECPoint publicKey; // Public key used for encryption private EllipticCurve curve; // Elliptic curve used in cryptography private ECPoint basePoint; // Base point G on the elliptic curve public ECC(int bits) { generateKeys(bits); // Generates public-private key pair } public EllipticCurve getCurve() { return curve; // Returns the elliptic curve } public void setCurve(EllipticCurve curve) { this.curve = curve; } // Getter and Setter for private key public BigInteger getPrivateKey() { return privateKey; } public void setPrivateKey(BigInteger privateKey) { this.privateKey = privateKey; } /** * Encrypts the message using the public key. * The message is transformed into an ECPoint and encrypted with elliptic curve operations. * * @param message The plain message to be encrypted * @return The encrypted message as an array of ECPoints (R, S) */ public ECPoint[] encrypt(String message) { BigInteger m = new BigInteger(message.getBytes()); // Convert message to BigInteger SecureRandom r = new SecureRandom(); // Generate random value for k BigInteger k = new BigInteger(curve.getFieldSize(), r); // Generate random scalar k // Calculate point r = k * G, where G is the base point ECPoint rPoint = basePoint.multiply(k, curve.getP(), curve.getA()); // Calculate point s = k * publicKey + encodedMessage ECPoint sPoint = publicKey.multiply(k, curve.getP(), curve.getA()).add(curve.encodeMessage(m), curve.getP(), curve.getA()); return new ECPoint[] {rPoint, sPoint}; // Return encrypted message as two ECPoints } /** * Decrypts the encrypted message using the private key. * The decryption process is the reverse of encryption, recovering the original message. * * @param encryptedMessage The encrypted message as an array of ECPoints (R, S) * @return The decrypted plain message as a String */ public String decrypt(ECPoint[] encryptedMessage) { ECPoint rPoint = encryptedMessage[0]; // First part of ciphertext ECPoint sPoint = encryptedMessage[1]; // Second part of ciphertext // Perform decryption: s - r * privateKey ECPoint decodedMessage = sPoint.subtract(rPoint.multiply(privateKey, curve.getP(), curve.getA()), curve.getP(), curve.getA()); BigInteger m = curve.decodeMessage(decodedMessage); // Decode the message from ECPoint return new String(m.toByteArray()); // Convert BigInteger back to String } /** * Generates a new public-private key pair for encryption and decryption. * * @param bits The size (in bits) of the keys to generate */ public final void generateKeys(int bits) { SecureRandom r = new SecureRandom(); curve = new EllipticCurve(bits); // Initialize a new elliptic curve basePoint = curve.getBasePoint(); // Set the base point G // Generate private key as a random BigInteger privateKey = new BigInteger(bits, r); // Generate public key as the point publicKey = privateKey * G publicKey = basePoint.multiply(privateKey, curve.getP(), curve.getA()); } /** * Class representing an elliptic curve with the form y^2 = x^3 + ax + b. */ public static class EllipticCurve { private final BigInteger a; // Coefficient a in the curve equation private final BigInteger b; // Coefficient b in the curve equation private final BigInteger p; // Prime number p, defining the finite field private final ECPoint basePoint; // Base point G on the curve // Constructor with explicit parameters for a, b, p, and base point public EllipticCurve(BigInteger a, BigInteger b, BigInteger p, ECPoint basePoint) { this.a = a; this.b = b; this.p = p; this.basePoint = basePoint; } // Constructor that randomly generates the curve parameters public EllipticCurve(int bits) { SecureRandom r = new SecureRandom(); this.p = BigInteger.probablePrime(bits, r); // Random prime p this.a = new BigInteger(bits, r); // Random coefficient a this.b = new BigInteger(bits, r); // Random coefficient b this.basePoint = new ECPoint(BigInteger.valueOf(4), BigInteger.valueOf(8)); // Fixed base point G } public ECPoint getBasePoint() { return basePoint; } public BigInteger getP() { return p; } public BigInteger getA() { return a; } public BigInteger getB() { return b; } public int getFieldSize() { return p.bitLength(); } public ECPoint encodeMessage(BigInteger message) { // Simple encoding of a message as an ECPoint (this is a simplified example) return new ECPoint(message, message); } public BigInteger decodeMessage(ECPoint point) { return point.getX(); // Decode the message from ECPoint (simplified) } } /** * Class representing a point on the elliptic curve. */ public static class ECPoint { private final BigInteger x; // X-coordinate of the point private final BigInteger y; // Y-coordinate of the point public ECPoint(BigInteger x, BigInteger y) { this.x = x; this.y = y; } public BigInteger getX() { return x; } public BigInteger getY() { return y; } @Override public String toString() { return \"ECPoint(x=\" + x.toString() + \", y=\" + y.toString() + \")\"; } /** * Add two points on the elliptic curve. */ public ECPoint add(ECPoint other, BigInteger p, BigInteger a) { if (this.x.equals(BigInteger.ZERO) && this.y.equals(BigInteger.ZERO)) { return other; // If this point is the identity, return the other point } if (other.x.equals(BigInteger.ZERO) && other.y.equals(BigInteger.ZERO)) { return this; // If the other point is the identity, return this point } BigInteger lambda; if (this.equals(other)) { // Special case: point doubling lambda = this.x.pow(2).multiply(BigInteger.valueOf(3)).add(a).multiply(this.y.multiply(BigInteger.valueOf(2)).modInverse(p)).mod(p); } else { // General case: adding two different points lambda = other.y.subtract(this.y).multiply(other.x.subtract(this.x).modInverse(p)).mod(p); } BigInteger xr = lambda.pow(2).subtract(this.x).subtract(other.x).mod(p); BigInteger yr = lambda.multiply(this.x.subtract(xr)).subtract(this.y).mod(p); return new ECPoint(xr, yr); } /** * Subtract two points on the elliptic curve. */ public ECPoint subtract(ECPoint other, BigInteger p, BigInteger a) { ECPoint negOther = new ECPoint(other.x, p.subtract(other.y)); // Negate the Y coordinate return this.add(negOther, p, a); // Add the negated point } /** * Multiply a point by a scalar (repeated addition). */ public ECPoint multiply(BigInteger k, BigInteger p, BigInteger a) { ECPoint result = new ECPoint(BigInteger.ZERO, BigInteger.ZERO); // Identity point ECPoint addend = this; while (k.signum() > 0) { if (k.testBit(0)) { result = result.add(addend, p, a); // Add the current point } addend = addend.add(addend, p, a); // Double the point k = k.shiftRight(1); // Divide k by 2 } return result; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; public class EDFScheduling$Process { private String a; private int b; private int c; private int d; private int e; public EDFScheduling$Process(String string, int n, int n2) { this.a = string; this.b = n; this.c = n2; } public String getProcessId() { return this.a; } public int getBurstTime() { return this.b; } public int getDeadline() { return this.c; } public int getWaitingTime() { return this.d; } public void setWaitingTime(int n) { this.d = n; } public int getTurnAroundTime() { return this.e; } public void setTurnAroundTime(int n) { this.e = n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; public class EDFScheduling$Process { private String a; private int b; private int c; private int d; private int e; public EDFScheduling$Process(String string, int n, int n2) { this.a = string; this.b = n; this.c = n2; } public String getProcessId() { return this.a; } public int getBurstTime() { return this.b; } public int getDeadline() { return this.c; } public int getWaitingTime() { return this.d; } public void setWaitingTime(int n) { this.d = n; } public int getTurnAroundTime() { return this.e; } public void setTurnAroundTime(int n) { this.e = n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.EDFScheduling$Process; import java.util.ArrayList; import java.util.Comparator; import java.util.List; public final class EDFScheduling { private List a; private EDFScheduling() { } public EDFScheduling(List list) { this.a = list; } public final List scheduleProcesses() { this.a.sort(Comparator.comparingInt(EDFScheduling$Process::getDeadline)); int n = 0; ArrayList<EDFScheduling$Process> arrayList = new ArrayList<EDFScheduling$Process>(); for (EDFScheduling$Process eDFScheduling$Process : this.a) { eDFScheduling$Process.setWaitingTime(n); EDFScheduling$Process eDFScheduling$Process2 = eDFScheduling$Process; eDFScheduling$Process2.setTurnAroundTime(eDFScheduling$Process2.getWaitingTime() + eDFScheduling$Process.getBurstTime()); if ((n += eDFScheduling$Process.getBurstTime()) > eDFScheduling$Process.getDeadline()) { System.out.println(\"Warning: Process \" + eDFScheduling$Process.getProcessId() + \" missed its deadline.\"); } arrayList.add(eDFScheduling$Process); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.Comparator; import java.util.List; /** * The Earliest Deadline First (EDF) Scheduling class implements a dynamic scheduling algorithm. * It assigns the CPU to processes with the earliest deadlines, ensuring that deadlines are met if possible. * This scheduling algorithm is ideal for real-time systems where meeting deadlines is critical. */ public final class EDFScheduling { private EDFScheduling() { } private List<Process> processes; /** * Constructs an EDFScheduling object with a list of processes. * * @param processes List of processes to be scheduled. */ public EDFScheduling(final List<Process> processes) { this.processes = processes; } /** * Schedules the processes using Earliest Deadline First (EDF) scheduling. * Processes are sorted by their deadlines, and the method simulates their execution. * It calculates the waiting time and turnaround time for each process. * * @return List of processes after they have been executed in order of earliest deadline first. */ public List<Process> scheduleProcesses() { processes.sort(Comparator.comparingInt(Process::getDeadline)); int currentTime = 0; List<Process> executedProcesses = new ArrayList<>(); for (Process process : processes) { process.setWaitingTime(currentTime); currentTime += process.getBurstTime(); process.setTurnAroundTime(process.getWaitingTime() + process.getBurstTime()); if (currentTime > process.getDeadline()) { System.out.println(\"Warning: Process \" + process.getProcessId() + \" missed its deadline.\"); } executedProcesses.add(process); } return executedProcesses; } /** * The Process class represents a process with an ID, burst time, deadline, waiting time, and turnaround time. */ public static class Process { private String processId; private int burstTime; private int deadline; private int waitingTime; private int turnAroundTime; public Process(String processId, int burstTime, int deadline) { this.processId = processId; this.burstTime = burstTime; this.deadline = deadline; } public String getProcessId() { return processId; } public int getBurstTime() { return burstTime; } public int getDeadline() { return deadline; } public int getWaitingTime() { return waitingTime; } public void setWaitingTime(int waitingTime) { this.waitingTime = waitingTime; } public int getTurnAroundTime() { return turnAroundTime; } public void setTurnAroundTime(int turnAroundTime) { this.turnAroundTime = turnAroundTime; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.audiofilters; public class EMAFilter { private final double a; private double b; public EMAFilter(double d) { if (d <= 0.0 || d > 1.0) { throw new IllegalArgumentException(\"Alpha must be between 0 and 1.\"); } this.a = d; this.b = 0.0; } public double[] apply(double[] dArray) { if (dArray.length == 0) { return new double[0]; } double[] dArray2 = new double[dArray.length]; dArray2[0] = this.b = dArray[0]; for (int i = 1; i < dArray.length; ++i) { dArray2[i] = this.b = this.a * dArray[i] + (1.0 - this.a) * this.b; } return dArray2; } }", "deobfuscated_code": "package com.thealgorithms.audiofilters; /** * Exponential Moving Average (EMA) Filter for smoothing audio signals. * * <p>This filter applies an exponential moving average to a sequence of audio * signal values, making it useful for smoothing out rapid fluctuations. * The smoothing factor (alpha) controls the degree of smoothing. * * <p>Based on the definition from * <a href=\"https://en.wikipedia.org/wiki/Moving_average\">Wikipedia link</a>. */ public class EMAFilter { private final double alpha; private double emaValue; /** * Constructs an EMA filter with a given smoothing factor. * * @param alpha Smoothing factor (0 < alpha <= 1) * @throws IllegalArgumentException if alpha is not in (0, 1] */ public EMAFilter(double alpha) { if (alpha <= 0 || alpha > 1) { throw new IllegalArgumentException(\"Alpha must be between 0 and 1.\"); } this.alpha = alpha; this.emaValue = 0.0; } /** * Applies the EMA filter to an audio signal array. * * @param audioSignal Array of audio samples to process * @return Array of processed (smoothed) samples */ public double[] apply(double[] audioSignal) { if (audioSignal.length == 0) { return new double[0]; } double[] emaSignal = new double[audioSignal.length]; emaValue = audioSignal[0]; emaSignal[0] = emaValue; for (int i = 1; i < audioSignal.length; i++) { emaValue = alpha * audioSignal[i] + (1 - alpha) * emaValue; emaSignal[i] = emaValue; } return emaSignal; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class EditDistance { private EditDistance() { } public static int minDistance(String string, String string2) { int n; int n2 = string.length(); int n3 = string2.length(); int[][] nArray = new int[n2 + 1][n3 + 1]; for (n = 0; n <= n2; ++n) { nArray[n][0] = n; } n = 0; while (n <= n3) { int n4 = n++; nArray[0][n4] = n4; } for (n = 0; n < n2; ++n) { char c = string.charAt(n); for (int i = 0; i < n3; ++i) { int n5 = string2.charAt(i); if (c == n5) { nArray[n + 1][i + 1] = nArray[n][i]; continue; } n5 = nArray[n][i] + 1; int n6 = nArray[n][i + 1] + 1; int n7 = nArray[n + 1][i] + 1; n5 = Math.min(n5, n6); nArray[n + 1][i + 1] = n5 = Math.min(n7, n5); } } return nArray[n2][n3]; } public static int editDistance(String string, String string2) { int[][] nArray = new int[string.length() + 1][string2.length() + 1]; return EditDistance.editDistance(string, string2, nArray); } public static int editDistance(String string, String string2, int[][] nArray) { int n; int n2 = string.length(); if (nArray[n2][n = string2.length()] > 0) { return nArray[n2][n]; } if (n2 == 0) { int n3 = n; nArray[n2][n3] = n3; return nArray[n2][n]; } if (n == 0) { nArray[n2][n] = n2; return nArray[n2][n]; } if (string.charAt(0) == string2.charAt(0)) { nArray[n2][n] = EditDistance.editDistance(string.substring(1), string2.substring(1), nArray); } else { int n4 = EditDistance.editDistance(string, string2.substring(1), nArray); int n5 = EditDistance.editDistance(string.substring(1), string2, nArray); int n6 = EditDistance.editDistance(string.substring(1), string2.substring(1), nArray); nArray[n2][n] = 1 + Math.min(n4, Math.min(n5, n6)); } return nArray[n2][n]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * A DynamicProgramming based solution for Edit Distance problem In Java * Description of Edit Distance with an Example: * * <p> * Edit distance is a way of quantifying how dissimilar two strings (e.g., * words) are to one another, by counting the minimum number of operations * required to transform one string into the other. The distance operations are * the removal, insertion, or substitution of a character in the string. * * <p> * * <p> * The Distance between \"kitten\" and \"sitting\" is 3. A minimal edit script that * transforms the former into the latter is: * * <p> * kitten  sitten (substitution of \"s\" for \"k\") sitten  sittin (substitution * of \"i\" for \"e\") sittin  sitting (insertion of \"g\" at the end). * * @author SUBHAM SANGHAI */ public final class EditDistance { private EditDistance() { } public static int minDistance(String word1, String word2) { int len1 = word1.length(); int len2 = word2.length(); // len1+1, len2+1, because finally return dp[len1][len2] int[][] dp = new int[len1 + 1][len2 + 1]; /* If second string is empty, the only option is to insert all characters of first string into second*/ for (int i = 0; i <= len1; i++) { dp[i][0] = i; } /* If first string is empty, the only option is to insert all characters of second string into first*/ for (int j = 0; j <= len2; j++) { dp[0][j] = j; } // iterate though, and check last char for (int i = 0; i < len1; i++) { char c1 = word1.charAt(i); for (int j = 0; j < len2; j++) { char c2 = word2.charAt(j); // if last two chars equal if (c1 == c2) { // update dp value for +1 length dp[i + 1][j + 1] = dp[i][j]; } else { /* if two characters are different , then take the minimum of the various operations(i.e insertion,removal,substitution)*/ int replace = dp[i][j] + 1; int insert = dp[i][j + 1] + 1; int delete = dp[i + 1][j] + 1; int min = Math.min(replace, insert); min = Math.min(delete, min); dp[i + 1][j + 1] = min; } } } /* return the final answer , after traversing through both the strings*/ return dp[len1][len2]; } // edit distance problem public static int editDistance(String s1, String s2) { int[][] storage = new int[s1.length() + 1][s2.length() + 1]; return editDistance(s1, s2, storage); } public static int editDistance(String s1, String s2, int[][] storage) { int m = s1.length(); int n = s2.length(); if (storage[m][n] > 0) { return storage[m][n]; } if (m == 0) { storage[m][n] = n; return storage[m][n]; } if (n == 0) { storage[m][n] = m; return storage[m][n]; } if (s1.charAt(0) == s2.charAt(0)) { storage[m][n] = editDistance(s1.substring(1), s2.substring(1), storage); } else { int op1 = editDistance(s1, s2.substring(1), storage); int op2 = editDistance(s1.substring(1), s2, storage); int op3 = editDistance(s1.substring(1), s2.substring(1), storage); storage[m][n] = 1 + Math.min(op1, Math.min(op2, op3)); } return storage[m][n]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.Queue; class EdmondsBlossomAlgorithm$BlossomAuxData { Queue a; int[] b; int[] c; boolean[] d; int[] e; boolean[] f; EdmondsBlossomAlgorithm$BlossomAuxData(Queue queue, int[] nArray, int[] nArray2, boolean[] blArray, int[] nArray3, boolean[] blArray2) { this.a = queue; this.b = nArray; this.c = nArray2; this.d = blArray; this.e = nArray3; this.f = blArray2; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.Queue; class EdmondsBlossomAlgorithm$BlossomAuxData { Queue a; int[] b; int[] c; boolean[] d; int[] e; boolean[] f; EdmondsBlossomAlgorithm$BlossomAuxData(Queue queue, int[] nArray, int[] nArray2, boolean[] blArray, int[] nArray3, boolean[] blArray2) { this.a = queue; this.b = nArray; this.c = nArray2; this.d = blArray; this.e = nArray3; this.f = blArray2; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.EdmondsBlossomAlgorithm$BlossomAuxData; class EdmondsBlossomAlgorithm$BlossomData { EdmondsBlossomAlgorithm$BlossomAuxData a; int b; int c; int d; EdmondsBlossomAlgorithm$BlossomData(EdmondsBlossomAlgorithm$BlossomAuxData edmondsBlossomAlgorithm$BlossomAuxData, int n, int n2, int n3) { this.a = edmondsBlossomAlgorithm$BlossomAuxData; this.b = n; this.c = n2; this.d = n3; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.EdmondsBlossomAlgorithm$BlossomAuxData; class EdmondsBlossomAlgorithm$BlossomData { EdmondsBlossomAlgorithm$BlossomAuxData a; int b; int c; int d; EdmondsBlossomAlgorithm$BlossomData(EdmondsBlossomAlgorithm$BlossomAuxData edmondsBlossomAlgorithm$BlossomAuxData, int n, int n2, int n3) { this.a = edmondsBlossomAlgorithm$BlossomAuxData; this.b = n; this.c = n2; this.d = n3; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.EdmondsBlossomAlgorithm$BlossomAuxData; import com.thealgorithms.datastructures.graphs.EdmondsBlossomAlgorithm$BlossomData; import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.LinkedList; import java.util.List; public final class EdmondsBlossomAlgorithm { private EdmondsBlossomAlgorithm() { } public static List maximumMatching(Iterable object, int n) { ArrayList arrayList = new ArrayList(n); for (int i = 0; i < n; ++i) { arrayList.add(new ArrayList()); } Object object2 = object.iterator(); while (object2.hasNext()) { int[] nArray = (int[])object2.next(); object = nArray; int n2 = nArray[0]; Object object3 = object[1]; ((List)arrayList.get(n2)).add((int)object3); ((List)arrayList.get((int)object3)).add(n2); } int[] nArray = new int[n]; object2 = nArray; Arrays.fill(nArray, -1); object = new int[n]; int[] nArray2 = new int[n]; boolean[] blArray = new boolean[n]; boolean[] blArray2 = new boolean[n]; for (int i = 0; i < n; ++i) { if (object2[i] != -1) continue; Arrays.fill((int[])object, -1); int n3 = 0; while (n3 < n) { int n4 = n3++; nArray2[n4] = n4; } Arrays.fill(blArray, false); Arrays.fill(blArray2, false); LinkedList<Integer> linkedList = new LinkedList<Integer>(); linkedList.add(i); blArray2[i] = true; boolean bl = false; block4: while (!linkedList.isEmpty() && !bl) { int n5 = (Integer)linkedList.poll(); Iterator iterator = ((List)arrayList.get(n5)).iterator(); while (iterator.hasNext()) { Object object4; Object object5; int n6 = (Integer)iterator.next(); if (object2[n5] == n6 || nArray2[n5] == nArray2[n6]) continue; if (object[n6] == -1) { if (object2[n6] == -1) { object[n6] = n5; bl = true; object5 = n6; Object object6 = object; Object object7 = object2; while (object5 != -1) { object4 = object6[object5]; Object object8 = object7[object4]; object7[object4] = object5; object7[object5] = object4; object5 = object8; } continue block4; } Object object9 = object2[n6]; object[n6] = n5; object[object9] = n6; if (blArray2[object9]) continue; linkedList.add((int)object9); blArray2[object9] = true; continue; } object4 = n6; object5 = n5; Object object10 = object; int[] nArray3 = nArray2; boolean[] blArray3 = new boolean[nArray2.length]; while (true) { object5 = nArray3[object5]; blArray3[object5] = true; if (object10[object5] == -1) break; object5 = object10[object5]; } object5 = object4; while (!blArray3[object5 = nArray3[object5]]) { object5 = object10[object5]; } Object object11 = object5; if (object11 == -1) continue; EdmondsBlossomAlgorithm$BlossomData edmondsBlossomAlgorithm$BlossomData = new EdmondsBlossomAlgorithm$BlossomData(new EdmondsBlossomAlgorithm$BlossomAuxData(linkedList, (int[])object, nArray2, blArray, (int[])object2, blArray2), n5, n6, (int)object11); int n7 = edmondsBlossomAlgorithm$BlossomData.b; while (edmondsBlossomAlgorithm$BlossomData.a.c[n7] != edmondsBlossomAlgorithm$BlossomData.d) { object5 = edmondsBlossomAlgorithm$BlossomData.a.c[n7]; object4 = edmondsBlossomAlgorithm$BlossomData.a.c[edmondsBlossomAlgorithm$BlossomData.a.e[n7]]; edmondsBlossomAlgorithm$BlossomData.a.d[object5] = true; edmondsBlossomAlgorithm$BlossomData.a.d[object4] = true; n7 = edmondsBlossomAlgorithm$BlossomData.a.b[edmondsBlossomAlgorithm$BlossomData.a.e[n7]]; } n7 = edmondsBlossomAlgorithm$BlossomData.c; while (edmondsBlossomAlgorithm$BlossomData.a.c[n7] != edmondsBlossomAlgorithm$BlossomData.d) { object5 = edmondsBlossomAlgorithm$BlossomData.a.c[n7]; object4 = edmondsBlossomAlgorithm$BlossomData.a.c[edmondsBlossomAlgorithm$BlossomData.a.e[n7]]; edmondsBlossomAlgorithm$BlossomData.a.d[object5] = true; edmondsBlossomAlgorithm$BlossomData.a.d[object4] = true; n7 = edmondsBlossomAlgorithm$BlossomData.a.b[edmondsBlossomAlgorithm$BlossomData.a.e[n7]]; } for (n7 = 0; n7 < edmondsBlossomAlgorithm$BlossomData.a.c.length; ++n7) { if (!edmondsBlossomAlgorithm$BlossomData.a.d[edmondsBlossomAlgorithm$BlossomData.a.c[n7]]) continue; edmondsBlossomAlgorithm$BlossomData.a.c[n7] = edmondsBlossomAlgorithm$BlossomData.d; if (edmondsBlossomAlgorithm$BlossomData.a.f[n7]) continue; edmondsBlossomAlgorithm$BlossomData.a.a.add(n7); edmondsBlossomAlgorithm$BlossomData.a.f[n7] = true; } } } } ArrayList<int[]> arrayList2 = new ArrayList<int[]>(); for (int i = 0; i < n; ++i) { if (object2[i] == -1 || i >= object2[i]) continue; arrayList2.add(new int[]{i, (int)object2[i]}); } return arrayList2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.List; import java.util.Queue; /** * The EdmondsBlossomAlgorithm class implements Edmonds' Blossom Algorithm * to find the maximum matching in a general graph. The algorithm efficiently * handles cases where the graph contains odd-length cycles by contracting * \"blossoms\" and finding augmenting paths. *<p> * <a href=\"https://stanford.edu/~rezab/classes/cme323/S16/projects_reports/shoemaker_vare.pdf\">Documentation of Algorithm (Stanford University)</a> * <p></p> * <a href=\"https://en.wikipedia.org/wiki/Blossom_algorithm\">Wikipedia Documentation</a> */ public final class EdmondsBlossomAlgorithm { private EdmondsBlossomAlgorithm() { } private static final int UNMATCHED = -1; // Constant to represent unmatched vertices /** * Finds the maximum matching in a general graph (Edmonds Blossom Algorithm). * * @param edges A list of edges in the graph. * @param vertexCount The number of vertices in the graph. * @return A list of matched pairs of vertices. */ public static List<int[]> maximumMatching(Iterable<int[]> edges, int vertexCount) { List<List<Integer>> graph = new ArrayList<>(vertexCount); // Initialize each vertex's adjacency list. for (int i = 0; i < vertexCount; i++) { graph.add(new ArrayList<>()); } // Populate the graph with the edges for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; graph.get(u).add(v); graph.get(v).add(u); } // Initial matching array and auxiliary data structures int[] match = new int[vertexCount]; Arrays.fill(match, UNMATCHED); // All vertices are initially unmatched int[] parent = new int[vertexCount]; int[] base = new int[vertexCount]; boolean[] inBlossom = new boolean[vertexCount]; // Indicates if a vertex is part of a blossom boolean[] inQueue = new boolean[vertexCount]; // Tracks vertices in the BFS queue // Main logic for finding maximum matching for (int u = 0; u < vertexCount; u++) { if (match[u] == UNMATCHED) { // BFS initialization Arrays.fill(parent, UNMATCHED); for (int i = 0; i < vertexCount; i++) { base[i] = i; // Each vertex is its own base initially } Arrays.fill(inBlossom, false); Arrays.fill(inQueue, false); Queue<Integer> queue = new LinkedList<>(); queue.add(u); inQueue[u] = true; boolean augmentingPathFound = false; // BFS to find augmenting paths while (!queue.isEmpty() && !augmentingPathFound) { int current = queue.poll(); // Use a different name for clarity for (int y : graph.get(current)) { // Skip if we are looking at the same edge as the current match if (match[current] == y) { continue; } if (base[current] == base[y]) { continue; // Avoid self-loops } if (parent[y] == UNMATCHED) { // Case 1: y is unmatched, we've found an augmenting path if (match[y] == UNMATCHED) { parent[y] = current; augmentingPathFound = true; updateMatching(match, parent, y); // Augment along this path break; } // Case 2: y is matched, add y's match to the queue int z = match[y]; parent[y] = current; parent[z] = y; if (!inQueue[z]) { queue.add(z); inQueue[z] = true; } } else { // Case 3: Both x and y have a parent; check for a cycle/blossom int baseU = findBase(base, parent, current, y); if (baseU != UNMATCHED) { contractBlossom(new BlossomData(new BlossomAuxData(queue, parent, base, inBlossom, match, inQueue), current, y, baseU)); } } } } } } // Create result list of matched pairs List<int[]> matchingResult = new ArrayList<>(); for (int v = 0; v < vertexCount; v++) { if (match[v] != UNMATCHED && v < match[v]) { matchingResult.add(new int[] {v, match[v]}); } } return matchingResult; } /** * Updates the matching along the augmenting path found. * * @param match The matching array. * @param parent The parent array used during the BFS. * @param u The starting node of the augmenting path. */ private static void updateMatching(int[] match, int[] parent, int u) { while (u != UNMATCHED) { int v = parent[u]; int next = match[v]; match[v] = u; match[u] = v; u = next; } } /** * Finds the base of a node in the blossom. * * @param base The base array. * @param parent The parent array. * @param u One end of the edge. * @param v The other end of the edge. * @return The base of the node or UNMATCHED. */ private static int findBase(int[] base, int[] parent, int u, int v) { boolean[] visited = new boolean[base.length]; // Mark ancestors of u int currentU = u; while (true) { currentU = base[currentU]; // Move assignment out of the condition visited[currentU] = true; if (parent[currentU] == UNMATCHED) { break; } currentU = parent[currentU]; // Move assignment out of the condition } // Find the common ancestor of v int currentV = v; while (true) { currentV = base[currentV]; // Move assignment out of the condition if (visited[currentV]) { return currentV; } currentV = parent[currentV]; // Move assignment out of the condition } } /** * Contracts a blossom and updates the base array. * * @param blossomData The data containing the parameters related to the blossom contraction. */ private static void contractBlossom(BlossomData blossomData) { for (int x = blossomData.u; blossomData.auxData.base[x] != blossomData.lca; x = blossomData.auxData.parent[blossomData.auxData.match[x]]) { int baseX = blossomData.auxData.base[x]; int matchBaseX = blossomData.auxData.base[blossomData.auxData.match[x]]; // Split the inner assignment into two separate assignments blossomData.auxData.inBlossom[baseX] = true; blossomData.auxData.inBlossom[matchBaseX] = true; } for (int x = blossomData.v; blossomData.auxData.base[x] != blossomData.lca; x = blossomData.auxData.parent[blossomData.auxData.match[x]]) { int baseX = blossomData.auxData.base[x]; int matchBaseX = blossomData.auxData.base[blossomData.auxData.match[x]]; // Split the inner assignment into two separate assignments blossomData.auxData.inBlossom[baseX] = true; blossomData.auxData.inBlossom[matchBaseX] = true; } // Update the base for all marked vertices for (int i = 0; i < blossomData.auxData.base.length; i++) { if (blossomData.auxData.inBlossom[blossomData.auxData.base[i]]) { blossomData.auxData.base[i] = blossomData.lca; // Contract to the lowest common ancestor if (!blossomData.auxData.inQueue[i]) { blossomData.auxData.queue.add(i); // Add to queue if not already present blossomData.auxData.inQueue[i] = true; } } } } /** * Auxiliary data class to encapsulate common parameters for the blossom operations. */ static class BlossomAuxData { Queue<Integer> queue; // Queue for BFS traversal int[] parent; // Parent array to store the paths int[] base; // Base array to track the base of each vertex boolean[] inBlossom; // Flags to indicate if a vertex is in a blossom int[] match; // Array to store matches for each vertex boolean[] inQueue; // Flags to track vertices in the BFS queue BlossomAuxData(Queue<Integer> queue, int[] parent, int[] base, boolean[] inBlossom, int[] match, boolean[] inQueue) { this.queue = queue; this.parent = parent; this.base = base; this.inBlossom = inBlossom; this.match = match; this.inQueue = inQueue; } } /** * BlossomData class with reduced parameters. */ static class BlossomData { BlossomAuxData auxData; // Use the auxiliary data class int u; // One vertex in the edge int v; // Another vertex in the edge int lca; // Lowest Common Ancestor BlossomData(BlossomAuxData auxData, int u, int v, int lca) { this.auxData = auxData; this.u = u; this.v = v; this.lca = lca; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class EggDropping { private EggDropping() { } public static int minTrials(int n, int n2) { int n3; int[][] nArray = new int[n + 1][n2 + 1]; for (n3 = 1; n3 <= n; ++n3) { nArray[n3][0] = 0; nArray[n3][1] = 1; } n3 = 1; while (n3 <= n2) { int n4 = n3++; nArray[1][n4] = n4; } for (n3 = 2; n3 <= n; ++n3) { for (int i = 2; i <= n2; ++i) { nArray[n3][i] = Integer.MAX_VALUE; for (int j = 1; j <= i; ++j) { int n5 = 1 + Math.max(nArray[n3 - 1][j - 1], nArray[n3][i - j]); if (n5 >= nArray[n3][i]) continue; nArray[n3][i] = n5; } } } return nArray[n][n2]; } public static void main(String[] stringArray) { int n = EggDropping.minTrials(2, 4); System.out.println(n); } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * DynamicProgramming solution for the Egg Dropping Puzzle */ public final class EggDropping { private EggDropping() { } // min trials with n eggs and m floors public static int minTrials(int n, int m) { int[][] eggFloor = new int[n + 1][m + 1]; int result; int x; for (int i = 1; i <= n; i++) { eggFloor[i][0] = 0; // Zero trial for zero floor. eggFloor[i][1] = 1; // One trial for one floor } // j trials for only 1 egg for (int j = 1; j <= m; j++) { eggFloor[1][j] = j; } // Using bottom-up approach in DP for (int i = 2; i <= n; i++) { for (int j = 2; j <= m; j++) { eggFloor[i][j] = Integer.MAX_VALUE; for (x = 1; x <= j; x++) { result = 1 + Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]); // choose min of all values for particular x if (result < eggFloor[i][j]) { eggFloor[i][j] = result; } } } } return eggFloor[n][m]; } public static void main(String[] args) { int n = 2; int m = 4; // result outputs min no. of trials in worst case for n eggs and m floors int result = minTrials(n, m); System.out.println(result); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.lang.invoke.CallSite; import java.util.ArrayList; import java.util.List; public final class EgyptianFraction { private EgyptianFraction() { } public static List getEgyptianFraction(int n, int n2) { ArrayList<CallSite> arrayList = new ArrayList<CallSite>(); while (n != 0) { int n3 = (int)Math.ceil((double)n2 / (double)n); arrayList.add((CallSite)((Object)(\"1/\" + n3))); n = n * n3 - n2; n2 *= n3; } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.ArrayList; import java.util.List; /** * Class to represent a fraction as a sum of unique unit fractions. * Example: * 2/3 = 1/2 + 1/6 * 3/10 = 1/4 + 1/20 * * @author Hardvan */ public final class EgyptianFraction { private EgyptianFraction() { } /** * Calculates the Egyptian Fraction representation of a given fraction. * * @param numerator the numerator of the fraction * @param denominator the denominator of the fraction * @return List of unit fractions represented as strings \"1/x\" */ public static List<String> getEgyptianFraction(int numerator, int denominator) { List<String> result = new ArrayList<>(); while (numerator != 0) { int x = (int) Math.ceil((double) denominator / numerator); result.add(\"1/\" + x); numerator = numerator * x - denominator; denominator = denominator * x; } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.crdt; import java.time.Instant; class Element { private Object b; Instant a; Element(Object object, Instant instant) { this.b = object; this.a = instant; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.crdt; import java.time.Instant; class Element { private Object b; Instant a; Element(Object object, Instant instant) { this.b = object; this.a = instant; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; public class EmptyHeapException extends Exception { public EmptyHeapException(String string) { super(string); } public EmptyHeapException(String string, Throwable throwable) { super(string, throwable); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; /** * @author Nicolas Renard Exception to be thrown if the getElement method is * used on an empty heap. */ @SuppressWarnings(\"serial\") public class EmptyHeapException extends Exception { public EmptyHeapException(String message) { super(message); } public EmptyHeapException(String message, Throwable cause) { super(message, cause); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class EndianConverter { private EndianConverter() { } public static int bigToLittleEndian(int n) { return Integer.reverseBytes(n); } public static int littleToBigEndian(int n) { return Integer.reverseBytes(n); } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * Utility class for converting integers between big-endian and little-endian formats. * <p> * Endianness defines how byte sequences represent multi-byte data types: * <ul> * <li><b>Big-endian</b>: The most significant byte (MSB) comes first.</li> * <li><b>Little-endian</b>: The least significant byte (LSB) comes first.</li> * </ul> * <p> * Example conversion: * <ul> * <li>Big-endian to little-endian: {@code 0x12345678}  {@code 0x78563412}</li> * <li>Little-endian to big-endian: {@code 0x78563412}  {@code 0x12345678}</li> * </ul> * * <p>Note: Both conversions in this utility are equivalent since reversing the bytes is symmetric.</p> * * <p>This class only supports 32-bit integers.</p> * * @author Hardvan */ public final class EndianConverter { private EndianConverter() { } /** * Converts a 32-bit integer from big-endian to little-endian. * * @param value the integer in big-endian format * @return the integer in little-endian format */ public static int bigToLittleEndian(int value) { return Integer.reverseBytes(value); } /** * Converts a 32-bit integer from little-endian to big-endian. * * @param value the integer in little-endian format * @return the integer in big-endian format */ public static int littleToBigEndian(int value) { return Integer.reverseBytes(value); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.ArrayList; import java.util.function.BiFunction; public final class EulerMethod { private EulerMethod() { } public static void main(String[] object) { System.out.println(\"example 1:\"); object = (d, d2) -> d; object = EulerMethod.eulerFull(0.0, 4.0, 0.1, 0.0, (BiFunction)object); if (!a) { Object object2 = object; if (((double[])((ArrayList)object2).get(((ArrayList)object2).size() - 1))[1] != 7.800000000000003) { throw new AssertionError(); } } ((ArrayList)object).forEach(dArray -> System.out.printf(\"x: %1$f; y: %2$f%n\", dArray[0], dArray[1])); System.out.println(\"\\n\\nexample 2:\"); object = (d, d2) -> d2; object = EulerMethod.eulerFull(0.0, 4.0, 0.1, 1.0, (BiFunction)object); if (!a) { Object object3 = object; if (((double[])((ArrayList)object3).get(((ArrayList)object3).size() - 1))[1] != 45.25925556817596) { throw new AssertionError(); } } ((ArrayList)object).forEach(dArray -> System.out.printf(\"x: %1$f; y: %2$f%n\", dArray[0], dArray[1])); System.out.println(\"\\n\\nexample 3:\"); object = (d, d2) -> d + d2 + d * d2; object = EulerMethod.eulerFull(0.0, 0.1, 0.025, 1.0, (BiFunction)object); if (!a) { Object object4 = object; if (((double[])((ArrayList)object4).get(((ArrayList)object4).size() - 1))[1] != 1.1116729841674804) { throw new AssertionError(); } } ((ArrayList)object).forEach(dArray -> System.out.printf(\"x: %1$f; y: %2$f%n\", dArray[0], dArray[1])); } public static double eulerStep(double d, double d2, double d3, BiFunction biFunction) { if (d2 <= 0.0) { throw new IllegalArgumentException(\"stepSize should be greater than zero\"); } return d3 + d2 * (Double)biFunction.apply(d, d3); } public static ArrayList eulerFull(double d, double d2, double d3, double d4, BiFunction biFunction) { if (d >= d2) { throw new IllegalArgumentException(\"xEnd should be greater than xStart\"); } if (d3 <= 0.0) { throw new IllegalArgumentException(\"stepSize should be greater than zero\"); } ArrayList<double[]> arrayList = new ArrayList<double[]>(); double[] dArray = new double[]{d, d4}; arrayList.add(dArray); double d5 = d4; double d6 = d; while (d6 < d2) { d5 = EulerMethod.eulerStep(d6, d3, d5, biFunction); double[] dArray2 = new double[]{d6 += d3, d5}; arrayList.add(dArray2); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; import java.util.function.BiFunction; /** * In mathematics and computational science, the Euler method (also called * forward Euler method) is a first-order numerical procedure for solving * ordinary differential equations (ODEs) with a given initial value. It is the * most basic explicit method for numerical integration of ordinary differential * equations. The method proceeds in a series of steps. At each step the y-value * is calculated by evaluating the differential equation at the previous step, * multiplying the result with the step-size and adding it to the last y-value: * y_n+1 = y_n + stepSize * f(x_n, y_n). (description adapted from * https://en.wikipedia.org/wiki/Euler_method ) (see also: * https://www.geeksforgeeks.org/euler-method-solving-differential-equation/ ) */ public final class EulerMethod { private EulerMethod() { } /** * Illustrates how the algorithm is used in 3 examples and prints the * results to the console. */ public static void main(String[] args) { System.out.println(\"example 1:\"); BiFunction<Double, Double, Double> exampleEquation1 = (x, y) -> x; ArrayList<double[]> points1 = eulerFull(0, 4, 0.1, 0, exampleEquation1); assert points1.get(points1.size() - 1)[1] == 7.800000000000003; points1.forEach(point -> System.out.printf(\"x: %1$f; y: %2$f%n\", point[0], point[1])); // example from https://en.wikipedia.org/wiki/Euler_method System.out.println(\"\\n\\nexample 2:\"); BiFunction<Double, Double, Double> exampleEquation2 = (x, y) -> y; ArrayList<double[]> points2 = eulerFull(0, 4, 0.1, 1, exampleEquation2); assert points2.get(points2.size() - 1)[1] == 45.25925556817596; points2.forEach(point -> System.out.printf(\"x: %1$f; y: %2$f%n\", point[0], point[1])); // example from https://www.geeksforgeeks.org/euler-method-solving-differential-equation/ System.out.println(\"\\n\\nexample 3:\"); BiFunction<Double, Double, Double> exampleEquation3 = (x, y) -> x + y + x * y; ArrayList<double[]> points3 = eulerFull(0, 0.1, 0.025, 1, exampleEquation3); assert points3.get(points3.size() - 1)[1] == 1.1116729841674804; points3.forEach(point -> System.out.printf(\"x: %1$f; y: %2$f%n\", point[0], point[1])); } /** * calculates the next y-value based on the current value of x, y and the * stepSize the console. * * @param xCurrent Current x-value. * @param stepSize Step-size on the x-axis. * @param yCurrent Current y-value. * @param differentialEquation The differential equation to be solved. * @return The next y-value. */ public static double eulerStep(double xCurrent, double stepSize, double yCurrent, BiFunction<Double, Double, Double> differentialEquation) { if (stepSize <= 0) { throw new IllegalArgumentException(\"stepSize should be greater than zero\"); } return yCurrent + stepSize * differentialEquation.apply(xCurrent, yCurrent); } /** * Loops through all the steps until xEnd is reached, adds a point for each * step and then returns all the points * * @param xStart First x-value. * @param xEnd Last x-value. * @param stepSize Step-size on the x-axis. * @param yStart First y-value. * @param differentialEquation The differential equation to be solved. * @return The points constituting the solution of the differential * equation. */ public static ArrayList<double[]> eulerFull(double xStart, double xEnd, double stepSize, double yStart, BiFunction<Double, Double, Double> differentialEquation) { if (xStart >= xEnd) { throw new IllegalArgumentException(\"xEnd should be greater than xStart\"); } if (stepSize <= 0) { throw new IllegalArgumentException(\"stepSize should be greater than zero\"); } ArrayList<double[]> points = new ArrayList<double[]>(); double[] firstPoint = {xStart, yStart}; points.add(firstPoint); double yCurrent = yStart; double xCurrent = xStart; while (xCurrent < xEnd) { // Euler's method for next step yCurrent = eulerStep(xCurrent, stepSize, yCurrent, differentialEquation); xCurrent += stepSize; double[] point = {xCurrent, yCurrent}; points.add(point); } return points; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class EulersFunction { private EulersFunction() { } public static int getEuler(int n) { int n2 = n; if (n2 <= 0) { throw new IllegalArgumentException(\"n must be positive.\"); } n2 = n; int n3 = 2; while (true) { int n4 = ++n3; if (n4 * n4 > n) break; if (n % n3 != 0) continue; while (n % n3 == 0) { n /= n3; } int n5 = n2; n2 = n5 - n5 / n3; } if (n > 1) { int n6 = n2; n2 = n6 - n6 / n; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Utility class for computing * <a href=\"https://en.wikipedia.org/wiki/Euler%27s_totient_function\">Euler's totient function</a>. */ public final class EulersFunction { private EulersFunction() { } /** * Validates that the input is a positive integer. * * @param n the input number to validate * @throws IllegalArgumentException if {@code n} is non-positive */ private static void checkInput(int n) { if (n <= 0) { throw new IllegalArgumentException(\"n must be positive.\"); } } /** * Computes the value of Euler's totient function for a given input. * This function has a time complexity of O(sqrt(n)). * * @param n the input number * @return the value of Euler's totient function for the given input * @throws IllegalArgumentException if {@code n} is non-positive */ public static int getEuler(int n) { checkInput(n); int result = n; for (int i = 2; i * i <= n; i++) { if (n % i == 0) { while (n % i == 0) { n /= i; } result -= result / i; } } if (n > 1) { result -= result / n; } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; class ExchangeSort implements SortAlgorithm { ExchangeSort() { } @Override public Comparable[] sort(Comparable[] comparableArray) { for (int i = 0; i < comparableArray.length - 1; ++i) { for (int j = i + 1; j < comparableArray.length; ++j) { if (!SortUtils.greater(comparableArray[i], comparableArray[j])) continue; SortUtils.swap(comparableArray, i, j); } } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * ExchangeSort is an implementation of the Exchange Sort algorithm. * * <p> * Exchange sort works by comparing each element with all subsequent elements, * swapping where needed, to ensure the correct placement of each element * in the final sorted order. It iteratively performs this process for each * element in the array. While it lacks the advantage of bubble sort in * detecting sorted lists in one pass, it can be more efficient than bubble sort * due to a constant factor (one less pass over the data to be sorted; half as * many total comparisons) in worst-case scenarios. * </p> * * <p> * Reference: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort * </p> * * @author 555vedant (Vedant Kasar) */ class ExchangeSort implements SortAlgorithm { /** * Implementation of Exchange Sort Algorithm * * @param array the array to be sorted. * @param <T> the type of elements in the array. * @return the sorted array. */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { for (int i = 0; i < array.length - 1; i++) { for (int j = i + 1; j < array.length; j++) { if (SortUtils.greater(array[i], array[j])) { SortUtils.swap(array, i, j); } } } return array; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; import java.util.Arrays; class ExponentialSearch implements SearchAlgorithm { ExponentialSearch() { } @Override public int find(Comparable[] comparableArray, Comparable comparable) { int n; if (comparableArray.length == 0) { return -1; } if (comparableArray[0].equals(comparable)) { return 0; } if (comparableArray[comparableArray.length - 1].equals(comparable)) { return comparableArray.length - 1; } for (n = 1; n < comparableArray.length && comparableArray[n].compareTo(comparable) < 0; n <<= 1) { } return Arrays.binarySearch(comparableArray, n / 2, Math.min(n, comparableArray.length), comparable); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; import java.util.Arrays; class ExponentialSearch implements SearchAlgorithm { ExponentialSearch() { } @Override public int find(Comparable[] comparableArray, Comparable comparable) { int n; if (comparableArray.length == 0) { return -1; } if (comparableArray[0].equals(comparable)) { return 0; } if (comparableArray[comparableArray.length - 1].equals(comparable)) { return comparableArray.length - 1; } for (n = 1; n < comparableArray.length && comparableArray[n].compareTo(comparable) < 0; n <<= 1) { } return Arrays.binarySearch(comparableArray, n / 2, Math.min(n, comparableArray.length), comparable); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import java.util.List; public class FCFSScheduling { private List a; public void scheduleProcesses() { FCFSScheduling fCFSScheduling = this; List cfr_ignored_0 = fCFSScheduling.a; throw new NullPointerException(); } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import com.thealgorithms.devutils.entities.ProcessDetails; import java.util.List; /** * Non-pre-emptive First Come First Serve scheduling. This can be understood here - * https://www.scaler.com/topics/first-come-first-serve/ */ public class FCFSScheduling { private List<ProcessDetails> processes; FCFSScheduling(final List<ProcessDetails> processes) { this.processes = processes; } public void scheduleProcesses() { evaluateWaitingTime(); evaluateTurnAroundTime(); } private void evaluateWaitingTime() { int processesNumber = processes.size(); if (processesNumber == 0) { return; } int waitingTime = 0; int burstTime = processes.get(0).getBurstTime(); processes.get(0).setWaitingTime(waitingTime); // for the first process, waiting time will be 0. for (int i = 1; i < processesNumber; i++) { processes.get(i).setWaitingTime(waitingTime + burstTime); waitingTime = processes.get(i).getWaitingTime(); burstTime = processes.get(i).getBurstTime(); } } private void evaluateTurnAroundTime() { for (final var process : processes) { process.setTurnAroundTimeTime(process.getBurstTime() + process.getWaitingTime()); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; class FFT$Complex { private double a; private double b; FFT$Complex() { this.a = 0.0; this.b = 0.0; } FFT$Complex(double d, double d2) { this.a = d; this.b = d2; } public double getReal() { return this.a; } public double getImaginary() { return this.b; } public FFT$Complex add(FFT$Complex fFT$Complex) { FFT$Complex fFT$Complex2 = new FFT$Complex(); new FFT$Complex().a = this.a + fFT$Complex.a; fFT$Complex2.b = this.b + fFT$Complex.b; return fFT$Complex2; } public FFT$Complex subtract(FFT$Complex fFT$Complex) { FFT$Complex fFT$Complex2 = new FFT$Complex(); new FFT$Complex().a = this.a - fFT$Complex.a; fFT$Complex2.b = this.b - fFT$Complex.b; return fFT$Complex2; } public FFT$Complex multiply(FFT$Complex fFT$Complex) { FFT$Complex fFT$Complex2 = new FFT$Complex(); new FFT$Complex().a = this.a * fFT$Complex.a - this.b * fFT$Complex.b; fFT$Complex2.b = this.a * fFT$Complex.b + this.b * fFT$Complex.a; return fFT$Complex2; } public FFT$Complex multiply(double d) { FFT$Complex fFT$Complex = new FFT$Complex(); new FFT$Complex().a = this.a * d; fFT$Complex.b = this.b * d; return fFT$Complex; } public FFT$Complex conjugate() { FFT$Complex fFT$Complex = new FFT$Complex(); new FFT$Complex().a = this.a; fFT$Complex.b = -this.b; return fFT$Complex; } public double abs() { return Math.hypot(this.a, this.b); } public FFT$Complex divide(FFT$Complex fFT$Complex) { FFT$Complex fFT$Complex2 = new FFT$Complex(); double d = fFT$Complex.abs() * fFT$Complex.abs(); d = (double)Math.round(d * 1.0E9) / 1.0E9; fFT$Complex2.a = (this.a * fFT$Complex.a + this.b * fFT$Complex.b) / d; fFT$Complex2.b = (this.b * fFT$Complex.a - this.a * fFT$Complex.b) / d; return fFT$Complex2; } public FFT$Complex divide(double d) { FFT$Complex fFT$Complex = new FFT$Complex(); new FFT$Complex().a = this.a / d; fFT$Complex.b = this.b / d; return fFT$Complex; } public double real() { return this.a; } public double imaginary() { return this.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; class FFT$Complex { private double a; private double b; FFT$Complex() { this.a = 0.0; this.b = 0.0; } FFT$Complex(double d, double d2) { this.a = d; this.b = d2; } public double getReal() { return this.a; } public double getImaginary() { return this.b; } public FFT$Complex add(FFT$Complex fFT$Complex) { FFT$Complex fFT$Complex2 = new FFT$Complex(); new FFT$Complex().a = this.a + fFT$Complex.a; fFT$Complex2.b = this.b + fFT$Complex.b; return fFT$Complex2; } public FFT$Complex subtract(FFT$Complex fFT$Complex) { FFT$Complex fFT$Complex2 = new FFT$Complex(); new FFT$Complex().a = this.a - fFT$Complex.a; fFT$Complex2.b = this.b - fFT$Complex.b; return fFT$Complex2; } public FFT$Complex multiply(FFT$Complex fFT$Complex) { FFT$Complex fFT$Complex2 = new FFT$Complex(); new FFT$Complex().a = this.a * fFT$Complex.a - this.b * fFT$Complex.b; fFT$Complex2.b = this.a * fFT$Complex.b + this.b * fFT$Complex.a; return fFT$Complex2; } public FFT$Complex multiply(double d) { FFT$Complex fFT$Complex = new FFT$Complex(); new FFT$Complex().a = this.a * d; fFT$Complex.b = this.b * d; return fFT$Complex; } public FFT$Complex conjugate() { FFT$Complex fFT$Complex = new FFT$Complex(); new FFT$Complex().a = this.a; fFT$Complex.b = -this.b; return fFT$Complex; } public double abs() { return Math.hypot(this.a, this.b); } public FFT$Complex divide(FFT$Complex fFT$Complex) { FFT$Complex fFT$Complex2 = new FFT$Complex(); double d = fFT$Complex.abs() * fFT$Complex.abs(); d = (double)Math.round(d * 1.0E9) / 1.0E9; fFT$Complex2.a = (this.a * fFT$Complex.a + this.b * fFT$Complex.b) / d; fFT$Complex2.b = (this.b * fFT$Complex.a - this.a * fFT$Complex.b) / d; return fFT$Complex2; } public FFT$Complex divide(double d) { FFT$Complex fFT$Complex = new FFT$Complex(); new FFT$Complex().a = this.a / d; fFT$Complex.b = this.b / d; return fFT$Complex; } public double real() { return this.a; } public double imaginary() { return this.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.FFT$Complex; import java.util.ArrayList; import java.util.Collections; public final class FFT { private FFT() { } public static ArrayList fft(ArrayList arrayList, boolean bl) { int n; ArrayList arrayList2 = arrayList; int n2 = arrayList2.size(); for (n = 1; n < n2; n <<= 1) { } for (int i = 0; i < n - n2; ++i) { arrayList2.add(new FFT$Complex()); } int n3 = arrayList.size(); n = FFT.findLog2(n3); arrayList = FFT.fftBitReversal(n3, n, arrayList); n = bl ? -1 : 1; for (n2 = 2; n2 <= n3; n2 <<= 1) { double d = Math.PI * -2 / (double)n2 * (double)n; FFT$Complex fFT$Complex = new FFT$Complex(Math.cos(d), Math.sin(d)); for (int i = 0; i < n3; i += n2) { FFT$Complex fFT$Complex2 = new FFT$Complex(1.0, 0.0); for (int j = 0; j < n2 / 2; ++j) { FFT$Complex fFT$Complex3 = (FFT$Complex)arrayList.get(i + j); FFT$Complex fFT$Complex4 = fFT$Complex2.multiply((FFT$Complex)arrayList.get(i + j + n2 / 2)); arrayList.set(i + j, fFT$Complex3.add(fFT$Complex4)); arrayList.set(i + j + n2 / 2, fFT$Complex3.subtract(fFT$Complex4)); fFT$Complex2 = fFT$Complex2.multiply(fFT$Complex); } } } arrayList = FFT.inverseFFT(n3, bl, arrayList); return arrayList; } public static int findLog2(int n) { int n2 = 0; while (1 << n2 < n) { ++n2; } return n2; } public static ArrayList fftBitReversal(int n, int n2, ArrayList arrayList) { for (int i = 0; i < n; ++i) { int n3 = n2; int n4 = i; int n5 = 0; for (int j = 0; j < n3; ++j) { if ((n4 & 1 << j) == 0) continue; n5 |= 1 << n3 - 1 - j; } n4 = n5; if (i >= n4) continue; Collections.swap(arrayList, i, n4); } return arrayList; } public static ArrayList inverseFFT(int n, boolean n2, ArrayList arrayList) { if (n2 != 0) { for (n2 = 0; n2 < arrayList.size(); ++n2) { FFT$Complex fFT$Complex = (FFT$Complex)arrayList.get(n2); arrayList.set(n2, fFT$Complex.divide(n)); } } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; /** * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal * using the Cooley-Tukey algorithm. * * @author Ioannis Karavitsis * @version 1.0 */ public final class FFT { private FFT() { } /** * This class represents a complex number and has methods for basic * operations. * * <p> * More info: * https://introcs.cs.princeton.edu/java/32class/Complex.java.html */ static class Complex { private double real; private double img; /** * Default Constructor. Creates the complex number 0. */ Complex() { real = 0; img = 0; } /** * Constructor. Creates a complex number. * * @param r The real part of the number. * @param i The imaginary part of the number. */ Complex(double r, double i) { real = r; img = i; } /** * Returns the real part of the complex number. * * @return The real part of the complex number. */ public double getReal() { return real; } /** * Returns the imaginary part of the complex number. * * @return The imaginary part of the complex number. */ public double getImaginary() { return img; } /** * Adds this complex number to another. * * @param z The number to be added. * @return The sum. */ public Complex add(Complex z) { Complex temp = new Complex(); temp.real = this.real + z.real; temp.img = this.img + z.img; return temp; } /** * Subtracts a number from this complex number. * * @param z The number to be subtracted. * @return The difference. */ public Complex subtract(Complex z) { Complex temp = new Complex(); temp.real = this.real - z.real; temp.img = this.img - z.img; return temp; } /** * Multiplies this complex number by another. * * @param z The number to be multiplied. * @return The product. */ public Complex multiply(Complex z) { Complex temp = new Complex(); temp.real = this.real * z.real - this.img * z.img; temp.img = this.real * z.img + this.img * z.real; return temp; } /** * Multiplies this complex number by a scalar. * * @param n The real number to be multiplied. * @return The product. */ public Complex multiply(double n) { Complex temp = new Complex(); temp.real = this.real * n; temp.img = this.img * n; return temp; } /** * Finds the conjugate of this complex number. * * @return The conjugate. */ public Complex conjugate() { Complex temp = new Complex(); temp.real = this.real; temp.img = -this.img; return temp; } /** * Finds the magnitude of the complex number. * * @return The magnitude. */ public double abs() { return Math.hypot(this.real, this.img); } /** * Divides this complex number by another. * * @param z The divisor. * @return The quotient. */ public Complex divide(Complex z) { Complex temp = new Complex(); double d = z.abs() * z.abs(); d = (double) Math.round(d * 1000000000d) / 1000000000d; temp.real = (this.real * z.real + this.img * z.img) / (d); temp.img = (this.img * z.real - this.real * z.img) / (d); return temp; } /** * Divides this complex number by a scalar. * * @param n The divisor which is a real number. * @return The quotient. */ public Complex divide(double n) { Complex temp = new Complex(); temp.real = this.real / n; temp.img = this.img / n; return temp; } public double real() { return real; } public double imaginary() { return img; } } /** * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm * with Bit-Reversal. The size of the input signal must be a power of 2. If * it isn't then it is padded with zeros and the output FFT will be bigger * than the input signal. * * <p> * More info: * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/ * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm * https://cp-algorithms.com/algebra/fft.html * @param x The discrete signal which is then converted to the FFT or the * IFFT of signal x. * @param inverse True if you want to find the inverse FFT. * @return */ public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) { /* Pad the signal with zeros if necessary */ paddingPowerOfTwo(x); int n = x.size(); int log2n = findLog2(n); x = fftBitReversal(n, log2n, x); int direction = inverse ? -1 : 1; /* Main loop of the algorithm */ for (int len = 2; len <= n; len *= 2) { double angle = -2 * Math.PI / len * direction; Complex wlen = new Complex(Math.cos(angle), Math.sin(angle)); for (int i = 0; i < n; i += len) { Complex w = new Complex(1, 0); for (int j = 0; j < len / 2; j++) { Complex u = x.get(i + j); Complex v = w.multiply(x.get(i + j + len / 2)); x.set(i + j, u.add(v)); x.set(i + j + len / 2, u.subtract(v)); w = w.multiply(wlen); } } } x = inverseFFT(n, inverse, x); return x; } /* Find the log2(n) */ public static int findLog2(int n) { int log2n = 0; while ((1 << log2n) < n) { log2n++; } return log2n; } /* Swap the values of the signal with bit-reversal method */ public static ArrayList<Complex> fftBitReversal(int n, int log2n, ArrayList<Complex> x) { int reverse; for (int i = 0; i < n; i++) { reverse = reverseBits(i, log2n); if (i < reverse) { Collections.swap(x, i, reverse); } } return x; } /* Divide by n if we want the inverse FFT */ public static ArrayList<Complex> inverseFFT(int n, boolean inverse, ArrayList<Complex> x) { if (inverse) { for (int i = 0; i < x.size(); i++) { Complex z = x.get(i); x.set(i, z.divide(n)); } } return x; } /** * This function reverses the bits of a number. It is used in Cooley-Tukey * FFT algorithm. * * <p> * E.g. num = 13 = 00001101 in binary log2n = 8 Then reversed = 176 = * 10110000 in binary * * <p> * More info: https://cp-algorithms.com/algebra/fft.html * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/ * * @param num The integer you want to reverse its bits. * @param log2n The number of bits you want to reverse. * @return The reversed number */ private static int reverseBits(int num, int log2n) { int reversed = 0; for (int i = 0; i < log2n; i++) { if ((num & (1 << i)) != 0) { reversed |= 1 << (log2n - 1 - i); } } return reversed; } /** * This method pads an ArrayList with zeros in order to have a size equal to * the next power of two of the previous size. * * @param x The ArrayList to be padded. */ private static void paddingPowerOfTwo(Collection<Complex> x) { int n = 1; int oldSize = x.size(); while (n < oldSize) { n *= 2; } for (int i = 0; i < n - oldSize; i++) { x.add(new Complex()); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.ConvolutionFFT; import com.thealgorithms.maths.FFT$Complex; import java.util.ArrayList; import java.util.List; public final class FFTBluestein { private FFTBluestein() { } public static void fftBluestein(List list, boolean bl) { int n; double d; int n2; int n3 = list.size(); int n4 = 2 * n3 - 1; int n5 = bl ? -1 : 1; ArrayList<FFT$Complex> arrayList = new ArrayList<FFT$Complex>(); ArrayList<FFT$Complex> arrayList2 = new ArrayList<FFT$Complex>(); for (n2 = 0; n2 < n4; ++n2) { arrayList2.add(new FFT$Complex()); } for (n2 = 0; n2 < n3; ++n2) { d = (double)((n2 - n3 + 1) * (n2 - n3 + 1)) * Math.PI / (double)n3 * (double)n5; arrayList2.set(n2, new FFT$Complex(Math.cos(d), Math.sin(d))); arrayList2.set(n4 - n2 - 1, new FFT$Complex(Math.cos(d), Math.sin(d))); } for (n2 = 0; n2 < n3; ++n2) { d = (double)(-n2 * n2) * Math.PI / (double)n3 * (double)n5; arrayList.add(((FFT$Complex)list.get(n2)).multiply(new FFT$Complex(Math.cos(d), Math.sin(d)))); } ArrayList arrayList3 = ConvolutionFFT.convolutionFFT(arrayList, arrayList2); for (n = 0; n < n3; ++n) { double d2 = (double)(-1 * n * n) * Math.PI / (double)n3 * (double)n5; FFT$Complex fFT$Complex = new FFT$Complex(Math.cos(d2), Math.sin(d2)); list.set(n, fFT$Complex.multiply((FFT$Complex)arrayList3.get(n + n3 - 1))); } if (bl) { for (n = 0; n < n3; ++n) { FFT$Complex fFT$Complex = (FFT$Complex)list.get(n); list.set(n, fFT$Complex.divide(n3)); } } } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; import java.util.List; /** * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal * using the Bluestein's algorithm. * * @author Ioannis Karavitsis * @version 1.0 */ public final class FFTBluestein { private FFTBluestein() { } /** * Bluestein's FFT Algorithm. * * <p> * More info: * https://en.wikipedia.org/wiki/Chirp_Z-transform#Bluestein.27s_algorithm * http://tka4.org/materials/lib/Articles-Books/Numerical%20Algorithms/Hartley_Trasform/Bluestein%27s%20FFT%20algorithm%20-%20Wikipedia,%20the%20free%20encyclopedia.htm * * @param x The discrete signal which is then converted to the FFT or the * IFFT of signal x. * @param inverse True if you want to find the inverse FFT. */ public static void fftBluestein(List<FFT.Complex> x, boolean inverse) { int n = x.size(); int bnSize = 2 * n - 1; int direction = inverse ? -1 : 1; ArrayList<FFT.Complex> an = new ArrayList<>(); ArrayList<FFT.Complex> bn = new ArrayList<>(); /* Initialization of the b(n) sequence (see Wikipedia's article above for the symbols * used)*/ for (int i = 0; i < bnSize; i++) { bn.add(new FFT.Complex()); } for (int i = 0; i < n; i++) { double angle = (i - n + 1) * (i - n + 1) * Math.PI / n * direction; bn.set(i, new FFT.Complex(Math.cos(angle), Math.sin(angle))); bn.set(bnSize - i - 1, new FFT.Complex(Math.cos(angle), Math.sin(angle))); } /* Initialization of the a(n) sequence */ for (int i = 0; i < n; i++) { double angle = -i * i * Math.PI / n * direction; an.add(x.get(i).multiply(new FFT.Complex(Math.cos(angle), Math.sin(angle)))); } ArrayList<FFT.Complex> convolution = ConvolutionFFT.convolutionFFT(an, bn); /* The final multiplication of the convolution with the b*(k) factor */ for (int i = 0; i < n; i++) { double angle = -1 * i * i * Math.PI / n * direction; FFT.Complex bk = new FFT.Complex(Math.cos(angle), Math.sin(angle)); x.set(i, bk.multiply(convolution.get(i + n - 1))); } /* Divide by n if we want the inverse FFT */ if (inverse) { for (int i = 0; i < n; i++) { FFT.Complex z = x.get(i); x.set(i, z.divide(n)); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.FIFOCache; import com.thealgorithms.datastructures.caches.FIFOCache$EvictionStrategy; import com.thealgorithms.datastructures.caches.FIFOCache$ImmediateEvictionStrategy; import java.util.function.BiConsumer; public class FIFOCache$Builder { private final int a; private long b = 0L; private BiConsumer c; private FIFOCache$EvictionStrategy d = new FIFOCache$ImmediateEvictionStrategy(); public FIFOCache$Builder(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Capacity must be > 0\"); } this.a = n; } public FIFOCache$Builder defaultTTL(long l) { if (l < 0L) { throw new IllegalArgumentException(\"Default TTL must be >= 0\"); } this.b = l; return this; } public FIFOCache$Builder evictionListener(BiConsumer biConsumer) { if (biConsumer == null) { throw new IllegalArgumentException(\"Listener must not be null\"); } this.c = biConsumer; return this; } public FIFOCache build() { return new FIFOCache(this); } public FIFOCache$Builder evictionStrategy(FIFOCache$EvictionStrategy fIFOCache$EvictionStrategy) { if (fIFOCache$EvictionStrategy == null) { throw new IllegalArgumentException(\"Eviction strategy must not be null\"); } this.d = fIFOCache$EvictionStrategy; return this; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.FIFOCache; import com.thealgorithms.datastructures.caches.FIFOCache$EvictionStrategy; import com.thealgorithms.datastructures.caches.FIFOCache$ImmediateEvictionStrategy; import java.util.function.BiConsumer; public class FIFOCache$Builder { private final int a; private long b = 0L; private BiConsumer c; private FIFOCache$EvictionStrategy d = new FIFOCache$ImmediateEvictionStrategy(); public FIFOCache$Builder(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Capacity must be > 0\"); } this.a = n; } public FIFOCache$Builder defaultTTL(long l) { if (l < 0L) { throw new IllegalArgumentException(\"Default TTL must be >= 0\"); } this.b = l; return this; } public FIFOCache$Builder evictionListener(BiConsumer biConsumer) { if (biConsumer == null) { throw new IllegalArgumentException(\"Listener must not be null\"); } this.c = biConsumer; return this; } public FIFOCache build() { return new FIFOCache(this); } public FIFOCache$Builder evictionStrategy(FIFOCache$EvictionStrategy fIFOCache$EvictionStrategy) { if (fIFOCache$EvictionStrategy == null) { throw new IllegalArgumentException(\"Eviction strategy must not be null\"); } this.d = fIFOCache$EvictionStrategy; return this; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; class FIFOCache$CacheEntry { Object a; private long b; FIFOCache$CacheEntry(Object object, long l) { this.a = object; if (l == 0L) { this.b = Long.MAX_VALUE; return; } this.b = System.currentTimeMillis() + l; } final boolean a() { return System.currentTimeMillis() > this.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; class FIFOCache$CacheEntry { Object a; private long b; FIFOCache$CacheEntry(Object object, long l) { this.a = object; if (l == 0L) { this.b = Long.MAX_VALUE; return; } this.b = System.currentTimeMillis() + l; } final boolean a() { return System.currentTimeMillis() > this.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.FIFOCache; public interface FIFOCache$EvictionStrategy { public int onAccess(FIFOCache var1); }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.FIFOCache; public interface FIFOCache$EvictionStrategy { public int onAccess(FIFOCache var1); }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.FIFOCache; import com.thealgorithms.datastructures.caches.FIFOCache$EvictionStrategy; public class FIFOCache$ImmediateEvictionStrategy implements FIFOCache$EvictionStrategy { @Override public int onAccess(FIFOCache fIFOCache) { return fIFOCache.a(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.FIFOCache; import com.thealgorithms.datastructures.caches.FIFOCache$EvictionStrategy; public class FIFOCache$ImmediateEvictionStrategy implements FIFOCache$EvictionStrategy { @Override public int onAccess(FIFOCache fIFOCache) { return fIFOCache.a(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.FIFOCache; import com.thealgorithms.datastructures.caches.FIFOCache$EvictionStrategy; import java.util.concurrent.atomic.AtomicInteger; public class FIFOCache$PeriodicEvictionStrategy implements FIFOCache$EvictionStrategy { private final int a; private final AtomicInteger b = new AtomicInteger(); public FIFOCache$PeriodicEvictionStrategy(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Interval must be > 0\"); } this.a = n; } @Override public int onAccess(FIFOCache fIFOCache) { if (this.b.incrementAndGet() % this.a == 0) { return fIFOCache.a(); } return 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.FIFOCache; import com.thealgorithms.datastructures.caches.FIFOCache$EvictionStrategy; import java.util.concurrent.atomic.AtomicInteger; public class FIFOCache$PeriodicEvictionStrategy implements FIFOCache$EvictionStrategy { private final int a; private final AtomicInteger b = new AtomicInteger(); public FIFOCache$PeriodicEvictionStrategy(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Interval must be > 0\"); } this.a = n; } @Override public int onAccess(FIFOCache fIFOCache) { if (this.b.incrementAndGet() % this.a == 0) { return fIFOCache.a(); } return 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.FIFOCache$Builder; import com.thealgorithms.datastructures.caches.FIFOCache$CacheEntry; import com.thealgorithms.datastructures.caches.FIFOCache$EvictionStrategy; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.LinkedHashSet; import java.util.Map; import java.util.Set; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.function.BiConsumer; public final class FIFOCache { private final int a; private final long b; private final Map c; private final Lock d; private long e = 0L; private long f = 0L; private final BiConsumer g; private final FIFOCache$EvictionStrategy h; private FIFOCache(FIFOCache$Builder fIFOCache$Builder) { this.a = fIFOCache$Builder.a; this.b = fIFOCache$Builder.b; this.c = new LinkedHashMap(); this.d = new ReentrantLock(); this.g = fIFOCache$Builder.c; this.h = fIFOCache$Builder.d; } public final Object get(Object object) { if (object == null) { throw new IllegalArgumentException(\"Key must not be null\"); } this.d.lock(); try { this.h.onAccess(this); FIFOCache$CacheEntry fIFOCache$CacheEntry = (FIFOCache$CacheEntry)this.c.get(object); if (fIFOCache$CacheEntry == null || fIFOCache$CacheEntry.a()) { if (fIFOCache$CacheEntry != null) { this.c.remove(object); this.a(object, fIFOCache$CacheEntry.a); } ++this.f; return null; } ++this.e; object = fIFOCache$CacheEntry.a; return object; } finally { this.d.unlock(); } } public final void put(Object object, Object object2) { this.put(object, object2, this.b); } public final void put(Object object, Object object2, long l) { if (object == null || object2 == null) { throw new IllegalArgumentException(\"Key and value must not be null\"); } if (l < 0L) { throw new IllegalArgumentException(\"TTL must be >= 0\"); } this.d.lock(); try { Object object3 = (FIFOCache$CacheEntry)this.c.remove(object); if (object3 != null && !((FIFOCache$CacheEntry)object3).a()) { this.a(object, ((FIFOCache$CacheEntry)object3).a); } this.a(); if (this.c.size() >= this.a && (object3 = this.c.entrySet().iterator()).hasNext()) { Map.Entry entry = (Map.Entry)object3.next(); object3.remove(); this.a(entry.getKey(), ((FIFOCache$CacheEntry)entry.getValue()).a); } this.c.put(object, new FIFOCache$CacheEntry(object2, l)); return; } finally { this.d.unlock(); } } private int a() { int n = 0; Iterator iterator = this.c.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry entry = iterator.next(); if (entry == null || !((FIFOCache$CacheEntry)entry.getValue()).a()) continue; iterator.remove(); this.a(entry.getKey(), ((FIFOCache$CacheEntry)entry.getValue()).a); ++n; } return n; } public final Object removeKey(Object object) { if (object == null) { throw new IllegalArgumentException(\"Key cannot be null\"); } FIFOCache$CacheEntry fIFOCache$CacheEntry = (FIFOCache$CacheEntry)this.c.remove(object); if (fIFOCache$CacheEntry == null) { return null; } this.a(object, fIFOCache$CacheEntry.a); return fIFOCache$CacheEntry.a; } private void a(Object object, Object object2) { if (this.g != null) { try { this.g.accept(object, object2); return; } catch (Exception exception) { System.err.println(\"Eviction listener failed: \" + exception.getMessage()); } } } public final long getHits() { this.d.lock(); try { long l = this.e; return l; } finally { this.d.unlock(); } } public final long getMisses() { this.d.lock(); try { long l = this.f; return l; } finally { this.d.unlock(); } } public final int size() { this.d.lock(); try { this.h.onAccess(this); int n = 0; for (FIFOCache$CacheEntry fIFOCache$CacheEntry : this.c.values()) { if (fIFOCache$CacheEntry.a()) continue; ++n; } int n2 = n; return n2; } finally { this.d.unlock(); } } public final void clear() { this.d.lock(); try { for (Map.Entry entry : this.c.entrySet()) { this.a(entry.getKey(), ((FIFOCache$CacheEntry)entry.getValue()).a); } this.c.clear(); this.e = 0L; this.f = 0L; return; } finally { this.d.unlock(); } } public final Set getAllKeys() { this.d.lock(); try { LinkedHashSet linkedHashSet = new LinkedHashSet(); for (Map.Entry entry : this.c.entrySet()) { if (((FIFOCache$CacheEntry)entry.getValue()).a()) continue; linkedHashSet.add(entry.getKey()); } LinkedHashSet linkedHashSet2 = linkedHashSet; return linkedHashSet2; } finally { this.d.unlock(); } } public final FIFOCache$EvictionStrategy getEvictionStrategy() { return this.h; } public final String toString() { this.d.lock(); try { LinkedHashMap linkedHashMap = new LinkedHashMap(); for (Map.Entry entry : this.c.entrySet()) { if (((FIFOCache$CacheEntry)entry.getValue()).a()) continue; linkedHashMap.put(entry.getKey(), ((FIFOCache$CacheEntry)entry.getValue()).a); } String string = String.format(\"Cache(capacity=%d, size=%d, hits=%d, misses=%d, entries=%s)\", this.a, linkedHashMap.size(), this.e, this.f, linkedHashMap); return string; } finally { this.d.unlock(); } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.caches; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.LinkedHashSet; import java.util.Map; import java.util.Set; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.function.BiConsumer; /** * A thread-safe generic cache implementation using the First-In-First-Out eviction policy. * <p> * The cache holds a fixed number of entries, defined by its capacity. When the cache is full and a * new entry is added, the oldest entry in the cache is selected and evicted to make space. * <p> * Optionally, entries can have a time-to-live (TTL) in milliseconds. If a TTL is set, entries will * automatically expire and be removed upon access or insertion attempts. * <p> * Features: * <ul> * <li>Removes oldest entry when capacity is exceeded</li> * <li>Optional TTL (time-to-live in milliseconds) per entry or default TTL for all entries</li> * <li>Thread-safe access using locking</li> * <li>Hit and miss counters for cache statistics</li> * <li>Eviction listener callback support</li> * </ul> * * @param <K> the type of keys maintained by this cache * @param <V> the type of mapped values * See <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#First_in_first_out_(FIFO)\">FIFO</a> * @author Kevin Babu (<a href=\"https://www.github.com/KevinMwita7\">GitHub</a>) */ public final class FIFOCache<K, V> { private final int capacity; private final long defaultTTL; private final Map<K, CacheEntry<V>> cache; private final Lock lock; private long hits = 0; private long misses = 0; private final BiConsumer<K, V> evictionListener; private final EvictionStrategy<K, V> evictionStrategy; /** * Internal structure to store value + expiry timestamp. * * @param <V> the type of the value being cached */ private static class CacheEntry<V> { V value; long expiryTime; /** * Constructs a new {@code CacheEntry} with the specified value and time-to-live (TTL). * If TTL is 0, the entry is kept indefinitely, that is, unless it is the first value, * then it will be removed according to the FIFO principle * * @param value the value to cache * @param ttlMillis the time-to-live in milliseconds */ CacheEntry(V value, long ttlMillis) { this.value = value; if (ttlMillis == 0) { this.expiryTime = Long.MAX_VALUE; } else { this.expiryTime = System.currentTimeMillis() + ttlMillis; } } /** * Checks if the cache entry has expired. * * @return {@code true} if the current time is past the expiration time; {@code false} otherwise */ boolean isExpired() { return System.currentTimeMillis() > expiryTime; } } /** * Constructs a new {@code FIFOCache} instance using the provided {@link Builder}. * * <p>This constructor initializes the cache with the specified capacity and default TTL, * sets up internal data structures (a {@code LinkedHashMap} for cache entries and configures eviction. * * @param builder the {@code Builder} object containing configuration parameters */ private FIFOCache(Builder<K, V> builder) { this.capacity = builder.capacity; this.defaultTTL = builder.defaultTTL; this.cache = new LinkedHashMap<>(); this.lock = new ReentrantLock(); this.evictionListener = builder.evictionListener; this.evictionStrategy = builder.evictionStrategy; } /** * Retrieves the value associated with the specified key from the cache. * * <p>If the key is not present or the corresponding entry has expired, this method * returns {@code null}. If an expired entry is found, it will be removed and the * eviction listener (if any) will be notified. Cache hit-and-miss statistics are * also updated accordingly. * * @param key the key whose associated value is to be returned; must not be {@code null} * @return the cached value associated with the key, or {@code null} if not present or expired * @throws IllegalArgumentException if {@code key} is {@code null} */ public V get(K key) { if (key == null) { throw new IllegalArgumentException(\"Key must not be null\"); } lock.lock(); try { evictionStrategy.onAccess(this); CacheEntry<V> entry = cache.get(key); if (entry == null || entry.isExpired()) { if (entry != null) { cache.remove(key); notifyEviction(key, entry.value); } misses++; return null; } hits++; return entry.value; } finally { lock.unlock(); } } /** * Adds a key-value pair to the cache using the default time-to-live (TTL). * * <p>The key may overwrite an existing entry. The actual insertion is delegated * to the overloaded {@link #put(K, V, long)} method. * * @param key the key to cache the value under * @param value the value to be cached */ public void put(K key, V value) { put(key, value, defaultTTL); } /** * Adds a key-value pair to the cache with a specified time-to-live (TTL). * * <p>If the key already exists, its value is removed, re-inserted at tail and its TTL is reset. * If the key does not exist and the cache is full, the oldest entry is evicted to make space. * Expired entries are also cleaned up prior to any eviction. The eviction listener * is notified when an entry gets evicted. * * @param key the key to associate with the cached value; must not be {@code null} * @param value the value to be cached; must not be {@code null} * @param ttlMillis the time-to-live for this entry in milliseconds; must be >= 0 * @throws IllegalArgumentException if {@code key} or {@code value} is {@code null}, or if {@code ttlMillis} is negative */ public void put(K key, V value, long ttlMillis) { if (key == null || value == null) { throw new IllegalArgumentException(\"Key and value must not be null\"); } if (ttlMillis < 0) { throw new IllegalArgumentException(\"TTL must be >= 0\"); } lock.lock(); try { // If key already exists, remove it CacheEntry<V> oldEntry = cache.remove(key); if (oldEntry != null && !oldEntry.isExpired()) { notifyEviction(key, oldEntry.value); } // Evict expired entries to make space for new entry evictExpired(); // If no expired entry was removed, remove the oldest if (cache.size() >= capacity) { Iterator<Map.Entry<K, CacheEntry<V>>> it = cache.entrySet().iterator(); if (it.hasNext()) { Map.Entry<K, CacheEntry<V>> eldest = it.next(); it.remove(); notifyEviction(eldest.getKey(), eldest.getValue().value); } } // Insert new entry at tail cache.put(key, new CacheEntry<>(value, ttlMillis)); } finally { lock.unlock(); } } /** * Removes all expired entries from the cache. * * <p>This method iterates through the list of cached keys and checks each associated * entry for expiration. Expired entries are removed the cache map. For each eviction, * the eviction listener is notified. */ private int evictExpired() { int count = 0; Iterator<Map.Entry<K, CacheEntry<V>>> it = cache.entrySet().iterator(); while (it.hasNext()) { Map.Entry<K, CacheEntry<V>> entry = it.next(); if (entry != null && entry.getValue().isExpired()) { it.remove(); notifyEviction(entry.getKey(), entry.getValue().value); count++; } } return count; } /** * Removes the specified key and its associated entry from the cache. * * @param key the key to remove from the cache; * @return the value associated with the key; or {@code null} if no such key exists */ public V removeKey(K key) { if (key == null) { throw new IllegalArgumentException(\"Key cannot be null\"); } CacheEntry<V> entry = cache.remove(key); // No such key in cache if (entry == null) { return null; } notifyEviction(key, entry.value); return entry.value; } /** * Notifies the eviction listener, if one is registered, that a key-value pair has been evicted. * * <p>If the {@code evictionListener} is not {@code null}, it is invoked with the provided key * and value. Any exceptions thrown by the listener are caught and logged to standard error, * preventing them from disrupting cache operations. * * @param key the key that was evicted * @param value the value that was associated with the evicted key */ private void notifyEviction(K key, V value) { if (evictionListener != null) { try { evictionListener.accept(key, value); } catch (Exception e) { System.err.println(\"Eviction listener failed: \" + e.getMessage()); } } } /** * Returns the number of successful cache lookups (hits). * * @return the number of cache hits */ public long getHits() { lock.lock(); try { return hits; } finally { lock.unlock(); } } /** * Returns the number of failed cache lookups (misses), including expired entries. * * @return the number of cache misses */ public long getMisses() { lock.lock(); try { return misses; } finally { lock.unlock(); } } /** * Returns the current number of entries in the cache, excluding expired ones. * * @return the current cache size */ public int size() { lock.lock(); try { evictionStrategy.onAccess(this); int count = 0; for (CacheEntry<V> entry : cache.values()) { if (!entry.isExpired()) { ++count; } } return count; } finally { lock.unlock(); } } /** * Removes all entries from the cache, regardless of their expiration status. * * <p>This method clears the internal cache map entirely, resets the hit-and-miss counters, * and notifies the eviction listener (if any) for each removed entry. * Note that expired entries are treated the same as active ones for the purpose of clearing. * * <p>This operation acquires the internal lock to ensure thread safety. */ public void clear() { lock.lock(); try { for (Map.Entry<K, CacheEntry<V>> entry : cache.entrySet()) { notifyEviction(entry.getKey(), entry.getValue().value); } cache.clear(); hits = 0; misses = 0; } finally { lock.unlock(); } } /** * Returns a set of all keys currently stored in the cache that have not expired. * * <p>This method iterates through the cache and collects the keys of all non-expired entries. * Expired entries are ignored but not removed. If you want to ensure expired entries are cleaned up, * consider invoking {@link EvictionStrategy#onAccess(FIFOCache)} or calling {@link #evictExpired()} manually. * * <p>This operation acquires the internal lock to ensure thread safety. * * @return a set containing all non-expired keys currently in the cache */ public Set<K> getAllKeys() { lock.lock(); try { Set<K> keys = new LinkedHashSet<>(); for (Map.Entry<K, CacheEntry<V>> entry : cache.entrySet()) { if (!entry.getValue().isExpired()) { keys.add(entry.getKey()); } } return keys; } finally { lock.unlock(); } } /** * Returns the current {@link EvictionStrategy} used by this cache instance. * @return the eviction strategy currently assigned to this cache */ public EvictionStrategy<K, V> getEvictionStrategy() { return evictionStrategy; } /** * Returns a string representation of the cache, including metadata and current non-expired entries. * * <p>The returned string includes the cache's capacity, current size (excluding expired entries), * hit-and-miss counts, and a map of all non-expired key-value pairs. This method acquires a lock * to ensure thread-safe access. * * @return a string summarizing the state of the cache */ @Override public String toString() { lock.lock(); try { Map<K, V> visible = new LinkedHashMap<>(); for (Map.Entry<K, CacheEntry<V>> entry : cache.entrySet()) { if (!entry.getValue().isExpired()) { visible.put(entry.getKey(), entry.getValue().value); } } return String.format(\"Cache(capacity=%d, size=%d, hits=%d, misses=%d, entries=%s)\", capacity, visible.size(), hits, misses, visible); } finally { lock.unlock(); } } /** * A strategy interface for controlling when expired entries are evicted from the cache. * * <p>Implementations decide whether and when to trigger {@link FIFOCache#evictExpired()} based * on cache usage patterns. This allows for flexible eviction behaviour such as periodic cleanup, * or no automatic cleanup. * * @param <K> the type of keys maintained by the cache * @param <V> the type of cached values */ public interface EvictionStrategy<K, V> { /** * Called on each cache access (e.g., {@link FIFOCache#get(Object)}) to optionally trigger eviction. * * @param cache the cache instance on which this strategy is applied * @return the number of expired entries evicted during this access */ int onAccess(FIFOCache<K, V> cache); } /** * An eviction strategy that performs eviction of expired entries on each call. * * @param <K> the type of keys * @param <V> the type of values */ public static class ImmediateEvictionStrategy<K, V> implements EvictionStrategy<K, V> { @Override public int onAccess(FIFOCache<K, V> cache) { return cache.evictExpired(); } } /** * An eviction strategy that triggers eviction on every fixed number of accesses. * * <p>This deterministic strategy ensures cleanup occurs at predictable intervals, * ideal for moderately active caches where memory usage is a concern. * * @param <K> the type of keys * @param <V> the type of values */ public static class PeriodicEvictionStrategy<K, V> implements EvictionStrategy<K, V> { private final int interval; private final AtomicInteger counter = new AtomicInteger(); /** * Constructs a periodic eviction strategy. * * @param interval the number of accesses between evictions; must be > 0 * @throws IllegalArgumentException if {@code interval} is less than or equal to 0 */ public PeriodicEvictionStrategy(int interval) { if (interval <= 0) { throw new IllegalArgumentException(\"Interval must be > 0\"); } this.interval = interval; } @Override public int onAccess(FIFOCache<K, V> cache) { if (counter.incrementAndGet() % interval == 0) { return cache.evictExpired(); } return 0; } } /** * A builder for constructing a {@link FIFOCache} instance with customizable settings. * * <p>Allows configuring capacity, default TTL, eviction listener, and a pluggable eviction * strategy. Call {@link #build()} to create the configured cache instance. * * @param <K> the type of keys maintained by the cache * @param <V> the type of values stored in the cache */ public static class Builder<K, V> { private final int capacity; private long defaultTTL = 0; private BiConsumer<K, V> evictionListener; private EvictionStrategy<K, V> evictionStrategy = new FIFOCache.ImmediateEvictionStrategy<>(); /** * Creates a new {@code Builder} with the specified cache capacity. * * @param capacity the maximum number of entries the cache can hold; must be > 0 * @throws IllegalArgumentException if {@code capacity} is less than or equal to 0 */ public Builder(int capacity) { if (capacity <= 0) { throw new IllegalArgumentException(\"Capacity must be > 0\"); } this.capacity = capacity; } /** * Sets the default time-to-live (TTL) in milliseconds for cache entries. * * @param ttlMillis the TTL duration in milliseconds; must be >= 0 * @return this builder instance for chaining * @throws IllegalArgumentException if {@code ttlMillis} is negative */ public Builder<K, V> defaultTTL(long ttlMillis) { if (ttlMillis < 0) { throw new IllegalArgumentException(\"Default TTL must be >= 0\"); } this.defaultTTL = ttlMillis; return this; } /** * Sets an eviction listener to be notified when entries are evicted from the cache. * * @param listener a {@link BiConsumer} that accepts evicted keys and values; must not be {@code null} * @return this builder instance for chaining * @throws IllegalArgumentException if {@code listener} is {@code null} */ public Builder<K, V> evictionListener(BiConsumer<K, V> listener) { if (listener == null) { throw new IllegalArgumentException(\"Listener must not be null\"); } this.evictionListener = listener; return this; } /** * Builds and returns a new {@link FIFOCache} instance with the configured parameters. * * @return a fully configured {@code FIFOCache} instance */ public FIFOCache<K, V> build() { return new FIFOCache<>(this); } /** * Sets the eviction strategy used to determine when to clean up expired entries. * * @param strategy an {@link EvictionStrategy} implementation; must not be {@code null} * @return this builder instance * @throws IllegalArgumentException if {@code strategy} is {@code null} */ public Builder<K, V> evictionStrategy(EvictionStrategy<K, V> strategy) { if (strategy == null) { throw new IllegalArgumentException(\"Eviction strategy must not be null\"); } this.evictionStrategy = strategy; return this; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class Factorial { private Factorial() { } public static long factorial(int n) { if (n < 0) { throw new IllegalArgumentException(\"Input number cannot be negative\"); } long l = 1L; for (int i = 1; i <= n; ++i) { l *= (long)i; } return l; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class Factorial { private Factorial() { } /** * Calculate factorial N using iteration * * @param n the number * @return the factorial of {@code n} */ public static long factorial(int n) { if (n < 0) { throw new IllegalArgumentException(\"Input number cannot be negative\"); } long factorial = 1; for (int i = 1; i <= n; ++i) { factorial *= i; } return factorial; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class FactorialRecursion { private FactorialRecursion() { } public static long factorial(int n) { if (n < 0) { throw new IllegalArgumentException(\"number is negative\"); } if (n == 0 || n == 1) { return 1L; } return (long)n * FactorialRecursion.factorial(n - 1); } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class FactorialRecursion { private FactorialRecursion() { } /** * Recursive FactorialRecursion Method * * @param n The number to factorial * @return The factorial of the number */ public static long factorial(int n) { if (n < 0) { throw new IllegalArgumentException(\"number is negative\"); } return n == 0 || n == 1 ? 1 : n * factorial(n - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class FairShareScheduling$User { String a; int b; int c; FairShareScheduling$User(String string) { this.a = string; this.b = 0; this.c = 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class FairShareScheduling$User { String a; int b; int c; FairShareScheduling$User(String string) { this.a = string; this.b = 0; this.c = 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.FairShareScheduling$User; import java.util.HashMap; import java.util.Map; public final class FairShareScheduling { private final Map a = new HashMap(); public final void addUser(String string) { this.a.putIfAbsent(string, new FairShareScheduling$User(string)); } public final void addTask(String object, int n) { if ((object = (FairShareScheduling$User)this.a.get(object)) != null) { ((FairShareScheduling$User)object).c += n; } } public final void allocateResources(int n) { int n2 = this.a.values().stream().mapToInt(fairShareScheduling$User -> fairShareScheduling$User.c).sum(); for (FairShareScheduling$User fairShareScheduling$User2 : this.a.values()) { ((FairShareScheduling$User)var3_3.next()).b = (int)((double)fairShareScheduling$User2.c / (double)n2 * (double)n); } } public final Map getAllocatedResources() { HashMap<String, Integer> hashMap = new HashMap<String, Integer>(); for (FairShareScheduling$User fairShareScheduling$User : this.a.values()) { hashMap.put(fairShareScheduling$User.a, fairShareScheduling$User.b); } return hashMap; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.HashMap; import java.util.Map; /** * FairShareScheduling allocates CPU resources equally among users or groups * instead of individual tasks. Each group gets a proportional share, * preventing resource hogging by a single user's processes. * * Use Case: Multi-user systems where users submit multiple tasks simultaneously, * such as cloud environments. * * @author Hardvan */ public final class FairShareScheduling { static class User { String name; int allocatedResources; int totalWeight; User(String name) { this.name = name; this.allocatedResources = 0; this.totalWeight = 0; } void addWeight(int weight) { this.totalWeight += weight; } } private final Map<String, User> users; // username -> User public FairShareScheduling() { users = new HashMap<>(); } public void addUser(String userName) { users.putIfAbsent(userName, new User(userName)); } public void addTask(String userName, int weight) { User user = users.get(userName); if (user != null) { user.addWeight(weight); } } public void allocateResources(int totalResources) { int totalWeights = users.values().stream().mapToInt(user -> user.totalWeight).sum(); for (User user : users.values()) { user.allocatedResources = (int) ((double) user.totalWeight / totalWeights * totalResources); } } public Map<String, Integer> getAllocatedResources() { Map<String, Integer> allocation = new HashMap<>(); for (User user : users.values()) { allocation.put(user.name, user.allocatedResources); } return allocation; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class FastExponentiation { private FastExponentiation() { } public static long fastExponentiation(long l, long l2, long l3) { if (l3 <= 0L) { throw new IllegalArgumentException(\"Modulus must be positive.\"); } if (l2 < 0L) { throw new ArithmeticException(\"Negative exponent is not supported.\"); } long l4 = 1L; l %= l3; while (l2 > 0L) { if ((l2 & 1L) == 1L) { l4 = l4 * l % l3; } long l5 = l; l = l5 * l5 % l3; l2 >>= 1; } return l4; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * This class provides a method to perform fast exponentiation (exponentiation by squaring), * which calculates (base^exp) % mod efficiently. * * <p>The algorithm works by repeatedly squaring the base and reducing the exponent * by half at each step. It exploits the fact that: * <ul> * <li>If exp is even, (base^exp) = (base^(exp/2))^2</li> * <li>If exp is odd, (base^exp) = base * (base^(exp-1))</li> * </ul> * The result is computed modulo `mod` at each step to avoid overflow and keep the result within bounds. * </p> * * <p><strong>Time complexity:</strong> O(log(exp))  much faster than naive exponentiation (O(exp)).</p> * * For more information, please visit {@link https://en.wikipedia.org/wiki/Exponentiation_by_squaring} */ public final class FastExponentiation { /** * Private constructor to hide the implicit public one. */ private FastExponentiation() { } /** * Performs fast exponentiation to calculate (base^exp) % mod using the method * of exponentiation by squaring. * * <p>This method efficiently computes the result by squaring the base and halving * the exponent at each step. It multiplies the base to the result when the exponent is odd. * * @param base the base number to be raised to the power of exp * @param exp the exponent to which the base is raised * @param mod the modulus to ensure the result does not overflow * @return (base^exp) % mod * @throws IllegalArgumentException if the modulus is less than or equal to 0 * @throws ArithmeticException if the exponent is negative (not supported in this implementation) */ public static long fastExponentiation(long base, long exp, long mod) { if (mod <= 0) { throw new IllegalArgumentException(\"Modulus must be positive.\"); } if (exp < 0) { throw new ArithmeticException(\"Negative exponent is not supported.\"); } long result = 1; base = base % mod; // Take the modulus of the base to handle large base values // Fast exponentiation by squaring algorithm while (exp > 0) { // If exp is odd, multiply the base to the result if ((exp & 1) == 1) { // exp & 1 checks if exp is odd result = result * base % mod; } // Square the base and halve the exponent base = base * base % mod; // base^2 % mod to avoid overflow exp >>= 1; // Right shift exp to divide it by 2 } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class FastInverseSqrt { private FastInverseSqrt() { } public static boolean inverseSqrt(float f) { float f2 = f; float f3 = 0.5f * f2; int n = Float.floatToIntBits(f2); n = 1597463007 - (n >> 1); float f4 = Float.intBitsToFloat(n); return (f4 *= 1.5f - f3 * f4 * f4) == 1.0f / (float)Math.sqrt(f); } public static boolean inverseSqrt(double d) { double d2 = d; double d3 = d2 * 0.5; long l = Double.doubleToLongBits(d2); l = 6910470738111508698L - (l >> 1); d2 = Double.longBitsToDouble(l); for (int i = 0; i < 4; ++i) { d2 *= 1.5 - d3 * d2 * d2; } return (d2 *= d) == 1.0 / Math.sqrt(d); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * @author <a href=\"https://github.com/siddhant2002\">Siddhant Swarup Mallick</a> * Program description - To find out the inverse square root of the given number * <a href=\"https://en.wikipedia.org/wiki/Fast_inverse_square_root\">Wikipedia</a> */ public final class FastInverseSqrt { private FastInverseSqrt() { } /** * Returns the inverse square root of the given number upto 6 - 8 decimal places. * calculates the inverse square root of the given number and returns true if calculated answer * matches with given answer else returns false * * OUTPUT : * Input - number = 4522 * Output: it calculates the inverse squareroot of a number and returns true with it matches the * given answer else returns false. 1st approach Time Complexity : O(1) Auxiliary Space Complexity : * O(1) Input - number = 4522 Output: it calculates the inverse squareroot of a number and returns * true with it matches the given answer else returns false. 2nd approach Time Complexity : O(1) * Auxiliary Space Complexity : O(1) */ public static boolean inverseSqrt(float number) { float x = number; float xhalf = 0.5f * x; int i = Float.floatToIntBits(x); i = 0x5f3759df - (i >> 1); x = Float.intBitsToFloat(i); x = x * (1.5f - xhalf * x * x); return x == ((float) 1 / (float) Math.sqrt(number)); } /** * Returns the inverse square root of the given number upto 14 - 16 decimal places. * calculates the inverse square root of the given number and returns true if calculated answer * matches with given answer else returns false */ public static boolean inverseSqrt(double number) { double x = number; double xhalf = 0.5d * x; long i = Double.doubleToLongBits(x); i = 0x5fe6ec85e7de30daL - (i >> 1); x = Double.longBitsToDouble(i); for (int it = 0; it < 4; it++) { x = x * (1.5d - xhalf * x * x); } x *= number; return x == 1 / Math.sqrt(number); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; public class FenwickTree { private int a; private int[] b; public FenwickTree(int n) { this.a = n; this.b = new int[n + 1]; } public void update(int n, int n2) { ++n; while (n <= this.a) { int n3 = n; this.b[n3] = this.b[n3] + n2; int n4 = n; n = n4 + (n4 & -n); } } public int query(int n) { ++n; int n2 = 0; while (n > 0) { n2 += this.b[n]; int n3 = n; n = n3 - (n3 & -n); } return n2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; public class FenwickTree { private int n; private int[] fenTree; /* Constructor which takes the size of the array as a parameter */ public FenwickTree(int n) { this.n = n; this.fenTree = new int[n + 1]; } /* A function which will add the element val at index i*/ public void update(int i, int val) { // As index starts from 0, increment the index by 1 i += 1; while (i <= n) { fenTree[i] += val; i += i & (-i); } } /* A function which will return the cumulative sum from index 1 to index i*/ public int query(int i) { // As index starts from 0, increment the index by 1 i += 1; int cumSum = 0; while (i > 0) { cumSum += fenTree[i]; i -= i & (-i); } return cumSum; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix.matrixexponentiation; import com.thealgorithms.matrix.utils.MatrixUtil; import java.math.BigDecimal; public final class Fibonacci { private static final BigDecimal a = BigDecimal.valueOf(1L); private static final BigDecimal b = BigDecimal.valueOf(0L); private static final BigDecimal[][] c = new BigDecimal[][]{{a, a}, {a, b}}; private static final BigDecimal[][] d = new BigDecimal[][]{{a, b}, {b, a}}; private Fibonacci() { } public static BigDecimal[][] fib(int n) { if (n == 0) { return d; } BigDecimal[][] bigDecimalArray = Fibonacci.fib(n / 2); bigDecimalArray = (BigDecimal[][])MatrixUtil.multiply(bigDecimalArray, bigDecimalArray).get(); if (n % 2 == 0) { return bigDecimalArray; } return (BigDecimal[][])MatrixUtil.multiply(c, bigDecimalArray).get(); } }", "deobfuscated_code": "package com.thealgorithms.matrix.matrixexponentiation; import com.thealgorithms.matrix.utils.MatrixUtil; import java.math.BigDecimal; /** * @author Anirudh Buvanesh (https://github.com/anirudhb11) For more information * see https://www.geeksforgeeks.org/matrix-exponentiation/ * */ public final class Fibonacci { private Fibonacci() { } // Exponentiation matrix for Fibonacci sequence private static final BigDecimal ONE = BigDecimal.valueOf(1); private static final BigDecimal ZERO = BigDecimal.valueOf(0); private static final BigDecimal[][] FIB_MATRIX = {{ONE, ONE}, {ONE, ZERO}}; private static final BigDecimal[][] IDENTITY_MATRIX = {{ONE, ZERO}, {ZERO, ONE}}; /** * Calculates the fibonacci number using matrix exponentiaition technique * * @param n The input n for which we have to determine the fibonacci number * Outputs the nth * fibonacci number * @return a 2 X 1 array as { {F_n+1}, {F_n} } */ public static BigDecimal[][] fib(int n) { if (n == 0) { return IDENTITY_MATRIX; } else { BigDecimal[][] cachedResult = fib(n / 2); BigDecimal[][] matrixExpResult = MatrixUtil.multiply(cachedResult, cachedResult).get(); if (n % 2 == 0) { return matrixExpResult; } else { return MatrixUtil.multiply(FIB_MATRIX, matrixExpResult).get(); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import com.thealgorithms.datastructures.heaps.FibonacciHeap; public class FibonacciHeap$HeapNode { public int key; private int a; private boolean b; private FibonacciHeap$HeapNode c; private FibonacciHeap$HeapNode d; private FibonacciHeap$HeapNode e; private FibonacciHeap$HeapNode f; public FibonacciHeap$HeapNode(FibonacciHeap fibonacciHeap, int n) { this.key = n; this.b = false; this.d = this; this.e = this; } public int getKey() { return this.key; } private boolean a() { return this.b; } private void b() { if (this.d()) { return; } this.b = true; } private void a(FibonacciHeap$HeapNode fibonacciHeap$HeapNode) { FibonacciHeap$HeapNode fibonacciHeap$HeapNode2 = this.d; this.d = fibonacciHeap$HeapNode; this.d.e.d = fibonacciHeap$HeapNode2; fibonacciHeap$HeapNode2.e = fibonacciHeap$HeapNode.e; this.d.e = this; } private FibonacciHeap$HeapNode c() { return this.d; } private boolean d() { return this.f == null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import com.thealgorithms.datastructures.heaps.FibonacciHeap; public class FibonacciHeap$HeapNode { public int key; private int a; private boolean b; private FibonacciHeap$HeapNode c; private FibonacciHeap$HeapNode d; private FibonacciHeap$HeapNode e; private FibonacciHeap$HeapNode f; public FibonacciHeap$HeapNode(FibonacciHeap fibonacciHeap, int n) { this.key = n; this.b = false; this.d = this; this.e = this; } public int getKey() { return this.key; } private boolean a() { return this.b; } private void b() { if (this.d()) { return; } this.b = true; } private void a(FibonacciHeap$HeapNode fibonacciHeap$HeapNode) { FibonacciHeap$HeapNode fibonacciHeap$HeapNode2 = this.d; this.d = fibonacciHeap$HeapNode; this.d.e.d = fibonacciHeap$HeapNode2; fibonacciHeap$HeapNode2.e = fibonacciHeap$HeapNode.e; this.d.e = this; } private FibonacciHeap$HeapNode c() { return this.d; } private boolean d() { return this.f == null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import com.thealgorithms.datastructures.heaps.FibonacciHeap$HeapNode; public class FibonacciHeap { private static final double a = (1.0 + Math.sqrt(5.0)) / 2.0; private FibonacciHeap$HeapNode b; private static int c = 0; private static int d = 0; private int e = 0; private int f = 0; private int g = 0; public FibonacciHeap() { this.b = null; } public FibonacciHeap(int n) { this.b = new FibonacciHeap$HeapNode(this, n); ++this.e; ++this.f; } public boolean empty() { return this.b == null; } public FibonacciHeap$HeapNode insert(int n) { FibonacciHeap$HeapNode fibonacciHeap$HeapNode = new FibonacciHeap$HeapNode(this, n); if (this.empty()) { this.b = fibonacciHeap$HeapNode; } else { this.b.a(fibonacciHeap$HeapNode); this.a(fibonacciHeap$HeapNode); } ++this.f; ++this.e; return fibonacciHeap$HeapNode; } public void deleteMin() { Object object; Object object2; if (this.empty()) { return; } if (this.f == 1) { this.b = null; --this.e; --this.f; return; } if (this.b.c != null) { object2 = this.b.c; object = this.b.c; ((FibonacciHeap$HeapNode)object2).f = null; while (((FibonacciHeap$HeapNode)object2).d != object) { object2 = ((FibonacciHeap$HeapNode)object2).d; ((FibonacciHeap$HeapNode)object2).d.f = null; } } if (this.e > 1) { this.b.e.d = this.b.d; this.b.d.e = this.b.e; if (this.b.c != null) { this.b.e.a(this.b.c); } } else { this.b = this.b.c; } --this.f; FibonacciHeap fibonacciHeap = this; object = fibonacciHeap.b.c(); object2 = fibonacciHeap; FibonacciHeap$HeapNode[] fibonacciHeap$HeapNodeArray = object; object = fibonacciHeap; Object object3 = new FibonacciHeap$HeapNode[(int)Math.floor(Math.log(fibonacciHeap.size()) / Math.log(a)) + 1]; fibonacciHeap$HeapNodeArray.e.d = null; while (fibonacciHeap$HeapNodeArray != null) { Object object4 = fibonacciHeap$HeapNodeArray; fibonacciHeap$HeapNodeArray = fibonacciHeap$HeapNodeArray.d; ((FibonacciHeap$HeapNode)object4).d = object4; ((FibonacciHeap$HeapNode)object4).e = object4; while (object3[((FibonacciHeap$HeapNode)object4).a] != null) { FibonacciHeap$HeapNode[] fibonacciHeap$HeapNodeArray2 = object4; object4 = object3[((FibonacciHeap$HeapNode)object4).a]; object = fibonacciHeap$HeapNodeArray2; if (fibonacciHeap$HeapNodeArray2.getKey() > ((FibonacciHeap$HeapNode)object4).getKey()) { Object object5 = object; object = object4; object4 = object5; } if (object.c == null) { object.c = object4; } else { object.c.a((FibonacciHeap$HeapNode)object4); } ((FibonacciHeap$HeapNode)object4).f = object; ++object.a; ++c; object4 = object; object3[((FibonacciHeap$HeapNode)object4).a - 1] = null; } object3[((FibonacciHeap$HeapNode)object4).a] = object4; } fibonacciHeap$HeapNodeArray = object = object3; object = object2; object3 = null; object.e = 0; for (int i = 0; i < fibonacciHeap$HeapNodeArray.length; ++i) { if (fibonacciHeap$HeapNodeArray[i] == null) continue; ++object.e; if (object3 == null) { fibonacciHeap$HeapNodeArray[i].d = object3 = fibonacciHeap$HeapNodeArray[i]; ((FibonacciHeap$HeapNode)object3).e = object3; continue; } ((FibonacciHeap$HeapNode)object3).a(fibonacciHeap$HeapNodeArray[i]); if (fibonacciHeap$HeapNodeArray[i].getKey() >= ((FibonacciHeap$HeapNode)object3).getKey()) continue; object3 = fibonacciHeap$HeapNodeArray[i]; } ((FibonacciHeap)object2).b = object3; } public FibonacciHeap$HeapNode findMin() { return this.b; } public void meld(FibonacciHeap fibonacciHeap) { if (fibonacciHeap.empty()) { return; } if (this.empty()) { this.b = fibonacciHeap.b; } else { this.b.a(fibonacciHeap.b); this.a(fibonacciHeap.b); } this.e += fibonacciHeap.e; this.f += fibonacciHeap.f; } public int size() { return this.f; } public int[] countersRep() { if (this.empty()) { return new int[0]; } int[] nArray = new int[(int)Math.floor(Math.log(this.size()) / Math.log(a)) + 1]; int[] nArray2 = nArray; int n = this.b.a; nArray[n] = nArray[n] + 1; FibonacciHeap$HeapNode fibonacciHeap$HeapNode = this.b.d; while (fibonacciHeap$HeapNode != this.b) { int n2 = fibonacciHeap$HeapNode.a; nArray2[n2] = nArray2[n2] + 1; fibonacciHeap$HeapNode = fibonacciHeap$HeapNode.d; } return nArray2; } public void delete(FibonacciHeap$HeapNode object) { FibonacciHeap$HeapNode fibonacciHeap$HeapNode = object; int n = fibonacciHeap$HeapNode.getKey() + 1; FibonacciHeap$HeapNode fibonacciHeap$HeapNode2 = fibonacciHeap$HeapNode; object = this; fibonacciHeap$HeapNode2.key = n = fibonacciHeap$HeapNode2.getKey() - n; if (fibonacciHeap$HeapNode2.d()) { ((FibonacciHeap)object).a(fibonacciHeap$HeapNode2); } else if (fibonacciHeap$HeapNode2.getKey() < fibonacciHeap$HeapNode2.f.getKey()) { FibonacciHeap$HeapNode fibonacciHeap$HeapNode3 = fibonacciHeap$HeapNode2.f; ((FibonacciHeap)object).c(fibonacciHeap$HeapNode2); ((FibonacciHeap)object).b(fibonacciHeap$HeapNode3); } this.deleteMin(); } public int potential() { return this.e + 2 * this.g; } public static int totalLinks() { return c; } public static int totalCuts() { return d; } private void a(FibonacciHeap$HeapNode fibonacciHeap$HeapNode) { if (fibonacciHeap$HeapNode.getKey() < this.b.getKey()) { this.b = fibonacciHeap$HeapNode; } } private void b(FibonacciHeap$HeapNode fibonacciHeap$HeapNode) { while (true) { if (!fibonacciHeap$HeapNode.a()) { fibonacciHeap$HeapNode.b(); if (fibonacciHeap$HeapNode.d()) break; ++this.g; return; } if (fibonacciHeap$HeapNode.d()) { return; } FibonacciHeap$HeapNode fibonacciHeap$HeapNode2 = fibonacciHeap$HeapNode.f; this.c(fibonacciHeap$HeapNode); fibonacciHeap$HeapNode = fibonacciHeap$HeapNode2; } } private void c(FibonacciHeap$HeapNode fibonacciHeap$HeapNode) { --fibonacciHeap$HeapNode.f.a; if (fibonacciHeap$HeapNode.b) { --this.g; fibonacciHeap$HeapNode.b = false; } if (fibonacciHeap$HeapNode.f.c == fibonacciHeap$HeapNode) { fibonacciHeap$HeapNode.f.c = fibonacciHeap$HeapNode.d == fibonacciHeap$HeapNode ? null : fibonacciHeap$HeapNode.d; } fibonacciHeap$HeapNode.e.d = fibonacciHeap$HeapNode.d; fibonacciHeap$HeapNode.d.e = fibonacciHeap$HeapNode.e; fibonacciHeap$HeapNode.d = fibonacciHeap$HeapNode; fibonacciHeap$HeapNode.e = fibonacciHeap$HeapNode; fibonacciHeap$HeapNode.f = null; this.b.a(fibonacciHeap$HeapNode); this.a(fibonacciHeap$HeapNode); ++this.e; ++d; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; /** * The {@code FibonacciHeap} class implements a Fibonacci Heap data structure, * which is a collection of trees that satisfy the minimum heap property. * This heap allows for efficient merging of heaps, as well as faster * decrease-key and delete operations compared to other heap data structures. * * <p>Key features of the Fibonacci Heap include: * <ul> * <li>Amortized O(1) time complexity for insert and decrease-key operations.</li> * <li>Amortized O(log n) time complexity for delete and delete-min operations.</li> * <li>Meld operation that combines two heaps in O(1) time.</li> * <li>Potential function that helps analyze the amortized time complexity.</li> * </ul> * * <p>This implementation maintains additional statistics such as the total number * of link and cut operations performed during the lifetime of the heap, which can * be accessed through static methods. * * <p>The Fibonacci Heap is composed of nodes represented by the inner class * {@code HeapNode}. Each node maintains a key, rank, marked status, and pointers * to its children and siblings. Nodes can be linked and cut as part of the heap * restructuring processes. * * @see HeapNode */ public class FibonacciHeap { private static final double GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2; private HeapNode min; private static int totalLinks = 0; private static int totalCuts = 0; private int numOfTrees = 0; private int numOfHeapNodes = 0; private int markedHeapNodesCounter = 0; /* * a constructor for an empty Heap * set the min to be null */ public FibonacciHeap() { this.min = null; } /* * a constructor for a Heap with one element * set the min to be the HeapNode with the given key * @pre key>=0 * @post empty == false */ public FibonacciHeap(int key) { this.min = new HeapNode(key); this.numOfTrees++; this.numOfHeapNodes++; } /* * check if the heap is empty * $ret == true - if the tree is empty */ public boolean empty() { return (this.min == null); } /** * Creates a node (of type HeapNode) which contains the given key, and inserts it into the heap. * * @pre key>=0 * @post (numOfnodes = = $prev numOfnodes + 1) * @post empty == false * $ret = the HeapNode we inserted */ public HeapNode insert(int key) { HeapNode toInsert = new HeapNode(key); // creates the node if (this.empty()) { this.min = toInsert; } else { // tree is not empty min.setNext(toInsert); this.updateMin(toInsert); } this.numOfHeapNodes++; this.numOfTrees++; return toInsert; } /** * Delete the node containing the minimum key in the heap * updates new min * * @post (numOfnodes = = $prev numOfnodes - 1) */ public void deleteMin() { if (this.empty()) { return; } if (this.numOfHeapNodes == 1) { // if there is only one tree this.min = null; this.numOfTrees--; this.numOfHeapNodes--; return; } // change all children's parent to null// if (this.min.child != null) { // min has a child HeapNode child = this.min.child; HeapNode tmpChild = child; child.parent = null; while (child.next != tmpChild) { child = child.next; child.parent = null; } } // delete the node// if (this.numOfTrees > 1) { (this.min.prev).next = this.min.next; (this.min.next).prev = this.min.prev; if (this.min.child != null) { (this.min.prev).setNext(this.min.child); } } else { // this.numOfTrees = 1 this.min = this.min.child; } this.numOfHeapNodes--; this.successiveLink(this.min.getNext()); } /** * Return the node of the heap whose key is minimal. * $ret == null if (empty==true) */ public HeapNode findMin() { return this.min; } /** * Meld the heap with heap2 * * @pre heap2 != null * @post (numOfnodes = = $prev numOfnodes + heap2.numOfnodes) */ public void meld(FibonacciHeap heap2) { if (heap2.empty()) { return; } if (this.empty()) { this.min = heap2.min; } else { this.min.setNext(heap2.min); this.updateMin(heap2.min); } this.numOfTrees += heap2.numOfTrees; this.numOfHeapNodes += heap2.numOfHeapNodes; } /** * Return the number of elements in the heap * $ret == 0 if heap is empty */ public int size() { return this.numOfHeapNodes; } /** * Return a counters array, where the value of the i-th index is the number of trees with rank i * in the heap. returns an empty array for an empty heap */ public int[] countersRep() { if (this.empty()) { return new int[0]; /// return an empty array } int[] rankArray = new int[(int) Math.floor(Math.log(this.size()) / Math.log(GOLDEN_RATIO)) + 1]; // creates the array rankArray[this.min.rank]++; HeapNode curr = this.min.next; while (curr != this.min) { rankArray[curr.rank]++; curr = curr.next; } return rankArray; } /** * Deletes the node x from the heap (using decreaseKey(x) to -1) * * @pre heap contains x * @post (numOfnodes = = $prev numOfnodes - 1) */ public void delete(HeapNode x) { this.decreaseKey(x, x.getKey() + 1); // change key to be the minimal (-1) this.deleteMin(); // delete it } /** * The function decreases the key of the node x by delta. * * @pre x.key >= delta (we don't realize it when calling from delete()) * @pre heap contains x */ private void decreaseKey(HeapNode x, int delta) { int newKey = x.getKey() - delta; x.key = newKey; if (x.isRoot()) { // no parent to x this.updateMin(x); return; } if (x.getKey() >= x.parent.getKey()) { return; } // we don't need to cut HeapNode prevParent = x.parent; this.cut(x); this.cascadingCuts(prevParent); } /** * returns the current potential of the heap, which is: * Potential = #trees + 2*#markedNodes */ public int potential() { return numOfTrees + (2 * markedHeapNodesCounter); } /** * This static function returns the total number of link operations made during the run-time of * the program. A link operation is the operation which gets as input two trees of the same * rank, and generates a tree of rank bigger by one. */ public static int totalLinks() { return totalLinks; } /** * This static function returns the total number of cut operations made during the run-time of * the program. A cut operation is the operation which disconnects a subtree from its parent * (during decreaseKey/delete methods). */ public static int totalCuts() { return totalCuts; } /* * updates the min of the heap (if needed) * @pre this.min == @param (posMin) if and only if (posMin.key < this.min.key) */ private void updateMin(HeapNode posMin) { if (posMin.getKey() < this.min.getKey()) { this.min = posMin; } } /* * Recursively \"runs\" all the way up from @param (curr) and mark the nodes. * stop the recursion if we had arrived to a marked node or to a root. * if we arrived to a marked node, we cut it and continue recursively. * called after a node was cut. * @post (numOfnodes == $prev numOfnodes) */ private void cascadingCuts(HeapNode curr) { if (!curr.isMarked()) { // stop the recursion curr.mark(); if (!curr.isRoot()) { this.markedHeapNodesCounter++; } } else { if (curr.isRoot()) { return; } HeapNode prevParent = curr.parent; this.cut(curr); this.cascadingCuts(prevParent); } } /* * cut a node (and his \"subtree\") from his origin tree and connect it to the heap as a new tree. * called after a node was cut. * @post (numOfnodes == $prev numOfnodes) */ private void cut(HeapNode curr) { curr.parent.rank--; if (curr.marked) { this.markedHeapNodesCounter--; curr.marked = false; } if (curr.parent.child == curr) { // we should change the parent's child if (curr.next == curr) { // curr do not have brothers curr.parent.child = null; } else { // curr have brothers curr.parent.child = curr.next; } } curr.prev.next = curr.next; curr.next.prev = curr.prev; curr.next = curr; curr.prev = curr; curr.parent = null; this.min.setNext(curr); this.updateMin(curr); this.numOfTrees++; totalCuts++; } /* * */ private void successiveLink(HeapNode curr) { HeapNode[] buckets = this.toBuckets(curr); this.min = this.fromBuckets(buckets); } /* * */ private HeapNode[] toBuckets(HeapNode curr) { HeapNode[] buckets = new HeapNode[(int) Math.floor(Math.log(this.size()) / Math.log(GOLDEN_RATIO)) + 1]; curr.prev.next = null; HeapNode tmpCurr; while (curr != null) { tmpCurr = curr; curr = curr.next; tmpCurr.next = tmpCurr; tmpCurr.prev = tmpCurr; while (buckets[tmpCurr.rank] != null) { tmpCurr = this.link(tmpCurr, buckets[tmpCurr.rank]); buckets[tmpCurr.rank - 1] = null; } buckets[tmpCurr.rank] = tmpCurr; } return buckets; } /* * */ private HeapNode fromBuckets(HeapNode[] buckets) { HeapNode tmpMin = null; this.numOfTrees = 0; for (int i = 0; i < buckets.length; i++) { if (buckets[i] != null) { this.numOfTrees++; if (tmpMin == null) { tmpMin = buckets[i]; tmpMin.next = tmpMin; tmpMin.prev = tmpMin; } else { tmpMin.setNext(buckets[i]); if (buckets[i].getKey() < tmpMin.getKey()) { tmpMin = buckets[i]; } } } } return tmpMin; } /* * link between two nodes (and their trees) * defines the smaller node to be the parent */ private HeapNode link(HeapNode c1, HeapNode c2) { if (c1.getKey() > c2.getKey()) { HeapNode c3 = c1; c1 = c2; c2 = c3; } if (c1.child == null) { c1.child = c2; } else { c1.child.setNext(c2); } c2.parent = c1; c1.rank++; totalLinks++; return c1; } /** * public class HeapNode * each HeapNode belongs to a heap (Inner class) */ public class HeapNode { public int key; private int rank; private boolean marked; private HeapNode child; private HeapNode next; private HeapNode prev; private HeapNode parent; /* * a constructor for a heapNode withe key @param (key) * prev == next == this * parent == child == null */ public HeapNode(int key) { this.key = key; this.marked = false; this.next = this; this.prev = this; } /* * returns the key of the node. */ public int getKey() { return this.key; } /* * checks whether the node is marked * $ret = true if one child has been cut */ private boolean isMarked() { return this.marked; } /* * mark a node (after a child was cut) * @inv root.mark() == false. */ private void mark() { if (this.isRoot()) { return; } // check if the node is a root this.marked = true; } /* * add the node @param (newNext) to be between this and this.next * works fine also if @param (newNext) does not \"stands\" alone */ private void setNext(HeapNode newNext) { HeapNode tmpNext = this.next; this.next = newNext; this.next.prev.next = tmpNext; tmpNext.prev = newNext.prev; this.next.prev = this; } /* * returns the next node to this node */ private HeapNode getNext() { return this.next; } /* * check if the node is a root * root definition - this.parent == null (uppest in his tree) */ private boolean isRoot() { return (this.parent == null); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.math.BigDecimal; import java.util.List; import java.util.Optional; import java.util.stream.Stream; public final class FibonacciJavaStreams { private FibonacciJavaStreams() { } public static Optional calculate(BigDecimal object) { if (object == null || ((BigDecimal)object).compareTo(BigDecimal.ZERO) < 0) { throw new IllegalArgumentException(\"Input index cannot be null or negative!\"); } if (((BigDecimal)object).compareTo(BigDecimal.ONE) < 0) { return Optional.of(BigDecimal.ZERO); } if (((BigDecimal)object).compareTo(BigDecimal.TWO) < 0) { return Optional.of(BigDecimal.ONE); } if ((object = Stream.iterate(object, bigDecimal -> bigDecimal.compareTo(BigDecimal.ZERO) > 0, bigDecimal -> bigDecimal.subtract(BigDecimal.ONE)).reduce(List.of(), (list, bigDecimal) -> { if (list.isEmpty() || list.size() < 2) { return List.of(BigDecimal.ZERO, BigDecimal.ONE); } return List.of((BigDecimal)list.get(1), ((BigDecimal)list.get(0)).add((BigDecimal)list.get(1))); }, (list, list2) -> list)).isEmpty()) { return Optional.empty(); } Object object2 = object; return Optional.of((BigDecimal)object2.get(object2.size() - 1)); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.math.BigDecimal; import java.util.List; import java.util.Optional; import java.util.stream.Stream; /** * @author: caos321 * @date: 14 October 2021 (Thursday) */ public final class FibonacciJavaStreams { private FibonacciJavaStreams() { } public static Optional<BigDecimal> calculate(final BigDecimal index) { if (index == null || index.compareTo(BigDecimal.ZERO) < 0) { throw new IllegalArgumentException(\"Input index cannot be null or negative!\"); } if (index.compareTo(BigDecimal.ONE) < 0) { return Optional.of(BigDecimal.ZERO); } if (index.compareTo(BigDecimal.TWO) < 0) { return Optional.of(BigDecimal.ONE); } final List<BigDecimal> results = Stream.iterate(index, x -> x.compareTo(BigDecimal.ZERO) > 0, x -> x.subtract(BigDecimal.ONE)) .reduce(List.of(), (list, current) -> list.isEmpty() || list.size() < 2 ? List.of(BigDecimal.ZERO, BigDecimal.ONE) : List.of(list.get(1), list.get(0).add(list.get(1))), (list1, list2) -> list1); return results.isEmpty() ? Optional.empty() : Optional.of(results.get(results.size() - 1)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.math.BigInteger; public final class FibonacciLoop { private FibonacciLoop() { } public static BigInteger compute(int n) { if (n < 0) { throw new IllegalArgumentException(\"Input 'n' must be a non-negative integer.\"); } if (n <= 1) { return BigInteger.valueOf(n); } BigInteger bigInteger = BigInteger.ZERO; BigInteger bigInteger2 = BigInteger.ONE; for (int i = 2; i <= n; ++i) { BigInteger bigInteger3 = bigInteger.add(bigInteger2); bigInteger = bigInteger2; bigInteger2 = bigInteger3; } return bigInteger2; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.math.BigInteger; /** * This class provides methods for calculating Fibonacci numbers using BigInteger for large values of 'n'. */ public final class FibonacciLoop { private FibonacciLoop() { // Private constructor to prevent instantiation of this utility class. } /** * Calculates the nth Fibonacci number. * * @param n The index of the Fibonacci number to calculate. * @return The nth Fibonacci number as a BigInteger. * @throws IllegalArgumentException if the input 'n' is a negative integer. */ public static BigInteger compute(final int n) { if (n < 0) { throw new IllegalArgumentException(\"Input 'n' must be a non-negative integer.\"); } if (n <= 1) { return BigInteger.valueOf(n); } BigInteger prev = BigInteger.ZERO; BigInteger current = BigInteger.ONE; for (int i = 2; i <= n; i++) { BigInteger next = prev.add(current); prev = current; current = next; } return current; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class FibonacciNumberCheck { private FibonacciNumberCheck() { } public static boolean isPerfectSquare(long l) { long l2 = (long)Math.sqrt(l); return l2 * l2 == l; } public static boolean isFibonacciNumber(long l) { long l2 = 5L * l * l + 4L; long l3 = 5L * l * l - 4L; return FibonacciNumberCheck.isPerfectSquare(l2) || FibonacciNumberCheck.isPerfectSquare(l3); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Fibonacci: 0 1 1 2 3 5 8 13 21 ... * This code checks Fibonacci Numbers up to 45th number. * Other checks fail because of 'long'-type overflow. */ public final class FibonacciNumberCheck { private FibonacciNumberCheck() { } /** * Check if a number is perfect square number * * @param number the number to be checked * @return <tt>true</tt> if {@code number} is a perfect square, otherwise * <tt>false</tt> */ public static boolean isPerfectSquare(long number) { long sqrt = (long) Math.sqrt(number); return sqrt * sqrt == number; } /** * Check if a number is a Fibonacci number. This is true if and only if at * least one of 5x^2+4 or 5x^2-4 is a perfect square * * @param number the number * @return <tt>true</tt> if {@code number} is a Fibonacci number, otherwise * <tt>false</tt> * @link https://en.wikipedia.org/wiki/Fibonacci_number#Identification */ public static boolean isFibonacciNumber(long number) { long value1 = 5 * number * number + 4; long value2 = 5 * number * number - 4; return isPerfectSquare(value1) || isPerfectSquare(value2); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class FibonacciNumberGoldenRation { public static final int MAX_ARG = 70; private FibonacciNumberGoldenRation() { } public static long compute(int n) { if (n < 0) { throw new IllegalArgumentException(\"Input 'n' must be a non-negative integer.\"); } if (n > 70) { throw new IllegalArgumentException(\"Input 'n' is too big to give accurate result.\"); } if (n <= 1) { return n; } double d = Math.sqrt(5.0); double d2 = (d + 1.0) / 2.0; double d3 = (1.0 - d) / 2.0; double d4 = (Math.pow(d2, n) - Math.pow(d3, n)) / d; return Math.round(d4); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * This class provides methods for calculating Fibonacci numbers using Binet's formula. * Binet's formula is based on the golden ratio and allows computing Fibonacci numbers efficiently. * * @see <a href=\"https://en.wikipedia.org/wiki/Fibonacci_sequence#Binet's_formula\">Binet's formula on Wikipedia</a> */ public final class FibonacciNumberGoldenRation { private FibonacciNumberGoldenRation() { // Private constructor to prevent instantiation of this utility class. } /** * Compute the limit for 'n' that fits in a long data type. * Reducing the limit to 70 due to potential floating-point arithmetic errors * that may result in incorrect results for larger inputs. */ public static final int MAX_ARG = 70; /** * Calculates the nth Fibonacci number using Binet's formula. * * @param n The index of the Fibonacci number to calculate. * @return The nth Fibonacci number as a long. * @throws IllegalArgumentException if the input 'n' is negative or exceeds the range of a long data type. */ public static long compute(int n) { if (n < 0) { throw new IllegalArgumentException(\"Input 'n' must be a non-negative integer.\"); } if (n > MAX_ARG) { throw new IllegalArgumentException(\"Input 'n' is too big to give accurate result.\"); } if (n <= 1) { return n; } // Calculate the nth Fibonacci number using the golden ratio formula final double sqrt5 = Math.sqrt(5); final double phi = (1 + sqrt5) / 2; final double psi = (1 - sqrt5) / 2; final double result = (Math.pow(phi, n) - Math.pow(psi, n)) / sqrt5; // Round to the nearest integer and return as a long return Math.round(result); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; public class FibonacciSearch implements SearchAlgorithm { @Override public int find(Comparable[] comparableArray, Comparable comparable) { boolean bl; int n; block9: { if (comparableArray.length == 0) { throw new IllegalArgumentException(\"Input array must not be empty.\"); } Comparable[] comparableArray2 = comparableArray; for (n = 1; n < comparableArray2.length; ++n) { if (comparableArray2[n - 1].compareTo(comparableArray2[n]) <= 0) continue; bl = false; break block9; } bl = true; } if (!bl) { throw new IllegalArgumentException(\"Input array must be sorted.\"); } if (comparable == null) { throw new IllegalArgumentException(\"Key must not be null.\"); } int n2 = 1; n = 0; int n3 = 1; int n4 = comparableArray.length; while (n3 < n4) { n = n2; n2 = n3; n3 = n + n2; } int n5 = -1; while (n3 > 1) { int n6 = Math.min(n5 + n, n4 - 1); if (comparableArray[n6].compareTo(comparable) < 0) { n3 = n2; n2 = n; n = n3 - n2; n5 = n6; continue; } if (comparableArray[n6].compareTo(comparable) > 0) { n3 = n; n = n3 - (n2 -= n); continue; } return n6; } if (n2 == 1 && comparableArray[n5 + 1] == comparable) { return n5 + 1; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; /** * FibonacciSearch is a search algorithm that finds the position of a target value in * a sorted array using Fibonacci numbers. * * <p> * The time complexity for this search algorithm is O(log n). * The space complexity for this search algorithm is O(1). * </p> * * <p> * Note: This algorithm requires that the input array be sorted. * </p> */ @SuppressWarnings({\"rawtypes\", \"unchecked\"}) public class FibonacciSearch implements SearchAlgorithm { /** * Finds the index of the specified key in a sorted array using Fibonacci search. * * @param array The sorted array to search. * @param key The element to search for. * @param <T> The type of the elements in the array, which must be comparable. * @throws IllegalArgumentException if the input array is not sorted or empty, or if the key is null. * @return The index of the key if found, otherwise -1. */ @Override public <T extends Comparable<T>> int find(T[] array, T key) { if (array.length == 0) { throw new IllegalArgumentException(\"Input array must not be empty.\"); } if (!isSorted(array)) { throw new IllegalArgumentException(\"Input array must be sorted.\"); } if (key == null) { throw new IllegalArgumentException(\"Key must not be null.\"); } int fibMinus1 = 1; int fibMinus2 = 0; int fibNumber = fibMinus1 + fibMinus2; int n = array.length; while (fibNumber < n) { fibMinus2 = fibMinus1; fibMinus1 = fibNumber; fibNumber = fibMinus2 + fibMinus1; } int offset = -1; while (fibNumber > 1) { int i = Math.min(offset + fibMinus2, n - 1); if (array[i].compareTo(key) < 0) { fibNumber = fibMinus1; fibMinus1 = fibMinus2; fibMinus2 = fibNumber - fibMinus1; offset = i; } else if (array[i].compareTo(key) > 0) { fibNumber = fibMinus2; fibMinus1 = fibMinus1 - fibMinus2; fibMinus2 = fibNumber - fibMinus1; } else { return i; } } if (fibMinus1 == 1 && array[offset + 1] == key) { return offset + 1; } return -1; } private boolean isSorted(Comparable[] array) { for (int i = 1; i < array.length; i++) { if (array[i - 1].compareTo(array[i]) > 0) { return false; } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.recursion; public final class FibonacciSeries { private FibonacciSeries() { throw new UnsupportedOperationException(\"Utility class\"); } public static int fibonacci(int n) { if (n <= 1) { return n; } return FibonacciSeries.fibonacci(n - 1) + FibonacciSeries.fibonacci(n - 2); } }", "deobfuscated_code": "package com.thealgorithms.recursion; /* The Fibonacci series is a sequence of numbers where each number is the sum of the two preceding ones, starting with 0 and 1. NUMBER 0 1 2 3 4 5 6 7 8 9 10 ... FIBONACCI 0 1 1 2 3 5 8 13 21 34 55 ... */ public final class FibonacciSeries { private FibonacciSeries() { throw new UnsupportedOperationException(\"Utility class\"); } public static int fibonacci(int n) { if (n <= 1) { return n; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.Collections; import java.util.PriorityQueue; import java.util.Random; public final class FindKthNumber { private static final Random a = new Random(); private FindKthNumber() { } public static int findKthMax(int[] nArray, int n) { if (n <= 0 || n > nArray.length) { throw new IllegalArgumentException(\"k must be between 1 and the size of the array\"); } return FindKthNumber.a(nArray, 0, nArray.length - 1, nArray.length - n); } private static int a(int[] nArray, int n, int n2, int n3) { while (n != n2) { int n4 = n + a.nextInt(n2 - n + 1); if (n3 == (n4 = FindKthNumber.b(nArray, n, n2, n4))) { return nArray[n3]; } if (n3 < n4) { n2 = n4 - 1; continue; } n = n4 + 1; } return nArray[n]; } private static int b(int[] nArray, int n, int n2, int n3) { int n4 = nArray[n3]; FindKthNumber.a(nArray, n3, n2); n3 = n; while (n < n2) { if (nArray[n] < n4) { FindKthNumber.a(nArray, n3, n); ++n3; } ++n; } FindKthNumber.a(nArray, n3, n2); return n3; } private static void a(int[] nArray, int n, int n2) { int n3 = nArray[n]; nArray[n] = nArray[n2]; nArray[n2] = n3; } public static int findKthMaxUsingHeap(int[] nArray, int n) { if (n <= 0 || n > nArray.length) { throw new IllegalArgumentException(\"k must be between 1 and the size of the array\"); } PriorityQueue priorityQueue = new PriorityQueue(Collections.reverseOrder()); for (int n2 : nArray) { priorityQueue.add(n2); } while (n > 1) { priorityQueue.poll(); --n; } return (Integer)priorityQueue.peek(); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.Collections; import java.util.PriorityQueue; import java.util.Random; /** * Use a quicksort-based approach to identify the k-th largest or k-th max element within the provided array. */ public final class FindKthNumber { private FindKthNumber() { } private static final Random RANDOM = new Random(); public static int findKthMax(int[] array, int k) { if (k <= 0 || k > array.length) { throw new IllegalArgumentException(\"k must be between 1 and the size of the array\"); } // Convert k-th largest to index for QuickSelect return quickSelect(array, 0, array.length - 1, array.length - k); } private static int quickSelect(int[] array, int left, int right, int kSmallest) { if (left == right) { return array[left]; } // Randomly select a pivot index int pivotIndex = left + RANDOM.nextInt(right - left + 1); pivotIndex = partition(array, left, right, pivotIndex); if (kSmallest == pivotIndex) { return array[kSmallest]; } else if (kSmallest < pivotIndex) { return quickSelect(array, left, pivotIndex - 1, kSmallest); } else { return quickSelect(array, pivotIndex + 1, right, kSmallest); } } private static int partition(int[] array, int left, int right, int pivotIndex) { int pivotValue = array[pivotIndex]; // Move pivot to end swap(array, pivotIndex, right); int storeIndex = left; // Move all smaller elements to the left for (int i = left; i < right; i++) { if (array[i] < pivotValue) { swap(array, storeIndex, i); storeIndex++; } } // Move pivot to its final place swap(array, storeIndex, right); return storeIndex; } private static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } public static int findKthMaxUsingHeap(int[] array, int k) { if (k <= 0 || k > array.length) { throw new IllegalArgumentException(\"k must be between 1 and the size of the array\"); } PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // using max-heap to store numbers. for (int num : array) { maxHeap.add(num); } while (k > 1) { maxHeap.poll(); // removing max number from heap k--; } return maxHeap.peek(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class FindMax { private FindMax() { } public static int findMax(int[] nArray) { int n = nArray.length; if (n == 0) { throw new IllegalArgumentException(\"Array must be non-empty.\"); } int n2 = nArray[0]; for (int i = 1; i < n; ++i) { if (nArray[i] <= n2) continue; n2 = nArray[i]; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class FindMax { private FindMax() { } /** * @brief finds the maximum value stored in the input array * * @param array the input array * @exception IllegalArgumentException input array is empty * @return the maximum value stored in the input array */ public static int findMax(final int[] array) { int n = array.length; if (n == 0) { throw new IllegalArgumentException(\"Array must be non-empty.\"); } int max = array[0]; for (int i = 1; i < n; i++) { if (array[i] > max) { max = array[i]; } } return max; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class FindMaxRecursion { private FindMaxRecursion() { } public static int max(int[] nArray, int n, int n2) { if (nArray.length == 0) { throw new IllegalArgumentException(\"Array must be non-empty.\"); } if (n == n2) { return nArray[n]; } int n3 = n + n2 >>> 1; n = FindMaxRecursion.max(nArray, n, n3); int n4 = FindMaxRecursion.max(nArray, n3 + 1, n2); return Math.max(n, n4); } public static int max(int[] nArray) { return FindMaxRecursion.max(nArray, 0, nArray.length - 1); } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class FindMaxRecursion { private FindMaxRecursion() { } /** * Get max of an array using divide and conquer algorithm * * @param array contains elements * @param low the index of the first element * @param high the index of the last element * @return max of {@code array} */ public static int max(final int[] array, final int low, final int high) { if (array.length == 0) { throw new IllegalArgumentException(\"Array must be non-empty.\"); } if (low == high) { return array[low]; // or array[high] } int mid = (low + high) >>> 1; int leftMax = max(array, low, mid); // get max in [low, mid] int rightMax = max(array, mid + 1, high); // get max in [mid+1, high] return Math.max(leftMax, rightMax); } /** * Get max of an array using recursion algorithm * * @param array contains elements * @return max value of {@code array} */ public static int max(final int[] array) { return max(array, 0, array.length - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class FindMin { private FindMin() { } public static int findMin(int[] nArray) { if (nArray.length == 0) { throw new IllegalArgumentException(\"Array must be non-empty.\"); } int n = nArray[0]; for (int i = 1; i < nArray.length; ++i) { if (nArray[i] >= n) continue; n = nArray[i]; } return n; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class FindMin { private FindMin() { } /** * @brief finds the minimum value stored in the input array * * @param array the input array * @exception IllegalArgumentException input array is empty * @return the mimum value stored in the input array */ public static int findMin(final int[] array) { if (array.length == 0) { throw new IllegalArgumentException(\"Array must be non-empty.\"); } int min = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] < min) { min = array[i]; } } return min; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class FindMinRecursion { private FindMinRecursion() { } public static int min(int[] nArray, int n, int n2) { if (nArray.length == 0) { throw new IllegalArgumentException(\"array must be non-empty.\"); } if (n == n2) { return nArray[n]; } int n3 = n + n2 >>> 1; n = FindMinRecursion.min(nArray, n, n3); int n4 = FindMinRecursion.min(nArray, n3 + 1, n2); return Math.min(n, n4); } public static int min(int[] nArray) { return FindMinRecursion.min(nArray, 0, nArray.length - 1); } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class FindMinRecursion { private FindMinRecursion() { } /** * Get min of an array using divide and conquer algorithm * * @param array contains elements * @param low the index of the first element * @param high the index of the last element * @return min of {@code array} */ public static int min(final int[] array, final int low, final int high) { if (array.length == 0) { throw new IllegalArgumentException(\"array must be non-empty.\"); } if (low == high) { return array[low]; // or array[high] } int mid = (low + high) >>> 1; int leftMin = min(array, low, mid); // get min in [low, mid] int rightMin = min(array, mid + 1, high); // get min in [mid+1, high] return Math.min(leftMin, rightMin); } /** * Get min of an array using recursion algorithm * * @param array contains elements * @return min value of {@code array} */ public static int min(final int[] array) { return min(array, 0, array.length - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class FindNthBit { private FindNthBit() { throw new UnsupportedOperationException(\"Utility class\"); } public static int findNthBit(int n, int n2) { if (n2 <= 0) { throw new IllegalArgumentException(\"Bit position must be greater than or equal to 1.\"); } return (n & 1 << n2 - 1) >> n2 - 1; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * A utility class to find the Nth bit of a given number. * * <p>This class provides a method to extract the value of the Nth bit (either 0 or 1) * from the binary representation of a given integer. * * <p>Example: * <pre>{@code * int result = FindNthBit.findNthBit(5, 2); // returns 0 as the 2nd bit of 5 (binary 101) is 0. * }</pre> * * <p>Author: <a href=\"https://github.com/Tuhinm2002\">Tuhinm2002</a> */ public final class FindNthBit { /** * Private constructor to prevent instantiation. * * <p>This is a utility class, and it should not be instantiated. * Attempting to instantiate this class will throw an UnsupportedOperationException. */ private FindNthBit() { throw new UnsupportedOperationException(\"Utility class\"); } /** * Finds the value of the Nth bit of the given number. * * <p>This method uses bitwise operations to extract the Nth bit from the * binary representation of the given integer. * * @param num the integer number whose Nth bit is to be found * @param n the bit position (1-based) to retrieve * @return the value of the Nth bit (0 or 1) * @throws IllegalArgumentException if the bit position is less than 1 */ public static int findNthBit(int num, int n) { if (n < 1) { throw new IllegalArgumentException(\"Bit position must be greater than or equal to 1.\"); } // Shifting the number to the right by (n - 1) positions and checking the last bit return (num & (1 << (n - 1))) >> (n - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class FirstDifferentBit { private FirstDifferentBit() { } public static int firstDifferentBit(int n, int n2) { return Integer.numberOfTrailingZeros(n ^= n2); } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class provides a method to find the first differing bit * between two integers. * * Example: * x = 10 (1010 in binary) * y = 12 (1100 in binary) * The first differing bit is at index 1 (0-based) * So, the output will be 1 * * @author Hardvan */ public final class FirstDifferentBit { private FirstDifferentBit() { } /** * Identifies the index of the first differing bit between two integers. * Steps: * 1. XOR the two integers to get the differing bits * 2. Find the index of the first set bit in XOR result * * @param x the first integer * @param y the second integer * @return the index of the first differing bit (0-based) */ public static int firstDifferentBit(int x, int y) { int diff = x ^ y; return Integer.numberOfTrailingZeros(diff); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.MemoryManagementAlgorithms; import java.util.ArrayList; class FirstFitCPU extends MemoryManagementAlgorithms { FirstFitCPU() { } @Override public ArrayList fitProcess(int[] nArray, int[] nArray2) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); int n = nArray2.length; for (int i = 0; i < n; ++i) { int n2; int n3; block2: { int n4 = n3 = nArray2[i]; int[] nArray3 = nArray; for (int j = 0; j < nArray3.length; ++j) { if (nArray3[j] < n4) continue; n2 = j; break block2; } n2 = -255; } int n5 = n2; arrayList.add(n5); if (n5 == -255) continue; int n6 = n5; nArray[n6] = nArray[n6] - n3; } return arrayList; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.MemoryManagementAlgorithms; import java.util.ArrayList; class FirstFitCPU extends MemoryManagementAlgorithms { FirstFitCPU() { } @Override public ArrayList fitProcess(int[] nArray, int[] nArray2) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); int n = nArray2.length; for (int i = 0; i < n; ++i) { int n2; int n3; block2: { int n4 = n3 = nArray2[i]; int[] nArray3 = nArray; for (int j = 0; j < nArray3.length; ++j) { if (nArray3[j] < n4) continue; n2 = j; break block2; } n2 = -255; } int n5 = n2; arrayList.add(n5); if (n5 == -255) continue; int n6 = n5; nArray[n6] = nArray[n6] - n3; } return arrayList; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; public class FlashSort implements SortAlgorithm { private double a = 0.45; public FlashSort() { } public FlashSort(double d) { if (d <= 0.0 || d >= 1.0) { throw new IllegalArgumentException(\"Classification ratio must be between 0 and 1 (exclusive).\"); } this.a = d; } public double getClassificationRatio() { return this.a; } public void setClassificationRatio(double d) { if (d <= 0.0 || d >= 1.0) { throw new IllegalArgumentException(\"Classification ratio must be between 0 and 1 (exclusive).\"); } this.a = d; } @Override public Comparable[] sort(Comparable[] comparableArray) { Comparable[] comparableArray2 = comparableArray; FlashSort flashSort = this; if (comparableArray2.length != 0) { int n; Comparable[] comparableArray3 = comparableArray2; Comparable comparable = comparableArray2[0]; for (n = 1; n < comparableArray3.length; ++n) { if (comparableArray3[n].compareTo(comparable) >= 0) continue; comparable = comparableArray3[n]; } Comparable comparable2 = comparable; comparableArray3 = comparableArray2; int n2 = 0; for (n = 1; n < comparableArray3.length; ++n) { if (comparableArray3[n].compareTo(comparableArray3[n2]) <= 0) continue; n2 = n; } int n3 = n2; if (comparableArray2[n3].compareTo(comparable2) != 0) { int n4; int n5 = (int)(flashSort.a * (double)comparableArray2.length); int[] nArray = new int[n5]; double d = (double)(n5 - 1) / (double)comparableArray2[n3].compareTo(comparable2); Comparable comparable3 = comparable2; double d2 = d; int[] nArray2 = nArray; Object[] objectArray = comparableArray2; for (n4 = 0; n4 < objectArray.length; ++n4) { int n6; int n7 = n6 = (int)(d2 * (double)objectArray[n4].compareTo(comparable3)); nArray2[n7] = nArray2[n7] + 1; } objectArray = nArray; for (int i = 1; i < objectArray.length; ++i) { int n8 = i; objectArray[n8] = objectArray[n8] + objectArray[i - 1]; } n4 = n5; n5 = comparableArray2.length; comparable3 = comparable2; double d3 = d; nArray2 = nArray; objectArray = comparableArray2; int n9 = 0; int n10 = 0; int n11 = n4 - 1; while (n9 < n5 - 1) { while (n10 > nArray2[n11] - 1) { n11 = (int)(d3 * (double)objectArray[++n10].compareTo(comparable3)); } Comparable comparable4 = objectArray[n10]; while (n10 != nArray2[n11]) { n11 = (int)(d3 * (double)comparable4.compareTo(comparable3)); Comparable comparable5 = objectArray[nArray2[n11] - 1]; objectArray[nArray2[n11] - 1] = comparable4; comparable4 = comparable5; int n12 = n11; nArray2[n12] = nArray2[n12] - 1; ++n9; } } objectArray = comparableArray2; int n13 = comparableArray2.length; for (n = 1; n < n13; ++n) { comparable3 = objectArray[n]; for (n5 = n - 1; n5 >= 0 && objectArray[n5].compareTo(comparable3) > 0; --n5) { objectArray[n5 + 1] = objectArray[n5]; } objectArray[n5 + 1] = comparable3; } } } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * Implementation of Flash Sort algorithm that implements the SortAlgorithm interface. * * Sorts an array using the Flash Sort algorithm. * <p> * Flash Sort is a distribution sorting algorithm that partitions the data into * different classes based on a classification array. It performs the sorting by * first distributing the data elements into different buckets (or classes) and * then permuting these buckets into the sorted order. * <p> * The method works as follows: * <ol> * <li>Finds the minimum and maximum values in the array.</li> * <li>Initializes a classification array `L` to keep track of the number of elements in each class.</li> * <li>Computes a normalization constant `c1` to map elements into classes.</li> * <li>Classifies each element of the array into the corresponding bucket in the classification array.</li> * <li>Transforms the classification array to compute the starting indices of each bucket.</li> * <li>Permutes the elements of the array into sorted order based on the classification.</li> * <li>Uses insertion sort for the final arrangement to ensure complete sorting.</li> * </ol> */ public class FlashSort implements SortAlgorithm { private double classificationRatio = 0.45; public FlashSort() { } public FlashSort(double classificationRatio) { if (classificationRatio <= 0 || classificationRatio >= 1) { throw new IllegalArgumentException(\"Classification ratio must be between 0 and 1 (exclusive).\"); } this.classificationRatio = classificationRatio; } public double getClassificationRatio() { return classificationRatio; } public void setClassificationRatio(double classificationRatio) { if (classificationRatio <= 0 || classificationRatio >= 1) { throw new IllegalArgumentException(\"Classification ratio must be between 0 and 1 (exclusive).\"); } this.classificationRatio = classificationRatio; } /** * Sorts an array using the Flash Sort algorithm. * * @param array the array to be sorted. * @param <T> the type of elements to be sorted, must be comparable. * @return the sorted array. */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { flashSort(array); return array; } /** * Sorts an array using the Flash Sort algorithm. * * @param arr the array to be sorted. * @param <T> the type of elements to be sorted, must be comparable. */ private <T extends Comparable<? super T>> void flashSort(T[] arr) { if (arr.length == 0) { return; } final T min = findMin(arr); final int maxIndex = findMaxIndex(arr); if (arr[maxIndex].compareTo(min) == 0) { return; // All elements are the same } final int m = (int) (classificationRatio * arr.length); final int[] classificationArray = new int[m]; final double c1 = (double) (m - 1) / arr[maxIndex].compareTo(min); classify(arr, classificationArray, c1, min); transform(classificationArray); permute(arr, classificationArray, c1, min, arr.length, m); insertionSort(arr); } /** * Finds the minimum value in the array. * * @param arr the array to find the minimum value in. * @param <T> the type of elements in the array, must be comparable. * @return the minimum value in the array. */ private <T extends Comparable<? super T>> T findMin(final T[] arr) { T min = arr[0]; for (int i = 1; i < arr.length; i++) { if (arr[i].compareTo(min) < 0) { min = arr[i]; } } return min; } /** * Finds the index of the maximum value in the array. * * @param arr the array to find the maximum value index in. * @param <T> the type of elements in the array, must be comparable. * @return the index of the maximum value in the array. */ private <T extends Comparable<? super T>> int findMaxIndex(final T[] arr) { int maxIndex = 0; for (int i = 1; i < arr.length; i++) { if (arr[i].compareTo(arr[maxIndex]) > 0) { maxIndex = i; } } return maxIndex; } /** * Classifies elements of the array into the classification array classificationArray. * * @param arr the array to be classified. * @param classificationArray the classification array holding the count of elements in each class. * @param c1 the normalization constant used to map the elements to the classification array. * @param min the minimum value in the array. * @param <T> the type of elements in the array, must be comparable. */ private <T extends Comparable<? super T>> void classify(final T[] arr, final int[] classificationArray, final double c1, final T min) { for (int i = 0; i < arr.length; i++) { int k = (int) (c1 * arr[i].compareTo(min)); classificationArray[k]++; } } /** * Transforms the classification array classificationArray into the starting index array. * * @param classificationArray the classification array holding the count of elements in each class. */ private void transform(final int[] classificationArray) { for (int i = 1; i < classificationArray.length; i++) { classificationArray[i] += classificationArray[i - 1]; } } /** * Permutes the array into sorted order based on the classification array classificationArray. * * @param arr the array to be permuted. * @param classificationArray the classification array holding the count of elements in each class. * @param c1 the normalization constant used to map the elements to the classification array. * @param min the minimum value in the array. * @param n the length of the array. * @param m the number of classes in the classification array. * @param <T> the type of elements in the array, must be comparable. */ private <T extends Comparable<? super T>> void permute(final T[] arr, final int[] classificationArray, final double c1, T min, int n, int m) { int move = 0; int j = 0; int k = m - 1; T flash; while (move < n - 1) { while (j > classificationArray[k] - 1) { j++; k = (int) (c1 * arr[j].compareTo(min)); } flash = arr[j]; while (j != classificationArray[k]) { k = (int) (c1 * flash.compareTo(min)); T temp = arr[classificationArray[k] - 1]; arr[classificationArray[k] - 1] = flash; flash = temp; classificationArray[k]--; move++; } } } /** * Sorts an array using the insertion sort algorithm. * * @param arr the array to be sorted. * @param <T> the type of elements to be sorted, must be comparable. */ private <T extends Comparable<? super T>> void insertionSort(final T[] arr) { int n = arr.length; for (int i = 1; i < n; i++) { T key = arr[i]; int j = i - 1; while (j >= 0 && arr[j].compareTo(key) > 0) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; public final class FloodFill { private FloodFill() { } public static int getPixel(int[][] nArray, int n, int n2) { return nArray[n][n2]; } public static void putPixel(int[][] nArray, int n, int n2, int n3) { nArray[n][n2] = n3; } public static void floodFill(int[][] nArray, int n, int n2, int n3, int n4) { while (n3 != n4 && n >= 0 && n < nArray.length && n2 >= 0 && n2 < nArray[n].length && FloodFill.getPixel(nArray, n, n2) == n4) { FloodFill.putPixel(nArray, n, n2, n3); FloodFill.floodFill(nArray, n + 1, n2, n3, n4); FloodFill.floodFill(nArray, n - 1, n2, n3, n4); FloodFill.floodFill(nArray, n, n2 + 1, n3, n4); FloodFill.floodFill(nArray, n, n2 - 1, n3, n4); FloodFill.floodFill(nArray, n + 1, n2 - 1, n3, n4); FloodFill.floodFill(nArray, n - 1, n2 + 1, n3, n4); FloodFill.floodFill(nArray, n + 1, n2 + 1, n3, n4); --n2; --n; } return; } }", "deobfuscated_code": "package com.thealgorithms.backtracking; /** * Java program for Flood fill algorithm. * @author Akshay Dubey (<a href=\"https://github.com/itsAkshayDubey\">Git-Akshay Dubey</a>) */ public final class FloodFill { private FloodFill() { } /** * Get the color at the given coordinates of a 2D image * * @param image The image to be filled * @param x The x co-ordinate of which color is to be obtained * @param y The y co-ordinate of which color is to be obtained */ public static int getPixel(final int[][] image, final int x, final int y) { return image[x][y]; } /** * Put the color at the given coordinates of a 2D image * * @param image The image to be filled * @param x The x co-ordinate at which color is to be filled * @param y The y co-ordinate at which color is to be filled */ public static void putPixel(final int[][] image, final int x, final int y, final int newColor) { image[x][y] = newColor; } /** * Fill the 2D image with new color * * @param image The image to be filled * @param x The x co-ordinate at which color is to be filled * @param y The y co-ordinate at which color is to be filled * @param newColor The new color which to be filled in the image * @param oldColor The old color which is to be replaced in the image */ public static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) { if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) { return; } putPixel(image, x, y, newColor); /* Recursively check for horizontally & vertically adjacent coordinates */ floodFill(image, x + 1, y, newColor, oldColor); floodFill(image, x - 1, y, newColor, oldColor); floodFill(image, x, y + 1, newColor, oldColor); floodFill(image, x, y - 1, newColor, oldColor); /* Recursively check for diagonally adjacent coordinates */ floodFill(image, x + 1, y - 1, newColor, oldColor); floodFill(image, x - 1, y + 1, newColor, oldColor); floodFill(image, x + 1, y + 1, newColor, oldColor); floodFill(image, x - 1, y - 1, newColor, oldColor); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class Floor { private Floor() { } public static double floor(double d) { double d2 = d; if (d2 - (double)((int)d2) == 0.0) { return d; } double d3 = d; if (d3 - (double)((int)d3) > 0.0) { return (int)d; } return (int)d - 1; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class Floor { private Floor() { } /** * Returns the largest (closest to positive infinity) * * @param number the number * @return the largest (closest to positive infinity) of given * {@code number} */ public static double floor(double number) { if (number - (int) number == 0) { return number; } else if (number - (int) number > 0) { return (int) number; } else { return (int) number - 1; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.ArrayList; import java.util.List; final class FloydTriangle { private FloydTriangle() { } public static List generateFloydTriangle(int n) { ArrayList arrayList = new ArrayList(); int n2 = 1; for (int i = 0; i < n; ++i) { ArrayList<Integer> arrayList2 = new ArrayList<Integer>(); for (int j = 0; j <= i; ++j) { arrayList2.add(n2++); } arrayList.add(arrayList2); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.ArrayList; import java.util.List; final class FloydTriangle { private FloydTriangle() { } /** * Generates a Floyd Triangle with the specified number of rows. * * @param rows The number of rows in the triangle. * @return A List representing the Floyd Triangle. */ public static List<List<Integer>> generateFloydTriangle(int rows) { List<List<Integer>> triangle = new ArrayList<>(); int number = 1; for (int i = 0; i < rows; i++) { List<Integer> row = new ArrayList<>(); for (int j = 0; j <= i; j++) { row.add(number++); } triangle.add(row); } return triangle; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; public class FloydWarshall { private int[][] a; private int b; public static final int INFINITY = 999; public FloydWarshall(int n) { this.a = new int[n + 1][n + 1]; this.b = n; } public void floydwarshall(int[][] object) { int n; int n2; for (n2 = 1; n2 <= this.b; ++n2) { System.arraycopy(object[n2], 1, this.a[n2], 1, this.b); } for (n2 = 1; n2 <= this.b; ++n2) { for (int i = 1; i <= this.b; ++i) { for (n = 1; n <= this.b; ++n) { if (this.a[i][n2] + this.a[n2][n] >= this.a[i][n]) continue; int[] nArray = this.a[i]; nArray[n] = nArray[n2] + this.a[n2][n]; } } } object = this; for (n2 = 1; n2 <= object.b; ++n2) { System.out.print(\"\\t\" + n2); } System.out.println(); for (n2 = 1; n2 <= object.b; ++n2) { System.out.print(n2 + \"\\t\"); for (n = 1; n <= object.b; ++n) { System.out.print(object.a[n2][n] + \"\\t\"); } System.out.println(); } } public Object[] getDistanceMatrix() { return this.a; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; /** * The {@code FloydWarshall} class provides an implementation of the Floyd-Warshall algorithm * to compute the shortest paths between all pairs of vertices in a weighted graph. * It handles both positive and negative edge weights but does not support negative cycles. * The algorithm is based on dynamic programming and runs in O(V^3) time complexity, * where V is the number of vertices in the graph. * * <p> * The distance matrix is updated iteratively to find the shortest distance between any two vertices * by considering each vertex as an intermediate step. * </p> * * Reference: <a href=\"https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\">Floyd-Warshall Algorithm</a> */ public class FloydWarshall { private int[][] distanceMatrix; private int numberofvertices; public static final int INFINITY = 999; /** * Constructs a Floyd-Warshall instance for a graph with the given number of vertices. * Initializes the distance matrix for the graph. * * @param numberofvertices The number of vertices in the graph. */ public FloydWarshall(int numberofvertices) { distanceMatrix = new int[numberofvertices + 1][numberofvertices + 1]; // The matrix is initialized with 0's by default this.numberofvertices = numberofvertices; } /** * Executes the Floyd-Warshall algorithm to compute the shortest path between all pairs of vertices. * It uses an adjacency matrix to calculate the distance matrix by considering each vertex as an intermediate point. * * @param adjacencyMatrix The weighted adjacency matrix representing the graph. * A value of 0 means no direct edge between the vertices, except for diagonal elements which are 0 (distance to self). */ public void floydwarshall(int[][] adjacencyMatrix) { // Initialize the distance matrix with the adjacency matrix. for (int source = 1; source <= numberofvertices; source++) { System.arraycopy(adjacencyMatrix[source], 1, distanceMatrix[source], 1, numberofvertices); } for (int intermediate = 1; intermediate <= numberofvertices; intermediate++) { for (int source = 1; source <= numberofvertices; source++) { for (int destination = 1; destination <= numberofvertices; destination++) { // Update distance if a shorter path through the intermediate vertex exists. if (distanceMatrix[source][intermediate] + distanceMatrix[intermediate][destination] < distanceMatrix[source][destination]) { distanceMatrix[source][destination] = distanceMatrix[source][intermediate] + distanceMatrix[intermediate][destination]; } } } } printDistanceMatrix(); } /** * Prints the distance matrix representing the shortest paths between all pairs of vertices. * The rows and columns correspond to the source and destination vertices. */ private void printDistanceMatrix() { // Print header for vertices for (int source = 1; source <= numberofvertices; source++) { System.out.print(\"\\t\" + source); } System.out.println(); // Print the distance matrix for (int source = 1; source <= numberofvertices; source++) { System.out.print(source + \"\\t\"); for (int destination = 1; destination <= numberofvertices; destination++) { System.out.print(distanceMatrix[source][destination] + \"\\t\"); } System.out.println(); } } public Object[] getDistanceMatrix() { return distanceMatrix; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.LinkedList; public final class FordFulkerson { private FordFulkerson() { } public static int networkFlow(int n, int[][] nArray, int[][] nArray2, int n2, int n3) { int n4 = 0; while (true) { int n5; int n6; int[] nArray3 = new int[n]; boolean[] blArray = new boolean[n]; LinkedList<Integer> linkedList = new LinkedList<Integer>(); linkedList.add(n2); blArray[n2] = true; nArray3[n2] = -1; while (!linkedList.isEmpty() && !blArray[n3]) { n6 = (Integer)linkedList.poll(); for (n5 = 0; n5 < n; ++n5) { if (blArray[n5] || nArray[n6][n5] - nArray2[n6][n5] <= 0) continue; linkedList.add(n5); blArray[n5] = true; nArray3[n5] = n6; } } if (!blArray[n3]) break; n6 = Integer.MAX_VALUE; n5 = n3; while (n5 != n2) { int n7 = nArray3[n5]; n6 = Math.min(n6, nArray[n7][n5] - nArray2[n7][n5]); n5 = nArray3[n5]; } n5 = n3; while (n5 != n2) { int n8 = nArray3[n5]; int[] nArray4 = nArray2[n8]; int n9 = n5; nArray4[n9] = nArray4[n9] + n6; int[] nArray5 = nArray2[n5]; int n10 = n8; nArray5[n10] = nArray5[n10] - n6; n5 = nArray3[n5]; } n4 += n6; } return n4; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.LinkedList; import java.util.Queue; /** * This class implements the Ford-Fulkerson algorithm to compute the maximum flow * in a flow network. * * <p>The algorithm uses breadth-first search (BFS) to find augmenting paths from * the source vertex to the sink vertex, updating the flow in the network until * no more augmenting paths can be found.</p> */ public final class FordFulkerson { private static final int INF = Integer.MAX_VALUE; private FordFulkerson() { } /** * Computes the maximum flow in a flow network using the Ford-Fulkerson algorithm. * * @param vertexCount the number of vertices in the flow network * @param capacity a 2D array representing the capacity of edges in the network * @param flow a 2D array representing the current flow in the network * @param source the source vertex in the flow network * @param sink the sink vertex in the flow network * @return the total maximum flow from the source to the sink */ public static int networkFlow(int vertexCount, int[][] capacity, int[][] flow, int source, int sink) { int totalFlow = 0; while (true) { int[] parent = new int[vertexCount]; boolean[] visited = new boolean[vertexCount]; Queue<Integer> queue = new LinkedList<>(); queue.add(source); visited[source] = true; parent[source] = -1; while (!queue.isEmpty() && !visited[sink]) { int current = queue.poll(); for (int next = 0; next < vertexCount; next++) { if (!visited[next] && capacity[current][next] - flow[current][next] > 0) { queue.add(next); visited[next] = true; parent[next] = current; } } } if (!visited[sink]) { break; // No more augmenting paths } int pathFlow = INF; for (int v = sink; v != source; v = parent[v]) { int u = parent[v]; pathFlow = Math.min(pathFlow, capacity[u][v] - flow[u][v]); } for (int v = sink; v != source; v = parent[v]) { int u = parent[v]; flow[u][v] += pathFlow; flow[v][u] -= pathFlow; } totalFlow += pathFlow; } return totalFlow; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.Arrays; import java.util.Comparator; public final class FractionalKnapsack { private FractionalKnapsack() { } public static int fractionalKnapsack(int[] nArray, int[] nArray2, int n) { int n2; double[][] dArray2 = new double[nArray.length][2]; for (n2 = 0; n2 < nArray.length; ++n2) { dArray2[n2][0] = n2; dArray2[n2][1] = (double)nArray2[n2] / (double)nArray[n2]; } Arrays.sort(dArray2, Comparator.comparingDouble(dArray -> dArray[1])); n2 = 0; double d = n; for (n = dArray2.length - 1; n >= 0; --n) { int n3 = (int)dArray2[n][0]; if (d >= (double)nArray[n3]) { n2 += nArray2[n3]; d -= (double)nArray[n3]; continue; } n2 += (int)(dArray2[n][1] * d); break; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.Arrays; import java.util.Comparator; /** * The FractionalKnapsack class provides a method to solve the fractional knapsack problem * using a greedy algorithm approach. It allows for selecting fractions of items to maximize * the total value in a knapsack with a given weight capacity. * * The problem consists of a set of items, each with a weight and a value, and a knapsack * that can carry a maximum weight. The goal is to maximize the value of items in the knapsack, * allowing for the inclusion of fractions of items. * * Problem Link: https://en.wikipedia.org/wiki/Continuous_knapsack_problem */ public final class FractionalKnapsack { private FractionalKnapsack() { } /** * Computes the maximum value that can be accommodated in a knapsack of a given capacity. * * @param weight an array of integers representing the weights of the items * @param value an array of integers representing the values of the items * @param capacity an integer representing the maximum weight capacity of the knapsack * @return the maximum value that can be obtained by including the items in the knapsack */ public static int fractionalKnapsack(int[] weight, int[] value, int capacity) { double[][] ratio = new double[weight.length][2]; for (int i = 0; i < weight.length; i++) { ratio[i][0] = i; ratio[i][1] = value[i] / (double) weight[i]; } Arrays.sort(ratio, Comparator.comparingDouble(o -> o[1])); int finalValue = 0; double current = capacity; for (int i = ratio.length - 1; i >= 0; i--) { int index = (int) ratio[i][0]; if (current >= weight[index]) { finalValue += value[index]; current -= weight[index]; } else { finalValue += (int) (ratio[i][1] * current); break; } } return finalValue; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class FrizzyNumber { private FrizzyNumber() { } public static double getNthFrizzy(int n, int n2) { double d = 0.0; int n3 = 0; do { d += Math.pow(n, n3++) * (double)(n2 % 2); } while ((n2 /= 2) > 0); return d; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * @author <a href=\"https://github.com/siddhant2002\">Siddhant Swarup Mallick</a> * Program description - To find the FrizzyNumber */ public final class FrizzyNumber { private FrizzyNumber() { } /** * Returns the n-th number that is a sum of powers * of the given base. * Example: base = 3 and n = 4 * Ascending order of sums of powers of 3 = * 3^0 = 1, 3^1 = 3, 3^1 + 3^0 = 4, 3^2 + 3^0 = 9 * Ans = 9 * * @param base The base whose n-th sum of powers is required * @param n Index from ascending order of sum of powers of base * @return n-th sum of powers of base */ public static double getNthFrizzy(int base, int n) { double final1 = 0.0; int i = 0; do { final1 += Math.pow(base, i++) * (n % 2); } while ((n /= 2) > 0); return final1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class GCD { private GCD() { } public static int gcd(int n, int n2) { if (n < 0 || n2 < 0) { throw new ArithmeticException(); } if (n == 0 || n2 == 0) { return Math.abs(n - n2); } while (n % n2 != 0) { int n3 = n % n2; n = n2; n2 = n3; } return n2; } public static int gcd(int ... nArray) { int n = 0; for (int n2 : nArray) { n = GCD.gcd(n, n2); } return n; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * This class provides methods to compute the Greatest Common Divisor (GCD) of two or more integers. * * The Greatest Common Divisor (GCD) of two or more integers is the largest positive integer that divides each of the integers without leaving a remainder. * * The GCD can be computed using the Euclidean algorithm, which is based on the principle that the GCD of two numbers also divides their difference. * * For more information, refer to the * <a href=\"https://en.wikipedia.org/wiki/Greatest_common_divisor\">Greatest Common Divisor</a> Wikipedia page. * * <b>Example usage:</b> * <pre> * int result1 = GCD.gcd(48, 18); * System.out.println(\"GCD of 48 and 18: \" + result1); // Output: 6 * * int result2 = GCD.gcd(48, 18, 30); * System.out.println(\"GCD of 48, 18, and 30: \" + result2); // Output: 6 * </pre> * @author Oskar Enmalm 3/10/17 */ public final class GCD { private GCD() { } /** * get the greatest common divisor * * @param num1 the first number * @param num2 the second number * @return gcd */ public static int gcd(int num1, int num2) { if (num1 < 0 || num2 < 0) { throw new ArithmeticException(); } if (num1 == 0 || num2 == 0) { return Math.abs(num1 - num2); } while (num1 % num2 != 0) { int remainder = num1 % num2; num1 = num2; num2 = remainder; } return num2; } /** * @brief computes gcd of an array of numbers * * @param numbers the input array * @return gcd of all of the numbers in the input array */ public static int gcd(int... numbers) { int result = 0; for (final var number : numbers) { result = gcd(result, number); } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class GCDRecursion { private GCDRecursion() { } public static void main(String[] stringArray) { System.out.println(GCDRecursion.gcd(20, 15)); System.out.println(GCDRecursion.gcd(10, 8)); System.out.println(GCDRecursion.gcd(GCDRecursion.gcd(10, 5), GCDRecursion.gcd(5, 10))); } public static int gcd(int n, int n2) { while (true) { if (n < 0 || n2 < 0) { throw new ArithmeticException(); } if (n == 0 || n2 == 0) { return Math.abs(n - n2); } if (n % n2 == 0) { return n2; } int n3 = n2; n2 = n % n2; n = n3; } } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * @author https://github.com/shellhub/ */ public final class GCDRecursion { private GCDRecursion() { } public static void main(String[] args) { System.out.println(gcd(20, 15)); /* output: 5 */ System.out.println(gcd(10, 8)); /* output: 2 */ System.out.println(gcd(gcd(10, 5), gcd(5, 10))); /* output: 5 */ } /** * get greatest common divisor * * @param a the first number * @param b the second number * @return gcd */ public static int gcd(int a, int b) { if (a < 0 || b < 0) { throw new ArithmeticException(); } if (a == 0 || b == 0) { return Math.abs(a - b); } if (a % b == 0) { return b; } else { return gcd(b, a % b); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.crdt; import java.util.Map; class GCounter { private final Map a; private final int b; private final int c; public void increment() { Integer.valueOf(this.b); Integer.valueOf(this.b); throw new NullPointerException(); } public int value() { throw new NullPointerException(); } public boolean compare(GCounter gCounter) { return true; } public void merge(GCounter gCounter) { } }", "deobfuscated_code": "package com.thealgorithms.datastructures.crdt; import java.util.HashMap; import java.util.Map; /** * G-Counter (Grow-only Counter) is a state-based CRDT (Conflict-free Replicated Data Type) * designed for tracking counts in a distributed and concurrent environment. * Each process maintains its own counter, allowing only increments. The total count * is obtained by summing individual process counts. * This implementation supports incrementing, querying the total count, * comparing with other G-Counters, and merging with another G-Counter * to compute the element-wise maximum. * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) * * @author itakurah (https://github.com/itakurah) */ class GCounter { private final Map<Integer, Integer> counterMap; private final int myId; private final int n; /** * Constructs a G-Counter for a cluster of n nodes. * * @param n The number of nodes in the cluster. */ GCounter(int myId, int n) { this.myId = myId; this.n = n; this.counterMap = new HashMap<>(); for (int i = 0; i < n; i++) { counterMap.put(i, 0); } } /** * Increments the counter for the current node. */ public void increment() { counterMap.put(myId, counterMap.get(myId) + 1); } /** * Gets the total value of the counter by summing up values from all nodes. * * @return The total value of the counter. */ public int value() { int sum = 0; for (int v : counterMap.values()) { sum += v; } return sum; } /** * Compares the state of this G-Counter with another G-Counter. * * @param other The other G-Counter to compare with. * @return True if the state of this G-Counter is less than or equal to the state of the other G-Counter. */ public boolean compare(GCounter other) { for (int i = 0; i < n; i++) { if (this.counterMap.get(i) > other.counterMap.get(i)) { return false; } } return true; } /** * Merges the state of this G-Counter with another G-Counter. * * @param other The other G-Counter to merge with. */ public void merge(GCounter other) { for (int i = 0; i < n; i++) { this.counterMap.put(i, Math.max(this.counterMap.get(i), other.counterMap.get(i))); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.crdt; import java.util.HashSet; import java.util.Set; public class GSet { private final Set a = new HashSet(); public void addElement(Object object) { this.a.add(object); } public boolean lookup(Object object) { return this.a.contains(object); } public boolean compare(GSet gSet) { return gSet.a.containsAll(this.a); } public void merge(GSet gSet) { this.a.addAll(gSet.a); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.crdt; import java.util.HashSet; import java.util.Set; /** * GSet (Grow-only Set) is a state-based CRDT (Conflict-free Replicated Data Type) * that allows only the addition of elements and ensures that once an element is added, * it cannot be removed. The merge operation of two G-Sets is their union. * This implementation supports adding elements, looking up elements, comparing with other G-Sets, * and merging with another G-Set to create a new G-Set containing all unique elements from both sets. * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) * * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah) */ public class GSet<T> { private final Set<T> elements; /** * Constructs an empty G-Set. */ public GSet() { this.elements = new HashSet<>(); } /** * Adds an element to the G-Set. * * @param e the element to be added */ public void addElement(T e) { elements.add(e); } /** * Checks if the given element is present in the G-Set. * * @param e the element to be checked * @return true if the element is present, false otherwise */ public boolean lookup(T e) { return elements.contains(e); } /** * Compares the G-Set with another G-Set to check if it is a subset. * * @param other the other G-Set to compare with * @return true if the current G-Set is a subset of the other, false otherwise */ public boolean compare(GSet<T> other) { return other.elements.containsAll(elements); } /** * Merges the current G-Set with another G-Set, creating a new G-Set * containing all unique elements from both sets. * * @param other the G-Set to merge with */ public void merge(GSet<T> other) { elements.addAll(other.elements); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.AbstractCollection; import java.util.HashMap; import java.util.LinkedList; import java.util.Map; public final class GaleShapley { private GaleShapley() { } public static Map stableMatch(Map map, Map map2) { HashMap<Object, String> hashMap = new HashMap<Object, String>(); LinkedList linkedList = new LinkedList(map2.keySet()); while (!linkedList.isEmpty()) { String string = (String)linkedList.poll(); Object object = (LinkedList)map2.get(string); if (object == null || ((AbstractCollection)object).isEmpty()) continue; String string2 = (String)hashMap.get(object = (String)((LinkedList)object).poll()); if (string2 == null) { hashMap.put(object, string); continue; } LinkedList linkedList2 = (LinkedList)map.get(object); if (linkedList2 == null) continue; if (linkedList2.indexOf(string) < linkedList2.indexOf(string2)) { hashMap.put(object, string); linkedList.add(string2); continue; } linkedList.add(string); } return hashMap; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.HashMap; import java.util.LinkedList; import java.util.Map; /** * Implementation of the Gale-Shapley Algorithm for Stable Matching. * Problem link: https://en.wikipedia.org/wiki/Stable_marriage_problem */ public final class GaleShapley { private GaleShapley() { } /** * Function to find stable matches between men and women. * * @param womenPrefs A map containing women's preferences where each key is a woman and the value is an array of men in order of preference. * @param menPrefs A map containing men's preferences where each key is a man and the value is an array of women in order of preference. * @return A map containing stable matches where the key is a woman and the value is her matched man. */ public static Map<String, String> stableMatch(Map<String, LinkedList<String>> womenPrefs, Map<String, LinkedList<String>> menPrefs) { // Initialize all men as free Map<String, String> engagements = new HashMap<>(); LinkedList<String> freeMen = new LinkedList<>(menPrefs.keySet()); // While there are free men while (!freeMen.isEmpty()) { String man = freeMen.poll(); // Get the first free man LinkedList<String> manPref = menPrefs.get(man); // Get the preferences of the man // Check if manPref is null or empty if (manPref == null || manPref.isEmpty()) { continue; // Skip if no preferences } // Propose to the first woman in the man's preference list String woman = manPref.poll(); String fiance = engagements.get(woman); // If the woman is not engaged, engage her with the current man if (fiance == null) { engagements.put(woman, man); } else { // If the woman prefers the current man over her current fiance LinkedList<String> womanPrefList = womenPrefs.get(woman); // Check if womanPrefList is null if (womanPrefList == null) { continue; // Skip if no preferences for the woman } if (womanPrefList.indexOf(man) < womanPrefList.indexOf(fiance)) { engagements.put(woman, man); freeMen.add(fiance); // Previous fiance becomes free } else { // Woman rejects the new proposal, the man remains free freeMen.add(man); } } } return engagements; // Return the stable matches } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.List; class GangScheduling$Gang { String a; List b; GangScheduling$Gang(String string) { this.a = string; this.b = new ArrayList(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.List; class GangScheduling$Gang { String a; List b; GangScheduling$Gang(String string) { this.a = string; this.b = new ArrayList(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.GangScheduling$Gang; import java.util.HashMap; import java.util.List; import java.util.Map; public final class GangScheduling { private final Map a = new HashMap(); public final void addGang(String string) { this.a.putIfAbsent(string, new GangScheduling$Gang(string)); } public final void addTaskToGang(String object, String string) { if ((object = (GangScheduling$Gang)this.a.get(object)) != null) { ((GangScheduling$Gang)object).b.add(string); } } public final Map getGangSchedules() { HashMap<String, List> hashMap = new HashMap<String, List>(); for (GangScheduling$Gang gangScheduling$Gang : this.a.values()) { hashMap.put(gangScheduling$Gang.a, gangScheduling$Gang.b); } return hashMap; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * GangScheduling groups related tasks (gangs) to run simultaneously on multiple processors. * All tasks in a gang are executed together or not at all. * * Use Case: Parallel computing environments where multiple threads of a program * need to run concurrently for optimal performance. * * @author Hardvan */ public final class GangScheduling { static class Gang { String name; List<String> tasks; Gang(String name) { this.name = name; this.tasks = new ArrayList<>(); } void addTask(String task) { tasks.add(task); } List<String> getTasks() { return tasks; } } private final Map<String, Gang> gangs; public GangScheduling() { gangs = new HashMap<>(); } public void addGang(String gangName) { gangs.putIfAbsent(gangName, new Gang(gangName)); } public void addTaskToGang(String gangName, String task) { Gang gang = gangs.get(gangName); if (gang != null) { gang.addTask(task); } } public Map<String, List<String>> getGangSchedules() { Map<String, List<String>> schedules = new HashMap<>(); for (Gang gang : gangs.values()) { schedules.put(gang.name, gang.getTasks()); } return schedules; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; public final class GaussLegendre { private GaussLegendre() { } public static void main(String[] stringArray) { for (int i = 1; i <= 3; ++i) { int n = i; double d = 1.0; double d2 = Math.pow(2.0, -0.5); double d3 = 0.25; double d4 = 1.0; for (int j = 0; j < n; ++j) { double d5 = d4; double d6 = d3; double d7 = d2; double d8 = d; double[] dArray = new double[4]; double[] dArray2 = dArray; dArray[0] = (d8 + d7) / 2.0; dArray2[1] = Math.sqrt(d8 * d7); dArray2[2] = d6 - d5 * Math.pow(d8 - dArray2[0], 2.0); dArray2[3] = d5 * 2.0; double[] dArray3 = dArray2; d = dArray2[0]; d2 = dArray3[1]; d3 = dArray3[2]; d4 = dArray3[3]; } System.out.println(Math.pow(d + d2, 2.0) / (d3 * 4.0)); } } }", "deobfuscated_code": "package com.thealgorithms.others; /** * Guass Legendre Algorithm ref * https://en.wikipedia.org/wiki/GaussLegendre_algorithm * * @author AKS1996 */ public final class GaussLegendre { private GaussLegendre() { } public static void main(String[] args) { for (int i = 1; i <= 3; ++i) { System.out.println(pi(i)); } } static double pi(int l) { /* * l: No of loops to run */ double a = 1; double b = Math.pow(2, -0.5); double t = 0.25; double p = 1; for (int i = 0; i < l; ++i) { double[] temp = update(a, b, t, p); a = temp[0]; b = temp[1]; t = temp[2]; p = temp[3]; } return Math.pow(a + b, 2) / (4 * t); } static double[] update(double a, double b, double t, double p) { double[] values = new double[4]; values[0] = (a + b) / 2; values[1] = Math.sqrt(a * b); values[2] = t - p * Math.pow(a - values[0], 2); values[3] = 2 * p; return values; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.ArrayList; import java.util.List; public final class Gaussian { private Gaussian() { } public static ArrayList gaussian(int n, List list) { int n2; double[][] dArray = new double[n + 1][n + 1]; int n3 = n; double[][] dArray2 = new double[n3][n3 + 1]; for (n2 = 0; n2 < n; ++n2) { for (int i = 0; i <= n; ++i) { dArray[n2][i] = (Double)list.get(n2); } } dArray = Gaussian.gaussianElimination(n, n2, dArray); return Gaussian.valueOfGaussian(n, dArray2, dArray); } public static double[][] gaussianElimination(int n, int n2, double[][] dArray) { for (int i = 0; i < n - 1; ++i) { for (n2 = i; n2 < n - 1; ++n2) { double d = dArray[n2 + 1][i] / dArray[i][i]; for (int j = i; j <= n; ++j) { dArray[n2 + 1][j] = dArray[n2 + 1][j] - d * dArray[i][j]; } } } return dArray; } public static ArrayList valueOfGaussian(int n, double[][] dArray, double[][] dArray2) { int n2; int n3; ArrayList<Double> arrayList = new ArrayList<Double>(); for (n3 = 0; n3 < n; ++n3) { for (n2 = 0; n2 <= n; ++n2) { dArray[n3][n2] = dArray2[n3][n2]; } } for (n3 = n - 1; n3 >= 0; --n3) { double d = 0.0; for (n2 = n - 1; n2 > n3; --n2) { dArray[n3][n2] = dArray[n2][n2] * dArray[n3][n2]; d = dArray[n3][n2] + d; } dArray[n3][n3] = dArray[n3][n3] == 0.0 ? 0.0 : (dArray[n3][n] - d) / dArray[n3][n3]; arrayList.add(dArray[n3][n2]); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; import java.util.List; public final class Gaussian { private Gaussian() { } public static ArrayList<Double> gaussian(int matSize, List<Double> matrix) { int i; int j = 0; double[][] mat = new double[matSize + 1][matSize + 1]; double[][] x = new double[matSize][matSize + 1]; // Values from arraylist to matrix for (i = 0; i < matSize; i++) { for (j = 0; j <= matSize; j++) { mat[i][j] = matrix.get(i); } } mat = gaussianElimination(matSize, i, mat); return valueOfGaussian(matSize, x, mat); } // Perform Gaussian elimination public static double[][] gaussianElimination(int matSize, int i, double[][] mat) { int step = 0; for (step = 0; step < matSize - 1; step++) { for (i = step; i < matSize - 1; i++) { double a = (mat[i + 1][step] / mat[step][step]); for (int j = step; j <= matSize; j++) { mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]); } } } return mat; } // calculate the x_1, x_2, ... values of the gaussian and save it in an arraylist. public static ArrayList<Double> valueOfGaussian(int matSize, double[][] x, double[][] mat) { ArrayList<Double> answerArray = new ArrayList<Double>(); int i; int j; for (i = 0; i < matSize; i++) { for (j = 0; j <= matSize; j++) { x[i][j] = mat[i][j]; } } for (i = matSize - 1; i >= 0; i--) { double sum = 0; for (j = matSize - 1; j > i; j--) { x[i][j] = x[j][j] * x[i][j]; sum = x[i][j] + sum; } if (x[i][i] == 0) { x[i][i] = 0; } else { x[i][i] = (x[i][matSize] - sum) / (x[i][i]); } answerArray.add(x[i][j]); } return answerArray; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.recursion; import java.util.ArrayList; import java.util.List; public final class GenerateSubsets { private GenerateSubsets() { } public static List subsetRecursion(String string) { return GenerateSubsets.a(\"\", string); } private static List a(String object, String string) { if (string.isEmpty()) { ArrayList<String> arrayList = new ArrayList<String>(); arrayList.add((String)object); return arrayList; } char c = string.charAt(0); string = string.substring(1); List list = GenerateSubsets.a((String)object + c, string); object = GenerateSubsets.a((String)object, string); list.addAll(object); return list; } }", "deobfuscated_code": "package com.thealgorithms.recursion; import java.util.ArrayList; import java.util.List; /** * Utility class to generate all subsets (power set) of a given string using recursion. * * <p>For example, the string \"ab\" will produce: [\"ab\", \"a\", \"b\", \"\"] */ public final class GenerateSubsets { private GenerateSubsets() { } /** * Generates all subsets (power set) of the given string using recursion. * * @param str the input string to generate subsets for * @return a list of all subsets of the input string */ public static List<String> subsetRecursion(String str) { return generateSubsets(\"\", str); } /** * Recursive helper method to generate subsets by including or excluding characters. * * @param current the current prefix being built * @param remaining the remaining string to process * @return list of subsets formed from current and remaining */ private static List<String> generateSubsets(String current, String remaining) { if (remaining.isEmpty()) { List<String> result = new ArrayList<>(); result.add(current); return result; } char ch = remaining.charAt(0); String next = remaining.substring(1); // Include the character List<String> withChar = generateSubsets(current + ch, next); // Exclude the character List<String> withoutChar = generateSubsets(current, next); withChar.addAll(withoutChar); return withChar; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; import java.util.ArrayList; import java.util.List; public class GenericArrayListQueue { private final List a = new ArrayList(); public boolean isEmpty() { return this.a.isEmpty(); } public Object peek() { if (this.isEmpty()) { return null; } return this.a.getFirst(); } public boolean add(Object object) { return this.a.add(object); } public Object poll() { if (this.isEmpty()) { return null; } return this.a.removeFirst(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.queues; import java.util.ArrayList; import java.util.List; /** * This class implements a GenericArrayListQueue, a queue data structure that * holds elements of any type specified at runtime, allowing flexibility in the type * of elements it stores. * * <p>The GenericArrayListQueue operates on a First-In-First-Out (FIFO) basis, where * elements added first are the first to be removed. New elements are added to the back * (or rear) of the queue, while removal of elements occurs from the front. * * @param <T> The type of elements held in this queue. */ public class GenericArrayListQueue<T> { /** * A list that stores the queue's elements in insertion order. */ private final List<T> elementList = new ArrayList<>(); /** * Checks if the queue is empty. * * @return {@code true} if the queue has no elements; {@code false} otherwise. */ public boolean isEmpty() { return elementList.isEmpty(); } /** * Retrieves, but does not remove, the element at the front of the queue. * * @return The element at the front of the queue, or {@code null} if the queue is empty. */ public T peek() { return isEmpty() ? null : elementList.getFirst(); } /** * Inserts an element at the back of the queue. * * @param element The element to be added to the queue. * @return {@code true} if the element was successfully added. */ public boolean add(T element) { return elementList.add(element); } /** * Retrieves and removes the element at the front of the queue. * * @return The element removed from the front of the queue, or {@code null} if the queue is empty. */ public T poll() { return isEmpty() ? null : elementList.removeFirst(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import com.thealgorithms.datastructures.hashmap.hashing.GenericHashMapUsingArray; public class GenericHashMapUsingArray$Node { Object a; Object b; public GenericHashMapUsingArray$Node(GenericHashMapUsingArray genericHashMapUsingArray, Object object, Object object2) { this.a = object; this.b = object2; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import com.thealgorithms.datastructures.hashmap.hashing.GenericHashMapUsingArray; public class GenericHashMapUsingArray$Node { Object a; Object b; public GenericHashMapUsingArray$Node(GenericHashMapUsingArray genericHashMapUsingArray, Object object, Object object2) { this.a = object; this.b = object2; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import com.thealgorithms.datastructures.hashmap.hashing.GenericHashMapUsingArray$Node; import java.util.AbstractSequentialList; import java.util.LinkedList; public class GenericHashMapUsingArray { private int a; private LinkedList[] b; public GenericHashMapUsingArray() { this.a(16); this.a = 0; } private void a(int n) { this.b = new LinkedList[n]; for (n = 0; n < this.b.length; ++n) { this.b[n] = new LinkedList(); } } public void put(Object object, Object linkedListArray) { int n = this.a(object); LinkedList linkedList = this.b[n]; for (GenericHashMapUsingArray$Node iterator : linkedList) { if (!iterator.a.equals(object)) continue; iterator.b = linkedListArray; return; } linkedList.add(new GenericHashMapUsingArray$Node(this, object, linkedListArray)); ++this.a; if ((float)this.a / (float)this.b.length > 0.75f) { object = this; linkedListArray = ((GenericHashMapUsingArray)object).b; ((GenericHashMapUsingArray)object).a(linkedListArray.length << 1); ((GenericHashMapUsingArray)object).a = 0; for (LinkedList linkedList2 : linkedListArray) { for (GenericHashMapUsingArray$Node genericHashMapUsingArray$Node : linkedList2) { ((GenericHashMapUsingArray)object).put(genericHashMapUsingArray$Node.a, genericHashMapUsingArray$Node.b); } } } } private int a(Object object) { return Math.floorMod(object.hashCode(), this.b.length); } public void remove(Object object) { int n = this.a(object); LinkedList linkedList = this.b[n]; GenericHashMapUsingArray$Node genericHashMapUsingArray$Node = null; for (GenericHashMapUsingArray$Node genericHashMapUsingArray$Node2 : linkedList) { if (!genericHashMapUsingArray$Node2.a.equals(object)) continue; genericHashMapUsingArray$Node = genericHashMapUsingArray$Node2; break; } if (genericHashMapUsingArray$Node != null) { linkedList.remove(genericHashMapUsingArray$Node); --this.a; } } public int size() { return this.a; } public Object get(Object object) { int n = this.a(object); Object object2 = this.b[n]; object2 = ((AbstractSequentialList)object2).iterator(); while (object2.hasNext()) { GenericHashMapUsingArray$Node genericHashMapUsingArray$Node = (GenericHashMapUsingArray$Node)object2.next(); if (!genericHashMapUsingArray$Node.a.equals(object)) continue; return genericHashMapUsingArray$Node.b; } return null; } public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"{\"); LinkedList[] linkedListArray = this.b; int n = this.b.length; for (int i = 0; i < n; ++i) { Object object = linkedListArray[i]; object = ((AbstractSequentialList)object).iterator(); while (object.hasNext()) { GenericHashMapUsingArray$Node genericHashMapUsingArray$Node = (GenericHashMapUsingArray$Node)object.next(); stringBuilder.append(genericHashMapUsingArray$Node.a); stringBuilder.append(\" : \"); stringBuilder.append(genericHashMapUsingArray$Node.b); stringBuilder.append(\", \"); } } if (stringBuilder.length() > 1) { StringBuilder stringBuilder2 = stringBuilder; stringBuilder2.setLength(stringBuilder2.length() - 2); } stringBuilder.append(\"}\"); return stringBuilder.toString(); } public boolean containsKey(Object object) { return this.get(object) != null; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.hashmap.hashing; import java.util.LinkedList; /** * A generic implementation of a hash map using an array of linked lists for collision resolution. * This class provides a way to store key-value pairs efficiently, allowing for average-case * constant time complexity for insertion, deletion, and retrieval operations. * * <p> * The hash map uses separate chaining for collision resolution. Each bucket in the hash map is a * linked list that stores nodes containing key-value pairs. When a collision occurs (i.e., when * two keys hash to the same index), the new key-value pair is simply added to the corresponding * linked list. * </p> * * <p> * The hash map automatically resizes itself when the load factor exceeds 0.75. The load factor is * defined as the ratio of the number of entries to the number of buckets. When resizing occurs, * all existing entries are rehashed and inserted into the new buckets. * </p> * * @param <K> the type of keys maintained by this hash map * @param <V> the type of mapped values */ @SuppressWarnings({\"rawtypes\", \"unchecked\"}) public class GenericHashMapUsingArray<K, V> { private int size; // Total number of key-value pairs private LinkedList<Node>[] buckets; // Array of linked lists (buckets) for storing entries /** * Constructs a new empty hash map with an initial capacity of 16. */ public GenericHashMapUsingArray() { initBuckets(16); size = 0; } /** * Initializes the buckets for the hash map with the specified number of buckets. * * @param n the number of buckets to initialize */ private void initBuckets(int n) { buckets = new LinkedList[n]; for (int i = 0; i < buckets.length; i++) { buckets[i] = new LinkedList<>(); } } /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old value is replaced. * * @param key the key with which the specified value is to be associated * @param value the value to be associated with the specified key */ public void put(K key, V value) { int bucketIndex = hashFunction(key); LinkedList<Node> nodes = buckets[bucketIndex]; // Update existing key's value if present for (Node node : nodes) { if (node.key.equals(key)) { node.value = value; return; } } // Insert new key-value pair nodes.add(new Node(key, value)); size++; // Check if rehashing is needed // Load factor threshold for resizing float loadFactorThreshold = 0.75f; if ((float) size / buckets.length > loadFactorThreshold) { reHash(); } } /** * Returns the index of the bucket in which the key would be stored. * * @param key the key whose bucket index is to be computed * @return the bucket index */ private int hashFunction(K key) { return Math.floorMod(key.hashCode(), buckets.length); } /** * Rehashes the map by doubling the number of buckets and re-inserting all entries. */ private void reHash() { LinkedList<Node>[] oldBuckets = buckets; initBuckets(oldBuckets.length * 2); this.size = 0; for (LinkedList<Node> nodes : oldBuckets) { for (Node node : nodes) { put(node.key, node.value); } } } /** * Removes the mapping for the specified key from this map if present. * * @param key the key whose mapping is to be removed from the map */ public void remove(K key) { int bucketIndex = hashFunction(key); LinkedList<Node> nodes = buckets[bucketIndex]; Node target = null; for (Node node : nodes) { if (node.key.equals(key)) { target = node; break; } } if (target != null) { nodes.remove(target); size--; } } /** * Returns the number of key-value pairs in this map. * * @return the number of key-value pairs */ public int size() { return this.size; } /** * Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. * * @param key the key whose associated value is to be returned * @return the value associated with the specified key, or null if no mapping exists */ public V get(K key) { int bucketIndex = hashFunction(key); LinkedList<Node> nodes = buckets[bucketIndex]; for (Node node : nodes) { if (node.key.equals(key)) { return node.value; } } return null; } @Override public String toString() { StringBuilder builder = new StringBuilder(); builder.append(\"{\"); for (LinkedList<Node> nodes : buckets) { for (Node node : nodes) { builder.append(node.key); builder.append(\" : \"); builder.append(node.value); builder.append(\", \"); } } // Remove trailing comma and space if (builder.length() > 1) { builder.setLength(builder.length() - 2); } builder.append(\"}\"); return builder.toString(); } /** * Returns true if this map contains a mapping for the specified key. * * @param key the key whose presence in this map is to be tested * @return true if this map contains a mapping for the specified key */ public boolean containsKey(K key) { return get(key) != null; } /** * A private class representing a key-value pair (node) in the hash map. */ public class Node { K key; V value; /** * Constructs a new Node with the specified key and value. * * @param key the key of the key-value pair * @param value the value of the key-value pair */ public Node(K key, V value) { this.key = key; this.value = value; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; class GenericHashMapUsingArrayList$Node { Object a; Object b; GenericHashMapUsingArrayList$Node(Object object, Object object2) { this.a = object; this.b = object2; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; class GenericHashMapUsingArrayList$Node { Object a; Object b; GenericHashMapUsingArrayList$Node(Object object, Object object2) { this.a = object; this.b = object2; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import com.thealgorithms.datastructures.hashmap.hashing.GenericHashMapUsingArrayList$Node; import java.util.AbstractSequentialList; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedList; public class GenericHashMapUsingArrayList { private ArrayList a = new ArrayList(); private int b; public GenericHashMapUsingArrayList() { for (int i = 0; i < 10; ++i) { this.a.add(new LinkedList()); } this.b = 0; } public void put(Object object, Object iterator) { int n = Math.abs(object.hashCode() % this.a.size()); LinkedList linkedList = (LinkedList)this.a.get(n); for (GenericHashMapUsingArrayList$Node genericHashMapUsingArrayList$Node : linkedList) { if (!genericHashMapUsingArrayList$Node.a.equals(object)) continue; genericHashMapUsingArrayList$Node.b = iterator; return; } linkedList.add(new GenericHashMapUsingArrayList$Node(object, iterator)); ++this.b; if ((float)this.b / (float)this.a.size() > 0.5f) { object = this; iterator = ((GenericHashMapUsingArrayList)object).a; ((GenericHashMapUsingArrayList)object).a = new ArrayList(); ((GenericHashMapUsingArrayList)object).b = 0; for (int i = 0; i < ((ArrayList)((Object)iterator)).size() << 1; ++i) { ((GenericHashMapUsingArrayList)object).a.add(new LinkedList()); } Iterator iterator2 = ((ArrayList)((Object)iterator)).iterator(); while (iterator2.hasNext()) { iterator = (LinkedList)iterator2.next(); iterator = ((AbstractSequentialList)((Object)iterator)).iterator(); while (iterator.hasNext()) { GenericHashMapUsingArrayList$Node genericHashMapUsingArrayList$Node = (GenericHashMapUsingArrayList$Node)iterator.next(); ((GenericHashMapUsingArrayList)object).put(genericHashMapUsingArrayList$Node.a, genericHashMapUsingArrayList$Node.b); } } } } public Object get(Object object) { int n = Math.abs(object.hashCode() % this.a.size()); Object object2 = (LinkedList)this.a.get(n); object2 = ((AbstractSequentialList)object2).iterator(); while (object2.hasNext()) { GenericHashMapUsingArrayList$Node genericHashMapUsingArrayList$Node = (GenericHashMapUsingArrayList$Node)object2.next(); if (!genericHashMapUsingArrayList$Node.a.equals(object)) continue; return genericHashMapUsingArrayList$Node.b; } return null; } public void remove(Object object) { int n = Math.abs(object.hashCode() % this.a.size()); LinkedList linkedList = (LinkedList)this.a.get(n); GenericHashMapUsingArrayList$Node genericHashMapUsingArrayList$Node = null; for (GenericHashMapUsingArrayList$Node genericHashMapUsingArrayList$Node2 : linkedList) { if (!genericHashMapUsingArrayList$Node2.a.equals(object)) continue; genericHashMapUsingArrayList$Node = genericHashMapUsingArrayList$Node2; break; } if (genericHashMapUsingArrayList$Node != null) { linkedList.remove(genericHashMapUsingArrayList$Node); --this.b; } } public boolean containsKey(Object object) { return this.get(object) != null; } public int size() { return this.b; } public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"{\"); for (Object object : this.a) { object = ((AbstractSequentialList)object).iterator(); while (object.hasNext()) { GenericHashMapUsingArrayList$Node genericHashMapUsingArrayList$Node = (GenericHashMapUsingArrayList$Node)object.next(); stringBuilder.append(genericHashMapUsingArrayList$Node.a); stringBuilder.append(\" : \"); stringBuilder.append(genericHashMapUsingArrayList$Node.b); stringBuilder.append(\", \"); } } if (stringBuilder.length() > 1) { StringBuilder stringBuilder2 = stringBuilder; stringBuilder2.setLength(stringBuilder2.length() - 2); } stringBuilder.append(\"}\"); return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.hashmap.hashing; import java.util.ArrayList; import java.util.LinkedList; /** * A generic implementation of a hash map using an array list of linked lists for collision resolution. * This class allows storage of key-value pairs with average-case constant time complexity for insertion, * deletion, and retrieval operations. * * <p> * The hash map uses separate chaining to handle collisions. Each bucket in the hash map is represented * by a linked list that holds nodes containing key-value pairs. When multiple keys hash to the same index, * they are stored in the same linked list. * </p> * * <p> * The hash map automatically resizes itself when the load factor exceeds 0.5. The load factor is defined * as the ratio of the number of entries to the number of buckets. When resizing occurs, all existing entries * are rehashed and inserted into the new buckets. * </p> * * @param <K> the type of keys maintained by this hash map * @param <V> the type of mapped values */ public class GenericHashMapUsingArrayList<K, V> { private ArrayList<LinkedList<Node>> buckets; // Array list of buckets (linked lists) private int size; // Number of key-value pairs in the hash map /** * Constructs a new empty hash map with an initial capacity of 10 buckets. */ public GenericHashMapUsingArrayList() { buckets = new ArrayList<>(); for (int i = 0; i < 10; i++) { buckets.add(new LinkedList<>()); } size = 0; } /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old value is replaced. * * @param key the key with which the specified value is to be associated * @param value the value to be associated with the specified key */ public void put(K key, V value) { int hash = Math.abs(key.hashCode() % buckets.size()); LinkedList<Node> nodes = buckets.get(hash); for (Node node : nodes) { if (node.key.equals(key)) { node.val = value; return; } } nodes.add(new Node(key, value)); size++; // Load factor threshold for resizing float loadFactorThreshold = 0.5f; if ((float) size / buckets.size() > loadFactorThreshold) { reHash(); } } /** * Resizes the hash map by doubling the number of buckets and rehashing existing entries. */ private void reHash() { ArrayList<LinkedList<Node>> oldBuckets = buckets; buckets = new ArrayList<>(); size = 0; for (int i = 0; i < oldBuckets.size() * 2; i++) { buckets.add(new LinkedList<>()); } for (LinkedList<Node> nodes : oldBuckets) { for (Node node : nodes) { put(node.key, node.val); } } } /** * Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. * * @param key the key whose associated value is to be returned * @return the value associated with the specified key, or null if no mapping exists */ public V get(K key) { int hash = Math.abs(key.hashCode() % buckets.size()); LinkedList<Node> nodes = buckets.get(hash); for (Node node : nodes) { if (node.key.equals(key)) { return node.val; } } return null; } /** * Removes the mapping for the specified key from this map if present. * * @param key the key whose mapping is to be removed from the map */ public void remove(K key) { int hash = Math.abs(key.hashCode() % buckets.size()); LinkedList<Node> nodes = buckets.get(hash); Node target = null; for (Node node : nodes) { if (node.key.equals(key)) { target = node; break; } } if (target != null) { nodes.remove(target); size--; } } /** * Returns true if this map contains a mapping for the specified key. * * @param key the key whose presence in this map is to be tested * @return true if this map contains a mapping for the specified key */ public boolean containsKey(K key) { return get(key) != null; } /** * Returns the number of key-value pairs in this map. * * @return the number of key-value pairs */ public int size() { return this.size; } /** * Returns a string representation of the map, containing all key-value pairs. * * @return a string representation of the map */ @Override public String toString() { StringBuilder builder = new StringBuilder(); builder.append(\"{\"); for (LinkedList<Node> nodes : buckets) { for (Node node : nodes) { builder.append(node.key); builder.append(\" : \"); builder.append(node.val); builder.append(\", \"); } } // Remove trailing comma and space if there are any elements if (builder.length() > 1) { builder.setLength(builder.length() - 2); } builder.append(\"}\"); return builder.toString(); } /** * A private inner class representing a key-value pair (node) in the hash map. */ private class Node { K key; V val; /** * Constructs a new Node with the specified key and value. * * @param key the key of the key-value pair * @param val the value of the key-value pair */ Node(K key, V val) { this.key = key; this.val = val; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import java.util.ArrayList; import java.util.HashMap; public class GenericHeap { private final ArrayList a = new ArrayList(); private final HashMap b = new HashMap(); public void add(Comparable comparable) { if (comparable == null) { throw new IllegalArgumentException(\"Cannot insert null into the heap.\"); } this.a.add(comparable); this.b.put(comparable, this.a.size() - 1); GenericHeap genericHeap = this; genericHeap.a(genericHeap.a.size() - 1); } private void a(int n) { while (true) { int n2 = (n - 1) / 2; if (n <= 0) break; Comparable comparable = (Comparable)this.a.get(n2); Comparable comparable2 = (Comparable)this.a.get(n); if (comparable2.compareTo(comparable) <= 0) break; this.a(n2, n); n = n2; } } public int size() { return this.a.size(); } public boolean isEmpty() { return this.size() == 0; } public Comparable remove() { if (this.isEmpty()) { throw new IllegalStateException(\"Heap is empty\"); } this.a(0, this.size() - 1); Comparable comparable = (Comparable)this.a.remove(this.size() - 1); this.b.remove(comparable); this.b(0); return comparable; } private void b(int n) { while (true) { Comparable comparable; Comparable comparable2; int n2 = 2 * n + 1; int n3 = 2 * n + 2; int n4 = n; if (n2 < this.size()) { comparable2 = (Comparable)this.a.get(n4); comparable = (Comparable)this.a.get(n2); if (comparable.compareTo(comparable2) > 0) { n4 = n2; } } if (n3 < this.size()) { comparable2 = (Comparable)this.a.get(n4); comparable = (Comparable)this.a.get(n3); if (comparable.compareTo(comparable2) > 0) { n4 = n3; } } if (n4 == n) break; this.a(n, n4); n = n4; } } public Comparable get() { if (this.isEmpty()) { throw new IllegalStateException(\"Heap is empty\"); } return (Comparable)this.a.getFirst(); } private void a(int n, int n2) { Comparable comparable = (Comparable)this.a.get(n); Comparable comparable2 = (Comparable)this.a.get(n2); this.a.set(n, comparable2); this.a.set(n2, comparable); this.b.put(comparable, n2); this.b.put(comparable2, n); } public void updatePriority(Comparable comparable) { if (!this.b.containsKey(comparable)) { throw new IllegalArgumentException(\"Item not found in the heap\"); } int n = (Integer)this.b.get(comparable); this.a(n); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; import java.util.ArrayList; import java.util.HashMap; /** * A generic implementation of a max heap data structure. * * @param <T> the type of elements in this heap, must extend Comparable. */ public class GenericHeap<T extends Comparable<T>> { private final ArrayList<T> data = new ArrayList<>(); private final HashMap<T, Integer> map = new HashMap<>(); /** * Adds an item to the heap, maintaining the heap property. * * @param item the item to be added */ public void add(T item) { if (item == null) { throw new IllegalArgumentException(\"Cannot insert null into the heap.\"); } this.data.add(item); map.put(item, this.data.size() - 1); upHeapify(this.data.size() - 1); } /** * Restores the heap property by moving the item at the given index upwards. * * @param ci the index of the current item */ private void upHeapify(int ci) { int pi = (ci - 1) / 2; if (ci > 0 && isLarger(this.data.get(ci), this.data.get(pi)) > 0) { swap(pi, ci); upHeapify(pi); } } /** * Returns the number of elements in the heap. * * @return the size of the heap */ public int size() { return this.data.size(); } /** * Checks if the heap is empty. * * @return true if the heap is empty, false otherwise */ public boolean isEmpty() { return this.size() == 0; } /** * Removes and returns the maximum item from the heap. * * @return the maximum item */ public T remove() { if (isEmpty()) { throw new IllegalStateException(\"Heap is empty\"); } this.swap(0, this.size() - 1); T rv = this.data.remove(this.size() - 1); map.remove(rv); downHeapify(0); return rv; } /** * Restores the heap property by moving the item at the given index downwards. * * @param pi the index of the current item */ private void downHeapify(int pi) { int lci = 2 * pi + 1; int rci = 2 * pi + 2; int mini = pi; if (lci < this.size() && isLarger(this.data.get(lci), this.data.get(mini)) > 0) { mini = lci; } if (rci < this.size() && isLarger(this.data.get(rci), this.data.get(mini)) > 0) { mini = rci; } if (mini != pi) { this.swap(pi, mini); downHeapify(mini); } } /** * Retrieves the maximum item from the heap without removing it. * * @return the maximum item */ public T get() { if (isEmpty()) { throw new IllegalStateException(\"Heap is empty\"); } return this.data.getFirst(); } /** * Compares two items to determine their order. * * @param t the first item * @param o the second item * @return a positive integer if t is greater than o, negative if t is less, and zero if they are equal */ private int isLarger(T t, T o) { return t.compareTo(o); } /** * Swaps two items in the heap and updates their indices in the map. * * @param i index of the first item * @param j index of the second item */ private void swap(int i, int j) { T ith = this.data.get(i); T jth = this.data.get(j); this.data.set(i, jth); this.data.set(j, ith); map.put(ith, j); map.put(jth, i); } /** * Updates the priority of the specified item by restoring the heap property. * * @param item the item whose priority is to be updated */ public void updatePriority(T item) { if (!map.containsKey(item)) { throw new IllegalArgumentException(\"Item not found in the heap\"); } int index = map.get(item); upHeapify(index); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class GenericRoot { private GenericRoot() { } private static int a(int n) { assert (n >= 0); if (n < 10) { return n; } return n % 10 + GenericRoot.a(n / 10); } public static int genericRoot(int n) { while ((n = Math.abs(n)) >= 10) { n = GenericRoot.a(n); } return n; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Calculates the generic root (repeated digital sum) of a non-negative integer. * <p> * For example, the generic root of 12345 is calculated as: * 1 + 2 + 3 + 4 + 5 = 15, * then 1 + 5 = 6, so the generic root is 6. * <p> * Reference: * https://technotip.com/6774/c-program-to-find-generic-root-of-a-number/ */ public final class GenericRoot { private static final int BASE = 10; private GenericRoot() { } /** * Computes the sum of the digits of a non-negative integer in base 10. * * @param n non-negative integer * @return sum of digits of {@code n} */ private static int sumOfDigits(final int n) { assert n >= 0; if (n < BASE) { return n; } return (n % BASE) + sumOfDigits(n / BASE); } /** * Computes the generic root (repeated digital sum) of an integer. * For negative inputs, the absolute value is used. * * @param n integer input * @return generic root of {@code n} */ public static int genericRoot(final int n) { int number = Math.abs(n); if (number < BASE) { return number; } return genericRoot(sumOfDigits(number)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import java.util.ArrayList; final class GenericTree$Node { int a; ArrayList b = new ArrayList(); private GenericTree$Node() { } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import java.util.ArrayList; final class GenericTree$Node { int a; ArrayList b = new ArrayList(); private GenericTree$Node() { } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.GenericTree$Node; import java.util.ArrayList; import java.util.LinkedList; import java.util.Scanner; public class GenericTree { private final GenericTree$Node a; public GenericTree() { Scanner scanner = new Scanner(System.in); this.a = this.a(null, 0, scanner); } private GenericTree$Node a(GenericTree$Node genericTree$Node, int n, Scanner scanner) { if (genericTree$Node == null) { System.out.println(\"Enter root's data\"); } else { System.out.println(\"Enter data of parent of index \" + genericTree$Node.a + \" \" + n); } genericTree$Node = new GenericTree$Node(); new GenericTree$Node().a = scanner.nextInt(); System.out.println(\"number of children\"); n = scanner.nextInt(); for (int i = 0; i < n; ++i) { GenericTree$Node genericTree$Node2 = this.a(genericTree$Node, i, scanner); genericTree$Node.b.add(genericTree$Node2); } return genericTree$Node; } public void display() { GenericTree genericTree = this; genericTree.a(genericTree.a); } private void a(GenericTree$Node genericTree$Node) { int n; System.out.print(genericTree$Node.a + \"=>\"); for (n = 0; n < genericTree$Node.b.size(); ++n) { System.out.print(((GenericTree$Node)genericTree$Node.b.get((int)n)).a + \" \"); } System.out.println(\".\"); for (n = 0; n < genericTree$Node.b.size(); ++n) { this.a((GenericTree$Node)genericTree$Node.b.get(n)); } } public int size2call() { GenericTree genericTree = this; return genericTree.size2(genericTree.a); } public int size2(GenericTree$Node genericTree$Node) { int n = 0; for (int i = 0; i < genericTree$Node.b.size(); ++i) { n += this.size2((GenericTree$Node)genericTree$Node.b.get(i)); } return n + 1; } public int maxcall() { int n = this.a.a; GenericTree genericTree = this; return genericTree.a(genericTree.a, n); } private int a(GenericTree$Node genericTree$Node, int n) { if (n < genericTree$Node.a) { n = genericTree$Node.a; } for (int i = 0; i < genericTree$Node.b.size(); ++i) { n = this.a((GenericTree$Node)genericTree$Node.b.get(i), n); } return n; } public int heightcall() { GenericTree genericTree = this; return genericTree.b(genericTree.a) - 1; } private int b(GenericTree$Node genericTree$Node) { int n = 0; for (int i = 0; i < genericTree$Node.b.size(); ++i) { int n2 = this.b((GenericTree$Node)genericTree$Node.b.get(i)); if (n2 <= n) continue; n = n2; } return n + 1; } public boolean findcall(int n) { GenericTree genericTree = this; return genericTree.b(genericTree.a, n); } private boolean b(GenericTree$Node genericTree$Node, int n) { if (genericTree$Node.a == n) { return true; } for (int i = 0; i < genericTree$Node.b.size(); ++i) { if (!this.b((GenericTree$Node)genericTree$Node.b.get(i), n)) continue; return true; } return false; } public void depthcaller(int n) { GenericTree genericTree = this; genericTree.depth(genericTree.a, n); } public void depth(GenericTree$Node genericTree$Node, int n) { if (n == 0) { System.out.println(genericTree$Node.a); return; } for (int i = 0; i < genericTree$Node.b.size(); ++i) { this.depth((GenericTree$Node)genericTree$Node.b.get(i), n - 1); } } public void preordercall() { GenericTree genericTree = this; genericTree.c(genericTree.a); System.out.println(\".\"); } private void c(GenericTree$Node genericTree$Node) { System.out.print(genericTree$Node.a + \" \"); for (int i = 0; i < genericTree$Node.b.size(); ++i) { this.c((GenericTree$Node)genericTree$Node.b.get(i)); } } public void postordercall() { GenericTree genericTree = this; genericTree.d(genericTree.a); System.out.println(\".\"); } private void d(GenericTree$Node genericTree$Node) { for (int i = 0; i < genericTree$Node.b.size(); ++i) { this.d((GenericTree$Node)genericTree$Node.b.get(i)); } System.out.print(genericTree$Node.a + \" \"); } public void levelorder() { LinkedList<GenericTree$Node> linkedList = new LinkedList<GenericTree$Node>(); linkedList.addLast(this.a); while (!linkedList.isEmpty()) { int n = ((GenericTree$Node)linkedList.getFirst()).a; System.out.print(n + \" \"); for (n = 0; n < ((GenericTree$Node)linkedList.getFirst()).b.size(); ++n) { LinkedList<GenericTree$Node> linkedList2 = linkedList; linkedList2.addLast((GenericTree$Node)((GenericTree$Node)linkedList2.getFirst()).b.get(n)); } linkedList.removeFirst(); } System.out.println(\".\"); } public void removeleavescall() { GenericTree genericTree = this; genericTree.e(genericTree.a); } private void e(GenericTree$Node genericTree$Node) { int n; ArrayList<Integer> arrayList = new ArrayList<Integer>(); for (n = 0; n < genericTree$Node.b.size(); ++n) { if (((GenericTree$Node)genericTree$Node.b.get((int)n)).b.size() == 0) { arrayList.add(n); continue; } this.e((GenericTree$Node)genericTree$Node.b.get(n)); } for (n = arrayList.size() - 1; n >= 0; --n) { genericTree$Node.b.remove((Integer)arrayList.get(n)); } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayList; import java.util.LinkedList; import java.util.Scanner; /** * A generic tree is a tree which can have as many children as it can be It * might be possible that every node present is directly connected to root node. * * <p> * In this code Every function has two copies: one function is helper function * which can be called from main and from that function a private function is * called which will do the actual work. I have done this, while calling from * main one have to give minimum parameters. */ public class GenericTree { private static final class Node { int data; ArrayList<Node> child = new ArrayList<>(); } private final Node root; public GenericTree() { // Constructor Scanner scn = new Scanner(System.in); root = createTreeG(null, 0, scn); } private Node createTreeG(Node node, int childIndex, Scanner scanner) { // display if (node == null) { System.out.println(\"Enter root's data\"); } else { System.out.println(\"Enter data of parent of index \" + node.data + \" \" + childIndex); } // input node = new Node(); node.data = scanner.nextInt(); System.out.println(\"number of children\"); int number = scanner.nextInt(); for (int i = 0; i < number; i++) { Node child = createTreeG(node, i, scanner); node.child.add(child); } return node; } /** * Function to display the generic tree */ public void display() { // Helper function display1(root); } private void display1(Node parent) { System.out.print(parent.data + \"=>\"); for (int i = 0; i < parent.child.size(); i++) { System.out.print(parent.child.get(i).data + \" \"); } System.out.println(\".\"); for (int i = 0; i < parent.child.size(); i++) { display1(parent.child.get(i)); } } /** * One call store the size directly but if you are asked compute size this * function to calculate size goes as follows * * @return size */ public int size2call() { return size2(root); } public int size2(Node roott) { int sz = 0; for (int i = 0; i < roott.child.size(); i++) { sz += size2(roott.child.get(i)); } return sz + 1; } /** * Function to compute maximum value in the generic tree * * @return maximum value */ public int maxcall() { int maxi = root.data; return max(root, maxi); } private int max(Node roott, int maxi) { if (maxi < roott.data) { maxi = roott.data; } for (int i = 0; i < roott.child.size(); i++) { maxi = max(roott.child.get(i), maxi); } return maxi; } /** * Function to compute HEIGHT of the generic tree * * @return height */ public int heightcall() { return height(root) - 1; } private int height(Node node) { int h = 0; for (int i = 0; i < node.child.size(); i++) { int k = height(node.child.get(i)); if (k > h) { h = k; } } return h + 1; } /** * Function to find whether a number is present in the generic tree or not * * @param info number * @return present or not */ public boolean findcall(int info) { return find(root, info); } private boolean find(Node node, int info) { if (node.data == info) { return true; } for (int i = 0; i < node.child.size(); i++) { if (find(node.child.get(i), info)) { return true; } } return false; } /** * Function to calculate depth of generic tree * * @param dep depth */ public void depthcaller(int dep) { depth(root, dep); } public void depth(Node node, int dep) { if (dep == 0) { System.out.println(node.data); return; } for (int i = 0; i < node.child.size(); i++) { depth(node.child.get(i), dep - 1); } } /** * Function to print generic tree in pre-order */ public void preordercall() { preorder(root); System.out.println(\".\"); } private void preorder(Node node) { System.out.print(node.data + \" \"); for (int i = 0; i < node.child.size(); i++) { preorder(node.child.get(i)); } } /** * Function to print generic tree in post-order */ public void postordercall() { postorder(root); System.out.println(\".\"); } private void postorder(Node node) { for (int i = 0; i < node.child.size(); i++) { postorder(node.child.get(i)); } System.out.print(node.data + \" \"); } /** * Function to print generic tree in level-order */ public void levelorder() { LinkedList<Node> q = new LinkedList<>(); q.addLast(root); while (!q.isEmpty()) { int k = q.getFirst().data; System.out.print(k + \" \"); for (int i = 0; i < q.getFirst().child.size(); i++) { q.addLast(q.getFirst().child.get(i)); } q.removeFirst(); } System.out.println(\".\"); } /** * Function to remove all leaves of generic tree */ public void removeleavescall() { removeleaves(root); } private void removeleaves(Node node) { ArrayList<Integer> arr = new ArrayList<>(); for (int i = 0; i < node.child.size(); i++) { if (node.child.get(i).child.size() == 0) { arr.add(i); } else { removeleaves(node.child.get(i)); } } for (int i = arr.size() - 1; i >= 0; i--) { node.child.remove(arr.get(i) + 0); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class GnomeSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { int n = 1; int n2 = 2; while (n < comparableArray.length) { if (SortUtils.less(comparableArray[n - 1], comparableArray[n])) { n = n2++; continue; } SortUtils.swap(comparableArray, n - 1, n); if (--n != 0) continue; n = n2++; } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * Implementation of gnome sort * * @author Podshivalov Nikita (https://github.com/nikitap492) * @since 2018-04-10 */ public class GnomeSort implements SortAlgorithm { @Override public <T extends Comparable<T>> T[] sort(final T[] array) { int i = 1; int j = 2; while (i < array.length) { if (SortUtils.less(array[i - 1], array[i])) { i = j++; } else { SortUtils.swap(array, i - 1, i); if (--i == 0) { i = j++; } } } return array; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; public final class GoldbachConjecture$Result extends Record { private final int a; private final int b; public GoldbachConjecture$Result(int n, int n2) { this.a = n; this.b = n2; } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{GoldbachConjecture$Result.class, \"number1;number2\", \"a\", \"b\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{GoldbachConjecture$Result.class, \"number1;number2\", \"a\", \"b\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{GoldbachConjecture$Result.class, \"number1;number2\", \"a\", \"b\"}, this, object); } public final int number1() { return this.a; } public final int number2() { return this.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; public final class GoldbachConjecture$Result extends Record { private final int a; private final int b; public GoldbachConjecture$Result(int n, int n2) { this.a = n; this.b = n2; } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{GoldbachConjecture$Result.class, \"number1;number2\", \"a\", \"b\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{GoldbachConjecture$Result.class, \"number1;number2\", \"a\", \"b\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{GoldbachConjecture$Result.class, \"number1;number2\", \"a\", \"b\"}, this, object); } public final int number1() { return this.a; } public final int number2() { return this.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.GoldbachConjecture$Result; import com.thealgorithms.maths.Prime.PrimeCheck; public final class GoldbachConjecture { private GoldbachConjecture() { } public static GoldbachConjecture$Result getPrimeSum(int n) { if (n <= 2 || n % 2 != 0) { throw new IllegalArgumentException(\"Number must be even and greater than 2.\"); } for (int i = 0; i <= n / 2; ++i) { if (!PrimeCheck.isPrime(i) || !PrimeCheck.isPrime(n - i)) continue; return new GoldbachConjecture$Result(i, n - i); } throw new IllegalStateException(\"No valid prime sum found.\"); } }", "deobfuscated_code": "package com.thealgorithms.maths; import static com.thealgorithms.maths.Prime.PrimeCheck.isPrime; /** * This is a representation of the unsolved problem of Goldbach's Projection, according to which every * even natural number greater than 2 can be written as the sum of 2 prime numbers * More info: https://en.wikipedia.org/wiki/Goldbach%27s_conjecture * @author Vasilis Sarantidis (https://github.com/BILLSARAN) */ public final class GoldbachConjecture { private GoldbachConjecture() { } public record Result(int number1, int number2) { } public static Result getPrimeSum(int number) { if (number <= 2 || number % 2 != 0) { throw new IllegalArgumentException(\"Number must be even and greater than 2.\"); } for (int i = 0; i <= number / 2; i++) { if (isPrime(i) && isPrime(number - i)) { return new Result(i, number - i); } } throw new IllegalStateException(\"No valid prime sum found.\"); // Should not occur } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.geometry; import com.thealgorithms.geometry.Point; import java.util.ArrayList; import java.util.Arrays; import java.util.Stack; public class GrahamScan { private final Stack a = new Stack(); public GrahamScan(Point[] pointArray) { int n; int n2; Arrays.sort(pointArray); Arrays.sort(pointArray, 1, pointArray.length, pointArray[0].polarOrder()); this.a.push(pointArray[0]); for (n2 = 1; n2 < pointArray.length && pointArray[0].equals(pointArray[n2]); ++n2) { } if (n2 == pointArray.length) { return; } for (n = n2 + 1; n < pointArray.length && Point.orientation(pointArray[0], pointArray[n2], pointArray[n]) == 0; ++n) { } this.a.push(pointArray[n - 1]); for (n2 = n; n2 < pointArray.length; ++n2) { Point point = (Point)this.a.pop(); while (Point.orientation((Point)this.a.peek(), point, pointArray[n2]) <= 0) { point = (Point)this.a.pop(); } this.a.push(point); this.a.push(pointArray[n2]); } } public Iterable hull() { return new ArrayList(this.a); } }", "deobfuscated_code": "package com.thealgorithms.geometry; import java.util.ArrayList; import java.util.Arrays; import java.util.Stack; /** * A Java program that computes the convex hull using the Graham Scan algorithm. * The time complexity is O(n) in the best case and O(n log(n)) in the worst case. * The space complexity is O(n). * This algorithm is applicable only to integral coordinates. * * References: * https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/geometry/graham_scan_algorithm.cpp * https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/geometry/graham_scan_functions.hpp * https://algs4.cs.princeton.edu/99hull/GrahamScan.java.html */ public class GrahamScan { private final Stack<Point> hull = new Stack<>(); public GrahamScan(Point[] points) { // Pre-process points: sort by y-coordinate, then by polar order with respect to the first point Arrays.sort(points); Arrays.sort(points, 1, points.length, points[0].polarOrder()); hull.push(points[0]); // Find the first point not equal to points[0] (firstNonEqualIndex) // and the first point not collinear firstNonCollinearIndex with the previous points int firstNonEqualIndex; for (firstNonEqualIndex = 1; firstNonEqualIndex < points.length; firstNonEqualIndex++) { if (!points[0].equals(points[firstNonEqualIndex])) { break; } } if (firstNonEqualIndex == points.length) { return; } int firstNonCollinearIndex; for (firstNonCollinearIndex = firstNonEqualIndex + 1; firstNonCollinearIndex < points.length; firstNonCollinearIndex++) { if (Point.orientation(points[0], points[firstNonEqualIndex], points[firstNonCollinearIndex]) != 0) { break; } } hull.push(points[firstNonCollinearIndex - 1]); // Process the remaining points and update the hull for (int i = firstNonCollinearIndex; i < points.length; i++) { Point top = hull.pop(); while (Point.orientation(hull.peek(), top, points[i]) <= 0) { top = hull.pop(); } hull.push(top); hull.push(points[i]); } } /** * @return An iterable collection of points representing the convex hull. */ public Iterable<Point> hull() { return new ArrayList<>(hull); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; public class Graph$Edge { public final String v1; public final String v2; public final int dist; Graph$Edge(String string, String string2, int n) { this.v1 = string; this.v2 = string2; this.dist = n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; public class Graph$Edge { public final String v1; public final String v2; public final int dist; Graph$Edge(String string, String string2, int n) { this.v1 = string; this.v2 = string2; this.dist = n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class Graph$Node { Comparable a; Graph$Node(Comparable comparable) { this.a = comparable; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class Graph$Node { Comparable a; Graph$Node(Comparable comparable) { this.a = comparable; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.HashMap; import java.util.Map; public class Graph$Vertex implements Comparable { public final String name; public int dist = Integer.MAX_VALUE; public Graph$Vertex previous = null; public final Map neighbours = new HashMap(); Graph$Vertex(String string) { this.name = string; } private void a() { Graph$Vertex graph$Vertex = this; if (graph$Vertex == graph$Vertex.previous) { System.out.printf(\"%s\", this.name); return; } if (this.previous == null) { System.out.printf(\"%s(unreached)\", this.name); return; } this.previous.a(); System.out.printf(\" -> %s(%d)\", this.name, this.dist); } public int compareTo(Graph$Vertex graph$Vertex) { if (this.dist == graph$Vertex.dist) { return this.name.compareTo(graph$Vertex.name); } return Integer.compare(this.dist, graph$Vertex.dist); } public boolean equals(Object object) { if (this == object) { return true; } if (object == null || this.getClass() != object.getClass()) { return false; } if (!super.equals(object)) { return false; } object = (Graph$Vertex)object; if (this.dist != ((Graph$Vertex)object).dist) { return false; } if (this.name != null ? !this.name.equals(((Graph$Vertex)object).name) : ((Graph$Vertex)object).name != null) { return false; } if (this.previous != null ? !this.previous.equals(((Graph$Vertex)object).previous) : ((Graph$Vertex)object).previous != null) { return false; } if (this.neighbours != null) { return this.neighbours.equals(((Graph$Vertex)object).neighbours); } return ((Graph$Vertex)object).neighbours == null; } public int hashCode() { int n = super.hashCode(); n = n * 31 + (this.name != null ? this.name.hashCode() : 0); n = n * 31 + this.dist; n = n * 31 + (this.previous != null ? this.previous.hashCode() : 0); n = n * 31 + (this.neighbours != null ? this.neighbours.hashCode() : 0); return n; } public String toString() { return \"(\" + this.name + \", \" + this.dist + \")\"; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.HashMap; import java.util.Map; public class Graph$Vertex implements Comparable { public final String name; public int dist = Integer.MAX_VALUE; public Graph$Vertex previous = null; public final Map neighbours = new HashMap(); Graph$Vertex(String string) { this.name = string; } private void a() { Graph$Vertex graph$Vertex = this; if (graph$Vertex == graph$Vertex.previous) { System.out.printf(\"%s\", this.name); return; } if (this.previous == null) { System.out.printf(\"%s(unreached)\", this.name); return; } this.previous.a(); System.out.printf(\" -> %s(%d)\", this.name, this.dist); } public int compareTo(Graph$Vertex graph$Vertex) { if (this.dist == graph$Vertex.dist) { return this.name.compareTo(graph$Vertex.name); } return Integer.compare(this.dist, graph$Vertex.dist); } public boolean equals(Object object) { if (this == object) { return true; } if (object == null || this.getClass() != object.getClass()) { return false; } if (!super.equals(object)) { return false; } object = (Graph$Vertex)object; if (this.dist != ((Graph$Vertex)object).dist) { return false; } if (this.name != null ? !this.name.equals(((Graph$Vertex)object).name) : ((Graph$Vertex)object).name != null) { return false; } if (this.previous != null ? !this.previous.equals(((Graph$Vertex)object).previous) : ((Graph$Vertex)object).previous != null) { return false; } if (this.neighbours != null) { return this.neighbours.equals(((Graph$Vertex)object).neighbours); } return ((Graph$Vertex)object).neighbours == null; } public int hashCode() { int n = super.hashCode(); n = n * 31 + (this.name != null ? this.name.hashCode() : 0); n = n * 31 + this.dist; n = n * 31 + (this.previous != null ? this.previous.hashCode() : 0); n = n * 31 + (this.neighbours != null ? this.neighbours.hashCode() : 0); return n; } public String toString() { return \"(\" + this.name + \", \" + this.dist + \")\"; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.Graph$Edge; import com.thealgorithms.others.Graph$Vertex; import java.util.HashMap; import java.util.Map; import java.util.TreeSet; class Graph { private final Map a; Graph(Graph$Edge[] graph$EdgeArray) { Graph$Edge graph$Edge; int n; this.a = new HashMap(graph$EdgeArray.length); Graph$Edge[] graph$EdgeArray2 = graph$EdgeArray; int n2 = graph$EdgeArray.length; for (n = 0; n < n2; ++n) { graph$Edge = graph$EdgeArray2[n]; if (!this.a.containsKey(graph$Edge.v1)) { this.a.put(graph$Edge.v1, new Graph$Vertex(graph$Edge.v1)); } if (this.a.containsKey(graph$Edge.v2)) continue; this.a.put(graph$Edge.v2, new Graph$Vertex(graph$Edge.v2)); } graph$EdgeArray2 = graph$EdgeArray; n2 = graph$EdgeArray.length; for (n = 0; n < n2; ++n) { graph$Edge = graph$EdgeArray2[n]; ((Graph$Vertex)this.a.get((Object)graph$Edge.v1)).neighbours.put((Graph$Vertex)this.a.get(graph$Edge.v2), graph$Edge.dist); } } public void dijkstra(String treeSet) { if (!this.a.containsKey(treeSet)) { System.err.printf(\"Graph doesn't contain start vertex \\\"%s\\\"%n\", treeSet); return; } treeSet = (Graph$Vertex)this.a.get(treeSet); Object object = new TreeSet<Object>(); for (Object object2 : this.a.values()) { ((Graph$Vertex)graph$Vertex.next()).previous = object2 == treeSet ? treeSet : null; ((Graph$Vertex)object2).dist = object2 == treeSet ? 0 : Integer.MAX_VALUE; object.add(object2); } treeSet = object; while (!treeSet.isEmpty()) { object = (Graph$Vertex)treeSet.pollFirst(); if (((Graph$Vertex)object).dist == Integer.MAX_VALUE) break; for (Map.Entry entry : ((Graph$Vertex)object).neighbours.entrySet()) { Graph$Vertex graph$Vertex = (Graph$Vertex)entry.getKey(); int n = ((Graph$Vertex)object).dist + (Integer)entry.getValue(); if (n >= graph$Vertex.dist) continue; treeSet.remove(graph$Vertex); graph$Vertex.dist = n; graph$Vertex.previous = object; treeSet.add(graph$Vertex); } } } public void printPath(String string) { if (!this.a.containsKey(string)) { System.err.printf(\"Graph doesn't contain end vertex \\\"%s\\\"%n\", string); return; } ((Graph$Vertex)this.a.get(string)).a(); System.out.println(); } public void printAllPaths() { for (Graph$Vertex graph$Vertex : this.a.values()) { graph$Vertex.a(); System.out.println(); } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.Graph$Edge; import com.thealgorithms.others.Graph$Vertex; import java.util.HashMap; import java.util.Map; import java.util.TreeSet; class Graph { private final Map a; Graph(Graph$Edge[] graph$EdgeArray) { Graph$Edge graph$Edge; int n; this.a = new HashMap(graph$EdgeArray.length); Graph$Edge[] graph$EdgeArray2 = graph$EdgeArray; int n2 = graph$EdgeArray.length; for (n = 0; n < n2; ++n) { graph$Edge = graph$EdgeArray2[n]; if (!this.a.containsKey(graph$Edge.v1)) { this.a.put(graph$Edge.v1, new Graph$Vertex(graph$Edge.v1)); } if (this.a.containsKey(graph$Edge.v2)) continue; this.a.put(graph$Edge.v2, new Graph$Vertex(graph$Edge.v2)); } graph$EdgeArray2 = graph$EdgeArray; n2 = graph$EdgeArray.length; for (n = 0; n < n2; ++n) { graph$Edge = graph$EdgeArray2[n]; ((Graph$Vertex)this.a.get((Object)graph$Edge.v1)).neighbours.put((Graph$Vertex)this.a.get(graph$Edge.v2), graph$Edge.dist); } } public void dijkstra(String treeSet) { if (!this.a.containsKey(treeSet)) { System.err.printf(\"Graph doesn't contain start vertex \\\"%s\\\"%n\", treeSet); return; } treeSet = (Graph$Vertex)this.a.get(treeSet); Object object = new TreeSet<Object>(); for (Object object2 : this.a.values()) { ((Graph$Vertex)graph$Vertex.next()).previous = object2 == treeSet ? treeSet : null; ((Graph$Vertex)object2).dist = object2 == treeSet ? 0 : Integer.MAX_VALUE; object.add(object2); } treeSet = object; while (!treeSet.isEmpty()) { object = (Graph$Vertex)treeSet.pollFirst(); if (((Graph$Vertex)object).dist == Integer.MAX_VALUE) break; for (Map.Entry entry : ((Graph$Vertex)object).neighbours.entrySet()) { Graph$Vertex graph$Vertex = (Graph$Vertex)entry.getKey(); int n = ((Graph$Vertex)object).dist + (Integer)entry.getValue(); if (n >= graph$Vertex.dist) continue; treeSet.remove(graph$Vertex); graph$Vertex.dist = n; graph$Vertex.previous = object; treeSet.add(graph$Vertex); } } } public void printPath(String string) { if (!this.a.containsKey(string)) { System.err.printf(\"Graph doesn't contain end vertex \\\"%s\\\"%n\", string); return; } ((Graph$Vertex)this.a.get(string)).a(); System.out.println(); } public void printAllPaths() { for (Graph$Vertex graph$Vertex : this.a.values()) { graph$Vertex.a(); System.out.println(); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.AdjacencyListGraph; public final class Graphs { private Graphs() { } public static void main(String[] object) { object = new AdjacencyListGraph(); assert (((AdjacencyListGraph)object).addEdge(Integer.valueOf(1), Integer.valueOf(2))); assert (((AdjacencyListGraph)object).addEdge(Integer.valueOf(1), Integer.valueOf(5))); assert (((AdjacencyListGraph)object).addEdge(Integer.valueOf(2), Integer.valueOf(5))); assert (!((AdjacencyListGraph)object).addEdge(Integer.valueOf(1), Integer.valueOf(2))); assert (((AdjacencyListGraph)object).addEdge(Integer.valueOf(2), Integer.valueOf(3))); assert (((AdjacencyListGraph)object).addEdge(Integer.valueOf(3), Integer.valueOf(4))); assert (((AdjacencyListGraph)object).addEdge(Integer.valueOf(4), Integer.valueOf(1))); assert (!((AdjacencyListGraph)object).addEdge(Integer.valueOf(2), Integer.valueOf(3))); System.out.println(object); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; class AdjacencyListGraph<E extends Comparable<E>> { ArrayList<Vertex> vertices; AdjacencyListGraph() { vertices = new ArrayList<>(); } private class Vertex { E data; ArrayList<Vertex> adjacentVertices; Vertex(E data) { adjacentVertices = new ArrayList<>(); this.data = data; } public boolean addAdjacentVertex(Vertex to) { for (Vertex v : adjacentVertices) { if (v.data.compareTo(to.data) == 0) { return false; // the edge already exists } } return adjacentVertices.add(to); // this will return true; } public boolean removeAdjacentVertex(E to) { // use indexes here so it is possible to // remove easily without implementing // equals method that ArrayList.remove(Object o) uses for (int i = 0; i < adjacentVertices.size(); i++) { if (adjacentVertices.get(i).data.compareTo(to) == 0) { adjacentVertices.remove(i); return true; } } return false; } } /** * this method removes an edge from the graph between two specified * vertices * * @param from the data of the vertex the edge is from * @param to the data of the vertex the edge is going to * @return returns false if the edge doesn't exist, returns true if the edge * exists and is removed */ public boolean removeEdge(E from, E to) { Vertex fromV = null; for (Vertex v : vertices) { if (from.compareTo(v.data) == 0) { fromV = v; break; } } if (fromV == null) { return false; } return fromV.removeAdjacentVertex(to); } /** * this method adds an edge to the graph between two specified vertices * * @param from the data of the vertex the edge is from * @param to the data of the vertex the edge is going to * @return returns true if the edge did not exist, return false if it * already did */ public boolean addEdge(E from, E to) { Vertex fromV = null; Vertex toV = null; for (Vertex v : vertices) { if (from.compareTo(v.data) == 0) { // see if from vertex already exists fromV = v; } else if (to.compareTo(v.data) == 0) { // see if to vertex already exists toV = v; } if (fromV != null && toV != null) { break; // both nodes exist so stop searching } } if (fromV == null) { fromV = new Vertex(from); vertices.add(fromV); } if (toV == null) { toV = new Vertex(to); vertices.add(toV); } return fromV.addAdjacentVertex(toV); } /** * this gives a list of vertices in the graph and their adjacencies * * @return returns a string describing this graph */ @Override public String toString() { StringBuilder sb = new StringBuilder(); for (Vertex v : vertices) { sb.append(\"Vertex: \"); sb.append(v.data); sb.append(\"\\n\"); sb.append(\"Adjacent vertices: \"); for (Vertex v2 : v.adjacentVertices) { sb.append(v2.data); sb.append(\" \"); } sb.append(\"\\n\"); } return sb.toString(); } } public final class Graphs { private Graphs() { } public static void main(String[] args) { AdjacencyListGraph<Integer> graph = new AdjacencyListGraph<>(); assert graph.addEdge(1, 2); assert graph.addEdge(1, 5); assert graph.addEdge(2, 5); assert !graph.addEdge(1, 2); assert graph.addEdge(2, 3); assert graph.addEdge(3, 4); assert graph.addEdge(4, 1); assert !graph.addEdge(2, 3); System.out.println(graph); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class GrayCodeConversion { private GrayCodeConversion() { } public static int binaryToGray(int n) { int n2 = n; return n2 ^ n2 >> 1; } public static int grayToBinary(int n) { int n2 = n; while (n > 0) { n2 ^= (n >>= 1); } return n2; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * Gray code is a binary numeral system where two successive values differ in only one bit. * This is a simple conversion between binary and Gray code. * Example: * 7 -> 0111 -> 0100 -> 4 * 4 -> 0100 -> 0111 -> 7 * 0 -> 0000 -> 0000 -> 0 * 1 -> 0001 -> 0000 -> 0 * 2 -> 0010 -> 0011 -> 3 * 3 -> 0011 -> 0010 -> 2 * * @author Hardvan */ public final class GrayCodeConversion { private GrayCodeConversion() { } /** * Converts a binary number to Gray code. * * @param num The binary number. * @return The corresponding Gray code. */ public static int binaryToGray(int num) { return num ^ (num >> 1); } /** * Converts a Gray code number back to binary. * * @param gray The Gray code number. * @return The corresponding binary number. */ public static int grayToBinary(int gray) { int binary = gray; while (gray > 0) { gray >>= 1; binary ^= gray; } return binary; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.NoSuchElementException; import java.util.Stack; public class GreatestElementConstantTime { private Stack a = new Stack(); private Stack b = new Stack(); public void push(int n) { if (this.a.isEmpty()) { this.a.push(n); this.b.push(n); return; } this.a.push(n); if (n > (Integer)this.b.peek()) { this.b.push(n); } } public void pop() { if (this.a.isEmpty()) { throw new NoSuchElementException(\"Stack is empty\"); } int n = (Integer)this.a.pop(); if (n == (Integer)this.b.peek()) { this.b.pop(); } } public Integer getMaximumElement() { if (this.b.isEmpty()) { return null; } return (Integer)this.b.peek(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.NoSuchElementException; import java.util.Stack; /** * A class that implements a stack that gives the maximum element in O(1) time. * The mainStack is used to store the all the elements of the stack * While the maxStack stores the maximum elements * When we want to get a maximum element, we call the top of the maximum stack * * Problem: https://www.baeldung.com/cs/stack-constant-time */ public class GreatestElementConstantTime { private Stack<Integer> mainStack; // initialize a mainStack private Stack<Integer> maxStack; // initialize a maxStack /** * Constructs two empty stacks */ public GreatestElementConstantTime() { mainStack = new Stack<>(); maxStack = new Stack<>(); } /** * Pushes an element onto the top of the stack. * Checks if the element is the maximum or not * If so, then pushes to the maximum stack * @param data The element to be pushed onto the stack. */ public void push(int data) { if (mainStack.isEmpty()) { mainStack.push(data); maxStack.push(data); return; } mainStack.push(data); if (data > maxStack.peek()) { maxStack.push(data); } } /** * Pops an element from the stack. * Checks if the element to be popped is the maximum or not * If so, then pop from the minStack * * @throws NoSuchElementException if the stack is empty. */ public void pop() { if (mainStack.isEmpty()) { throw new NoSuchElementException(\"Stack is empty\"); } int ele = mainStack.pop(); if (ele == maxStack.peek()) { maxStack.pop(); } } /** * Returns the maximum element present in the stack * * @return The element at the top of the maxStack, or null if the stack is empty. */ public Integer getMaximumElement() { if (maxStack.isEmpty()) { return null; } return maxStack.peek(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.Arrays; public class HamiltonianCycle { private int a; private int b; private int[] c; private int[][] d; public int[] findHamiltonianCycle(int[][] nArray) { if (nArray.length == 1) { return new int[]{0, 0}; } this.a = nArray.length; this.c = new int[this.a + 1]; Arrays.fill(this.c, -1); this.d = nArray; this.c[0] = 0; this.b = 1; if (!this.isPathFound(0)) { Arrays.fill(this.c, -1); } else { this.c[this.c.length - 1] = this.c[0]; } return this.c; } public boolean isPathFound(int n) { int n2 = this.d[n][0] == 1 && this.b == this.a ? 1 : 0; if (n2 != 0) { return true; } if (this.b == this.a) { return false; } for (n2 = 0; n2 < this.a; ++n2) { if (this.d[n][n2] != 1) continue; this.c[this.b++] = n2; this.d[n][n2] = 0; this.d[n2][n] = 0; if (!this.isPresent(n2)) { return this.isPathFound(n2); } this.d[n][n2] = 1; this.d[n2][n] = 1; this.c[--this.b] = -1; } return false; } public boolean isPresent(int n) { for (int i = 0; i < this.b - 1; ++i) { if (this.c[i] != n) continue; return true; } return false; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.Arrays; /** * Java program to find a Hamiltonian Cycle in a graph. * A Hamiltonian Cycle is a cycle that visits every vertex exactly once * and returns to the starting vertex. * * <p>For more details, see the * <a href=\"https://en.wikipedia.org/wiki/Hamiltonian_path\">Wikipedia article</a>. * * @author <a href=\"https://github.com/itsAkshayDubey\">Akshay Dubey</a> */ public class HamiltonianCycle { private int vertex; private int pathCount; private int[] cycle; private int[][] graph; /** * Finds a Hamiltonian Cycle for the given graph. * * @param graph Adjacency matrix representing the graph G(V, E), where V is * the set of vertices and E is the set of edges. * @return An array representing the Hamiltonian cycle if found, otherwise an * array filled with -1 indicating no Hamiltonian cycle exists. */ public int[] findHamiltonianCycle(int[][] graph) { // Single vertex graph if (graph.length == 1) { return new int[] {0, 0}; } this.vertex = graph.length; this.cycle = new int[this.vertex + 1]; // Initialize the cycle array with -1 to represent unvisited vertices Arrays.fill(this.cycle, -1); this.graph = graph; this.cycle[0] = 0; this.pathCount = 1; if (!isPathFound(0)) { Arrays.fill(this.cycle, -1); } else { this.cycle[this.cycle.length - 1] = this.cycle[0]; } return cycle; } /** * Recursively searches for a Hamiltonian cycle from the given vertex. * * @param vertex The current vertex from which to explore paths. * @return {@code true} if a Hamiltonian cycle is found, otherwise {@code false}. */ public boolean isPathFound(int vertex) { boolean isLastVertexConnectedToStart = this.graph[vertex][0] == 1 && this.pathCount == this.vertex; if (isLastVertexConnectedToStart) { return true; } // If all vertices are visited but the last vertex is not connected to the start if (this.pathCount == this.vertex) { return false; } for (int v = 0; v < this.vertex; v++) { if (this.graph[vertex][v] == 1) { // Check if there is an edge this.cycle[this.pathCount++] = v; // Add the vertex to the cycle this.graph[vertex][v] = 0; this.graph[v][vertex] = 0; // Recursively attempt to complete the cycle if (!isPresent(v)) { return isPathFound(v); } // Restore the edge if the path does not work this.graph[vertex][v] = 1; this.graph[v][vertex] = 1; this.cycle[--this.pathCount] = -1; } } return false; } /** * Checks if a vertex is already part of the current Hamiltonian path. * * @param vertex The vertex to check. * @return {@code true} if the vertex is already in the path, otherwise {@code false}. */ public boolean isPresent(int vertex) { for (int i = 0; i < pathCount - 1; i++) { if (cycle[i] == vertex) { return true; } } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class HammingDistance { private HammingDistance() { } public static int calculateHammingDistance(String string, String string2) { if (string == null || string2 == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } if (string.length() != string2.length()) { throw new IllegalArgumentException(\"String lengths must be equal\"); } int n = 0; for (int i = 0; i < string.length(); ++i) { if (string.charAt(i) == string2.charAt(i)) continue; ++n; } return n; } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * Class for calculating the Hamming distance between two strings of equal length. * <p> * The Hamming distance is the number of positions at which the corresponding symbols are different. * It is used in information theory, coding theory, and computer science. * </p> * @see <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\">Hamming distance - Wikipedia</a> */ public final class HammingDistance { private HammingDistance() { } /** * Calculates the Hamming distance between two strings of equal length. * <p> * The Hamming distance is defined only for strings of equal length. If the strings are not * of equal length, this method throws an {@code IllegalArgumentException}. * </p> * * @param s1 the first string * @param s2 the second string * @return the Hamming distance between the two strings * @throws IllegalArgumentException if the lengths of {@code s1} and {@code s2} are not equal */ public static int calculateHammingDistance(String s1, String s2) { if (s1 == null || s2 == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } if (s1.length() != s2.length()) { throw new IllegalArgumentException(\"String lengths must be equal\"); } int distance = 0; for (int i = 0; i < s1.length(); i++) { if (s1.charAt(i) != s2.charAt(i)) { distance++; } } return distance; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Arrays; import java.util.HashSet; import java.util.Scanner; import java.util.Set; public final class HappyNumbersSeq { private static final Set a = new HashSet<Integer>(Arrays.asList(4, 16, 20, 37, 58, 145)); private HappyNumbersSeq() { } public static void main(String[] object) { int n; object = new Scanner(System.in); System.out.print(\"Enter number: \"); int n2 = ((Scanner)object).nextInt(); while (n2 != 1 && !a.contains(n = n2)) { System.out.print(n2 + \" \"); n = n2; n2 = 0; while (n > 0) { int n3; int n4 = n3 = n % 10; n2 += n4 * n4; n /= 10; } } String string = n2 == 1 ? \"1 Happy number\" : \"Sad number\"; System.out.println(string); ((Scanner)object).close(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Arrays; import java.util.HashSet; import java.util.Scanner; import java.util.Set; public final class HappyNumbersSeq { private HappyNumbersSeq() { } private static final Set<Integer> CYCLE_NUMS = new HashSet<>(Arrays.asList(4, 16, 20, 37, 58, 145)); public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.print(\"Enter number: \"); int n = in.nextInt(); while (n != 1 && !isSad(n)) { System.out.print(n + \" \"); n = sumSquares(n); } String res = n == 1 ? \"1 Happy number\" : \"Sad number\"; System.out.println(res); in.close(); } private static int sumSquares(int n) { int s = 0; for (; n > 0; n /= 10) { int r = n % 10; s += r * r; } return s; } private static boolean isSad(int n) { return CYCLE_NUMS.contains(n); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class HarshadNumber { private HarshadNumber() { } public static boolean isHarshad(long l) { if (l <= 0L) { return false; } long l2 = 0L; for (long i = l; i > 0L; i /= 10L) { l2 += i % 10L; } return l % l2 == 0L; } public static boolean isHarshad(String object) { Long l = Long.valueOf((String)object); if (l <= 0L) { return false; } int n = 0; char[] cArray = ((String)object).toCharArray(); object = cArray; int n2 = cArray.length; for (int i = 0; i < n2; ++i) { Object object2 = object[i]; n += object2 - 48; } return l % (long)n == 0L; } }", "deobfuscated_code": "package com.thealgorithms.maths; // Wikipedia for Harshad Number : https://en.wikipedia.org/wiki/Harshad_number public final class HarshadNumber { private HarshadNumber() { } /** * A function to check if a number is Harshad number or not * * @param n The number to be checked * @return {@code true} if {@code a} is Harshad number, otherwise * {@code false} */ public static boolean isHarshad(long n) { if (n <= 0) { return false; } long t = n; long sumOfDigits = 0; while (t > 0) { sumOfDigits += t % 10; t /= 10; } return n % sumOfDigits == 0; } /** * A function to check if a number is Harshad number or not * * @param s The number in String to be checked * @return {@code true} if {@code a} is Harshad number, otherwise * {@code false} */ public static boolean isHarshad(String s) { final Long n = Long.valueOf(s); if (n <= 0) { return false; } int sumOfDigits = 0; for (char ch : s.toCharArray()) { sumOfDigits += ch - '0'; } return n % sumOfDigits == 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import com.thealgorithms.datastructures.hashmap.hashing.HashMap$Node; public class HashMap$LinkedList { private HashMap$Node a; public void insert(Object object, Object object2) { HashMap$Node hashMap$Node = this.findKey(object); if (hashMap$Node != null) { hashMap$Node.setValue(object2); return; } if (this.isEmpty()) { this.a = new HashMap$Node(object, object2); return; } hashMap$Node = this.a; while (hashMap$Node.getNext() != null) { hashMap$Node = hashMap$Node.getNext(); } hashMap$Node.setNext(new HashMap$Node(object, object2)); } public HashMap$Node findKey(Object object) { for (HashMap$Node hashMap$Node = this.a; hashMap$Node != null; hashMap$Node = hashMap$Node.getNext()) { if ((object != null || hashMap$Node.getKey() != null) && (hashMap$Node.getKey() == null || !hashMap$Node.getKey().equals(object))) continue; return hashMap$Node; } return null; } public void delete(Object object) { if (this.isEmpty()) { return; } if (object == null && this.a.getKey() == null || this.a.getKey() != null && this.a.getKey().equals(object)) { this.a = this.a.getNext(); return; } HashMap$Node hashMap$Node = this.a; while (hashMap$Node.getNext() != null) { if (object == null && hashMap$Node.getNext().getKey() == null || hashMap$Node.getNext().getKey() != null && hashMap$Node.getNext().getKey().equals(object)) { HashMap$Node hashMap$Node2 = hashMap$Node; hashMap$Node2.setNext(hashMap$Node2.getNext().getNext()); return; } hashMap$Node = hashMap$Node.getNext(); } } public String display() { HashMap$Node hashMap$Node = this.a; StringBuilder stringBuilder = new StringBuilder(); while (hashMap$Node != null) { stringBuilder.append(hashMap$Node.getKey()).append(\"=\").append(hashMap$Node.getValue()); if ((hashMap$Node = hashMap$Node.getNext()) == null) continue; stringBuilder.append(\" -> \"); } if (stringBuilder.toString().isEmpty()) { return \"null\"; } return stringBuilder.toString(); } public boolean isEmpty() { return this.a == null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import com.thealgorithms.datastructures.hashmap.hashing.HashMap$Node; public class HashMap$LinkedList { private HashMap$Node a; public void insert(Object object, Object object2) { HashMap$Node hashMap$Node = this.findKey(object); if (hashMap$Node != null) { hashMap$Node.setValue(object2); return; } if (this.isEmpty()) { this.a = new HashMap$Node(object, object2); return; } hashMap$Node = this.a; while (hashMap$Node.getNext() != null) { hashMap$Node = hashMap$Node.getNext(); } hashMap$Node.setNext(new HashMap$Node(object, object2)); } public HashMap$Node findKey(Object object) { for (HashMap$Node hashMap$Node = this.a; hashMap$Node != null; hashMap$Node = hashMap$Node.getNext()) { if ((object != null || hashMap$Node.getKey() != null) && (hashMap$Node.getKey() == null || !hashMap$Node.getKey().equals(object))) continue; return hashMap$Node; } return null; } public void delete(Object object) { if (this.isEmpty()) { return; } if (object == null && this.a.getKey() == null || this.a.getKey() != null && this.a.getKey().equals(object)) { this.a = this.a.getNext(); return; } HashMap$Node hashMap$Node = this.a; while (hashMap$Node.getNext() != null) { if (object == null && hashMap$Node.getNext().getKey() == null || hashMap$Node.getNext().getKey() != null && hashMap$Node.getNext().getKey().equals(object)) { HashMap$Node hashMap$Node2 = hashMap$Node; hashMap$Node2.setNext(hashMap$Node2.getNext().getNext()); return; } hashMap$Node = hashMap$Node.getNext(); } } public String display() { HashMap$Node hashMap$Node = this.a; StringBuilder stringBuilder = new StringBuilder(); while (hashMap$Node != null) { stringBuilder.append(hashMap$Node.getKey()).append(\"=\").append(hashMap$Node.getValue()); if ((hashMap$Node = hashMap$Node.getNext()) == null) continue; stringBuilder.append(\" -> \"); } if (stringBuilder.toString().isEmpty()) { return \"null\"; } return stringBuilder.toString(); } public boolean isEmpty() { return this.a == null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; public class HashMap$Node { private final Object a; private Object b; private HashMap$Node c; public HashMap$Node(Object object, Object object2) { this.a = object; this.b = object2; } public Object getKey() { return this.a; } public Object getValue() { return this.b; } public void setValue(Object object) { this.b = object; } public HashMap$Node getNext() { return this.c; } public void setNext(HashMap$Node hashMap$Node) { this.c = hashMap$Node; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; public class HashMap$Node { private final Object a; private Object b; private HashMap$Node c; public HashMap$Node(Object object, Object object2) { this.a = object; this.b = object2; } public Object getKey() { return this.a; } public Object getValue() { return this.b; } public void setValue(Object object) { this.b = object; } public HashMap$Node getNext() { return this.c; } public void setNext(HashMap$Node hashMap$Node) { this.c = hashMap$Node; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import com.thealgorithms.datastructures.hashmap.hashing.HashMap$LinkedList; import com.thealgorithms.datastructures.hashmap.hashing.HashMap$Node; public class HashMap { private final int a; private final HashMap$LinkedList[] b; public HashMap(int n) { this.a = n; this.b = new HashMap$LinkedList[n]; for (int i = 0; i < n; ++i) { this.b[i] = new HashMap$LinkedList(); } } private int a(Object object) { if (object == null) { return 0; } int n = object.hashCode() % this.a; if (n < 0) { return n + this.a; } return n; } public void insert(Object object, Object object2) { int n = this.a(object); this.b[n].insert(object, object2); } public void delete(Object object) { int n = this.a(object); this.b[n].delete(object); } public Object search(Object object) { int n = this.a(object); if ((object = this.b[n].findKey(object)) != null) { return ((HashMap$Node)object).getValue(); } return null; } public void display() { for (int i = 0; i < this.a; ++i) { System.out.printf(\"Bucket %d: %s%n\", i, this.b[i].display()); } } public void clear() { for (int i = 0; i < this.a; ++i) { this.b[i] = new HashMap$LinkedList(); } } public int size() { int n = 0; for (int i = 0; i < this.a; ++i) { n += this.b[i].isEmpty() ? 0 : 1; } return n; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.hashmap.hashing; /** * A generic HashMap implementation that uses separate chaining with linked lists * to handle collisions. The class supports basic operations such as insert, delete, * and search, as well as displaying the contents of the hash map. * * @param <K> the type of keys maintained by this map * @param <V> the type of mapped values */ @SuppressWarnings(\"rawtypes\") public class HashMap<K, V> { private final int hashSize; private final LinkedList<K, V>[] buckets; /** * Constructs a HashMap with the specified hash size. * * @param hashSize the number of buckets in the hash map */ @SuppressWarnings(\"unchecked\") public HashMap(int hashSize) { this.hashSize = hashSize; // Safe to suppress warning because we are creating an array of generic type this.buckets = new LinkedList[hashSize]; for (int i = 0; i < hashSize; i++) { buckets[i] = new LinkedList<>(); } } /** * Computes the hash code for the specified key. * Null keys are hashed to bucket 0. * * @param key the key for which the hash code is to be computed * @return the hash code corresponding to the key */ private int computeHash(K key) { if (key == null) { return 0; // Use a special bucket (e.g., bucket 0) for null keys } int hash = key.hashCode() % hashSize; return hash < 0 ? hash + hashSize : hash; } /** * Inserts the specified key-value pair into the hash map. * If the key already exists, the value is updated. * * @param key the key to be inserted * @param value the value to be associated with the key */ public void insert(K key, V value) { int hash = computeHash(key); buckets[hash].insert(key, value); } /** * Deletes the key-value pair associated with the specified key from the hash map. * * @param key the key whose key-value pair is to be deleted */ public void delete(K key) { int hash = computeHash(key); buckets[hash].delete(key); } /** * Searches for the value associated with the specified key in the hash map. * * @param key the key whose associated value is to be returned * @return the value associated with the specified key, or null if the key does not exist */ public V search(K key) { int hash = computeHash(key); Node<K, V> node = buckets[hash].findKey(key); return node != null ? node.getValue() : null; } /** * Displays the contents of the hash map, showing each bucket and its key-value pairs. */ public void display() { for (int i = 0; i < hashSize; i++) { System.out.printf(\"Bucket %d: %s%n\", i, buckets[i].display()); } } /** * Clears the contents of the hash map by reinitializing each bucket. */ public void clear() { for (int i = 0; i < hashSize; i++) { buckets[i] = new LinkedList<>(); } } /** * Gets the number of key-value pairs in the hash map. * * @return the number of key-value pairs in the hash map */ public int size() { int size = 0; for (int i = 0; i < hashSize; i++) { size += buckets[i].isEmpty() ? 0 : 1; } return size; } /** * A nested static class that represents a linked list used for separate chaining in the hash map. * * @param <K> the type of keys maintained by this linked list * @param <V> the type of mapped values */ public static class LinkedList<K, V> { private Node<K, V> head; /** * Inserts the specified key-value pair into the linked list. * If the linked list is empty, the pair becomes the head. * Otherwise, the pair is added to the end of the list. * * @param key the key to be inserted * @param value the value to be associated with the key */ public void insert(K key, V value) { Node<K, V> existingNode = findKey(key); if (existingNode != null) { existingNode.setValue(value); // Update the value, even if it's null } else { if (isEmpty()) { head = new Node<>(key, value); } else { Node<K, V> temp = findEnd(head); temp.setNext(new Node<>(key, value)); } } } /** * Finds the last node in the linked list. * * @param node the starting node * @return the last node in the linked list */ private Node<K, V> findEnd(Node<K, V> node) { while (node.getNext() != null) { node = node.getNext(); } return node; } /** * Finds the node associated with the specified key in the linked list. * * @param key the key to search for * @return the node associated with the specified key, or null if not found */ public Node<K, V> findKey(K key) { Node<K, V> temp = head; while (temp != null) { if ((key == null && temp.getKey() == null) || (temp.getKey() != null && temp.getKey().equals(key))) { return temp; } temp = temp.getNext(); } return null; } /** * Deletes the node associated with the specified key from the linked list. * Handles the case where the key could be null. * * @param key the key whose associated node is to be deleted */ public void delete(K key) { if (isEmpty()) { return; } // Handle the case where the head node has the key to delete if ((key == null && head.getKey() == null) || (head.getKey() != null && head.getKey().equals(key))) { head = head.getNext(); return; } // Traverse the list to find and delete the node Node<K, V> current = head; while (current.getNext() != null) { if ((key == null && current.getNext().getKey() == null) || (current.getNext().getKey() != null && current.getNext().getKey().equals(key))) { current.setNext(current.getNext().getNext()); return; } current = current.getNext(); } } /** * Displays the contents of the linked list as a string. * * @return a string representation of the linked list */ public String display() { return display(head); } /** * Constructs a string representation of the linked list non-recursively. * * @param node the starting node * @return a string representation of the linked list starting from the given node */ private String display(Node<K, V> node) { StringBuilder sb = new StringBuilder(); while (node != null) { sb.append(node.getKey()).append(\"=\").append(node.getValue()); node = node.getNext(); if (node != null) { sb.append(\" -> \"); } } return sb.toString().isEmpty() ? \"null\" : sb.toString(); } /** * Checks if the linked list is empty. * * @return true if the linked list is empty, false otherwise */ public boolean isEmpty() { return head == null; } } /** * A nested static class representing a node in the linked list. * * @param <K> the type of key maintained by this node * @param <V> the type of value maintained by this node */ public static class Node<K, V> { private final K key; private V value; private Node<K, V> next; /** * Constructs a Node with the specified key and value. * * @param key the key associated with this node * @param value the value associated with this node */ public Node(K key, V value) { this.key = key; this.value = value; } /** * Gets the key associated with this node. * * @return the key associated with this node */ public K getKey() { return key; } /** * Gets the value associated with this node. * * @return the value associated with this node */ public V getValue() { return value; } public void setValue(V value) { // This method allows updating the value this.value = value; } /** * Gets the next node in the linked list. * * @return the next node in the linked list */ public Node<K, V> getNext() { return next; } /** * Sets the next node in the linked list. * * @param next the next node to be linked */ public void setNext(Node<K, V> next) { this.next = next; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import java.util.Objects; public class HashMapCuckooHashing { private int a; private Integer[] b; private final Integer c; private int d; private int e; public HashMapCuckooHashing(int n) { this.b = new Integer[n]; this.a = n; this.c = Integer.MIN_VALUE; this.d = 0; this.e = (int)(Math.log(n) / Math.log(2.0)) + 2; } public int hashFunction1(int n) { if ((n %= this.a) < 0) { n += this.a; } return n; } public int hashFunction2(int n) { n /= this.a; if ((n %= this.a) < 0) { n += this.a; } return n; } public void insertKey2HashTable(int n) { Integer n2 = n; int n3 = 0; if (this.isFull()) { System.out.println(\"Hash table is full, lengthening & rehashing table\"); this.reHashTableIncreasesTableSize(); } if (this.checkTableContainsKey(n)) { throw new IllegalArgumentException(\"Key already exists; duplicates are not allowed.\"); } while (n3 <= this.e) { ++n3; int n4 = this.hashFunction1(n); if (this.b[n4] == null || Objects.equals(this.b[n4], this.c)) { this.b[n4] = n2; ++this.d; this.checkLoadFactor(); return; } Integer n5 = this.b[n4]; this.b[n4] = n2; n2 = n5; n4 = this.hashFunction2(n5); if (Objects.equals(this.b[n4], this.c)) { this.b[n4] = n2; ++this.d; this.checkLoadFactor(); return; } if (this.b[n4] == null) { this.b[n4] = n2; ++this.d; this.checkLoadFactor(); return; } n5 = this.b[n4]; this.b[n4] = n2; n2 = n5; } System.out.println(\"Infinite loop occurred, lengthening & rehashing table\"); this.reHashTableIncreasesTableSize(); this.insertKey2HashTable(n); } public void reHashTableIncreasesTableSize() { HashMapCuckooHashing hashMapCuckooHashing = new HashMapCuckooHashing(this.a << 1); for (int i = 0; i < this.a; ++i) { if (this.b[i] == null || Objects.equals(this.b[i], this.c)) continue; hashMapCuckooHashing.insertKey2HashTable(this.b[i]); } this.a <<= 1; this.b = hashMapCuckooHashing.b; this.e = (int)(Math.log(this.a) / Math.log(2.0)) + 2; } public void deleteKeyFromHashTable(int n) { Integer n2 = n; int n3 = this.hashFunction1(n); if (this.isEmpty()) { throw new IllegalArgumentException(\"Table is empty, cannot delete.\"); } if (Objects.equals(this.b[n3], n2)) { this.b[n3] = this.c; --this.d; return; } n3 = this.hashFunction2(n); if (Objects.equals(this.b[n3], n2)) { this.b[n3] = this.c; --this.d; return; } throw new IllegalArgumentException(\"Key \" + n + \" not found in the table.\"); } public void displayHashtable() { for (int i = 0; i < this.a; ++i) { if (this.b[i] == null || Objects.equals(this.b[i], this.c)) { System.out.println(\"Bucket \" + i + \": Empty\"); continue; } System.out.println(\"Bucket \" + i + \": \" + this.b[i].toString()); } System.out.println(); } public int findKeyInTable(int n) { Integer n2 = n; int n3 = this.hashFunction1(n); if (this.isEmpty()) { throw new IllegalArgumentException(\"Table is empty; cannot find keys.\"); } if (Objects.equals(this.b[n3], n2)) { return n3; } n3 = this.hashFunction2(n); if (!Objects.equals(this.b[n3], n2)) { throw new IllegalArgumentException(\"Key \" + n + \" not found in the table.\"); } return n3; } public boolean checkTableContainsKey(int n) { return this.b[this.hashFunction1(n)] != null && this.b[this.hashFunction1(n)].equals(n) || this.b[this.hashFunction2(n)] != null && this.b[this.hashFunction2(n)].equals(n); } public double checkLoadFactor() { double d; double d2 = (double)this.d / (double)this.a; if (d > 0.7) { System.out.printf(\"Load factor is %.2f, rehashing table.%n\", d2); this.reHashTableIncreasesTableSize(); } return d2; } public boolean isFull() { for (int i = 0; i < this.a; ++i) { if (this.b[i] != null && !Objects.equals(this.b[i], this.c)) continue; return false; } return true; } public boolean isEmpty() { for (int i = 0; i < this.a; ++i) { if (this.b[i] == null) continue; return false; } return true; } public int getNumberOfKeysInTable() { return this.d; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.hashmap.hashing; import java.util.Objects; /** * This class implements a hash table using Cuckoo Hashing. * Cuckoo hashing is a type of open-addressing hash table that resolves collisions * by relocating existing keys. It utilizes two hash functions to minimize collisions * and automatically resizes the table when the load factor exceeds 0.7. * * For more information on cuckoo hashing, refer to * <a href=\"https://en.wikipedia.org/wiki/Cuckoo_hashing\">this Wikipedia page</a>. */ public class HashMapCuckooHashing { private int tableSize; // Size of the hash table private Integer[] buckets; // Array representing the hash table private final Integer emptySlot; // Placeholder for deleted slots private int size; // Number of elements in the hash table private int thresh; // Threshold for detecting infinite loops during insertion /** * Constructs a HashMapCuckooHashing object with the specified initial table size. * * @param tableSize the initial size of the hash map */ public HashMapCuckooHashing(int tableSize) { this.buckets = new Integer[tableSize]; this.tableSize = tableSize; this.emptySlot = Integer.MIN_VALUE; this.size = 0; this.thresh = (int) (Math.log(tableSize) / Math.log(2)) + 2; } /** * Computes the first hash index for a given key using the modulo operation. * * @param key the key for which the hash index is computed * @return an integer index corresponding to the key */ public int hashFunction1(int key) { int hash = key % tableSize; if (hash < 0) { hash += tableSize; } return hash; } /** * Computes the second hash index for a given key using integer division. * * @param key the key for which the hash index is computed * @return an integer index corresponding to the key */ public int hashFunction2(int key) { int hash = key / tableSize; hash %= tableSize; if (hash < 0) { hash += tableSize; } return hash; } /** * Inserts a key into the hash table using cuckoo hashing. * If the target bucket is occupied, it relocates the existing key and attempts to insert * it into its alternate location. If the insertion process exceeds the threshold, * the table is resized. * * @param key the key to be inserted into the hash table * @throws IllegalArgumentException if the key already exists in the table */ public void insertKey2HashTable(int key) { Integer wrappedInt = key; Integer temp; int hash; int loopCounter = 0; if (isFull()) { System.out.println(\"Hash table is full, lengthening & rehashing table\"); reHashTableIncreasesTableSize(); } if (checkTableContainsKey(key)) { throw new IllegalArgumentException(\"Key already exists; duplicates are not allowed.\"); } while (loopCounter <= thresh) { loopCounter++; hash = hashFunction1(key); if ((buckets[hash] == null) || Objects.equals(buckets[hash], emptySlot)) { buckets[hash] = wrappedInt; size++; checkLoadFactor(); return; } temp = buckets[hash]; buckets[hash] = wrappedInt; wrappedInt = temp; hash = hashFunction2(temp); if (Objects.equals(buckets[hash], emptySlot)) { buckets[hash] = wrappedInt; size++; checkLoadFactor(); return; } else if (buckets[hash] == null) { buckets[hash] = wrappedInt; size++; checkLoadFactor(); return; } temp = buckets[hash]; buckets[hash] = wrappedInt; wrappedInt = temp; } System.out.println(\"Infinite loop occurred, lengthening & rehashing table\"); reHashTableIncreasesTableSize(); insertKey2HashTable(key); } /** * Rehashes the current table to a new size (double the current size) and reinserts existing keys. */ public void reHashTableIncreasesTableSize() { HashMapCuckooHashing newT = new HashMapCuckooHashing(tableSize * 2); for (int i = 0; i < tableSize; i++) { if (buckets[i] != null && !Objects.equals(buckets[i], emptySlot)) { newT.insertKey2HashTable(this.buckets[i]); } } this.tableSize *= 2; this.buckets = newT.buckets; this.thresh = (int) (Math.log(tableSize) / Math.log(2)) + 2; } /** * Deletes a key from the hash table, marking its position as available. * * @param key the key to be deleted from the hash table * @throws IllegalArgumentException if the table is empty or if the key is not found */ public void deleteKeyFromHashTable(int key) { Integer wrappedInt = key; int hash = hashFunction1(key); if (isEmpty()) { throw new IllegalArgumentException(\"Table is empty, cannot delete.\"); } if (Objects.equals(buckets[hash], wrappedInt)) { buckets[hash] = emptySlot; size--; return; } hash = hashFunction2(key); if (Objects.equals(buckets[hash], wrappedInt)) { buckets[hash] = emptySlot; size--; return; } throw new IllegalArgumentException(\"Key \" + key + \" not found in the table.\"); } /** * Displays the hash table contents, bucket by bucket. */ public void displayHashtable() { for (int i = 0; i < tableSize; i++) { if ((buckets[i] == null) || Objects.equals(buckets[i], emptySlot)) { System.out.println(\"Bucket \" + i + \": Empty\"); } else { System.out.println(\"Bucket \" + i + \": \" + buckets[i].toString()); } } System.out.println(); } /** * Finds the index of a given key in the hash table. * * @param key the key to be found * @return the index where the key is located * @throws IllegalArgumentException if the table is empty or the key is not found */ public int findKeyInTable(int key) { Integer wrappedInt = key; int hash = hashFunction1(key); if (isEmpty()) { throw new IllegalArgumentException(\"Table is empty; cannot find keys.\"); } if (Objects.equals(buckets[hash], wrappedInt)) { return hash; } hash = hashFunction2(key); if (!Objects.equals(buckets[hash], wrappedInt)) { throw new IllegalArgumentException(\"Key \" + key + \" not found in the table.\"); } else { return hash; } } /** * Checks if the given key is present in the hash table. * * @param key the key to be checked * @return true if the key exists, false otherwise */ public boolean checkTableContainsKey(int key) { return ((buckets[hashFunction1(key)] != null && buckets[hashFunction1(key)].equals(key)) || (buckets[hashFunction2(key)] != null && buckets[hashFunction2(key)].equals(key))); } /** * Checks the load factor of the hash table. If the load factor exceeds 0.7, * the table is resized to prevent further collisions. * * @return the current load factor of the hash table */ public double checkLoadFactor() { double factor = (double) size / tableSize; if (factor > .7) { System.out.printf(\"Load factor is %.2f, rehashing table.%n\", factor); reHashTableIncreasesTableSize(); } return factor; } /** * Checks if the hash map is full. * * @return true if the hash map is full, false otherwise */ public boolean isFull() { for (int i = 0; i < tableSize; i++) { if (buckets[i] == null || Objects.equals(buckets[i], emptySlot)) { return false; } } return true; } /** * Checks if the hash map is empty. * * @return true if the hash map is empty, false otherwise */ public boolean isEmpty() { for (int i = 0; i < tableSize; i++) { if (buckets[i] != null) { return false; } } return true; } /** * Returns the current number of keys in the hash table. * * @return the number of keys present in the hash table */ public int getNumberOfKeysInTable() { return size; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import com.thealgorithms.datastructures.heaps.HeapElement; public interface Heap { public HeapElement getElement(); public void insertElement(HeapElement var1); public void deleteElement(int var1); }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; /** * Interface common to heap data structures.<br> * * <p> * Heaps are tree-like data structures that allow storing elements in a specific * way. Each node corresponds to an element and has one parent node (except for * the root) and at most two children nodes. Every element contains a key, and * those keys indicate how the tree shall be built. For instance, for a * min-heap, the key of a node shall be greater than or equal to its parent's * and lower than or equal to its children's (the opposite rule applies to a * max-heap). * * <p> * All heap-related operations (inserting or deleting an element, extracting the * min or max) are performed in O(log n) time. * * @author Nicolas Renard */ public interface Heap { /** * @return the top element in the heap, the one with lowest key for min-heap * or with the highest key for max-heap * @throws EmptyHeapException if heap is empty */ HeapElement getElement() throws EmptyHeapException; /** * Inserts an element in the heap. Adds it to then end and toggle it until * it finds its right position. * * @param element an instance of the HeapElement class. */ void insertElement(HeapElement element); /** * Delete an element in the heap. * * @param elementIndex int containing the position in the heap of the * element to be deleted. */ void deleteElement(int elementIndex) throws EmptyHeapException; }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; public class HeapElement { private final double a; private final Object b; public HeapElement(double d, Object object) { this.a = d; this.b = object; } public HeapElement(int n, Object object) { this.a = n; this.b = object; } public HeapElement(Integer n, Object object) { this.a = n.intValue(); this.b = object; } public HeapElement(Double d, Object object) { this.a = d; this.b = object; } public HeapElement(double d) { this.a = d; this.b = null; } public HeapElement(int n) { this.a = n; this.b = null; } public HeapElement(Integer n) { this.a = n.intValue(); this.b = null; } public HeapElement(Double d) { this.a = d; this.b = null; } public Object getInfo() { return this.b; } public double getKey() { return this.a; } public String toString() { return \"Key: \" + this.a + \" - \" + (this.b != null ? this.b.toString() : \"No additional info\"); } public boolean equals(Object object) { if (object instanceof HeapElement) { object = (HeapElement)object; return this.a == ((HeapElement)object).a && (this.b != null ? this.b.equals(((HeapElement)object).b) : ((HeapElement)object).b == null); } return false; } public int hashCode() { int n = 31 * (int)this.a; return n += this.b != null ? this.b.hashCode() : 0; } public String getValue() { return this.b.toString(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; /** * Class representing an element in a heap. * * <p> * A heap element contains two attributes: a key used for ordering in the heap * (which can be of type int or double, either as primitive types or as wrapper objects) * and an additional immutable object that can store any supplementary information the user desires. * Note that using mutable objects may compromise the integrity of this information. * </p> * * <p> * The key attribute is used to determine the order of elements in the heap, * while the additionalInfo attribute can carry user-defined data associated with the key. * </p> * * <p> * This class provides multiple constructors to accommodate various key types and includes * methods to retrieve the key and additional information. * </p> * * @author Nicolas Renard */ public class HeapElement { private final double key; private final Object additionalInfo; // Constructors /** * Creates a HeapElement with the specified key and additional information. * * @param key the key of the element (primitive type double) * @param info any immutable object containing additional information, may be null */ public HeapElement(double key, Object info) { this.key = key; this.additionalInfo = info; } /** * Creates a HeapElement with the specified key and additional information. * * @param key the key of the element (primitive type int) * @param info any immutable object containing additional information, may be null */ public HeapElement(int key, Object info) { this.key = key; this.additionalInfo = info; } /** * Creates a HeapElement with the specified key and additional information. * * @param key the key of the element (object type Integer) * @param info any immutable object containing additional information, may be null */ public HeapElement(Integer key, Object info) { this.key = key; this.additionalInfo = info; } /** * Creates a HeapElement with the specified key and additional information. * * @param key the key of the element (object type Double) * @param info any immutable object containing additional information, may be null */ public HeapElement(Double key, Object info) { this.key = key; this.additionalInfo = info; } /** * Creates a HeapElement with the specified key. * * @param key the key of the element (primitive type double) */ public HeapElement(double key) { this.key = key; this.additionalInfo = null; } /** * Creates a HeapElement with the specified key. * * @param key the key of the element (primitive type int) */ public HeapElement(int key) { this.key = key; this.additionalInfo = null; } /** * Creates a HeapElement with the specified key. * * @param key the key of the element (object type Integer) */ public HeapElement(Integer key) { this.key = key; this.additionalInfo = null; } /** * Creates a HeapElement with the specified key. * * @param key the key of the element (object type Double) */ public HeapElement(Double key) { this.key = key; this.additionalInfo = null; } // Getters /** * Returns the object containing the additional information provided by the user. * * @return the additional information */ public Object getInfo() { return additionalInfo; } /** * Returns the key value of the element. * * @return the key of the element */ public double getKey() { return key; } // Overridden object methods /** * Returns a string representation of the heap element. * * @return a string describing the key and additional information */ @Override public String toString() { return \"Key: \" + key + \" - \" + (additionalInfo != null ? additionalInfo.toString() : \"No additional info\"); } /** * @param o : an object to compare with the current element * @return true if the keys on both elements are identical and the * additional info objects are identical. */ @Override public boolean equals(Object o) { if (o instanceof HeapElement otherHeapElement) { return this.key == otherHeapElement.key && (this.additionalInfo != null ? this.additionalInfo.equals(otherHeapElement.additionalInfo) : otherHeapElement.additionalInfo == null); } return false; } /** * Returns a hash code value for the heap element. * * @return a hash code value for this heap element */ @Override public int hashCode() { int result = 31 * (int) key; result += (additionalInfo != null) ? additionalInfo.hashCode() : 0; return result; } public String getValue() { return additionalInfo.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class HeapSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { int n; int n2 = n = comparableArray.length; Comparable[] comparableArray2 = comparableArray; HeapSort heapSort = this; for (int i = n2 / 2; i > 0; --i) { HeapSort.a(comparableArray2, i, n2); } while (n > 1) { SortUtils.swap(comparableArray, 0, n - 1); HeapSort.a(comparableArray, 1, --n); } return comparableArray; } private static void a(Comparable[] comparableArray, int n, int n2) { while (2 * n <= n2) { int n3 = 2 * n; if (n3 < n2 && SortUtils.less(comparableArray[n3 - 1], comparableArray[n3])) { ++n3; } if (!SortUtils.less(comparableArray[n - 1], comparableArray[n3 - 1])) break; SortUtils.swap(comparableArray, n - 1, n3 - 1); n = n3; } } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * Heap Sort Algorithm Implementation * * @see <a href=\"https://en.wikipedia.org/wiki/Heapsort\">Heap Sort Algorithm</a> */ public class HeapSort implements SortAlgorithm { /** * For simplicity, we are considering the heap root index as 1 instead of 0. * This approach simplifies future calculations. As a result, we decrease * the indexes by 1 when calling {@link SortUtils#less(Comparable, Comparable)} * and provide adjusted values to the {@link SortUtils#swap(Object[], int, int)} methods. */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { int n = array.length; heapify(array, n); while (n > 1) { SortUtils.swap(array, 0, n - 1); n--; siftDown(array, 1, n); } return array; } private <T extends Comparable<T>> void heapify(final T[] array, final int n) { for (int k = n / 2; k >= 1; k--) { siftDown(array, k, n); } } private <T extends Comparable<T>> void siftDown(final T[] array, int k, final int n) { while (2 * k <= n) { int j = 2 * k; if (j < n && SortUtils.less(array[j - 1], array[j])) { j++; } if (!SortUtils.less(array[k - 1], array[j - 1])) { break; } SortUtils.swap(array, k - 1, j - 1); k = j; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.tree; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class HeavyLightDecomposition { private List a = new ArrayList(); private int[] b; private int[] c; private int[] d; private int[] e; private int[] f; private int[] g; private int[] h; private int i; public HeavyLightDecomposition(int n) { int n2; for (n2 = 0; n2 <= n; ++n2) { this.a.add(new ArrayList()); } this.b = new int[n + 1]; this.c = new int[n + 1]; this.d = new int[n + 1]; this.e = new int[n + 1]; this.f = new int[n + 1]; this.g = new int[n + 1]; this.h = new int[4 * (n + 1)]; for (n2 = 0; n2 <= n; ++n2) { this.e[n2] = -1; } this.i = 0; } public int getPosition(int n) { return this.f[n]; } public int getPositionIndex() { return this.i; } public void addEdge(int n, int n2) { ((List)this.a.get(n)).add(n2); ((List)this.a.get(n2)).add(n); } private void a(int n, int n2) { this.b[n] = n2; this.d[n] = 1; Iterator iterator = ((List)this.a.get(n)).iterator(); while (iterator.hasNext()) { int n3 = (Integer)iterator.next(); if (n3 == n2) continue; this.c[n3] = this.c[n] + 1; this.a(n3, n); int n4 = n; this.d[n4] = this.d[n4] + this.d[n3]; } } private void b(int n, int n2) { int n3; this.e[n] = n2; ++this.i; int n4 = -1; int n5 = -1; Iterator iterator = ((List)this.a.get(n)).iterator(); while (iterator.hasNext()) { n3 = (Integer)iterator.next(); if (n3 == this.b[n] || this.d[n3] <= n5) continue; n4 = n3; n5 = this.d[n3]; } if (n4 != -1) { this.b(n4, n2); } iterator = ((List)this.a.get(n)).iterator(); while (iterator.hasNext()) { n3 = (Integer)iterator.next(); if (n3 == this.b[n] || n3 == n4) continue; int n6 = n3; this.b(n6, n6); } } private void a(int n, int n2, int n3) { if (n2 == n3) { this.h[n] = this.g[n2]; return; } int n4 = (n2 + n3) / 2; this.a(2 * n, n2, n4); this.a(2 * n + 1, n4 + 1, n3); this.h[n] = Math.max(this.h[2 * n], this.h[2 * n + 1]); } public void updateSegmentTree(int n, int n2, int n3, int n4, int n5) { if (n2 == n3) { this.h[n] = n5; return; } int n6 = (n2 + n3) / 2; if (n4 <= n6) { this.updateSegmentTree(2 * n, n2, n6, n4, n5); } else { this.updateSegmentTree(2 * n + 1, n6 + 1, n3, n4, n5); } this.h[n] = Math.max(this.h[2 * n], this.h[2 * n + 1]); } public int querySegmentTree(int n, int n2, int n3, int n4, int n5) { if (n4 > n3 || n5 < n2) { return Integer.MIN_VALUE; } if (n4 <= n2 && n3 <= n5) { return this.h[n]; } int n6 = (n2 + n3) / 2; n2 = this.querySegmentTree(2 * n, n2, n6, n4, n5); n = this.querySegmentTree(2 * n + 1, n6 + 1, n3, n4, n5); return Math.max(n2, n); } public int queryMaxInPath(int n, int n2) { int n3; int n4 = Integer.MIN_VALUE; while (this.e[n] != this.e[n2]) { if (this.c[this.e[n]] < this.c[this.e[n2]]) { n3 = n; n = n2; n2 = n3; } n4 = Math.max(n4, this.querySegmentTree(1, 0, this.i - 1, this.f[this.e[n]], this.f[n])); n = this.b[this.e[n]]; } if (this.c[n] > this.c[n2]) { n3 = n; n = n2; n2 = n3; } n4 = Math.max(n4, this.querySegmentTree(1, 0, this.i - 1, this.f[n], this.f[n2])); return n4; } public void initialize(int n, int[] nArray) { this.a(n, -1); int n2 = n; this.b(n2, n2); for (n = 0; n < nArray.length; ++n) { this.g[this.f[n]] = nArray[n]; } this.a(1, 0, this.i - 1); } }", "deobfuscated_code": "package com.thealgorithms.tree; import java.util.ArrayList; import java.util.List; /** * Heavy-Light Decomposition (HLD) implementation in Java. * HLD is used to efficiently handle path queries on trees, such as maximum, * sum, or updates. It decomposes the tree into heavy and light chains, * enabling queries in O(log N) time. * Wikipedia Reference: https://en.wikipedia.org/wiki/Heavy-light_decomposition * Author: Nithin U. * Github: https://github.com/NithinU2802 */ public class HeavyLightDecomposition { private List<List<Integer>> tree; private int[] parent; private int[] depth; private int[] subtreeSize; private int[] chainHead; private int[] position; private int[] nodeValue; private int[] segmentTree; private int positionIndex; public HeavyLightDecomposition(int n) { tree = new ArrayList<>(); for (int i = 0; i <= n; i++) { tree.add(new ArrayList<>()); } parent = new int[n + 1]; depth = new int[n + 1]; subtreeSize = new int[n + 1]; chainHead = new int[n + 1]; position = new int[n + 1]; nodeValue = new int[n + 1]; segmentTree = new int[4 * (n + 1)]; for (int i = 0; i <= n; i++) { chainHead[i] = -1; } positionIndex = 0; } public int getPosition(int index) { return position[index]; } public int getPositionIndex() { return positionIndex; } public void addEdge(int u, int v) { tree.get(u).add(v); tree.get(v).add(u); } private void dfsSize(int node, int parentNode) { parent[node] = parentNode; subtreeSize[node] = 1; for (int child : tree.get(node)) { if (child != parentNode) { depth[child] = depth[node] + 1; dfsSize(child, node); subtreeSize[node] += subtreeSize[child]; } } } private void decompose(int node, int head) { chainHead[node] = head; position[node] = positionIndex++; int heavyChild = -1; int maxSubtreeSize = -1; for (int child : tree.get(node)) { if (child != parent[node] && subtreeSize[child] > maxSubtreeSize) { heavyChild = child; maxSubtreeSize = subtreeSize[child]; } } if (heavyChild != -1) { decompose(heavyChild, head); } for (int child : tree.get(node)) { if (child != parent[node] && child != heavyChild) { decompose(child, child); } } } private void buildSegmentTree(int node, int start, int end) { if (start == end) { segmentTree[node] = nodeValue[start]; return; } int mid = (start + end) / 2; buildSegmentTree(2 * node, start, mid); buildSegmentTree(2 * node + 1, mid + 1, end); segmentTree[node] = Math.max(segmentTree[2 * node], segmentTree[2 * node + 1]); } public void updateSegmentTree(int node, int start, int end, int index, int value) { if (start == end) { segmentTree[node] = value; return; } int mid = (start + end) / 2; if (index <= mid) { updateSegmentTree(2 * node, start, mid, index, value); } else { updateSegmentTree(2 * node + 1, mid + 1, end, index, value); } segmentTree[node] = Math.max(segmentTree[2 * node], segmentTree[2 * node + 1]); } public int querySegmentTree(int node, int start, int end, int left, int right) { if (left > end || right < start) { return Integer.MIN_VALUE; } if (left <= start && end <= right) { return segmentTree[node]; } int mid = (start + end) / 2; int leftQuery = querySegmentTree(2 * node, start, mid, left, right); int rightQuery = querySegmentTree(2 * node + 1, mid + 1, end, left, right); return Math.max(leftQuery, rightQuery); } public int queryMaxInPath(int u, int v) { int result = Integer.MIN_VALUE; while (chainHead[u] != chainHead[v]) { if (depth[chainHead[u]] < depth[chainHead[v]]) { int temp = u; u = v; v = temp; } result = Math.max(result, querySegmentTree(1, 0, positionIndex - 1, position[chainHead[u]], position[u])); u = parent[chainHead[u]]; } if (depth[u] > depth[v]) { int temp = u; u = v; v = temp; } result = Math.max(result, querySegmentTree(1, 0, positionIndex - 1, position[u], position[v])); return result; } public void initialize(int root, int[] values) { dfsSize(root, -1); decompose(root, root); for (int i = 0; i < values.length; i++) { nodeValue[position[i]] = values[i]; } buildSegmentTree(1, 0, positionIndex - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class HeronsFormula { private HeronsFormula() { } public static double herons(double d, double d2, double d3) { block3: { block2: { double d4; double d5; double d6 = d3; double d7 = d2; double d8 = d; if (!(d5 > 0.0 && d7 > 0.0 && d6 > 0.0)) break block2; d6 = d3; d7 = d2; d8 = d; if (d4 + d7 > d6 && d7 + d6 > d8 && d6 + d8 > d7) break block3; } throw new IllegalArgumentException(\"Triangle can't be formed with the given side lengths\"); } double d9 = (d + d2 + d3) / 2.0; return Math.sqrt(d9 * (d9 - d) * (d9 - d2) * (d9 - d3)); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Wikipedia for HeronsFormula => https://en.wikipedia.org/wiki/Heron%27s_formula * Find the area of a triangle using only side lengths */ public final class HeronsFormula { /* * A function to get the Area of a Triangle using Heron's Formula * @param s1,s2,s3 => the three sides of the Triangle * @return area using the formula ((s(s  s1)(s  s2)(s  s3))) * here s is called semi-perimeter and it is the half of the perimeter (i.e; s = (s1+s2+s3)/2) * @author satyabarghav */ private HeronsFormula() { } private static boolean areAllSidesPositive(final double a, final double b, final double c) { return a > 0 && b > 0 && c > 0; } private static boolean canFormTriangle(final double a, final double b, final double c) { return a + b > c && b + c > a && c + a > b; } public static double herons(final double a, final double b, final double c) { if (!areAllSidesPositive(a, b, c) || !canFormTriangle(a, b, c)) { throw new IllegalArgumentException(\"Triangle can't be formed with the given side lengths\"); } final double s = (a + b + c) / 2.0; return Math.sqrt((s) * (s - a) * (s - b) * (s - c)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class HexToOct { private HexToOct() { } public static int hexToDecimal(String string) { String string2 = \"0123456789ABCDEF\"; string = string.toUpperCase(); int n = 0; for (int i = 0; i < string.length(); ++i) { int n2 = string.charAt(i); n2 = string2.indexOf(n2); n = n * 16 + n2; } return n; } public static int decimalToOctal(int n) { int n2 = 0; int n3 = 1; while (n > 0) { int n4 = n % 8; n2 += n4 * n3; n /= 8; n3 *= 10; } return n2; } public static int hexToOctal(String string) { int n = HexToOct.hexToDecimal(string); return HexToOct.decimalToOctal(n); } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * Converts any Hexadecimal Number to Octal * * @author Tanmay Joshi */ public final class HexToOct { private HexToOct() { } /** * Converts a Hexadecimal number to a Decimal number. * * @param hex The Hexadecimal number as a String. * @return The Decimal equivalent as an integer. */ public static int hexToDecimal(String hex) { String hexDigits = \"0123456789ABCDEF\"; hex = hex.toUpperCase(); int decimalValue = 0; for (int i = 0; i < hex.length(); i++) { char hexChar = hex.charAt(i); int digitValue = hexDigits.indexOf(hexChar); decimalValue = 16 * decimalValue + digitValue; } return decimalValue; } /** * Converts a Decimal number to an Octal number. * * @param decimal The Decimal number as an integer. * @return The Octal equivalent as an integer. */ public static int decimalToOctal(int decimal) { int octalValue = 0; int placeValue = 1; while (decimal > 0) { int remainder = decimal % 8; octalValue += remainder * placeValue; decimal /= 8; placeValue *= 10; } return octalValue; } /** * Converts a Hexadecimal number to an Octal number. * * @param hex The Hexadecimal number as a String. * @return The Octal equivalent as an integer. */ public static int hexToOctal(String hex) { int decimalValue = hexToDecimal(hex); return decimalToOctal(decimalValue); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public class HexaDecimalToBinary { public String convert(String string) { int n = Integer.parseInt(string, 16); String string2 = Integer.toBinaryString(n); return this.completeDigits(string2); } public String completeDigits(String charSequence) { charSequence = new StringBuilder((String)charSequence); while (((StringBuilder)charSequence).length() < 8) { ((StringBuilder)charSequence).insert(0, \"0\"); } charSequence = ((StringBuilder)charSequence).toString(); return charSequence; } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * Utility class for converting hexadecimal numbers to binary representation. * <p> * A hexadecimal number consists of digits from {@code [0-9]} and {@code [A-F]} (case-insensitive), * while binary representation uses only {@code [0, 1]}. * <p> * This class provides methods to: * <ul> * <li>Convert a hexadecimal string to its binary string equivalent.</li> * <li>Ensure the binary output is padded to 8 bits (1 byte).</li> * </ul> * <p> * Example: * <ul> * <li>{@code \"A1\"}  {@code \"10100001\"}</li> * <li>{@code \"1\"}  {@code \"00000001\"}</li> * </ul> * * <p>This class assumes that the input hexadecimal string is valid.</p> */ public class HexaDecimalToBinary { /** * Converts a hexadecimal string to its binary string equivalent. * The binary output is padded to a minimum of 8 bits (1 byte). * Steps: * <ol> * <li>Convert the hexadecimal string to an integer.</li> * <li>Convert the integer to a binary string.</li> * <li>Pad the binary string to ensure it is at least 8 bits long.</li> * <li>Return the padded binary string.</li> * </ol> * * @param numHex the hexadecimal string (e.g., \"A1\", \"7F\") * @throws NumberFormatException if the input string is not a valid hexadecimal number * @return the binary string representation, padded to 8 bits (e.g., \"10100001\") */ public String convert(String numHex) { int conHex = Integer.parseInt(numHex, 16); String binary = Integer.toBinaryString(conHex); return completeDigits(binary); } /** * Pads the binary string to ensure it is at least 8 bits long. * If the binary string is shorter than 8 bits, it adds leading zeros. * * @param binNum the binary string to pad * @return the padded binary string with a minimum length of 8 */ public String completeDigits(String binNum) { final int byteSize = 8; StringBuilder binNumBuilder = new StringBuilder(binNum); while (binNumBuilder.length() < byteSize) { binNumBuilder.insert(0, \"0\"); } binNum = binNumBuilder.toString(); return binNum; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class HexaDecimalToDecimal { private HexaDecimalToDecimal() { } public static int getHexaToDec(String string) { String string2 = \"0123456789ABCDEF\"; string = string.toUpperCase(); int n = 0; for (int i = 0; i < string.length(); ++i) { int n2 = string2.indexOf(string.charAt(i)); if (n2 == -1) { throw new IllegalArgumentException(\"Invalid hexadecimal character: \" + string.charAt(i)); } n = n * 16 + n2; } return n; } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * Utility class for converting a hexadecimal string to its decimal representation. * <p> * A hexadecimal number uses the base-16 numeral system, with the following characters: * <ul> * <li>Digits: 0-9</li> * <li>Letters: A-F (case-insensitive)</li> * </ul> * Each character represents a power of 16. For example: * <pre> * Hexadecimal \"A1\" = 10*16^1 + 1*16^0 = 161 (decimal) * </pre> * * <p>This class provides a method to perform the conversion without using built-in Java utilities.</p> */ public final class HexaDecimalToDecimal { private HexaDecimalToDecimal() { } /** * Converts a hexadecimal string to its decimal integer equivalent. * <p>The input string is case-insensitive, and must contain valid hexadecimal characters [0-9, A-F].</p> * * @param hex the hexadecimal string to convert * @return the decimal integer representation of the input hexadecimal string * @throws IllegalArgumentException if the input string contains invalid characters */ public static int getHexaToDec(String hex) { String digits = \"0123456789ABCDEF\"; hex = hex.toUpperCase(); int val = 0; for (int i = 0; i < hex.length(); i++) { int d = digits.indexOf(hex.charAt(i)); if (d == -1) { throw new IllegalArgumentException(\"Invalid hexadecimal character: \" + hex.charAt(i)); } val = 16 * val + d; } return val; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class HigherLowerPowerOfTwo { private HigherLowerPowerOfTwo() { } public static int nextHigherPowerOfTwo(int n) { if (n <= 0) { return 1; } int n2 = --n; n = n2 | n2 >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; return n + 1; } public static int nextLowerPowerOfTwo(int n) { if (n <= 0) { return 0; } return Integer.highestOneBit(n); } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * HigherLowerPowerOfTwo class has two methods to find the next higher and lower power of two. * <p> * nextHigherPowerOfTwo method finds the next higher power of two. * nextLowerPowerOfTwo method finds the next lower power of two. * Both methods take an integer as input and return the next higher or lower power of two. * If the input is less than 1, the next higher power of two is 1. * If the input is less than or equal to 1, the next lower power of two is 0. * nextHigherPowerOfTwo method uses bitwise operations to find the next higher power of two. * nextLowerPowerOfTwo method uses Integer.highestOneBit method to find the next lower power of two. * The time complexity of both methods is O(1). * The space complexity of both methods is O(1). * </p> * * @author Hardvan */ public final class HigherLowerPowerOfTwo { private HigherLowerPowerOfTwo() { } /** * Finds the next higher power of two. * * @param x The given number. * @return The next higher power of two. */ public static int nextHigherPowerOfTwo(int x) { if (x < 1) { return 1; } x--; x |= x >> 1; x |= x >> 2; x |= x >> 4; x |= x >> 8; x |= x >> 16; return x + 1; } /** * Finds the next lower power of two. * * @param x The given number. * @return The next lower power of two. */ public static int nextLowerPowerOfTwo(int x) { if (x < 1) { return 0; } return Integer.highestOneBit(x); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class HighestResponseRatioNextScheduling$Process { private String e; int a; int b; int c; boolean d; HighestResponseRatioNextScheduling$Process(String string, int n, int n2) { this.e = string; this.a = n; this.b = n2; this.c = 0; this.d = false; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class HighestResponseRatioNextScheduling$Process { private String e; int a; int b; int c; boolean d; HighestResponseRatioNextScheduling$Process(String string, int n, int n2) { this.e = string; this.a = n; this.b = n2; this.c = 0; this.d = false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.HighestResponseRatioNextScheduling$Process; import java.util.Arrays; import java.util.Comparator; public final class HighestResponseRatioNextScheduling { private HighestResponseRatioNextScheduling() { } public static int[] calculateTurnAroundTime(String[] objectArray, int[] nArray, int[] nArray2, int n) { int n2; int n3 = 0; int[] nArray3 = new int[n]; HighestResponseRatioNextScheduling$Process[] highestResponseRatioNextScheduling$ProcessArray = new HighestResponseRatioNextScheduling$Process[n]; for (n2 = 0; n2 < n; ++n2) { highestResponseRatioNextScheduling$ProcessArray[n2] = new HighestResponseRatioNextScheduling$Process(objectArray[n2], nArray[n2], nArray2[n2]); } Arrays.sort(highestResponseRatioNextScheduling$ProcessArray, Comparator.comparingInt(highestResponseRatioNextScheduling$Process -> highestResponseRatioNextScheduling$Process.a)); n2 = 0; while (n2 < n) { int n4 = n3; objectArray = highestResponseRatioNextScheduling$ProcessArray; objectArray = highestResponseRatioNextScheduling$ProcessArray; double d = -1.0; int n5 = -1; for (int i = 0; i < objectArray.length; ++i) { double d2; Object object = objectArray[i]; if (((HighestResponseRatioNextScheduling$Process)object).d || ((HighestResponseRatioNextScheduling$Process)object).a > n4) continue; int n6 = n4; double d3 = (double)(((HighestResponseRatioNextScheduling$Process)object).b + n6 - ((HighestResponseRatioNextScheduling$Process)object).a) / (double)((HighestResponseRatioNextScheduling$Process)object).b; if (!(d2 > d)) continue; d = d3; n5 = i; } int n7 = n5; if (n7 == -1) { ++n3; continue; } HighestResponseRatioNextScheduling$Process highestResponseRatioNextScheduling$Process2 = highestResponseRatioNextScheduling$ProcessArray[n7]; n3 = Math.max(n3, highestResponseRatioNextScheduling$Process2.a); highestResponseRatioNextScheduling$Process2.c = n3 + highestResponseRatioNextScheduling$Process2.b - highestResponseRatioNextScheduling$Process2.a; n3 += highestResponseRatioNextScheduling$Process2.b; highestResponseRatioNextScheduling$Process2.d = true; ++n2; } for (int i = 0; i < n; ++i) { nArray3[i] = highestResponseRatioNextScheduling$ProcessArray[i].c; } return nArray3; } public static int[] calculateWaitingTime(int[] nArray, int[] nArray2) { int[] nArray3 = new int[nArray.length]; for (int i = 0; i < nArray.length; ++i) { nArray3[i] = nArray[i] - nArray2[i]; } return nArray3; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.Arrays; import java.util.Comparator; /** * The {@code HighestResponseRatioNextScheduling} class implements the * Highest Response Ratio Next (HRRN) scheduling algorithm. * HRRN is a non-preemptive scheduling algorithm that selects the process with * the highest response ratio for execution. * The response ratio is calculated as: * * <pre> * Response Ratio = (waiting time + burst time) / burst time * </pre> * * HRRN is designed to reduce the average waiting time and improve overall * system performance by balancing between short and long processes, * minimizing process starvation. */ public final class HighestResponseRatioNextScheduling { private static final int PROCESS_NOT_FOUND = -1; private static final double INITIAL_MAX_RESPONSE_RATIO = -1.0; private HighestResponseRatioNextScheduling() { } /** * Represents a process in the scheduling algorithm. */ private static class Process { String name; int arrivalTime; int burstTime; int turnAroundTime; boolean finished; Process(String name, int arrivalTime, int burstTime) { this.name = name; this.arrivalTime = arrivalTime; this.burstTime = burstTime; this.turnAroundTime = 0; this.finished = false; } /** * Calculates the response ratio for this process. * * @param currentTime The current time in the scheduling process. * @return The response ratio for this process. */ double calculateResponseRatio(int currentTime) { return (double) (burstTime + currentTime - arrivalTime) / burstTime; } } /** * Calculates the Turn Around Time (TAT) for each process. * * <p>Turn Around Time is calculated as the total time a process spends * in the system from arrival to completion. It is the sum of the burst time * and the waiting time.</p> * * @param processNames Array of process names. * @param arrivalTimes Array of arrival times corresponding to each process. * @param burstTimes Array of burst times for each process. * @param noOfProcesses The number of processes. * @return An array of Turn Around Times for each process. */ public static int[] calculateTurnAroundTime(final String[] processNames, final int[] arrivalTimes, final int[] burstTimes, final int noOfProcesses) { int currentTime = 0; int[] turnAroundTime = new int[noOfProcesses]; Process[] processes = new Process[noOfProcesses]; for (int i = 0; i < noOfProcesses; i++) { processes[i] = new Process(processNames[i], arrivalTimes[i], burstTimes[i]); } Arrays.sort(processes, Comparator.comparingInt(p -> p.arrivalTime)); int finishedProcessCount = 0; while (finishedProcessCount < noOfProcesses) { int nextProcessIndex = findNextProcess(processes, currentTime); if (nextProcessIndex == PROCESS_NOT_FOUND) { currentTime++; continue; } Process currentProcess = processes[nextProcessIndex]; currentTime = Math.max(currentTime, currentProcess.arrivalTime); currentProcess.turnAroundTime = currentTime + currentProcess.burstTime - currentProcess.arrivalTime; currentTime += currentProcess.burstTime; currentProcess.finished = true; finishedProcessCount++; } for (int i = 0; i < noOfProcesses; i++) { turnAroundTime[i] = processes[i].turnAroundTime; } return turnAroundTime; } /** * Calculates the Waiting Time (WT) for each process. * * @param turnAroundTime The Turn Around Times for each process. * @param burstTimes The burst times for each process. * @return An array of Waiting Times for each process. */ public static int[] calculateWaitingTime(int[] turnAroundTime, int[] burstTimes) { int[] waitingTime = new int[turnAroundTime.length]; for (int i = 0; i < turnAroundTime.length; i++) { waitingTime[i] = turnAroundTime[i] - burstTimes[i]; } return waitingTime; } /** * Finds the next process to be scheduled based on arrival times and the current time. * * @param processes Array of Process objects. * @param currentTime The current time in the scheduling process. * @return The index of the next process to be scheduled, or PROCESS_NOT_FOUND if no process is ready. */ private static int findNextProcess(Process[] processes, int currentTime) { return findHighestResponseRatio(processes, currentTime); } /** * Finds the process with the highest response ratio. * * <p>The response ratio is calculated as: * (waiting time + burst time) / burst time * where waiting time = current time - arrival time</p> * * @param processes Array of Process objects. * @param currentTime The current time in the scheduling process. * @return The index of the process with the highest response ratio, or PROCESS_NOT_FOUND if no process is ready. */ private static int findHighestResponseRatio(Process[] processes, int currentTime) { double maxResponseRatio = INITIAL_MAX_RESPONSE_RATIO; int maxIndex = PROCESS_NOT_FOUND; for (int i = 0; i < processes.length; i++) { Process process = processes[i]; if (!process.finished && process.arrivalTime <= currentTime) { double responseRatio = process.calculateResponseRatio(currentTime); if (responseRatio > maxResponseRatio) { maxResponseRatio = responseRatio; maxIndex = i; } } } return maxIndex; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; import java.util.Optional; public final class HighestSetBit { private HighestSetBit() { } public static Optional findHighestSetBit(int n) { if (n < 0) { throw new IllegalArgumentException(\"Input cannot be negative\"); } if (n == 0) { return Optional.empty(); } int n2 = 0; while (n > 0) { n >>= 1; ++n2; } return Optional.of(n2 - 1); } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; import java.util.Optional; /** * Find Highest Set Bit * * This class provides a utility method to calculate the position of the highest * (most significant) bit that is set to 1 in a given non-negative integer. * It is often used in bit manipulation tasks to find the left-most set bit in binary * representation of a number. * * Example: * - For input 18 (binary 10010), the highest set bit is at position 4 (zero-based index). * * @author Bama Charan Chhandogi * @version 1.0 * @since 2021-06-23 */ public final class HighestSetBit { private HighestSetBit() { } /** * Finds the highest (most significant) set bit in the given integer. * The method returns the position (index) of the highest set bit as an {@link Optional}. * * - If the number is 0, no bits are set, and the method returns {@link Optional#empty()}. * - If the number is negative, the method throws {@link IllegalArgumentException}. * * @param num The input integer for which the highest set bit is to be found. It must be non-negative. * @return An {@link Optional} containing the index of the highest set bit (zero-based). * Returns {@link Optional#empty()} if the number is 0. * @throws IllegalArgumentException if the input number is negative. */ public static Optional<Integer> findHighestSetBit(int num) { if (num < 0) { throw new IllegalArgumentException(\"Input cannot be negative\"); } if (num == 0) { return Optional.empty(); } int position = 0; while (num > 0) { num >>= 1; position++; } return Optional.of(position - 1); // Subtract 1 to convert to zero-based index } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; public class HillCipher { public String encrypt(String string, int[][] nArray) { string = string.toUpperCase().replaceAll(\"[^A-Z]\", \"\"); int n = nArray.length; this.a(nArray, n); StringBuilder stringBuilder = new StringBuilder(); int[] nArray2 = new int[n]; int[] nArray3 = new int[n]; int n2 = 0; while (n2 < string.length()) { int n3; for (n3 = 0; n3 < n; ++n3) { nArray2[n3] = n2 < string.length() ? string.charAt(n2++) - 65 : 23; } for (n3 = 0; n3 < n; ++n3) { nArray3[n3] = 0; for (int i = 0; i < n; ++i) { int n4 = n3; nArray3[n4] = nArray3[n4] + nArray[n3][i] * nArray2[i]; } nArray3[n3] = nArray3[n3] % 26; stringBuilder.append((char)(nArray3[n3] + 65)); } } return stringBuilder.toString(); } public String decrypt(String string, int[][] nArray) { string = string.toUpperCase().replaceAll(\"[^A-Z]\", \"\"); int n = nArray.length; this.a(nArray, n); StringBuilder stringBuilder = new StringBuilder(); int[] nArray2 = new int[n]; int[] nArray3 = new int[n]; int n2 = 0; while (n2 < string.length()) { int n3; for (n3 = 0; n3 < n; ++n3) { nArray2[n3] = n2 < string.length() ? string.charAt(n2++) - 65 : 23; } for (n3 = 0; n3 < n; ++n3) { nArray3[n3] = 0; for (int i = 0; i < n; ++i) { int n4 = n3; nArray3[n4] = nArray3[n4] + nArray[n3][i] * nArray2[i]; } nArray3[n3] = nArray3[n3] % 26; stringBuilder.append((char)(nArray3[n3] + 65)); } } return stringBuilder.toString(); } private void a(int[][] nArray, int n) { int n2 = this.b(nArray, n) % 26; if (n2 == 0) { throw new IllegalArgumentException(\"Invalid key matrix. Determinant is zero modulo 26.\"); } } private int b(int[][] nArray, int n) { int n2 = 0; if (n == 1) { return nArray[0][0]; } int n3 = 1; int[][] nArray2 = new int[n - 1][n - 1]; for (int i = 0; i < n; ++i) { int n4 = 0; for (int j = 1; j < n; ++j) { int n5 = 0; for (int k = 0; k < n; ++k) { if (k == i) continue; nArray2[n4][n5++] = nArray[j][k]; } ++n4; } n2 += n3 * nArray[0][i] * this.b(nArray2, n - 1); n3 = -n3; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.ciphers; public class HillCipher { // Encrypts the message using the key matrix public String encrypt(String message, int[][] keyMatrix) { message = message.toUpperCase().replaceAll(\"[^A-Z]\", \"\"); int matrixSize = keyMatrix.length; validateDeterminant(keyMatrix, matrixSize); StringBuilder cipherText = new StringBuilder(); int[] messageVector = new int[matrixSize]; int[] cipherVector = new int[matrixSize]; int index = 0; while (index < message.length()) { for (int i = 0; i < matrixSize; i++) { if (index < message.length()) { messageVector[i] = message.charAt(index++) - 'A'; } else { messageVector[i] = 'X' - 'A'; // Padding with 'X' if needed } } for (int i = 0; i < matrixSize; i++) { cipherVector[i] = 0; for (int j = 0; j < matrixSize; j++) { cipherVector[i] += keyMatrix[i][j] * messageVector[j]; } cipherVector[i] = cipherVector[i] % 26; cipherText.append((char) (cipherVector[i] + 'A')); } } return cipherText.toString(); } // Decrypts the message using the inverse key matrix public String decrypt(String message, int[][] inverseKeyMatrix) { message = message.toUpperCase().replaceAll(\"[^A-Z]\", \"\"); int matrixSize = inverseKeyMatrix.length; validateDeterminant(inverseKeyMatrix, matrixSize); StringBuilder plainText = new StringBuilder(); int[] messageVector = new int[matrixSize]; int[] plainVector = new int[matrixSize]; int index = 0; while (index < message.length()) { for (int i = 0; i < matrixSize; i++) { if (index < message.length()) { messageVector[i] = message.charAt(index++) - 'A'; } else { messageVector[i] = 'X' - 'A'; // Padding with 'X' if needed } } for (int i = 0; i < matrixSize; i++) { plainVector[i] = 0; for (int j = 0; j < matrixSize; j++) { plainVector[i] += inverseKeyMatrix[i][j] * messageVector[j]; } plainVector[i] = plainVector[i] % 26; plainText.append((char) (plainVector[i] + 'A')); } } return plainText.toString(); } // Validates that the determinant of the key matrix is not zero modulo 26 private void validateDeterminant(int[][] keyMatrix, int n) { int det = determinant(keyMatrix, n) % 26; if (det == 0) { throw new IllegalArgumentException(\"Invalid key matrix. Determinant is zero modulo 26.\"); } } // Computes the determinant of a matrix recursively private int determinant(int[][] matrix, int n) { int det = 0; if (n == 1) { return matrix[0][0]; } int sign = 1; int[][] subMatrix = new int[n - 1][n - 1]; for (int x = 0; x < n; x++) { int subI = 0; for (int i = 1; i < n; i++) { int subJ = 0; for (int j = 0; j < n; j++) { if (j != x) { subMatrix[subI][subJ++] = matrix[i][j]; } } subI++; } det += sign * matrix[0][x] * determinant(subMatrix, n - 1); sign = -sign; } return det; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.HashMap; public final class HorspoolSearch { private static HashMap a; private static Integer b; private static int c; private HorspoolSearch() { } public static int findFirst(String string, String string2) { return HorspoolSearch.a(string, string2, true); } public static int findFirstInsensitive(String string, String string2) { return HorspoolSearch.a(string, string2, false); } public static Integer getLastComparisons() { return c; } private static int a(String string, String string2, boolean bl) { a = HorspoolSearch.a(string); c = 0; if (string.length() == 0) { return -1; } int n = string.length() - 1; while (n < string2.length()) { int n2; for (n2 = string.length() - 1; n2 >= 0; --n2) { char c; ++HorspoolSearch.c; char c2 = string.charAt(n2); if (HorspoolSearch.a(c2, c = string2.charAt(n + n2 - (string.length() - 1)), bl)) continue; n += HorspoolSearch.a(string2.charAt(n)).intValue(); break; } if (n2 != -1) continue; return n - string.length() + 1; } return -1; } private static boolean a(char c, char c2, boolean bl) { if (bl) { return c == c2; } return Character.toLowerCase(c) == Character.toLowerCase(c2); } private static HashMap a(String string) { b = string.length(); HashMap<Character, Integer> hashMap = new HashMap<Character, Integer>(); int n = string.length() - 2; while (n >= 0) { char c2 = string.charAt(n); int n2 = n--; hashMap.computeIfAbsent(Character.valueOf(c2), c -> string.length() - 1 - n2); } return hashMap; } private static Integer a(char c) { if (a.get(Character.valueOf(c)) != null) { return (Integer)a.get(Character.valueOf(c)); } return b; } static { c = 0; } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.HashMap; /** * This class is not thread safe<br> * <br> * (From wikipedia) In computer science, the BoyerMooreHorspool algorithm or * Horspool's algorithm is an algorithm for finding substrings in strings. It * was published by Nigel Horspool in 1980. * <br> * <a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm>Wikipedia * page</a><br> * <br> * * <p> * An explanation:<br> * * <p> * The Horspool algorithm is a simplification of the Boyer-Moore algorithm in * that it uses only one of the two heuristic methods for increasing the number * of characters shifted when finding a bad match in the text. This method is * usually called the \"bad symbol\" or \"bad character\" shift. The bad symbol * shift method is classified as an input enhancement method in the theory of * algorithms. Input enhancement is (from wikipedia) the principle that * processing a given input to a problem and altering it in a specific way will * increase runtime efficiency or space efficiency, or both. Both algorithms try * to match the pattern and text comparing the pattern symbols to the text's * from right to left.<br> * <br> * * <p> * In the bad symbol shift method, a table is created prior to the search, * called the \"bad symbol table\". The bad symbol table contains the shift values * for any symbol in the text and pattern. For these symbols, the value is the * length of the pattern, if the symbol is not in the first (length - 1) of the * pattern. Else it is the distance from its rightmost occurrence in the pattern * to the last symbol of the pattern. In practice, we only calculate the values * for the ones that exist in the first (length - 1) of the pattern.<br> * <br> * * <p> * For more details on the algorithm and the more advanced Boyer-Moore I * recommend checking out the wikipedia page and professor Anany Levitin's book: * Introduction To The Design And Analysis Of Algorithms. */ public final class HorspoolSearch { private HorspoolSearch() { } private static HashMap<Character, Integer> shiftValues; // bad symbol table private static Integer patternLength; private static int comparisons = 0; // total comparisons in the current/last search /** * Case sensitive version version of the algorithm * * @param pattern the pattern to be searched for (needle) * @param text the text being searched in (haystack) * @return -1 if not found or first index of the pattern in the text */ public static int findFirst(String pattern, String text) { return firstOccurrence(pattern, text, true); } /** * Case insensitive version version of the algorithm * * @param pattern the pattern to be searched for (needle) * @param text the text being searched in (haystack) * @return -1 if not found or first index of the pattern in the text */ public static int findFirstInsensitive(String pattern, String text) { return firstOccurrence(pattern, text, false); } /** * Utility method that returns comparisons made by last run (mainly for * tests) * * @return number of character comparisons of the last search */ public static Integer getLastComparisons() { return HorspoolSearch.comparisons; } /** * Fairly standard implementation of the Horspool algorithm. Only the index * of the last character of the pattern on the text is saved and shifted by * the appropriate amount when a mismatch is found. The algorithm stops at * the first match or when the entire text has been exhausted. * * @param pattern String to be matched in the text * @param text text String * @return index of first occurrence of the pattern in the text */ private static int firstOccurrence(String pattern, String text, boolean caseSensitive) { shiftValues = calcShiftValues(pattern); // build the bad symbol table comparisons = 0; // reset comparisons if (pattern.length() == 0) { // return failure, if pattern empty return -1; } int textIndex = pattern.length() - 1; // align pattern with text start and get index of the last character // while pattern is not out of text bounds while (textIndex < text.length()) { // try to match pattern with current part of the text starting from last character int i = pattern.length() - 1; while (i >= 0) { comparisons++; char patternChar = pattern.charAt(i); char textChar = text.charAt((textIndex + i) - (pattern.length() - 1)); if (!charEquals(patternChar, textChar, caseSensitive)) { // bad character, shift pattern textIndex += getShiftValue(text.charAt(textIndex)); break; } i--; } // check for full match if (i == -1) { return textIndex - pattern.length() + 1; } } // text exhausted, return failure return -1; } /** * Compares the argument characters * * @param c1 first character * @param c2 second character * @param caseSensitive boolean determining case sensitivity of comparison * @return truth value of the equality comparison */ private static boolean charEquals(char c1, char c2, boolean caseSensitive) { if (caseSensitive) { return c1 == c2; } return Character.toLowerCase(c1) == Character.toLowerCase(c2); } /** * Builds the bad symbol table required to run the algorithm. The method * starts from the second to last character of the pattern and moves to the * left. When it meets a new character, it is by definition its rightmost * occurrence and therefore puts the distance from the current index to the * index of the last character into the table. If the character is already * in the table, then it is not a rightmost occurrence, so it continues. * * @param pattern basis for the bad symbol table * @return the bad symbol table */ private static HashMap<Character, Integer> calcShiftValues(String pattern) { patternLength = pattern.length(); HashMap<Character, Integer> table = new HashMap<>(); for (int i = pattern.length() - 2; i >= 0; i--) { // length - 2 is the index of the second to last character char c = pattern.charAt(i); int finalI = i; table.computeIfAbsent(c, k -> pattern.length() - 1 - finalI); } return table; } /** * Helper function that uses the bad symbol shift table to return the * appropriate shift value for a given character * * @param c character * @return shift value that corresponds to the character argument */ private static Integer getShiftValue(char c) { if (shiftValues.get(c) != null) { return shiftValues.get(c); } else { return patternLength; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import java.util.Scanner; final class HowManyTimesRotated { private HowManyTimesRotated() { } public static void main(String[] object) { object = new Scanner(System.in); int n = ((Scanner)object).nextInt(); int[] nArray = new int[n]; for (int i = 0; i < n; ++i) { nArray[i] = ((Scanner)object).nextInt(); } System.out.println(\"The array has been rotated \" + HowManyTimesRotated.rotated(nArray) + \" times\"); ((Scanner)object).close(); } public static int rotated(int[] nArray) { int n = 0; int n2 = nArray.length - 1; int n3 = 0; while (n <= n2 && (nArray[n3 = n + (n2 - n) / 2] >= nArray[n3 - 1] || nArray[n3] >= nArray[n3 + 1])) { if (nArray[n3] > nArray[n3 - 1] && nArray[n3] < nArray[n3 + 1]) { n2 = n3 + 1; continue; } if (nArray[n3] <= nArray[n3 - 1] || nArray[n3] <= nArray[n3 + 1]) continue; n = n3 - 1; } return n3; } }", "deobfuscated_code": "package com.thealgorithms.searches; import java.util.Scanner; /* Problem Statement: Given an array, find out how many times it has to been rotated from its initial sorted position. Input-Output: Eg. [11,12,15,18,2,5,6,8] It has been rotated: 4 times (One rotation means putting the first element to the end) Note: The array cannot contain duplicates Logic: The position of the minimum element will give the number of times the array has been rotated from its initial sorted position. Eg. For [2,5,6,8,11,12,15,18], 1 rotation gives [5,6,8,11,12,15,18,2], 2 rotations [6,8,11,12,15,18,2,5] and so on. Finding the minimum element will take O(N) time but, we can use Binary Search to find the minimum element, we can reduce the complexity to O(log N). If we look at the rotated array, to identify the minimum element (say a[i]), we observe that a[i-1]>a[i]<a[i+1]. Some other test cases: 1. [1,2,3,4] Number of rotations: 0 or 4(Both valid) 2. [15,17,2,3,5] Number of rotations: 3 */ final class HowManyTimesRotated { private HowManyTimesRotated() { } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i++) { a[i] = sc.nextInt(); } System.out.println(\"The array has been rotated \" + rotated(a) + \" times\"); sc.close(); } public static int rotated(int[] a) { int low = 0; int high = a.length - 1; int mid = 0; // low + (high-low)/2 = (low + high)/2 while (low <= high) { mid = low + (high - low) / 2; if (a[mid] < a[mid - 1] && a[mid] < a[mid + 1]) { break; } else if (a[mid] > a[mid - 1] && a[mid] < a[mid + 1]) { high = mid + 1; } else if (a[mid] > a[mid - 1] && a[mid] > a[mid + 1]) { low = mid - 1; } } return mid; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.HuffmanNode; import com.thealgorithms.others.MyComparator; import java.util.PriorityQueue; import java.util.Scanner; public final class Huffman { private Huffman() { } public static void printCode(HuffmanNode huffmanNode, String object) { while (true) { if (huffmanNode.c == null && huffmanNode.d == null && Character.isLetter(huffmanNode.b)) { System.out.println(huffmanNode.b + \":\" + (String)object); return; } Huffman.printCode(huffmanNode.c, (String)object + \"0\"); object = (String)object + \"1\"; huffmanNode = huffmanNode.d; } } public static void main(String[] object) { HuffmanNode huffmanNode; object = new Scanner(System.in); Object object2 = new char[]{'a', 'b', 'c', 'd', 'e', 'f'}; Object object3 = new int[]{5, 9, 12, 13, 16, 45}; PriorityQueue<Object> priorityQueue = new PriorityQueue<Object>(6, new MyComparator()); for (int i = 0; i < 6; ++i) { huffmanNode = new HuffmanNode(); new HuffmanNode().b = object2[i]; huffmanNode.a = object3[i]; huffmanNode.c = null; huffmanNode.d = null; priorityQueue.add(huffmanNode); } Object object4 = null; while (priorityQueue.size() > 1) { huffmanNode = (HuffmanNode)priorityQueue.peek(); priorityQueue.poll(); object2 = (HuffmanNode)priorityQueue.peek(); priorityQueue.poll(); object3 = new HuffmanNode(); new HuffmanNode().a = huffmanNode.a + object2.a; object3.b = (char)45; object3.c = huffmanNode; object3.d = object2; object4 = object3; priorityQueue.add(object3); } Huffman.printCode(object4, \"\"); ((Scanner)object).close(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Comparator; import java.util.PriorityQueue; import java.util.Scanner; // node class is the basic structure // of each node present in the Huffman - tree. class HuffmanNode { int data; char c; HuffmanNode left; HuffmanNode right; } // comparator class helps to compare the node // on the basis of one of its attribute. // Here we will be compared // on the basis of data values of the nodes. class MyComparator implements Comparator<HuffmanNode> { public int compare(HuffmanNode x, HuffmanNode y) { return x.data - y.data; } } public final class Huffman { private Huffman() { } // recursive function to print the // huffman-code through the tree traversal. // Here s is the huffman - code generated. public static void printCode(HuffmanNode root, String s) { // base case; if the left and right are null // then its a leaf node and we print // the code s generated by traversing the tree. if (root.left == null && root.right == null && Character.isLetter(root.c)) { // c is the character in the node System.out.println(root.c + \":\" + s); return; } // if we go to left then add \"0\" to the code. // if we go to the right add\"1\" to the code. // recursive calls for left and // right sub-tree of the generated tree. printCode(root.left, s + \"0\"); printCode(root.right, s + \"1\"); } // main function public static void main(String[] args) { Scanner s = new Scanner(System.in); // number of characters. int n = 6; char[] charArray = {'a', 'b', 'c', 'd', 'e', 'f'}; int[] charfreq = {5, 9, 12, 13, 16, 45}; // creating a priority queue q. // makes a min-priority queue(min-heap). PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new MyComparator()); for (int i = 0; i < n; i++) { // creating a Huffman node object // and add it to the priority queue. HuffmanNode hn = new HuffmanNode(); hn.c = charArray[i]; hn.data = charfreq[i]; hn.left = null; hn.right = null; // add functions adds // the huffman node to the queue. q.add(hn); } // create a root node HuffmanNode root = null; // Here we will extract the two minimum value // from the heap each time until // its size reduces to 1, extract until // all the nodes are extracted. while (q.size() > 1) { // first min extract. HuffmanNode x = q.peek(); q.poll(); // second min extarct. HuffmanNode y = q.peek(); q.poll(); // new node f which is equal HuffmanNode f = new HuffmanNode(); // to the sum of the frequency of the two nodes // assigning values to the f node. f.data = x.data + y.data; f.c = '-'; // first extracted node as left child. f.left = x; // second extracted node as the right child. f.right = y; // marking the f node as the root node. root = f; // add this node to the priority-queue. q.add(f); } // print the codes by traversing the tree printCode(root, \"\"); s.close(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; class HuffmanNode { int a; char b; HuffmanNode c; HuffmanNode d; HuffmanNode() { } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; class HuffmanNode { int a; char b; HuffmanNode c; HuffmanNode d; HuffmanNode() { } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.audiofilters; public class IIRFilter { private final int a; private final double[] b; private final double[] c; private final double[] d; private final double[] e; public IIRFilter(int n) { if (n <= 0) { throw new IllegalArgumentException(\"order must be greater than zero\"); } this.a = n; this.b = new double[n + 1]; this.c = new double[n + 1]; this.b[0] = 1.0; this.c[0] = 1.0; this.d = new double[n]; this.e = new double[n]; } public void setCoeffs(double[] dArray, double[] dArray2) { if (dArray.length != this.a) { throw new IllegalArgumentException(\"aCoeffs must be of size \" + this.a + \", got \" + dArray.length); } if (dArray[0] == 0.0) { throw new IllegalArgumentException(\"aCoeffs.get(0) must not be zero\"); } if (dArray2.length != this.a) { throw new IllegalArgumentException(\"bCoeffs must be of size \" + this.a + \", got \" + dArray2.length); } for (int i = 0; i < this.a; ++i) { this.b[i] = dArray[i]; this.c[i] = dArray2[i]; } } public double process(double d) { int n; double d2 = 0.0; for (n = 1; n <= this.a; ++n) { d2 += this.c[n] * this.d[n - 1] - this.b[n] * this.e[n - 1]; } d2 = (d2 + this.c[0] * d) / this.b[0]; for (n = this.a - 1; n > 0; --n) { this.d[n] = this.d[n - 1]; this.e[n] = this.e[n - 1]; } this.d[0] = d; this.e[0] = d2; return d2; } }", "deobfuscated_code": "package com.thealgorithms.audiofilters; /** * N-Order IIR Filter Assumes inputs are normalized to [-1, 1] * * Based on the difference equation from * <a href=\"https://en.wikipedia.org/wiki/Infinite_impulse_response\">Wikipedia link</a> */ public class IIRFilter { private final int order; private final double[] coeffsA; private final double[] coeffsB; private final double[] historyX; private final double[] historyY; /** * Construct an IIR Filter * * @param order the filter's order * @throws IllegalArgumentException if order is zero or less */ public IIRFilter(int order) throws IllegalArgumentException { if (order < 1) { throw new IllegalArgumentException(\"order must be greater than zero\"); } this.order = order; coeffsA = new double[order + 1]; coeffsB = new double[order + 1]; // Sane defaults coeffsA[0] = 1.0; coeffsB[0] = 1.0; historyX = new double[order]; historyY = new double[order]; } /** * Set coefficients * * @param aCoeffs Denominator coefficients * @param bCoeffs Numerator coefficients * @throws IllegalArgumentException if {@code aCoeffs} or {@code bCoeffs} is * not of size {@code order}, or if {@code aCoeffs[0]} is 0.0 */ public void setCoeffs(double[] aCoeffs, double[] bCoeffs) throws IllegalArgumentException { if (aCoeffs.length != order) { throw new IllegalArgumentException(\"aCoeffs must be of size \" + order + \", got \" + aCoeffs.length); } if (aCoeffs[0] == 0.0) { throw new IllegalArgumentException(\"aCoeffs.get(0) must not be zero\"); } if (bCoeffs.length != order) { throw new IllegalArgumentException(\"bCoeffs must be of size \" + order + \", got \" + bCoeffs.length); } for (int i = 0; i < order; i++) { coeffsA[i] = aCoeffs[i]; coeffsB[i] = bCoeffs[i]; } } /** * Process a single sample * * @param sample the sample to process * @return the processed sample */ public double process(double sample) { double result = 0.0; // Process for (int i = 1; i <= order; i++) { result += (coeffsB[i] * historyX[i - 1] - coeffsA[i] * historyY[i - 1]); } result = (result + coeffsB[0] * sample) / coeffsA[0]; // Feedback for (int i = order - 1; i > 0; i--) { historyX[i] = historyX[i - 1]; historyY[i] = historyY[i - 1]; } historyX[0] = sample; historyY[0] = result; return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class IPConverter { private IPConverter() { } public static String ipToBinary(String stringArray) { StringBuilder stringBuilder = new StringBuilder(); for (String string : stringArray.split(\"\\\\.\")) { int n = Integer.parseInt(string); char[] cArray = new char[]{'0', '0', '0', '0', '0', '0', '0', '0'}; for (int i = 7; i >= 0; --i) { if ((n & 1) == 1) { cArray[i] = 49; } n >>>= 1; } stringBuilder.append(new String(cArray)).append(\".\"); } return stringBuilder.substring(0, stringBuilder.length() - 1); } public static String binaryToIP(String stringArray) { StringBuilder stringBuilder = new StringBuilder(); for (String string : stringArray.split(\"\\\\.\")) { stringBuilder.append(Integer.parseInt(string, 2)).append(\".\"); } return stringBuilder.substring(0, stringBuilder.length() - 1); } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * Converts an IPv4 address to its binary equivalent and vice-versa. * IP to Binary: Converts an IPv4 address to its binary equivalent. * Example: 127.3.4.5 -> 01111111.00000011.00000100.00000101 * * Binary to IP: Converts a binary equivalent to an IPv4 address. * Example: 01111111.00000011.00000100.00000101 -> 127.3.4.5 * * @author Hardvan */ public final class IPConverter { private IPConverter() { } /** * Converts an IPv4 address to its binary equivalent. * @param ip The IPv4 address to convert. * @return The binary equivalent of the IPv4 address. */ public static String ipToBinary(String ip) { StringBuilder binary = new StringBuilder(); for (String octet : ip.split(\"\\\\.\")) { binary.append(octetToBinary(Integer.parseInt(octet))).append(\".\"); } return binary.substring(0, binary.length() - 1); } /** * Converts a single octet to its 8-bit binary representation. * @param octet The octet to convert (0-255). * @return The 8-bit binary representation as a String. */ private static String octetToBinary(int octet) { char[] binary = {'0', '0', '0', '0', '0', '0', '0', '0'}; for (int i = 7; i >= 0; i--) { if ((octet & 1) == 1) { binary[i] = '1'; } octet >>>= 1; } return new String(binary); } /** * Converts a binary equivalent to an IPv4 address. * @param binary The binary equivalent to convert. * @return The IPv4 address of the binary equivalent. */ public static String binaryToIP(String binary) { StringBuilder ip = new StringBuilder(); for (String octet : binary.split(\"\\\\.\")) { ip.append(Integer.parseInt(octet, 2)).append(\".\"); } return ip.substring(0, ip.length() - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.net.InetAddress; import java.net.UnknownHostException; import java.util.Arrays; public final class IPv6Converter { private IPv6Converter() { } public static String ipv4ToIpv6(String object) { if (object == null || ((String)object).isEmpty()) { throw new UnknownHostException(\"IPv4 address is empty.\"); } object = InetAddress.getByName((String)object); object = ((InetAddress)object).getAddress(); byte[] byArray = new byte[16]; byte[] byArray2 = byArray; byArray[10] = -1; byArray2[11] = -1; System.arraycopy(object, 0, byArray2, 12, 4); object = new StringBuilder(\"::ffff:\"); for (int i = 12; i < 16; ++i) { ((StringBuilder)object).append(byArray2[i] & 0xFF); if (i >= 15) continue; ((StringBuilder)object).append('.'); } return ((StringBuilder)object).toString(); } /* * Unable to fully structure code */ public static String ipv6ToIpv4(String var0) { var0 = InetAddress.getByName((String)var0); v0 = var0.getAddress(); var0 = v0; var1_1 = v0; if (v0.length != 16) ** GOTO lbl-1000 for (var2_2 = 0; var2_2 < 10; ++var2_2) { if (var1_1[var2_2] == 0) { continue; } ** GOTO lbl-1000 } if (var1_1[10] == -1 && var1_1[11] == -1) { v1 = true; } else lbl-1000: // 3 sources { v1 = false; } if (v1) { v2 = Arrays.copyOfRange((byte[])var0, 12, 16); var0 = v2; var0 = InetAddress.getByAddress(v2); return var0.getHostAddress(); } throw new IllegalArgumentException(\"Not a valid IPv6-mapped IPv4 address.\"); } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.net.InetAddress; import java.net.UnknownHostException; import java.util.Arrays; /** * A utility class for converting between IPv6 and IPv4 addresses. * * - Converts IPv4 to IPv6-mapped IPv6 address. * - Extracts IPv4 address from IPv6-mapped IPv6. * - Handles exceptions for invalid inputs. * * @author Hardvan */ public final class IPv6Converter { private IPv6Converter() { } /** * Converts an IPv4 address (e.g., \"192.0.2.128\") to an IPv6-mapped IPv6 address. * Example: IPv4 \"192.0.2.128\" -> IPv6 \"::ffff:192.0.2.128\" * * @param ipv4Address The IPv4 address in string format. * @return The corresponding IPv6-mapped IPv6 address. * @throws UnknownHostException If the IPv4 address is invalid. * @throws IllegalArgumentException If the IPv6 address is not a mapped IPv4 address. */ public static String ipv4ToIpv6(String ipv4Address) throws UnknownHostException { if (ipv4Address == null || ipv4Address.isEmpty()) { throw new UnknownHostException(\"IPv4 address is empty.\"); } InetAddress ipv4 = InetAddress.getByName(ipv4Address); byte[] ipv4Bytes = ipv4.getAddress(); // Create IPv6-mapped IPv6 address (starts with ::ffff:) byte[] ipv6Bytes = new byte[16]; ipv6Bytes[10] = (byte) 0xff; ipv6Bytes[11] = (byte) 0xff; System.arraycopy(ipv4Bytes, 0, ipv6Bytes, 12, 4); // Manually format to \"::ffff:x.x.x.x\" format StringBuilder ipv6String = new StringBuilder(\"::ffff:\"); for (int i = 12; i < 16; i++) { ipv6String.append(ipv6Bytes[i] & 0xFF); if (i < 15) { ipv6String.append('.'); } } return ipv6String.toString(); } /** * Extracts the IPv4 address from an IPv6-mapped IPv6 address. * Example: IPv6 \"::ffff:192.0.2.128\" -> IPv4 \"192.0.2.128\" * * @param ipv6Address The IPv6 address in string format. * @return The extracted IPv4 address. * @throws UnknownHostException If the IPv6 address is invalid or not a mapped IPv4 address. */ public static String ipv6ToIpv4(String ipv6Address) throws UnknownHostException { InetAddress ipv6 = InetAddress.getByName(ipv6Address); byte[] ipv6Bytes = ipv6.getAddress(); // Check if the address is an IPv6-mapped IPv4 address if (isValidIpv6MappedIpv4(ipv6Bytes)) { byte[] ipv4Bytes = Arrays.copyOfRange(ipv6Bytes, 12, 16); InetAddress ipv4 = InetAddress.getByAddress(ipv4Bytes); return ipv4.getHostAddress(); } else { throw new IllegalArgumentException(\"Not a valid IPv6-mapped IPv4 address.\"); } } /** * Helper function to check if the given byte array represents * an IPv6-mapped IPv4 address (prefix 0:0:0:0:0:ffff). * * @param ipv6Bytes Byte array representation of the IPv6 address. * @return True if the address is IPv6-mapped IPv4, otherwise false. */ private static boolean isValidIpv6MappedIpv4(byte[] ipv6Bytes) { // IPv6-mapped IPv4 addresses are 16 bytes long, with the first 10 bytes set to 0, // followed by 0xff, 0xff, and the last 4 bytes representing the IPv4 address. if (ipv6Bytes.length != 16) { return false; } for (int i = 0; i < 10; i++) { if (ipv6Bytes[i] != 0) { return false; } } return ipv6Bytes[10] == (byte) 0xff && ipv6Bytes[11] == (byte) 0xff; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class IndexOfRightMostSetBit { private IndexOfRightMostSetBit() { } public static int indexOfRightMostSetBit(int n) { if (n == 0) { return -1; } if (n < 0) { n = -n; n &= ~n + 1; } int n2 = 0; while ((n & 1) == 0) { n >>= 1; ++n2; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * Utility class for bit manipulation operations. * This class provides methods to work with bitwise operations. * Specifically, it includes a method to find the index of the rightmost set bit * in an integer. * This class is not meant to be instantiated. * * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi) */ public final class IndexOfRightMostSetBit { private IndexOfRightMostSetBit() { } /** * Finds the index of the rightmost set bit in the given integer. * The index is zero-based, meaning the rightmost bit has an index of 0. * * @param n the integer to check for the rightmost set bit * @return the index of the rightmost set bit; -1 if there are no set bits * (i.e., the input integer is 0) */ public static int indexOfRightMostSetBit(int n) { if (n == 0) { return -1; // No set bits } // Handle negative numbers by finding the two's complement if (n < 0) { n = -n; n = n & (~n + 1); // Isolate the rightmost set bit } int index = 0; while ((n & 1) == 0) { n = n >> 1; index++; } return index; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import com.thealgorithms.stacks.BalancedBrackets; import java.io.Serializable; import java.util.Stack; import java.util.Vector; import java.util.regex.Matcher; import java.util.regex.Pattern; public final class InfixToPostfix { private InfixToPostfix() { } public static String infix2PostFix(String object) { Object object2 = object; Serializable serializable = Pattern.compile(\"[^(){}\\\\[\\\\]<>]\"); object2 = ((Pattern)serializable).matcher((CharSequence)object2); if (!BalancedBrackets.isBalanced(((Matcher)object2).replaceAll(\"\"))) { throw new IllegalArgumentException(\"Invalid expression: unbalanced brackets.\"); } object2 = new StringBuilder(); serializable = new Stack(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object3 = object[i]; if (Character.isLetterOrDigit((char)object3)) { ((StringBuilder)object2).append((char)object3); continue; } if (object3 == 40) { ((Stack)serializable).push(Character.valueOf((char)object3)); continue; } if (object3 == 41) { while (!((Vector)serializable).isEmpty() && ((Character)((Stack)serializable).peek()).charValue() != '(') { ((StringBuilder)object2).append(((Stack)serializable).pop()); } ((Stack)serializable).pop(); continue; } while (!((Vector)serializable).isEmpty() && InfixToPostfix.a((char)object3) <= InfixToPostfix.a(((Character)((Stack)serializable).peek()).charValue())) { ((StringBuilder)object2).append(((Stack)serializable).pop()); } ((Stack)serializable).push(Character.valueOf((char)object3)); } while (!((Vector)serializable).isEmpty()) { ((StringBuilder)object2).append(((Stack)serializable).pop()); } return ((StringBuilder)object2).toString(); } private static int a(char c) { switch (c) { case '+': case '-': { return 0; } case '*': case '/': { return 1; } case '^': { return 2; } } return -1; } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * Utility class for converting an infix arithmetic expression * into its equivalent postfix (Reverse Polish Notation) form. * <p> * This class provides a static method to perform the conversion, * validating balanced brackets before processing. * </p> */ public final class InfixToPostfix { private InfixToPostfix() { } /** * Converts a given infix expression string to a postfix expression string. * <p> * The method first checks if the brackets in the input expression are balanced * by calling {@code BalancedBrackets.isBalanced} on the filtered brackets. * If the brackets are not balanced, it throws an IllegalArgumentException. * </p> * <p> * Supported operators are: {@code +, -, *, /, ^} * and operands can be letters or digits. * </p> * * @param infixExpression the arithmetic expression in infix notation * @return the equivalent postfix notation expression * @throws IllegalArgumentException if the brackets in the expression are unbalanced */ public static String infix2PostFix(String infixExpression) { if (!BalancedBrackets.isBalanced(filterBrackets(infixExpression))) { throw new IllegalArgumentException(\"Invalid expression: unbalanced brackets.\"); } StringBuilder output = new StringBuilder(); Stack<Character> operatorStack = new Stack<>(); for (char token : infixExpression.toCharArray()) { if (Character.isLetterOrDigit(token)) { // Append operands (letters or digits) directly to output output.append(token); } else if (token == '(') { // Push '(' to stack operatorStack.push(token); } else if (token == ')') { // Pop and append until '(' is found while (!operatorStack.isEmpty() && operatorStack.peek() != '(') { output.append(operatorStack.pop()); } operatorStack.pop(); // Remove '(' from stack } else { // Pop operators with higher or equal precedence and append them while (!operatorStack.isEmpty() && precedence(token) <= precedence(operatorStack.peek())) { output.append(operatorStack.pop()); } operatorStack.push(token); } } // Pop any remaining operators while (!operatorStack.isEmpty()) { output.append(operatorStack.pop()); } return output.toString(); } /** * Returns the precedence level of the given operator. * * @param operator the operator character (e.g., '+', '-', '*', '/', '^') * @return the precedence value: higher means higher precedence, * or -1 if the character is not a recognized operator */ private static int precedence(char operator) { return switch (operator) { case '+', '-' -> 0; case '*', '/' -> 1; case '^' -> 2; default -> -1; }; } /** * Extracts only the bracket characters from the input string. * Supports parentheses (), curly braces {}, square brackets [], and angle brackets &lt;&gt;. * * @param input the original expression string * @return a string containing only bracket characters from the input */ private static String filterBrackets(String input) { Pattern pattern = Pattern.compile(\"[^(){}\\\\[\\\\]<>]\"); Matcher matcher = pattern.matcher(input); return matcher.replaceAll(\"\"); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import com.thealgorithms.stacks.BalancedBrackets; import java.io.Serializable; import java.util.Stack; import java.util.Vector; import java.util.regex.Matcher; import java.util.regex.Pattern; public final class InfixToPrefix { private InfixToPrefix() { } public static String infix2Prefix(String object) { if (object == null) { throw new NullPointerException(\"Input expression cannot be null.\"); } if (((String)(object = ((String)object).trim())).isEmpty()) { return \"\"; } Object object2 = object; Serializable serializable = Pattern.compile(\"[^(){}\\\\[\\\\]<>]\"); object2 = ((Pattern)serializable).matcher((CharSequence)object2); if (!BalancedBrackets.isBalanced(((Matcher)object2).replaceAll(\"\"))) { throw new IllegalArgumentException(\"Invalid expression: unbalanced brackets.\"); } object2 = new StringBuilder(); serializable = new Stack(); object = new StringBuilder((String)object).reverse().toString(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object3 = object[i]; if (Character.isLetterOrDigit((char)object3)) { ((StringBuilder)object2).append((char)object3); continue; } if (object3 == 41) { ((Stack)serializable).push(Character.valueOf((char)object3)); continue; } if (object3 == 40) { while (!((Vector)serializable).isEmpty() && ((Character)((Stack)serializable).peek()).charValue() != ')') { ((StringBuilder)object2).append(((Stack)serializable).pop()); } ((Stack)serializable).pop(); continue; } while (!((Vector)serializable).isEmpty() && InfixToPrefix.a((char)object3) < InfixToPrefix.a(((Character)((Stack)serializable).peek()).charValue())) { ((StringBuilder)object2).append(((Stack)serializable).pop()); } ((Stack)serializable).push(Character.valueOf((char)object3)); } while (!((Vector)serializable).isEmpty()) { ((StringBuilder)object2).append(((Stack)serializable).pop()); } return ((StringBuilder)object2).reverse().toString(); } private static int a(char c) { switch (c) { case '+': case '-': { return 0; } case '*': case '/': { return 1; } case '^': { return 2; } } return -1; } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * Utility class for converting an infix arithmetic expression * into its equivalent prefix notation expression. * <p> * This class provides a static method to perform the conversion, * validating balanced brackets before processing. * </p> */ public final class InfixToPrefix { private InfixToPrefix() { } /** * Converts a given infix expression string to a prefix expression string. * <p> * The method validates that the input expression has balanced brackets using * {@code BalancedBrackets.isBalanced} on the filtered bracket characters. * It throws an {@code IllegalArgumentException} if the brackets are unbalanced, * and a {@code NullPointerException} if the input is null. * </p> * <p> * Supported operators: {@code +, -, *, /, ^} and operands can be letters or digits. * </p> * * @param infixExpression the arithmetic expression in infix notation * @return the equivalent prefix notation expression * @throws IllegalArgumentException if brackets are unbalanced * @throws NullPointerException if the input expression is null */ public static String infix2Prefix(String infixExpression) { if (infixExpression == null) { throw new NullPointerException(\"Input expression cannot be null.\"); } infixExpression = infixExpression.trim(); if (infixExpression.isEmpty()) { return \"\"; } if (!BalancedBrackets.isBalanced(filterBrackets(infixExpression))) { throw new IllegalArgumentException(\"Invalid expression: unbalanced brackets.\"); } StringBuilder output = new StringBuilder(); Stack<Character> operatorStack = new Stack<>(); // Reverse the infix expression to facilitate prefix conversion String reversedInfix = new StringBuilder(infixExpression).reverse().toString(); for (char token : reversedInfix.toCharArray()) { if (Character.isLetterOrDigit(token)) { // Append operands directly to output output.append(token); } else if (token == ')') { // Push ')' onto stack (since expression is reversed, '(' and ')' roles swapped) operatorStack.push(token); } else if (token == '(') { // Pop operators until ')' is found while (!operatorStack.isEmpty() && operatorStack.peek() != ')') { output.append(operatorStack.pop()); } operatorStack.pop(); // Remove the ')' } else { // Pop operators with higher precedence before pushing current operator while (!operatorStack.isEmpty() && precedence(token) < precedence(operatorStack.peek())) { output.append(operatorStack.pop()); } operatorStack.push(token); } } // Append any remaining operators in stack while (!operatorStack.isEmpty()) { output.append(operatorStack.pop()); } // Reverse the output to obtain the final prefix expression return output.reverse().toString(); } /** * Returns the precedence level of the given operator. * * @param operator the operator character (e.g., '+', '-', '*', '/', '^') * @return the precedence value: higher means higher precedence, * or -1 if the character is not a recognized operator */ private static int precedence(char operator) { return switch (operator) { case '+', '-' -> 0; case '*', '/' -> 1; case '^' -> 2; default -> -1; }; } /** * Extracts only the bracket characters from the input string. * Supports parentheses (), curly braces {}, square brackets [], and angle brackets &lt;&gt;. * * @param input the original expression string * @return a string containing only bracket characters from the input */ private static String filterBrackets(String input) { Pattern pattern = Pattern.compile(\"[^(){}\\\\[\\\\]<>]\"); Matcher matcher = pattern.matcher(input); return matcher.replaceAll(\"\"); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.List; public final class InorderTraversal { private InorderTraversal() { } public static List recursiveInorder(BinaryTree$Node binaryTree$Node) { ArrayList arrayList = new ArrayList(); InorderTraversal.a(binaryTree$Node, arrayList); return arrayList; } public static List iterativeInorder(BinaryTree$Node binaryTree$Node) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); if (binaryTree$Node == null) { return arrayList; } ArrayDeque<BinaryTree$Node> arrayDeque = new ArrayDeque<BinaryTree$Node>(); while (!arrayDeque.isEmpty() || binaryTree$Node != null) { while (binaryTree$Node != null) { arrayDeque.push(binaryTree$Node); binaryTree$Node = binaryTree$Node.left; } binaryTree$Node = (BinaryTree$Node)arrayDeque.pop(); arrayList.add(binaryTree$Node.data); binaryTree$Node = binaryTree$Node.right; } return arrayList; } private static void a(BinaryTree$Node binaryTree$Node, List list) { while (binaryTree$Node != null) { InorderTraversal.a(binaryTree$Node.left, list); list.add(binaryTree$Node.data); binaryTree$Node = binaryTree$Node.right; } return; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Deque; import java.util.List; /** * Given tree is traversed in an 'inorder' way: LEFT -> ROOT -> RIGHT. * Below are given the recursive and iterative implementations. * * Complexities: * Recursive: O(n) - time, O(n) - space, where 'n' is the number of nodes in a tree. * * Iterative: O(n) - time, O(h) - space, where 'n' is the number of nodes in a tree * and 'h' is the height of a binary tree. * In the worst case 'h' can be O(n) if tree is completely unbalanced, for instance: * 5 * \\ * 6 * \\ * 7 * \\ * 8 * * @author Albina Gimaletdinova on 21/02/2023 */ public final class InorderTraversal { private InorderTraversal() { } public static List<Integer> recursiveInorder(BinaryTree.Node root) { List<Integer> result = new ArrayList<>(); recursiveInorder(root, result); return result; } public static List<Integer> iterativeInorder(BinaryTree.Node root) { List<Integer> result = new ArrayList<>(); if (root == null) { return result; } Deque<BinaryTree.Node> stack = new ArrayDeque<>(); while (!stack.isEmpty() || root != null) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); result.add(root.data); root = root.right; } return result; } private static void recursiveInorder(BinaryTree.Node root, List<Integer> result) { if (root == null) { return; } recursiveInorder(root.left, result); result.add(root.data); recursiveInorder(root.right, result); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Scanner; public final class InsertDeleteInArray { private InsertDeleteInArray() { } public static void main(String[] object) { object = new Scanner(System.in); try { int n; int n2; System.out.println(\"Enter the size of the array\"); int n3 = ((Scanner)object).nextInt(); int[] nArray = new int[n3]; for (n2 = 0; n2 < n3; ++n2) { System.out.println(\"Enter the element\"); nArray[n2] = ((Scanner)object).nextInt(); } System.out.println(\"Enter the index at which the element should be inserted\"); int n4 = ((Scanner)object).nextInt(); System.out.println(\"Enter the element to be inserted\"); int n5 = ((Scanner)object).nextInt(); int[] nArray2 = new int[++n3]; for (n2 = 0; n2 < n3; ++n2) { nArray2[n2] = n2 <= n4 ? nArray[n2] : nArray[n2 - 1]; } nArray2[n4] = n5; for (n2 = 0; n2 < n3; ++n2) { System.out.println(nArray2[n2]); } System.out.println(\"Enter the index at which element is to be deleted\"); for (n2 = n = ((Scanner)object).nextInt(); n2 < n3 - 1; ++n2) { nArray2[n2] = nArray2[n2 + 1]; } for (n2 = 0; n2 < n3 - 1; ++n2) { System.out.println(nArray2[n2]); } return; } finally { ((Scanner)object).close(); } } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Scanner; public final class InsertDeleteInArray { private InsertDeleteInArray() { } public static void main(String[] args) { try (Scanner s = new Scanner(System.in)) { System.out.println(\"Enter the size of the array\"); int size = s.nextInt(); int[] a = new int[size]; int i; // To enter the initial elements for (i = 0; i < size; i++) { System.out.println(\"Enter the element\"); a[i] = s.nextInt(); } // To insert a new element(we are creating a new array) System.out.println(\"Enter the index at which the element should be inserted\"); int insertPos = s.nextInt(); System.out.println(\"Enter the element to be inserted\"); int ins = s.nextInt(); int size2 = size + 1; int[] b = new int[size2]; for (i = 0; i < size2; i++) { if (i <= insertPos) { b[i] = a[i]; } else { b[i] = a[i - 1]; } } b[insertPos] = ins; for (i = 0; i < size2; i++) { System.out.println(b[i]); } // To delete an element given the index System.out.println(\"Enter the index at which element is to be deleted\"); int delPos = s.nextInt(); for (i = delPos; i < size2 - 1; i++) { b[i] = b[i + 1]; } for (i = 0; i < size2 - 1; i++) { System.out.println(b[i]); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; class InsertionSort implements SortAlgorithm { InsertionSort() { } @Override public Comparable[] sort(Comparable[] comparableArray) { return this.sort(comparableArray, 0, comparableArray.length); } public Comparable[] sort(Comparable[] comparableArray, int n, int n2) { if (comparableArray == null || n >= n2) { return comparableArray; } for (int i = n + 1; i < n2; ++i) { Comparable comparable = comparableArray[i]; for (int j = i - 1; j >= n && SortUtils.less(comparable, comparableArray[j]); --j) { comparableArray[j + 1] = comparableArray[j]; } comparableArray[j + 1] = comparable; } return comparableArray; } public Comparable[] sentinelSort(Comparable[] comparableArray) { int n; if (comparableArray == null || comparableArray.length <= 1) { return comparableArray; } Comparable[] comparableArray2 = comparableArray; int n2 = 0; for (n = 1; n < comparableArray2.length; ++n) { if (!SortUtils.less(comparableArray2[n], comparableArray2[n2])) continue; n2 = n; } int n3 = n2; SortUtils.swap(comparableArray, 0, n3); for (n3 = 2; n3 < comparableArray.length; ++n3) { Comparable comparable = comparableArray[n3]; for (n = n3; n > 0 && SortUtils.less(comparable, comparableArray[n - 1]); --n) { comparableArray[n] = comparableArray[n - 1]; } comparableArray[n] = comparable; } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; class InsertionSort implements SortAlgorithm { /** * Sorts the given array using the standard Insertion Sort algorithm. * * @param array The array to be sorted * @param <T> The type of elements in the array, which must be comparable * @return The sorted array */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { return sort(array, 0, array.length); } /** * Sorts a subarray of the given array using the standard Insertion Sort algorithm. * * @param array The array to be sorted * @param lo The starting index of the subarray * @param hi The ending index of the subarray (exclusive) * @param <T> The type of elements in the array, which must be comparable * @return The sorted array */ public <T extends Comparable<T>> T[] sort(T[] array, final int lo, final int hi) { if (array == null || lo >= hi) { return array; } for (int i = lo + 1; i < hi; i++) { final T key = array[i]; int j = i - 1; while (j >= lo && SortUtils.less(key, array[j])) { array[j + 1] = array[j]; j--; } array[j + 1] = key; } return array; } /** * Sentinel sort is a function which on the first step finds the minimal element in the provided * array and puts it to the zero position, such a trick gives us an ability to avoid redundant * comparisons like `j > 0` and swaps (we can move elements on position right, until we find * the right position for the chosen element) on further step. * * @param array The array to be sorted * @param <T> The type of elements in the array, which must be comparable * @return The sorted array */ public <T extends Comparable<T>> T[] sentinelSort(T[] array) { if (array == null || array.length <= 1) { return array; } final int minElemIndex = findMinIndex(array); SortUtils.swap(array, 0, minElemIndex); for (int i = 2; i < array.length; i++) { final T currentValue = array[i]; int j = i; while (j > 0 && SortUtils.less(currentValue, array[j - 1])) { array[j] = array[j - 1]; j--; } array[j] = currentValue; } return array; } /** * Finds the index of the minimum element in the array. * * @param array The array to be searched * @param <T> The type of elements in the array, which must be comparable * @return The index of the minimum element */ private <T extends Comparable<T>> int findMinIndex(final T[] array) { int minIndex = 0; for (int i = 1; i < array.length; i++) { if (SortUtils.less(array[i], array[minIndex])) { minIndex = i; } } return minIndex; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.util.Map; public final class IntegerToEnglish { private static final Map a = Map.ofEntries(Map.entry(0, \"\"), Map.entry(1, \"One\"), Map.entry(2, \"Two\"), Map.entry(3, \"Three\"), Map.entry(4, \"Four\"), Map.entry(5, \"Five\"), Map.entry(6, \"Six\"), Map.entry(7, \"Seven\"), Map.entry(8, \"Eight\"), Map.entry(9, \"Nine\"), Map.entry(10, \"Ten\"), Map.entry(11, \"Eleven\"), Map.entry(12, \"Twelve\"), Map.entry(13, \"Thirteen\"), Map.entry(14, \"Fourteen\"), Map.entry(15, \"Fifteen\"), Map.entry(16, \"Sixteen\"), Map.entry(17, \"Seventeen\"), Map.entry(18, \"Eighteen\"), Map.entry(19, \"Nineteen\"), Map.entry(20, \"Twenty\"), Map.entry(30, \"Thirty\"), Map.entry(40, \"Forty\"), Map.entry(50, \"Fifty\"), Map.entry(60, \"Sixty\"), Map.entry(70, \"Seventy\"), Map.entry(80, \"Eighty\"), Map.entry(90, \"Ninety\"), Map.entry(100, \"Hundred\")); private static final Map b = Map.ofEntries(Map.entry(1, \"Thousand\"), Map.entry(2, \"Million\"), Map.entry(3, \"Billion\")); private IntegerToEnglish() { } public static String integerToEnglishWords(int n) { if (n == 0) { return \"Zero\"; } StringBuilder stringBuilder = new StringBuilder(); int n2 = 0; while (n > 0) { int n3 = n % 1000; n /= 1000; if (n3 > 0) { Object object; int n4; int n5 = n3 % 100; StringBuilder stringBuilder2 = new StringBuilder(); if (n5 <= 20) { stringBuilder2.append((String)a.get(n5)); } else if (a.containsKey(n5)) { stringBuilder2.append((String)a.get(n5)); } else { n4 = n5 / 10; String string = a.getOrDefault(n4 * 10, \"\"); String string2 = a.getOrDefault(n5 %= 10, \"\"); stringBuilder2.append(string); if (string2 != null && !string2.isEmpty()) { stringBuilder2.append(\" \").append(string2); } } n4 = n3 / 100; if (n4 > 0) { if (stringBuilder2.length() > 0) { stringBuilder2.insert(0, \" \"); } stringBuilder2.insert(0, String.format(\"%s Hundred\", a.get(n4))); } if (!((String)(object = stringBuilder2.toString().trim())).isEmpty()) { if (n2 > 0) { object = (String)object + \" \" + (String)b.get(n2); } if (stringBuilder.length() > 0) { stringBuilder.insert(0, \" \"); } stringBuilder.insert(0, (String)object); } } ++n2; } return stringBuilder.toString().trim(); } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.util.Map; /** * A utility class to convert integers to their English word representation. * * <p>The class supports conversion of numbers from 0 to 2,147,483,647 * (the maximum value of a 32-bit signed integer). It divides the number * into groups of three digits (thousands, millions, billions, etc.) and * translates each group into words.</p> * * <h2>Example Usage</h2> * <pre> * IntegerToEnglish.integerToEnglishWords(12345); * // Output: \"Twelve Thousand Three Hundred Forty Five\" * </pre> * * <p>This class uses two maps:</p> * <ul> * <li>BASE_NUMBERS_MAP: Holds English words for numbers 0-20, multiples of 10 up to 90, and 100.</li> * <li>THOUSAND_POWER_MAP: Maps powers of 1000 (e.g., Thousand, Million, Billion).</li> * </ul> */ public final class IntegerToEnglish { private static final Map<Integer, String> BASE_NUMBERS_MAP = Map.ofEntries(Map.entry(0, \"\"), Map.entry(1, \"One\"), Map.entry(2, \"Two\"), Map.entry(3, \"Three\"), Map.entry(4, \"Four\"), Map.entry(5, \"Five\"), Map.entry(6, \"Six\"), Map.entry(7, \"Seven\"), Map.entry(8, \"Eight\"), Map.entry(9, \"Nine\"), Map.entry(10, \"Ten\"), Map.entry(11, \"Eleven\"), Map.entry(12, \"Twelve\"), Map.entry(13, \"Thirteen\"), Map.entry(14, \"Fourteen\"), Map.entry(15, \"Fifteen\"), Map.entry(16, \"Sixteen\"), Map.entry(17, \"Seventeen\"), Map.entry(18, \"Eighteen\"), Map.entry(19, \"Nineteen\"), Map.entry(20, \"Twenty\"), Map.entry(30, \"Thirty\"), Map.entry(40, \"Forty\"), Map.entry(50, \"Fifty\"), Map.entry(60, \"Sixty\"), Map.entry(70, \"Seventy\"), Map.entry(80, \"Eighty\"), Map.entry(90, \"Ninety\"), Map.entry(100, \"Hundred\")); private static final Map<Integer, String> THOUSAND_POWER_MAP = Map.ofEntries(Map.entry(1, \"Thousand\"), Map.entry(2, \"Million\"), Map.entry(3, \"Billion\")); private IntegerToEnglish() { } /** * Converts numbers less than 1000 into English words. * * @param number the integer value (0-999) to convert * @return the English word representation of the input number */ private static String convertToWords(int number) { int remainder = number % 100; StringBuilder result = new StringBuilder(); if (remainder <= 20) { result.append(BASE_NUMBERS_MAP.get(remainder)); } else if (BASE_NUMBERS_MAP.containsKey(remainder)) { result.append(BASE_NUMBERS_MAP.get(remainder)); } else { int tensDigit = remainder / 10; int onesDigit = remainder % 10; String tens = BASE_NUMBERS_MAP.getOrDefault(tensDigit * 10, \"\"); String ones = BASE_NUMBERS_MAP.getOrDefault(onesDigit, \"\"); result.append(tens); if (ones != null && !ones.isEmpty()) { result.append(\" \").append(ones); } } int hundredsDigit = number / 100; if (hundredsDigit > 0) { if (result.length() > 0) { result.insert(0, \" \"); } result.insert(0, String.format(\"%s Hundred\", BASE_NUMBERS_MAP.get(hundredsDigit))); } return result.toString().trim(); } /** * Converts a non-negative integer to its English word representation. * * @param number the integer to convert (0-2,147,483,647) * @return the English word representation of the input number */ public static String integerToEnglishWords(int number) { if (number == 0) { return \"Zero\"; } StringBuilder result = new StringBuilder(); int index = 0; while (number > 0) { int remainder = number % 1000; number /= 1000; if (remainder > 0) { String subResult = convertToWords(remainder); if (!subResult.isEmpty()) { if (index > 0) { subResult += \" \" + THOUSAND_POWER_MAP.get(index); } if (result.length() > 0) { result.insert(0, \" \"); } result.insert(0, subResult); } } index++; } return result.toString().trim(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class IntegerToRoman { private static final int[] a = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; private static final String[] b = new String[]{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}; private IntegerToRoman() { } public static String integerToRoman(int n) { if (n <= 0) { return \"\"; } StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < a.length; ++i) { int n2 = n / a[i]; stringBuilder.append(b[i].repeat(Math.max(0, n2))); n -= n2 * a[i]; } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * A utility class to convert integers into Roman numerals. * * <p>Roman numerals follow these rules: * <ul> * <li>I = 1</li> * <li>IV = 4</li> * <li>V = 5</li> * <li>IX = 9</li> * <li>X = 10</li> * <li>XL = 40</li> * <li>L = 50</li> * <li>XC = 90</li> * <li>C = 100</li> * <li>D = 500</li> * <li>M = 1000</li> * </ul> * * <p>Conversion is based on repeatedly subtracting the largest possible Roman numeral value * from the input number until it reaches zero. For example, 1994 is converted as: * <pre> * 1994 -> MCMXCIV (1000 + 900 + 90 + 4) * </pre> */ public final class IntegerToRoman { // Array of Roman numeral values in descending order private static final int[] ALL_ROMAN_NUMBERS_IN_ARABIC = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; // Corresponding Roman numeral symbols private static final String[] ALL_ROMAN_NUMBERS = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}; private IntegerToRoman() { } /** * Converts an integer to its Roman numeral representation. * Steps: * <ol> * <li>Iterate over the Roman numeral values in descending order</li> * <li>Calculate how many times a numeral fits</li> * <li>Append the corresponding symbol</li> * <li>Subtract the value from the number</li> * <li>Repeat until the number is zero</li> * <li>Return the Roman numeral representation</li> * </ol> * * @param num the integer value to convert (must be greater than 0) * @return the Roman numeral representation of the input integer * or an empty string if the input is non-positive */ public static String integerToRoman(int num) { if (num <= 0) { return \"\"; } StringBuilder builder = new StringBuilder(); for (int i = 0; i < ALL_ROMAN_NUMBERS_IN_ARABIC.length; i++) { int times = num / ALL_ROMAN_NUMBERS_IN_ARABIC[i]; builder.append(ALL_ROMAN_NUMBERS[i].repeat(Math.max(0, times))); num -= times * ALL_ROMAN_NUMBERS_IN_ARABIC[i]; } return builder.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; class InterpolationSearch { InterpolationSearch() { } public int find(int[] nArray, int n) { int n2 = 0; int n3 = nArray.length - 1; while (n2 <= n3 && n >= nArray[n2] && n <= nArray[n3]) { int n4 = n2 + (n3 - n2) / (nArray[n3] - nArray[n2]) * (n - nArray[n2]); if (nArray[n4] == n) { return n4; } if (nArray[n4] < n) { n2 = n4 + 1; continue; } n3 = n4 - 1; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; /** * InterpolationSearch is an algorithm that searches for a target value within a sorted array * by estimating the position based on the values at the corners of the current search range. * * <p> * The performance of this algorithm can vary: * - Worst-case performance: O(n) * - Best-case performance: O(1) * - Average performance: O(log(log(n))) if the elements are uniformly distributed; otherwise O(n) * - Worst-case space complexity: O(1) * </p> * * <p> * This search algorithm requires the input array to be sorted. * </p> * * @author Podshivalov Nikita (https://github.com/nikitap492) */ class InterpolationSearch { /** * Finds the index of the specified key in a sorted array using interpolation search. * * @param array The sorted array to search. * @param key The value to search for. * @return The index of the key if found, otherwise -1. */ public int find(int[] array, int key) { // Find indexes of two corners int start = 0; int end = (array.length - 1); // Since array is sorted, an element present // in array must be in range defined by corner while (start <= end && key >= array[start] && key <= array[end]) { // Probing the position with keeping // uniform distribution in mind. int pos = start + (((end - start) / (array[end] - array[start])) * (key - array[start])); // Condition of target found if (array[pos] == key) { return pos; } // If key is larger, key is in upper part if (array[pos] < key) { start = pos + 1; } // If key is smaller, x is in lower part else { end = pos - 1; } } return -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; public final class Intersection { private Intersection() { } public static List intersection(int[] object, int[] nArray) { if (object == null || nArray == null || ((int[])object).length == 0 || nArray.length == 0) { return Collections.emptyList(); } HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>(); for (int n3 : object) { hashMap.put(n3, hashMap.getOrDefault(n3, 0) + 1); } object = new ArrayList(); int[] nArray2 = nArray; int n4 = nArray.length; for (int n3 = 0; n3 < n4; ++n3) { int n5 = nArray2[n3]; if (hashMap.getOrDefault(n5, 0) <= 0) continue; object.add(n5); hashMap.computeIfPresent(n5, (n, n2) -> n2 - 1); } return object; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.hashmap.hashing; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; /** * The {@code Intersection} class provides a method to compute the intersection of two integer arrays. * <p> * This intersection includes duplicate values  meaning elements are included in the result * as many times as they appear in both arrays (i.e., multiset intersection). * </p> * * <p> * The algorithm uses a {@link java.util.HashMap} to count occurrences of elements in the first array, * then iterates through the second array to collect common elements based on these counts. * </p> * * <p> * Example usage: * <pre>{@code * int[] array1 = {1, 2, 2, 1}; * int[] array2 = {2, 2}; * List<Integer> result = Intersection.intersection(array1, array2); // result: [2, 2] * }</pre> * </p> * * <p> * Note: The order of elements in the returned list depends on the order in the second input array. * </p> */ public final class Intersection { private Intersection() { // Utility class; prevent instantiation } /** * Computes the intersection of two integer arrays, preserving element frequency. * For example, given [1,2,2,3] and [2,2,4], the result will be [2,2]. * * Steps: * 1. Count the occurrences of each element in the first array using a map. * 2. Iterate over the second array and collect common elements. * * @param arr1 the first array of integers * @param arr2 the second array of integers * @return a list containing the intersection of the two arrays (with duplicates), * or an empty list if either array is null or empty */ public static List<Integer> intersection(int[] arr1, int[] arr2) { if (arr1 == null || arr2 == null || arr1.length == 0 || arr2.length == 0) { return Collections.emptyList(); } Map<Integer, Integer> countMap = new HashMap<>(); for (int num : arr1) { countMap.put(num, countMap.getOrDefault(num, 0) + 1); } List<Integer> result = new ArrayList<>(); for (int num : arr2) { if (countMap.getOrDefault(num, 0) > 0) { result.add(num); countMap.computeIfPresent(num, (k, v) -> v - 1); } } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class IntrospectiveSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray == null || comparableArray.length <= 1) { return comparableArray; } int n = 2 * (int)(Math.log(comparableArray.length) / Math.log(2.0)); IntrospectiveSort.a(comparableArray, 0, comparableArray.length - 1, n); return comparableArray; } private static void a(Comparable[] comparableArray, int n, int n2, int n3) { while (n2 - n > 16) { if (n3 == 0) { IntrospectiveSort.c(comparableArray, n, n2); return; } int n4 = IntrospectiveSort.a(comparableArray, n, n2); IntrospectiveSort.a(comparableArray, n4 + 1, n2, n3 - 1); n2 = n4 - 1; } IntrospectiveSort.b(comparableArray, n, n2); } private static int a(Comparable[] comparableArray, int n, int n2) { int n3 = n + (int)(Math.random() * (double)(n2 - n + 1)); SortUtils.swap(comparableArray, n3, n2); Comparable comparable = comparableArray[n2]; int n4 = n - 1; while (n < n2) { if (SortUtils.a(comparable, comparableArray[n])) { SortUtils.swap(comparableArray, ++n4, n); } ++n; } SortUtils.swap(comparableArray, n4 + 1, n2); return n4 + 1; } private static void b(Comparable[] comparableArray, int n, int n2) { for (int i = n + 1; i <= n2; ++i) { Comparable comparable = comparableArray[i]; for (int j = i - 1; j >= n && SortUtils.greater(comparableArray[j], comparable); --j) { comparableArray[j + 1] = comparableArray[j]; } comparableArray[j + 1] = comparable; } } private static void c(Comparable[] comparableArray, int n, int n2) { int n3; int n4 = n2 - n + 1; for (n3 = n4 / 2 - 1; n3 >= 0; --n3) { IntrospectiveSort.b(comparableArray, n3, n4, n); } for (n3 = n2; n3 > n; --n3) { SortUtils.swap(comparableArray, n, n3); IntrospectiveSort.b(comparableArray, 0, n3 - n, n); } } private static void b(Comparable[] comparableArray, int n, int n2, int n3) { while (true) { int n4 = 2 * n + 1; int n5 = 2 * n + 2; int n6 = n; if (n4 < n2 && SortUtils.greater(comparableArray[n3 + n4], comparableArray[n3 + n6])) { n6 = n4; } if (n5 < n2 && SortUtils.greater(comparableArray[n3 + n5], comparableArray[n3 + n6])) { n6 = n5; } if (n6 == n) break; SortUtils.swap(comparableArray, n3 + n, n3 + n6); n = n6; } } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * Introspective Sort Algorithm Implementation * * @see <a href=\"https://en.wikipedia.org/wiki/Introsort\">IntroSort Algorithm</a> */ public class IntrospectiveSort implements SortAlgorithm { private static final int INSERTION_SORT_THRESHOLD = 16; /** * Sorts the given array using Introspective Sort, which combines quicksort, heapsort, and insertion sort. * * @param array The array to be sorted * @param <T> The type of elements in the array, which must be comparable * @return The sorted array */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { if (array == null || array.length <= 1) { return array; } final int depth = 2 * (int) (Math.log(array.length) / Math.log(2)); introspectiveSort(array, 0, array.length - 1, depth); return array; } /** * Performs introspective sort on the specified subarray. * * @param array The array to be sorted * @param low The starting index of the subarray * @param high The ending index of the subarray * @param depth The current depth of recursion * @param <T> The type of elements in the array, which must be comparable */ private static <T extends Comparable<T>> void introspectiveSort(T[] array, final int low, int high, final int depth) { while (high - low > INSERTION_SORT_THRESHOLD) { if (depth == 0) { heapSort(array, low, high); return; } final int pivotIndex = partition(array, low, high); introspectiveSort(array, pivotIndex + 1, high, depth - 1); high = pivotIndex - 1; } insertionSort(array, low, high); } /** * Partitions the array around a pivot. * * @param array The array to be partitioned * @param low The starting index of the subarray * @param high The ending index of the subarray * @param <T> The type of elements in the array, which must be comparable * @return The index of the pivot */ private static <T extends Comparable<T>> int partition(T[] array, final int low, final int high) { final int pivotIndex = low + (int) (Math.random() * (high - low + 1)); SortUtils.swap(array, pivotIndex, high); final T pivot = array[high]; int i = low - 1; for (int j = low; j < high; j++) { if (SortUtils.greaterOrEqual(pivot, array[j])) { i++; SortUtils.swap(array, i, j); } } SortUtils.swap(array, i + 1, high); return i + 1; } /** * Sorts a subarray using insertion sort. * * @param array The array to be sorted * @param low The starting index of the subarray * @param high The ending index of the subarray * @param <T> The type of elements in the array, which must be comparable */ private static <T extends Comparable<T>> void insertionSort(T[] array, final int low, final int high) { for (int i = low + 1; i <= high; i++) { final T key = array[i]; int j = i - 1; while (j >= low && SortUtils.greater(array[j], key)) { array[j + 1] = array[j]; j--; } array[j + 1] = key; } } /** * Sorts a subarray using heapsort. * * @param array The array to be sorted * @param low The starting index of the subarray * @param high The ending index of the subarray * @param <T> The type of elements in the array, which must be comparable */ private static <T extends Comparable<T>> void heapSort(T[] array, final int low, final int high) { final int n = high - low + 1; for (int i = (n / 2) - 1; i >= 0; i--) { heapify(array, i, n, low); } for (int i = high; i > low; i--) { SortUtils.swap(array, low, i); heapify(array, 0, i - low, low); } } /** * Maintains the heap property for a subarray. * * @param array The array to be heapified * @param i The index to be heapified * @param n The size of the heap * @param low The starting index of the subarray * @param <T> The type of elements in the array, which must be comparable */ private static <T extends Comparable<T>> void heapify(T[] array, final int i, final int n, final int low) { final int left = 2 * i + 1; final int right = 2 * i + 2; int largest = i; if (left < n && SortUtils.greater(array[low + left], array[low + largest])) { largest = left; } if (right < n && SortUtils.greater(array[low + right], array[low + largest])) { largest = right; } if (largest != i) { SortUtils.swap(array, low + i, low + largest); heapify(array, largest, n, low); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix; public final class InverseOfMatrix { private InverseOfMatrix() { } public static double[][] invert(double[][] dArray) { int n; int n2; double d; int n3 = dArray.length; double[][] dArray2 = new double[n3][n3]; int n4 = n3; double[][] dArray3 = new double[n4][n4]; int[] nArray = new int[n3]; for (int i = 0; i < n3; ++i) { dArray3[i][i] = 1.0; } int[] nArray2 = nArray; double[][] dArray4 = dArray; int n5 = nArray2.length; double[] dArray5 = new double[n5]; int n6 = 0; while (n6 < n5) { int n7 = n6++; nArray2[n7] = n7; } for (n6 = 0; n6 < n5; ++n6) { d = 0.0; for (n2 = 0; n2 < n5; ++n2) { double d2; double d3 = Math.abs(dArray4[n6][n2]); if (!(d2 > d)) continue; d = d3; } dArray5[n6] = d; } for (n6 = 0; n6 < n5 - 1; ++n6) { int n8; d = 0.0; n2 = n6; for (n8 = n6; n8 < n5; ++n8) { double d4; double d5 = Math.abs(dArray4[nArray2[n8]][n6]) / dArray5[nArray2[n8]]; if (!(d4 > d)) continue; d = d5; n2 = n8; } n8 = nArray2[n6]; nArray2[n6] = nArray2[n2]; nArray2[n2] = n8; for (int i = n6 + 1; i < n5; ++i) { double d6; dArray4[nArray2[i]][n6] = d6 = dArray4[nArray2[i]][n6] / dArray4[nArray2[n6]][n6]; for (n2 = n6 + 1; n2 < n5; ++n2) { double[] dArray6 = dArray4[nArray2[i]]; int n9 = n2; dArray6[n9] = dArray6[n9] - d6 * dArray4[nArray2[n6]][n2]; } } } for (n = 0; n < n3 - 1; ++n) { for (int i = n + 1; i < n3; ++i) { for (n5 = 0; n5 < n3; ++n5) { double[] dArray7 = dArray3[nArray[i]]; int n10 = n5; dArray7[n10] = dArray7[n10] - dArray[nArray[i]][n] * dArray3[nArray[n]][n5]; } } } for (n = 0; n < n3; ++n) { dArray2[n3 - 1][n] = dArray3[nArray[n3 - 1]][n] / dArray[nArray[n3 - 1]][n3 - 1]; for (int i = n3 - 2; i >= 0; --i) { dArray2[i][n] = dArray3[nArray[i]][n]; for (n5 = i + 1; n5 < n3; ++n5) { double[] dArray8 = dArray2[i]; int n11 = n; dArray8[n11] = dArray8[n11] - dArray[nArray[i]][n5] * dArray2[n5][n]; } double[] dArray9 = dArray2[i]; int n12 = n; dArray9[n12] = dArray9[n12] / dArray[nArray[i]][i]; } } return dArray2; } }", "deobfuscated_code": "package com.thealgorithms.matrix; /** * This class provides methods to compute the inverse of a square matrix * using Gaussian elimination. For more details, refer to: * https://en.wikipedia.org/wiki/Invertible_matrix */ public final class InverseOfMatrix { private InverseOfMatrix() { } public static double[][] invert(double[][] a) { int n = a.length; double[][] x = new double[n][n]; double[][] b = new double[n][n]; int[] index = new int[n]; // Initialize the identity matrix for (int i = 0; i < n; ++i) { b[i][i] = 1; } // Perform Gaussian elimination gaussian(a, index); // Update matrix b with the ratios stored during elimination for (int i = 0; i < n - 1; ++i) { for (int j = i + 1; j < n; ++j) { for (int k = 0; k < n; ++k) { b[index[j]][k] -= a[index[j]][i] * b[index[i]][k]; } } } // Perform backward substitution to find the inverse for (int i = 0; i < n; ++i) { x[n - 1][i] = b[index[n - 1]][i] / a[index[n - 1]][n - 1]; for (int j = n - 2; j >= 0; --j) { x[j][i] = b[index[j]][i]; for (int k = j + 1; k < n; ++k) { x[j][i] -= a[index[j]][k] * x[k][i]; } x[j][i] /= a[index[j]][j]; } } return x; } /** * Method to carry out the partial-pivoting Gaussian * elimination. Here index[] stores pivoting order. **/ private static void gaussian(double[][] a, int[] index) { int n = index.length; double[] c = new double[n]; // Initialize the index array for (int i = 0; i < n; ++i) { index[i] = i; } // Find the rescaling factors for each row for (int i = 0; i < n; ++i) { double c1 = 0; for (int j = 0; j < n; ++j) { double c0 = Math.abs(a[i][j]); if (c0 > c1) { c1 = c0; } } c[i] = c1; } // Perform pivoting for (int j = 0; j < n - 1; ++j) { double pi1 = 0; int k = j; for (int i = j; i < n; ++i) { double pi0 = Math.abs(a[index[i]][j]) / c[index[i]]; if (pi0 > pi1) { pi1 = pi0; k = i; } } // Swap rows int temp = index[j]; index[j] = index[k]; index[k] = temp; for (int i = j + 1; i < n; ++i) { double pj = a[index[i]][j] / a[index[j]][j]; // Record pivoting ratios below the diagonal a[index[i]][j] = pj; // Modify other elements accordingly for (int l = j + 1; l < n; ++l) { a[index[i]][l] -= pj * a[index[j]][l]; } } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class IsEven { private IsEven() { } public static boolean isEven(int n) { return (n & 1) == 0; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * Checks whether a number is even * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi) */ public final class IsEven { private IsEven() { } public static boolean isEven(int number) { return (number & 1) == 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class IsPowerTwo { private IsPowerTwo() { } public static boolean isPowerTwo(int n) { if (n <= 0) { return false; } int n2 = n; n = n2 & n2 - 1; return n == 0; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * Utility class for checking if a number is a power of two. * A power of two is a number that can be expressed as 2^n where n is a non-negative integer. * This class provides a method to determine if a given integer is a power of two using bit manipulation. * * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi) */ public final class IsPowerTwo { private IsPowerTwo() { } /** * Checks if the given integer is a power of two. * * A number is considered a power of two if it is greater than zero and * has exactly one '1' bit in its binary representation. This method * uses the property that for any power of two (n), the expression * (n & (n - 1)) will be zero. * * @param number the integer to check * @return true if the number is a power of two, false otherwise */ public static boolean isPowerTwo(int number) { if (number <= 0) { return false; } int ans = number & (number - 1); return ans == 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.HashMap; import java.util.HashSet; public final class Isomorphic { private Isomorphic() { } public static boolean areIsomorphic(String string, String string2) { if (string.length() != string2.length()) { return false; } HashMap<Character, Character> hashMap = new HashMap<Character, Character>(); HashSet<Character> hashSet = new HashSet<Character>(); for (int i = 0; i < string.length(); ++i) { char c = string.charAt(i); char c2 = string2.charAt(i); if (hashMap.containsKey(Character.valueOf(c))) { if (((Character)hashMap.get(Character.valueOf(c))).charValue() == c2) continue; return false; } if (hashSet.contains(Character.valueOf(c2))) { return false; } hashMap.put(Character.valueOf(c), Character.valueOf(c2)); hashSet.add(Character.valueOf(c2)); } return true; } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set; /** * Utility class to check if two strings are isomorphic. * * <p> * Two strings {@code s} and {@code t} are isomorphic if the characters in {@code s} * can be replaced to get {@code t}, while preserving the order of characters. * Each character must map to exactly one character, and no two characters can map to the same character. * </p> * * @see <a href=\"https://en.wikipedia.org/wiki/Isomorphism_(computer_science)\">Isomorphic Strings</a> */ public final class Isomorphic { private Isomorphic() { } /** * Checks if two strings are isomorphic. * * @param s the first input string * @param t the second input string * @return {@code true} if {@code s} and {@code t} are isomorphic; {@code false} otherwise */ public static boolean areIsomorphic(String s, String t) { if (s.length() != t.length()) { return false; } Map<Character, Character> map = new HashMap<>(); Set<Character> usedCharacters = new HashSet<>(); for (int i = 0; i < s.length(); i++) { char sourceChar = s.charAt(i); char targetChar = t.charAt(i); if (map.containsKey(sourceChar)) { if (map.get(sourceChar) != targetChar) { return false; } } else { if (usedCharacters.contains(targetChar)) { return false; } map.put(sourceChar, targetChar); usedCharacters.add(targetChar); } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; public final class IterativeBinarySearch implements SearchAlgorithm { @Override public final int find(Comparable[] comparableArray, Comparable comparable) { int n = 0; int n2 = comparableArray.length - 1; while (n <= n2) { int n3 = n + n2 >>> 1; int n4 = comparable.compareTo(comparableArray[n3]); if (n4 == 0) { return n3; } if (n4 < 0) { n2 = --n3; continue; } n = ++n3; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; /** * Binary search is one of the most popular algorithms This class represents * iterative version {@link BinarySearch} Iterative binary search is likely to * have lower constant factors because it doesn't involve the overhead of * manipulating the call stack. But in java the recursive version can be * optimized by the compiler to this version. * * <p> * Worst-case performance O(log n) Best-case performance O(1) Average * performance O(log n) Worst-case space complexity O(1) * * @author Gabriele La Greca : https://github.com/thegabriele97 * @author Podshivalov Nikita (https://github.com/nikitap492) * @see SearchAlgorithm * @see BinarySearch */ public final class IterativeBinarySearch implements SearchAlgorithm { /** * This method implements an iterative version of binary search algorithm * * @param array a sorted array * @param key the key to search in array * @return the index of key in the array or -1 if not found */ @Override public <T extends Comparable<T>> int find(T[] array, T key) { int l; int r; int k; int cmp; l = 0; r = array.length - 1; while (l <= r) { k = (l + r) >>> 1; cmp = key.compareTo(array[k]); if (cmp == 0) { return k; } else if (cmp < 0) { r = --k; } else { l = ++k; } } return -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; public class IterativeTernarySearch implements SearchAlgorithm { @Override public int find(Comparable[] comparableArray, Comparable comparable) { if (comparableArray == null || comparableArray.length == 0 || comparable == null) { return -1; } if (comparableArray.length == 1) { if (comparableArray[0].compareTo(comparable) == 0) { return 0; } return -1; } int n = 0; int n2 = comparableArray.length - 1; while (n2 > n) { int n3 = comparableArray[n].compareTo(comparable); int n4 = comparableArray[n2].compareTo(comparable); if (n3 == 0) { return n; } if (n4 == 0) { return n2; } n3 = n + (n2 - n) / 3 + 1; int n5 = n2; n4 = n5 - (n5 - n) / 3 - 1; if (comparableArray[n3].compareTo(comparable) <= 0) { n = n3; continue; } n2 = n4; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; /** * An iterative implementation of the Ternary Search algorithm. * * <p> * Ternary search is a divide-and-conquer algorithm that splits the array into three parts * instead of two, as in binary search. This implementation is iterative, reducing the overhead * associated with recursive function calls. However, the recursive version can also be optimized * by the Java compiler to resemble the iterative version, resulting in similar performance. * * <p> * Worst-case performance: (log3(N))<br> * Best-case performance: O(1)<br> * Average performance: (log3(N))<br> * Worst-case space complexity: O(1) * * <p> * This class implements the {@link SearchAlgorithm} interface, providing a generic search method * for any comparable type. * * @see SearchAlgorithm * @see TernarySearch * @since 2018-04-13 */ public class IterativeTernarySearch implements SearchAlgorithm { @Override public <T extends Comparable<T>> int find(T[] array, T key) { if (array == null || array.length == 0 || key == null) { return -1; } if (array.length == 1) { return array[0].compareTo(key) == 0 ? 0 : -1; } int left = 0; int right = array.length - 1; while (right > left) { int leftCmp = array[left].compareTo(key); int rightCmp = array[right].compareTo(key); if (leftCmp == 0) { return left; } if (rightCmp == 0) { return right; } int leftThird = left + (right - left) / 3 + 1; int rightThird = right - (right - left) / 3 - 1; if (array[leftThird].compareTo(key) <= 0) { left = leftThird; } else { right = rightThird; } } return -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class JobSchedulingWithDeadline$Job { int a; int b; int c; int d; }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class JobSchedulingWithDeadline$Job { int a; int b; int c; int d; }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.JobSchedulingWithDeadline$Job; import java.util.Arrays; import java.util.Comparator; public final class JobSchedulingWithDeadline { private JobSchedulingWithDeadline() { } public static int[] jobSequencingWithDeadlines(JobSchedulingWithDeadline$Job[] jobSchedulingWithDeadline$JobArray) { Arrays.sort(jobSchedulingWithDeadline$JobArray, Comparator.comparingInt(jobSchedulingWithDeadline$Job -> { int cfr_ignored_0 = jobSchedulingWithDeadline$Job.d; return 0; })); int n = Arrays.stream(jobSchedulingWithDeadline$JobArray).mapToInt(jobSchedulingWithDeadline$Job -> jobSchedulingWithDeadline$Job.c).max().orElse(0); int[] nArray = new int[n]; Arrays.fill(nArray, -1); int n2 = 0; block0: for (JobSchedulingWithDeadline$Job jobSchedulingWithDeadline$Job2 : jobSchedulingWithDeadline$JobArray) { int cfr_ignored_0 = jobSchedulingWithDeadline$Job2.b; int cfr_ignored_1 = jobSchedulingWithDeadline$Job2.c; int cfr_ignored_2 = jobSchedulingWithDeadline$Job2.c; int n3 = Math.min(-1, n - 1); while (true) { int cfr_ignored_3 = jobSchedulingWithDeadline$Job2.b; if (n3 < -1) continue block0; if (nArray[n3] == -1) { nArray[n3] = jobSchedulingWithDeadline$Job2.a; ++n2; int cfr_ignored_4 = jobSchedulingWithDeadline$Job2.d; continue block0; } --n3; } } return new int[]{n2, 0}; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.Arrays; import java.util.Comparator; /** * A class that implements a job scheduling algorithm to maximize profit * while adhering to job deadlines and arrival times. * * This class provides functionality to schedule jobs based on their profit, * arrival time, and deadlines to ensure that the maximum number of jobs is completed * within the given timeframe. It sorts the jobs in decreasing order of profit * and attempts to assign them to the latest possible time slots. */ public final class JobSchedulingWithDeadline { private JobSchedulingWithDeadline() { } /** * Represents a job with an ID, arrival time, deadline, and profit. * * Each job has a unique identifier, an arrival time (when it becomes available for scheduling), * a deadline by which it must be completed, and a profit associated with completing the job. */ static class Job { int jobId; int arrivalTime; int deadline; int profit; /** * Constructs a Job instance with the specified job ID, arrival time, deadline, and profit. * * @param jobId Unique identifier for the job * @param arrivalTime Time when the job becomes available for scheduling * @param deadline Deadline for completing the job * @param profit Profit earned upon completing the job */ Job(int jobId, int arrivalTime, int deadline, int profit) { this.jobId = jobId; this.arrivalTime = arrivalTime; this.deadline = deadline; this.profit = profit; } } /** * Schedules jobs to maximize profit while respecting their deadlines and arrival times. * * This method sorts the jobs in descending order of profit and attempts * to allocate them to time slots that are before or on their deadlines, * provided they have arrived. The function returns an array where the first element * is the total number of jobs scheduled and the second element is the total profit earned. * * @param jobs An array of Job objects, each representing a job with an ID, arrival time, * deadline, and profit. * @return An array of two integers: the first element is the count of jobs * that were successfully scheduled, and the second element is the * total profit earned from those jobs. */ public static int[] jobSequencingWithDeadlines(Job[] jobs) { Arrays.sort(jobs, Comparator.comparingInt(job -> - job.profit)); int maxDeadline = Arrays.stream(jobs).mapToInt(job -> job.deadline).max().orElse(0); int[] timeSlots = new int[maxDeadline]; Arrays.fill(timeSlots, -1); int count = 0; int maxProfit = 0; // Schedule the jobs for (Job job : jobs) { if (job.arrivalTime <= job.deadline) { for (int i = Math.min(job.deadline - 1, maxDeadline - 1); i >= job.arrivalTime - 1; i--) { if (timeSlots[i] == -1) { timeSlots[i] = job.jobId; count++; maxProfit += job.profit; break; } } } } return new int[] {count, maxProfit}; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; class JobSequencing$Job implements Comparable { char a; int b; private int c; public int compareTo(JobSequencing$Job jobSequencing$Job) { int cfr_ignored_0 = jobSequencing$Job.c; return 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; class JobSequencing$Job implements Comparable { char a; int b; private int c; public int compareTo(JobSequencing$Job jobSequencing$Job) { int cfr_ignored_0 = jobSequencing$Job.c; return 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import com.thealgorithms.greedyalgorithms.JobSequencing$Job; import java.util.ArrayList; import java.util.Arrays; public final class JobSequencing { private JobSequencing() { } public static String findJobSequence(ArrayList arrayList, int n) { Object[] objectArray = new Boolean[n]; Arrays.fill(objectArray, Boolean.FALSE); int[] nArray = new int[n]; for (int i = 0; i < n; ++i) { int cfr_ignored_0 = ((JobSequencing$Job)arrayList.get((int)i)).b; } StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"Job Sequence: \"); for (n = 0; n < arrayList.size(); ++n) { if (!((Boolean)objectArray[n]).booleanValue()) continue; stringBuilder.append(((JobSequencing$Job)arrayList.get((int)nArray[n])).a).append(\" -> \"); } if (stringBuilder.length() >= 4) { StringBuilder stringBuilder2 = stringBuilder; stringBuilder2.setLength(stringBuilder2.length() - 4); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.ArrayList; import java.util.Arrays; // Problem Link: https://en.wikipedia.org/wiki/Job-shop_scheduling public final class JobSequencing { private JobSequencing() { } // Define a Job class that implements Comparable for sorting by profit in descending order static class Job implements Comparable<Job> { char id; int deadline; int profit; // Compare jobs by profit in descending order @Override public int compareTo(Job otherJob) { return otherJob.profit - this.profit; } Job(char id, int deadline, int profit) { this.id = id; this.deadline = deadline; this.profit = profit; } } // Function to print the job sequence public static String findJobSequence(ArrayList<Job> jobs, int size) { Boolean[] slots = new Boolean[size]; Arrays.fill(slots, Boolean.FALSE); int[] result = new int[size]; // Iterate through jobs to find the optimal job sequence for (int i = 0; i < size; i++) { for (int j = jobs.get(i).deadline - 1; j >= 0; j--) { if (!slots[j]) { result[j] = i; slots[j] = Boolean.TRUE; break; } } } // Create a StringBuilder to build the job sequence string StringBuilder jobSequenceBuilder = new StringBuilder(); jobSequenceBuilder.append(\"Job Sequence: \"); for (int i = 0; i < jobs.size(); i++) { if (slots[i]) { jobSequenceBuilder.append(jobs.get(result[i]).id).append(\" -> \"); } } // Remove the trailing \" -> \" from the job sequence if (jobSequenceBuilder.length() >= 4) { jobSequenceBuilder.setLength(jobSequenceBuilder.length() - 4); } // Return the job sequence as a string return jobSequenceBuilder.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.Arrays; public final class JohnsonsAlgorithm { private JohnsonsAlgorithm() { } public static double[][] johnsonAlgorithm(double[][] dArray) { int n; int n2; int n3; int n4 = dArray.length; double[][] dArray2 = JohnsonsAlgorithm.convertToEdgeList(dArray); int n5 = n4; double[] dArray3 = new double[n5 + 1]; Arrays.fill(dArray3, Double.POSITIVE_INFINITY); dArray3[n5] = 0.0; double[][] dArray4 = (double[][])Arrays.copyOf(dArray2, dArray2.length + n5); for (n3 = 0; n3 < n5; ++n3) { dArray4[dArray2.length + n3] = new double[]{n5, n3, 0.0}; } for (n3 = 0; n3 < n5; ++n3) { dArray2 = dArray4; n2 = dArray4.length; for (int i = 0; i < n2; ++i) { double[] dArray5 = dArray2[i]; n = (int)dArray5[0]; int n6 = (int)dArray5[1]; double d = dArray5[2]; if (dArray3[n] == Double.POSITIVE_INFINITY || !(dArray3[n] + d < dArray3[n6])) continue; dArray3[n6] = dArray3[n] + d; } } double[][] dArray6 = dArray4; int n7 = dArray4.length; for (n2 = 0; n2 < n7; ++n2) { double[] dArray7 = dArray6[n2]; int n8 = (int)dArray7[0]; double d = dArray7[2]; n = (int)dArray7[1]; if (!(dArray3[n8] + d < dArray3[n])) continue; throw new IllegalArgumentException(\"Graph contains a negative weight cycle\"); } double[] dArray8 = Arrays.copyOf(dArray3, n5); dArray = JohnsonsAlgorithm.reweightGraph(dArray, dArray8); int n9 = n4; double[][] dArray9 = new double[n9][n9]; for (int i = 0; i < n4; ++i) { dArray9[i] = JohnsonsAlgorithm.dijkstra(dArray, i, dArray8); } return dArray9; } public static double[][] convertToEdgeList(double[][] dArray) { int n = dArray.length; ArrayList<double[]> arrayList = new ArrayList<double[]>(); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (i == j || Double.isInfinite(dArray[i][j])) continue; arrayList.add(new double[]{i, j, dArray[i][j]}); } } return (double[][])arrayList.toArray((T[])new double[0][]); } public static double[][] reweightGraph(double[][] dArray, double[] dArray2) { int n = dArray.length; double[][] dArray3 = new double[n][n]; for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (dArray[i][j] == 0.0) continue; dArray3[i][j] = dArray[i][j] + dArray2[i] - dArray2[j]; } } return dArray3; } public static double[] dijkstra(double[][] dArray, int n, double[] dArray2) { int n2; int n3 = dArray.length; double[] dArray3 = new double[n3]; boolean[] blArray = new boolean[n3]; Arrays.fill(dArray3, Double.POSITIVE_INFINITY); dArray3[n] = 0.0; for (n2 = 0; n2 < n3 - 1; ++n2) { int n4 = JohnsonsAlgorithm.minDistance(dArray3, blArray); blArray[n4] = true; for (int i = 0; i < n3; ++i) { if (blArray[i] || dArray[n4][i] == 0.0 || dArray3[n4] == Double.POSITIVE_INFINITY || !(dArray3[n4] + dArray[n4][i] < dArray3[i])) continue; dArray3[i] = dArray3[n4] + dArray[n4][i]; } } for (n2 = 0; n2 < n3; ++n2) { if (dArray3[n2] == Double.POSITIVE_INFINITY) continue; dArray3[n2] = dArray3[n2] - dArray2[n] + dArray2[n2]; } return dArray3; } public static int minDistance(double[] dArray, boolean[] blArray) { double d = Double.POSITIVE_INFINITY; int n = -1; for (int i = 0; i < dArray.length; ++i) { if (blArray[i] || !(dArray[i] <= d)) continue; d = dArray[i]; n = i; } return n; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.Arrays; import java.util.List; /** * This class implements Johnson's algorithm for finding all-pairs shortest paths in a weighted, * directed graph that may contain negative edge weights. * * Johnson's algorithm works by using the Bellman-Ford algorithm to compute a transformation of the * input graph that removes all negative weights, allowing Dijkstra's algorithm to be used for * efficient shortest path computations. * * Time Complexity: O(V^2 * log(V) + V*E) * Space Complexity: O(V^2) * * Where V is the number of vertices and E is the number of edges in the graph. * * For more information, please visit {@link https://en.wikipedia.org/wiki/Johnson%27s_algorithm} */ public final class JohnsonsAlgorithm { private static final double INF = Double.POSITIVE_INFINITY; private JohnsonsAlgorithm() { } /** * Executes Johnson's algorithm on the given graph. * Steps: * 1. Add a new vertex to the graph and run Bellman-Ford to compute modified weights * 2. t the graph using the modified weights * 3. Run Dijkstra's algorithm for each vertex to compute the shortest paths * The final result is a 2D array of shortest distances between all pairs of vertices. * * @param graph The input graph represented as an adjacency matrix. * @return A 2D array representing the shortest distances between all pairs of vertices. */ public static double[][] johnsonAlgorithm(double[][] graph) { int numVertices = graph.length; double[][] edges = convertToEdgeList(graph); double[] modifiedWeights = bellmanFord(edges, numVertices); double[][] reweightedGraph = reweightGraph(graph, modifiedWeights); double[][] shortestDistances = new double[numVertices][numVertices]; for (int source = 0; source < numVertices; source++) { shortestDistances[source] = dijkstra(reweightedGraph, source, modifiedWeights); } return shortestDistances; } /** * Converts the adjacency matrix representation of the graph to an edge list. * * @param graph The input graph as an adjacency matrix. * @return An array of edges, where each edge is represented as [from, to, weight]. */ public static double[][] convertToEdgeList(double[][] graph) { int numVertices = graph.length; List<double[]> edgeList = new ArrayList<>(); for (int i = 0; i < numVertices; i++) { for (int j = 0; j < numVertices; j++) { if (i != j && !Double.isInfinite(graph[i][j])) { // Only add edges that are not self-loops and have a finite weight edgeList.add(new double[] {i, j, graph[i][j]}); } } } return edgeList.toArray(new double[0][]); } /** * Implements the Bellman-Ford algorithm to compute the shortest paths from a new vertex * to all other vertices. This is used to calculate the weight function h(v) for reweighting. * * @param edges The edge list of the graph. * @param numVertices The number of vertices in the original graph. * @return An array of modified weights for each vertex. */ private static double[] bellmanFord(double[][] edges, int numVertices) { double[] dist = new double[numVertices + 1]; Arrays.fill(dist, INF); dist[numVertices] = 0; // Add edges from the new vertex to all original vertices double[][] allEdges = Arrays.copyOf(edges, edges.length + numVertices); for (int i = 0; i < numVertices; i++) { allEdges[edges.length + i] = new double[] {numVertices, i, 0}; } // Relax all edges V times for (int i = 0; i < numVertices; i++) { for (double[] edge : allEdges) { int u = (int) edge[0]; int v = (int) edge[1]; double weight = edge[2]; if (dist[u] != INF && dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; } } } // Check for negative weight cycles for (double[] edge : allEdges) { int u = (int) edge[0]; int v = (int) edge[1]; double weight = edge[2]; if (dist[u] + weight < dist[v]) { throw new IllegalArgumentException(\"Graph contains a negative weight cycle\"); } } return Arrays.copyOf(dist, numVertices); } /** * Reweights the graph using the modified weights computed by Bellman-Ford. * * @param graph The original graph. * @param modifiedWeights The modified weights from Bellman-Ford. * @return The reweighted graph. */ public static double[][] reweightGraph(double[][] graph, double[] modifiedWeights) { int numVertices = graph.length; double[][] reweightedGraph = new double[numVertices][numVertices]; for (int i = 0; i < numVertices; i++) { for (int j = 0; j < numVertices; j++) { if (graph[i][j] != 0) { // New weight = original weight + h(u) - h(v) reweightedGraph[i][j] = graph[i][j] + modifiedWeights[i] - modifiedWeights[j]; } } } return reweightedGraph; } /** * Implements Dijkstra's algorithm for finding shortest paths from a source vertex. * * @param reweightedGraph The reweighted graph to run Dijkstra's on. * @param source The source vertex. * @param modifiedWeights The modified weights from Bellman-Ford. * @return An array of shortest distances from the source to all other vertices. */ public static double[] dijkstra(double[][] reweightedGraph, int source, double[] modifiedWeights) { int numVertices = reweightedGraph.length; double[] dist = new double[numVertices]; boolean[] visited = new boolean[numVertices]; Arrays.fill(dist, INF); dist[source] = 0; for (int count = 0; count < numVertices - 1; count++) { int u = minDistance(dist, visited); visited[u] = true; for (int v = 0; v < numVertices; v++) { if (!visited[v] && reweightedGraph[u][v] != 0 && dist[u] != INF && dist[u] + reweightedGraph[u][v] < dist[v]) { dist[v] = dist[u] + reweightedGraph[u][v]; } } } // Adjust distances back to the original graph weights for (int i = 0; i < numVertices; i++) { if (dist[i] != INF) { dist[i] = dist[i] - modifiedWeights[source] + modifiedWeights[i]; } } return dist; } /** * Finds the vertex with the minimum distance value from the set of vertices * not yet included in the shortest path tree. * * @param dist Array of distances. * @param visited Array of visited vertices. * @return The index of the vertex with minimum distance. */ public static int minDistance(double[] dist, boolean[] visited) { double min = INF; int minIndex = -1; for (int v = 0; v < dist.length; v++) { if (!visited[v] && dist[v] <= min) { min = dist[v]; minIndex = v; } } return minIndex; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class JosephusProblem { private JosephusProblem() { } public static int findTheWinner(int n, int n2) { return JosephusProblem.winner(n, n2) + 1; } public static int winner(int n, int n2) { if (n == 1) { return 0; } return (JosephusProblem.winner(n - 1, n2) + n2) % n; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * There are n friends that are playing a game. The friends are sitting in a circle and are * numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend * brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings * you to the 1st friend. The rules of the game are as follows: 1.Start at the 1st friend. 2.Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once. 3.The last friend you counted leaves the circle and loses the game. 4.If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat. 5.Else, the last friend in the circle wins the game. @author Kunal */ public final class JosephusProblem { private JosephusProblem() { } /** * Find the Winner of the Circular Game. * * @param number of friends, n, and an integer k * @return return the winner of the game */ public static int findTheWinner(int n, int k) { return winner(n, k) + 1; } public static int winner(int n, int k) { if (n == 1) { return 0; } return (winner(n - 1, k) + k) % n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.lang.invoke.CallSite; import java.util.ArrayList; public final class JugglerSequence { private JugglerSequence() { } public static void jugglerSequence(int n) { ArrayList<CallSite> arrayList = new ArrayList<CallSite>(); arrayList.add((CallSite)((Object)(\"\" + n))); while (n != 1) { n = n % 2 == 0 ? (int)Math.floor(Math.sqrt(n)) : (int)Math.floor(Math.sqrt(n) * Math.sqrt(n) * Math.sqrt(n)); arrayList.add((CallSite)((Object)(\"\" + n))); } String string = String.join((CharSequence)\",\", arrayList); System.out.println(string); } public static void main(String[] stringArray) { JugglerSequence.jugglerSequence(3); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; import java.util.List; /* * Java program for printing juggler sequence * Wikipedia: https://en.wikipedia.org/wiki/Juggler_sequence * * Author: Akshay Dubey (https://github.com/itsAkshayDubey) * * */ public final class JugglerSequence { private JugglerSequence() { } /** * This method prints juggler sequence starting with the number in the parameter * * @param inputNumber Number from which juggler sequence is to be started */ public static void jugglerSequence(int inputNumber) { // Copy method argument to a local variable int n = inputNumber; List<String> seq = new ArrayList<>(); seq.add(n + \"\"); // Looping till n reaches 1 while (n != 1) { int temp; // if previous term is even then // next term in the sequence is square root of previous term // if previous term is odd then // next term is floor value of 3 time the square root of previous term // Check if previous term is even or odd if (n % 2 == 0) { temp = (int) Math.floor(Math.sqrt(n)); } else { temp = (int) Math.floor(Math.sqrt(n) * Math.sqrt(n) * Math.sqrt(n)); } n = temp; seq.add(n + \"\"); } String res = String.join(\",\", seq); System.out.println(res); } // Driver code public static void main(String[] args) { jugglerSequence(3); // Output: 3,5,11,36,6,2,1 } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; public class JumpSearch implements SearchAlgorithm { @Override public int find(Comparable[] comparableArray, Comparable comparable) { int n; int n2 = comparableArray.length; int n3 = n = (int)Math.sqrt(n2); while (n3 < n2 && comparable.compareTo(comparableArray[n3]) > 0) { n3 = Math.min(n3 + n, n2 - 1); } for (n = n3 - n; n <= n3 && n < n2; ++n) { if (!comparableArray[n].equals(comparable)) continue; return n; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; /** * An implementation of the Jump Search algorithm. * * <p> * Jump Search is an algorithm for searching sorted arrays. It works by dividing the array * into blocks of a fixed size (the block size is typically the square root of the array length) * and jumping ahead by this block size to find a range where the target element may be located. * Once the range is found, a linear search is performed within that block. * * <p> * The Jump Search algorithm is particularly effective for large sorted arrays where the cost of * performing a linear search on the entire array would be prohibitive. * * <p> * Worst-case performance: O(N)<br> * Best-case performance: O(1)<br> * Average performance: O(N)<br> * Worst-case space complexity: O(1) * * <p> * This class implements the {@link SearchAlgorithm} interface, providing a generic search method * for any comparable type. */ public class JumpSearch implements SearchAlgorithm { /** * Jump Search algorithm implementation. * * @param array the sorted array containing elements * @param key the element to be searched * @return the index of {@code key} if found, otherwise -1 */ @Override public <T extends Comparable<T>> int find(T[] array, T key) { int length = array.length; int blockSize = (int) Math.sqrt(length); int limit = blockSize; // Jumping ahead to find the block where the key may be located while (limit < length && key.compareTo(array[limit]) > 0) { limit = Math.min(limit + blockSize, length - 1); } // Perform linear search within the identified block for (int i = limit - blockSize; i <= limit && i < length; i++) { if (array[i].equals(key)) { return i; } } return -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.Arrays; public final class KCenters { private KCenters() { } public static int findKCenters(int[][] nArray, int n) { int n2; int n3; int n4 = nArray.length; boolean[] blArray = new boolean[n4]; int[] nArray2 = new int[n4]; Arrays.fill(nArray2, Integer.MAX_VALUE); blArray[0] = true; for (n3 = 1; n3 < n4; ++n3) { nArray2[n3] = Math.min(nArray2[n3], nArray[0][n3]); } for (n3 = 1; n3 < n; ++n3) { int n5 = -1; for (n2 = 0; n2 < n4; ++n2) { if (blArray[n2] || n5 != -1 && nArray2[n2] <= nArray2[n5]) continue; n5 = n2; } blArray[n5] = true; for (n2 = 0; n2 < n4; ++n2) { nArray2[n2] = Math.min(nArray2[n2], nArray[n5][n2]); } } n3 = 0; int[] nArray3 = nArray2; n2 = nArray2.length; for (int i = 0; i < n2; ++i) { n = nArray3[i]; n3 = Math.max(n3, n); } return n3; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.Arrays; /** * Given a set of points and a number k. * The goal is to minimize the maximum distance between any point and its nearest center. * Each point is assigned to the nearest center. * The distance between two points is the Euclidean distance. * The problem is NP-hard. * * @author Hardvan */ public final class KCenters { private KCenters() { } /** * Finds the maximum distance to the nearest center given k centers. * Steps: * 1. Initialize an array {@code selected} of size n and an array {@code maxDist} of size n. * 2. Set the first node as selected and update the maxDist array. * 3. For each center, find the farthest node from the selected centers. * 4. Update the maxDist array. * 5. Return the maximum distance to the nearest center. * * @param distances matrix representing distances between nodes * @param k the number of centers * @return the maximum distance to the nearest center */ public static int findKCenters(int[][] distances, int k) { int n = distances.length; boolean[] selected = new boolean[n]; int[] maxDist = new int[n]; Arrays.fill(maxDist, Integer.MAX_VALUE); selected[0] = true; for (int i = 1; i < n; i++) { maxDist[i] = Math.min(maxDist[i], distances[0][i]); } for (int centers = 1; centers < k; centers++) { int farthest = -1; for (int i = 0; i < n; i++) { if (!selected[i] && (farthest == -1 || maxDist[i] > maxDist[farthest])) { farthest = i; } } selected[farthest] = true; for (int i = 0; i < n; i++) { maxDist[i] = Math.min(maxDist[i], distances[farthest][i]); } } int result = 0; for (int dist : maxDist) { result = Math.max(result, dist); } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.KDTree$Point; class KDTree$Node { private KDTree$Point a; private int b; private KDTree$Node c; private KDTree$Node d; public KDTree$Point getPoint() { return this.a; } public KDTree$Node getLeft() { return this.c; } public KDTree$Node getRight() { return this.d; } public int getAxis() { return this.b; } public KDTree$Node getNearChild(KDTree$Point kDTree$Point) { if (kDTree$Point.getCoordinate(this.b) < this.a.getCoordinate(this.b)) { return this.c; } return this.d; } public KDTree$Node getFarChild(KDTree$Point kDTree$Point) { if (kDTree$Point.getCoordinate(this.b) < this.a.getCoordinate(this.b)) { return this.d; } return this.c; } public int getAxisCoordinate() { return this.a.getCoordinate(this.b); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.KDTree$Point; class KDTree$Node { private KDTree$Point a; private int b; private KDTree$Node c; private KDTree$Node d; public KDTree$Point getPoint() { return this.a; } public KDTree$Node getLeft() { return this.c; } public KDTree$Node getRight() { return this.d; } public int getAxis() { return this.b; } public KDTree$Node getNearChild(KDTree$Point kDTree$Point) { if (kDTree$Point.getCoordinate(this.b) < this.a.getCoordinate(this.b)) { return this.c; } return this.d; } public KDTree$Node getFarChild(KDTree$Point kDTree$Point) { if (kDTree$Point.getCoordinate(this.b) < this.a.getCoordinate(this.b)) { return this.d; } return this.c; } public int getAxisCoordinate() { return this.a.getCoordinate(this.b); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import java.util.Arrays; class KDTree$Point { private int[] a; public int getCoordinate(int n) { throw new NullPointerException(); } public int getDimension() { throw new NullPointerException(); } public boolean equals(Object object) { if (object instanceof KDTree$Point) { object = (KDTree$Point)object; return Arrays.equals(((KDTree$Point)object).a, this.a); } return false; } public int hashCode() { return Arrays.hashCode(this.a); } public String toString() { return Arrays.toString(this.a); } public static int comparableDistance(KDTree$Point kDTree$Point, KDTree$Point kDTree$Point2) { int n = 0; for (int i = 0; i < kDTree$Point.getDimension(); ++i) { int n2; int n3 = n2 = kDTree$Point.getCoordinate(i) - kDTree$Point2.getCoordinate(i); n += n3 * n3; } return n; } public static int comparableDistanceExceptAxis(KDTree$Point kDTree$Point, KDTree$Point kDTree$Point2, int n) { int n2 = 0; for (int i = 0; i < kDTree$Point.getDimension(); ++i) { int n3; if (i == n) continue; int n4 = n3 = kDTree$Point.getCoordinate(i) - kDTree$Point2.getCoordinate(i); n2 += n4 * n4; } return n2; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import java.util.Arrays; class KDTree$Point { private int[] a; public int getCoordinate(int n) { throw new NullPointerException(); } public int getDimension() { throw new NullPointerException(); } public boolean equals(Object object) { if (object instanceof KDTree$Point) { object = (KDTree$Point)object; return Arrays.equals(((KDTree$Point)object).a, this.a); } return false; } public int hashCode() { return Arrays.hashCode(this.a); } public String toString() { return Arrays.toString(this.a); } public static int comparableDistance(KDTree$Point kDTree$Point, KDTree$Point kDTree$Point2) { int n = 0; for (int i = 0; i < kDTree$Point.getDimension(); ++i) { int n2; int n3 = n2 = kDTree$Point.getCoordinate(i) - kDTree$Point2.getCoordinate(i); n += n3 * n3; } return n; } public static int comparableDistanceExceptAxis(KDTree$Point kDTree$Point, KDTree$Point kDTree$Point2, int n) { int n2 = 0; for (int i = 0; i < kDTree$Point.getDimension(); ++i) { int n3; if (i == n) continue; int n4 = n3 = kDTree$Point.getCoordinate(i) - kDTree$Point2.getCoordinate(i); n2 += n4 * n4; } return n2; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.KDTree$Node; import com.thealgorithms.datastructures.trees.KDTree$Point; import java.util.Arrays; import java.util.Comparator; import java.util.Objects; import java.util.Optional; public class KDTree { private KDTree$Node a; private final int b; public KDTree$Node getRoot() { return this.a; } public void insert(KDTree$Point kDTree$Point) { if (kDTree$Point.getDimension() != this.b) { throw new IllegalArgumentException(\"Point has wrong dimension\"); } KDTree kDTree = this; KDTree kDTree2 = kDTree; boolean bl = false; Object object = kDTree$Point; object = this.a; object = kDTree; int cfr_ignored_0 = kDTree.b; throw new ArithmeticException(); } public Optional search(KDTree$Point kDTree$Point) { if (kDTree$Point.getDimension() != this.b) { throw new IllegalArgumentException(\"Point has wrong dimension\"); } KDTree kDTree = this; return kDTree.search(kDTree.a, kDTree$Point); } public Optional search(KDTree$Node kDTree$Node, KDTree$Point kDTree$Point) { if (kDTree$Node == null) { return Optional.empty(); } if (kDTree$Node.a.equals(kDTree$Point)) { return Optional.of(kDTree$Node); } return this.search(kDTree$Node.getNearChild(kDTree$Point), kDTree$Point); } public KDTree$Point findMin(int n) { KDTree kDTree = this; return kDTree.findMin((KDTree$Node)kDTree.a, (int)n).a; } public KDTree$Node findMin(KDTree$Node kDTree$NodeArray, int n) { if (kDTree$NodeArray == null) { return null; } if (kDTree$NodeArray.getAxis() == n) { if (kDTree$NodeArray.c == null) { return kDTree$NodeArray; } return this.findMin(kDTree$NodeArray.c, n); } KDTree$Node kDTree$Node2 = this.findMin(kDTree$NodeArray.c, n); KDTree$Node kDTree$Node3 = this.findMin(kDTree$NodeArray.d, n); kDTree$NodeArray = new KDTree$Node[]{kDTree$Node2, kDTree$NodeArray, kDTree$Node3}; return Arrays.stream(kDTree$NodeArray).filter(Objects::nonNull).min(Comparator.comparingInt(kDTree$Node -> kDTree$Node.a.getCoordinate(n))).orElse(null); } public KDTree$Point findMax(int n) { KDTree kDTree = this; return kDTree.findMax((KDTree$Node)kDTree.a, (int)n).a; } public KDTree$Node findMax(KDTree$Node kDTree$NodeArray, int n) { if (kDTree$NodeArray == null) { return null; } if (kDTree$NodeArray.getAxis() == n) { if (kDTree$NodeArray.d == null) { return kDTree$NodeArray; } return this.findMax(kDTree$NodeArray.d, n); } KDTree$Node kDTree$Node2 = this.findMax(kDTree$NodeArray.c, n); KDTree$Node kDTree$Node3 = this.findMax(kDTree$NodeArray.d, n); kDTree$NodeArray = new KDTree$Node[]{kDTree$Node2, kDTree$NodeArray, kDTree$Node3}; return Arrays.stream(kDTree$NodeArray).filter(Objects::nonNull).max(Comparator.comparingInt(kDTree$Node -> kDTree$Node.a.getCoordinate(n))).orElse(null); } public void delete(KDTree$Point object) { object = (KDTree$Node)this.search((KDTree$Point)object).orElseThrow(() -> new IllegalArgumentException(\"Point not found\")); this.a = this.a(this.a, (KDTree$Node)object); } private KDTree$Node a(KDTree$Node kDTree$Node, KDTree$Node kDTree$Node2) { if (kDTree$Node == null) { return null; } if (kDTree$Node.equals(kDTree$Node2)) { if (kDTree$Node.d != null) { KDTree$Node kDTree$Node3 = this.findMin(kDTree$Node.d, kDTree$Node.getAxis()); kDTree$Node.a = kDTree$Node3.a; kDTree$Node.d = this.a(kDTree$Node.d, kDTree$Node3); } else if (kDTree$Node.c != null) { KDTree$Node kDTree$Node4 = this.findMin(kDTree$Node.c, kDTree$Node.getAxis()); kDTree$Node.a = kDTree$Node4.a; kDTree$Node.c = this.a(kDTree$Node.c, kDTree$Node4); } else { return null; } } if (kDTree$Node.getAxisCoordinate() < kDTree$Node2.a.getCoordinate(kDTree$Node.getAxis())) { kDTree$Node.c = this.a(kDTree$Node.c, kDTree$Node2); } else { kDTree$Node.d = this.a(kDTree$Node.d, kDTree$Node2); } return kDTree$Node; } public KDTree$Point findNearest(KDTree$Point kDTree$Point) { KDTree kDTree = this; return kDTree.a((KDTree$Node)kDTree.a, (KDTree$Point)kDTree$Point, (KDTree$Node)this.a).a; } private KDTree$Node a(KDTree$Node kDTree$Node, KDTree$Point kDTree$Point, KDTree$Node kDTree$Node2) { if (kDTree$Node == null) { return kDTree$Node2; } if (kDTree$Node.a.equals(kDTree$Point)) { return kDTree$Node; } int n = KDTree$Point.comparableDistance(kDTree$Node.a, kDTree$Point); int n2 = KDTree$Point.comparableDistanceExceptAxis(kDTree$Node.a, kDTree$Point, kDTree$Node.getAxis()); if (n < KDTree$Point.comparableDistance(kDTree$Node2.a, kDTree$Point)) { kDTree$Node2 = kDTree$Node; } kDTree$Node2 = this.a(kDTree$Node.getNearChild(kDTree$Point), kDTree$Point, kDTree$Node2); if (n2 < KDTree$Point.comparableDistance(kDTree$Node2.a, kDTree$Point)) { kDTree$Node2 = this.a(kDTree$Node.getFarChild(kDTree$Point), kDTree$Point, kDTree$Node2); } return kDTree$Node2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.Arrays; import java.util.Comparator; import java.util.Objects; import java.util.Optional; /* * K-D Tree Implementation * Wikipedia: https://en.wikipedia.org/wiki/K-d_tree * * Author: Amir Hosseini (https://github.com/itsamirhn) * * */ public class KDTree { private Node root; private final int k; // Dimensions of the points /** * Constructor for empty KDTree * * @param k Number of dimensions */ KDTree(int k) { this.k = k; } /** * Builds the KDTree from the specified points * * @param points Array of initial points */ KDTree(Point[] points) { if (points.length == 0) { throw new IllegalArgumentException(\"Points array cannot be empty\"); } this.k = points[0].getDimension(); for (Point point : points) { if (point.getDimension() != k) { throw new IllegalArgumentException(\"Points must have the same dimension\"); } } this.root = build(points, 0); } /** * Builds the KDTree from the specified coordinates of the points * * @param pointsCoordinates Array of initial points coordinates * */ KDTree(int[][] pointsCoordinates) { if (pointsCoordinates.length == 0) { throw new IllegalArgumentException(\"Points array cannot be empty\"); } this.k = pointsCoordinates[0].length; Point[] points = Arrays.stream(pointsCoordinates).map(Point::new).toArray(Point[] ::new); for (Point point : points) { if (point.getDimension() != k) { throw new IllegalArgumentException(\"Points must have the same dimension\"); } } this.root = build(points, 0); } static class Point { int[] coordinates; public int getCoordinate(int i) { return coordinates[i]; } public int getDimension() { return coordinates.length; } Point(int[] coordinates) { this.coordinates = coordinates; } @Override public boolean equals(Object obj) { if (obj instanceof Point other) { return Arrays.equals(other.coordinates, this.coordinates); } return false; } @Override public int hashCode() { return Arrays.hashCode(coordinates); } @Override public String toString() { return Arrays.toString(coordinates); } /** * Find the comparable distance between two points (without SQRT) * * @param p1 First point * @param p2 Second point * * @return The comparable distance between the two points */ public static int comparableDistance(Point p1, Point p2) { int distance = 0; for (int i = 0; i < p1.getDimension(); i++) { int t = p1.getCoordinate(i) - p2.getCoordinate(i); distance += t * t; } return distance; } /** * Find the comparable distance between two points with ignoring specified axis * * @param p1 First point * @param p2 Second point * @param axis The axis to ignore * * @return The distance between the two points */ public static int comparableDistanceExceptAxis(Point p1, Point p2, int axis) { int distance = 0; for (int i = 0; i < p1.getDimension(); i++) { if (i == axis) { continue; } int t = p1.getCoordinate(i) - p2.getCoordinate(i); distance += t * t; } return distance; } } static class Node { private Point point; private int axis; // 0 for x, 1 for y, 2 for z, etc. private Node left = null; // Left child private Node right = null; // Right child Node(Point point, int axis) { this.point = point; this.axis = axis; } public Point getPoint() { return point; } public Node getLeft() { return left; } public Node getRight() { return right; } public int getAxis() { return axis; } /** * Get the nearest child according to the specified point * * @param point The point to find the nearest child to * * @return The nearest child Node */ public Node getNearChild(Point point) { if (point.getCoordinate(axis) < this.point.getCoordinate(axis)) { return left; } else { return right; } } /** * Get the farthest child according to the specified point * * @param point The point to find the farthest child to * * @return The farthest child Node */ public Node getFarChild(Point point) { if (point.getCoordinate(axis) < this.point.getCoordinate(axis)) { return right; } else { return left; } } /** * Get the node axis coordinate of point * * @return The axis coordinate of the point */ public int getAxisCoordinate() { return point.getCoordinate(axis); } } public Node getRoot() { return root; } /** * Builds the KDTree from the specified points * * @param points Array of initial points * @param depth The current depth of the tree * * @return The root of the KDTree */ private Node build(Point[] points, int depth) { if (points.length == 0) { return null; } int axis = depth % k; if (points.length == 1) { return new Node(points[0], axis); } Arrays.sort(points, Comparator.comparingInt(o -> o.getCoordinate(axis))); int median = points.length >> 1; Node node = new Node(points[median], axis); node.left = build(Arrays.copyOfRange(points, 0, median), depth + 1); node.right = build(Arrays.copyOfRange(points, median + 1, points.length), depth + 1); return node; } /** * Insert a point into the KDTree * * @param point The point to insert * */ public void insert(Point point) { if (point.getDimension() != k) { throw new IllegalArgumentException(\"Point has wrong dimension\"); } root = insert(root, point, 0); } /** * Insert a point into a subtree * * @param root The root of the subtree * @param point The point to insert * @param depth The current depth of the tree * * @return The root of the KDTree */ private Node insert(Node root, Point point, int depth) { int axis = depth % k; if (root == null) { return new Node(point, axis); } if (point.getCoordinate(axis) < root.getAxisCoordinate()) { root.left = insert(root.left, point, depth + 1); } else { root.right = insert(root.right, point, depth + 1); } return root; } /** * Search for Node corresponding to the specified point in the KDTree * * @param point The point to search for * * @return The Node corresponding to the specified point */ public Optional<Node> search(Point point) { if (point.getDimension() != k) { throw new IllegalArgumentException(\"Point has wrong dimension\"); } return search(root, point); } /** * Search for Node corresponding to the specified point in a subtree * * @param root The root of the subtree to search in * @param point The point to search for * * @return The Node corresponding to the specified point */ public Optional<Node> search(Node root, Point point) { if (root == null) { return Optional.empty(); } if (root.point.equals(point)) { return Optional.of(root); } return search(root.getNearChild(point), point); } /** * Find a point with minimum value in specified axis in the KDTree * * @param axis The axis to find the minimum value in * * @return The point with minimum value in the specified axis */ public Point findMin(int axis) { return findMin(root, axis).point; } /** * Find a point with minimum value in specified axis in a subtree * * @param root The root of the subtree to search in * @param axis The axis to find the minimum value in * * @return The Node with minimum value in the specified axis of the point */ public Node findMin(Node root, int axis) { if (root == null) { return null; } if (root.getAxis() == axis) { if (root.left == null) { return root; } return findMin(root.left, axis); } else { Node left = findMin(root.left, axis); Node right = findMin(root.right, axis); Node[] candidates = {left, root, right}; return Arrays.stream(candidates).filter(Objects::nonNull).min(Comparator.comparingInt(a -> a.point.getCoordinate(axis))).orElse(null); } } /** * Find a point with maximum value in specified axis in the KDTree * * @param axis The axis to find the maximum value in * * @return The point with maximum value in the specified axis */ public Point findMax(int axis) { return findMax(root, axis).point; } /** * Find a point with maximum value in specified axis in a subtree * * @param root The root of the subtree to search in * @param axis The axis to find the maximum value in * * @return The Node with maximum value in the specified axis of the point */ public Node findMax(Node root, int axis) { if (root == null) { return null; } if (root.getAxis() == axis) { if (root.right == null) { return root; } return findMax(root.right, axis); } else { Node left = findMax(root.left, axis); Node right = findMax(root.right, axis); Node[] candidates = {left, root, right}; return Arrays.stream(candidates).filter(Objects::nonNull).max(Comparator.comparingInt(a -> a.point.getCoordinate(axis))).orElse(null); } } /** * Delete the node with the given point. * * @param point the point to delete * */ public void delete(Point point) { Node node = search(point).orElseThrow(() -> new IllegalArgumentException(\"Point not found\")); root = delete(root, node); } /** * Delete the specified node from a subtree. * * @param root The root of the subtree to delete from * @param node The node to delete * * @return The new root of the subtree */ private Node delete(Node root, Node node) { if (root == null) { return null; } if (root.equals(node)) { if (root.right != null) { Node min = findMin(root.right, root.getAxis()); root.point = min.point; root.right = delete(root.right, min); } else if (root.left != null) { Node min = findMin(root.left, root.getAxis()); root.point = min.point; root.left = delete(root.left, min); } else { return null; } } if (root.getAxisCoordinate() < node.point.getCoordinate(root.getAxis())) { root.left = delete(root.left, node); } else { root.right = delete(root.right, node); } return root; } /** * Finds the nearest point in the tree to the given point. * * @param point The point to find the nearest neighbor to. * */ public Point findNearest(Point point) { return findNearest(root, point, root).point; } /** * Finds the nearest point in a subtree to the given point. * * @param root The root of the subtree to search in. * @param point The point to find the nearest neighbor to. * @param nearest The nearest neighbor found so far. * */ private Node findNearest(Node root, Point point, Node nearest) { if (root == null) { return nearest; } if (root.point.equals(point)) { return root; } int distance = Point.comparableDistance(root.point, point); int distanceExceptAxis = Point.comparableDistanceExceptAxis(root.point, point, root.getAxis()); if (distance < Point.comparableDistance(nearest.point, point)) { nearest = root; } nearest = findNearest(root.getNearChild(point), point, nearest); if (distanceExceptAxis < Point.comparableDistance(nearest.point, point)) { nearest = findNearest(root.getFarChild(point), point, nearest); } return nearest; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class KMP { private KMP() { } public static void main(String[] stringArray) { KMP.kmpMatcher(\"AAAAABAAABA\", \"AAAA\"); } public static void kmpMatcher(String string, String string2) { int n = string.length(); int n2 = string2.length(); Object object = string2; Object object2 = ((String)object).length(); int[] nArray = new int[object2]; int[] nArray2 = nArray; nArray[0] = 0; int n3 = 0; for (int i = 1; i < object2; ++i) { while (n3 > 0 && ((String)object).charAt(n3) != ((String)object).charAt(i)) { n3 = nArray2[n3 - 1]; } if (((String)object).charAt(n3) == ((String)object).charAt(i)) { // empty if block } nArray2[i] = ++n3; } object = nArray2; object2 = 0; for (int i = 0; i < n; ++i) { while (object2 > 0 && string.charAt(i) != string2.charAt((int)object2)) { object2 = object[object2 - 1]; } if (string.charAt(i) == string2.charAt((int)object2)) { ++object2; } if (object2 != n2) continue; System.out.println(\"Pattern starts: \" + (i + 1 - n2)); object2 = object[object2 - 1]; } } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * Implementation of KnuthMorrisPratt algorithm Usage: see the main function * for an example */ public final class KMP { private KMP() { } // a working example public static void main(String[] args) { final String haystack = \"AAAAABAAABA\"; // This is the full string final String needle = \"AAAA\"; // This is the substring that we want to find kmpMatcher(haystack, needle); } // find the starting index in string haystack[] that matches the search word P[] public static void kmpMatcher(final String haystack, final String needle) { final int m = haystack.length(); final int n = needle.length(); final int[] pi = computePrefixFunction(needle); int q = 0; for (int i = 0; i < m; i++) { while (q > 0 && haystack.charAt(i) != needle.charAt(q)) { q = pi[q - 1]; } if (haystack.charAt(i) == needle.charAt(q)) { q++; } if (q == n) { System.out.println(\"Pattern starts: \" + (i + 1 - n)); q = pi[q - 1]; } } } // return the prefix function private static int[] computePrefixFunction(final String p) { final int n = p.length(); final int[] pi = new int[n]; pi[0] = 0; int q = 0; for (int i = 1; i < n; i++) { while (q > 0 && p.charAt(q) != p.charAt(i)) { q = pi[q - 1]; } if (p.charAt(q) == p.charAt(i)) { q++; } pi[i] = q; } return pi; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; class KMPSearch { KMPSearch() { } }", "deobfuscated_code": "package com.thealgorithms.searches; class KMPSearch { int kmpSearch(String pat, String txt) { int m = pat.length(); int n = txt.length(); // create lps[] that will hold the longest // prefix suffix values for pattern int[] lps = new int[m]; int j = 0; // index for pat[] // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pat, m, lps); int i = 0; // index for txt[] while ((n - i) >= (m - j)) { if (pat.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == m) { System.out.println(\"Found pattern \" + \"at index \" + (i - j)); int index = (i - j); j = lps[j - 1]; return index; } // mismatch after j matches else if (i < n && pat.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) { j = lps[j - 1]; } else { i = i + 1; } } } System.out.println(\"No pattern found\"); return -1; } void computeLPSArray(String pat, int m, int[] lps) { // length of the previous longest prefix suffix int len = 0; int i = 1; lps[0] = 0; // lps[0] is always 0 // the loop calculates lps[i] for i = 1 to m-1 while (i < m) { if (pat.charAt(i) == pat.charAt(len)) { len++; lps[i] = len; i++; } else { // (pat[i] != pat[len]) // This is tricky. Consider the example. // AAACAAAA and i = 7. The idea is similar // to search step. if (len != 0) { len = lps[len - 1]; // Also, note that we do not increment // i here } else { // if (len == 0) lps[i] = len; i++; } } } } } // This code has been contributed by Amit Khandelwal."}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class KadaneAlgorithm { private KadaneAlgorithm() { } public static boolean maxSum(int[] nArray, int n) { int n2 = nArray[0]; int n3 = 0; for (int n4 : nArray) { n2 = Math.max(n2, n3 += n4); if (n3 >= 0) continue; n3 = 0; } return n2 == n; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * This class implements Kadane's Algorithm to find the maximum subarray sum * within a given array of integers. The algorithm efficiently computes the maximum * sum of a contiguous subarray in linear time. * * Author: <a href=\"https://github.com/siddhant2002\">Siddhant Swarup Mallick</a> */ public final class KadaneAlgorithm { private KadaneAlgorithm() { } /** * Computes the maximum subarray sum using Kadane's Algorithm and checks * if it matches a predicted answer. * * @param a The input array of integers for which the maximum * subarray sum is to be calculated. * @param predictedAnswer The expected maximum subarray sum to be verified * against the computed sum. * @return true if the computed maximum subarray sum equals the predicted * answer, false otherwise. * * <p>Example:</p> * <pre> * Input: {89, 56, 98, 123, 26, 75, 12, 40, 39, 68, 91} * Output: true if the maximum subarray sum is equal to the * predicted answer. * </pre> * * <p>Algorithmic Complexity:</p> * <ul> * <li>Time Complexity: O(n) - the algorithm iterates through the array once.</li> * <li>Auxiliary Space Complexity: O(1) - only a constant amount of additional space is used.</li> * </ul> */ public static boolean maxSum(int[] a, int predictedAnswer) { int sum = a[0]; int runningSum = 0; for (int k : a) { runningSum += k; sum = Math.max(sum, runningSum); if (runningSum < 0) { runningSum = 0; } } return sum == predictedAnswer; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.AdjacencyList; import com.thealgorithms.datastructures.graphs.TopologicalSort; import java.util.ArrayList; import java.util.HashMap; import java.util.LinkedList; import java.util.Map; public final class KahnsAlgorithm { private KahnsAlgorithm() { } /* * WARNING - void declaration */ public static void main(String[] object) { void var3_8; object = new AdjacencyList(); ((AdjacencyList)object).a((Comparable)((Object)\"a\"), (Comparable)((Object)\"b\")); ((AdjacencyList)object).a((Comparable)((Object)\"c\"), (Comparable)((Object)\"a\")); ((AdjacencyList)object).a((Comparable)((Object)\"a\"), (Comparable)((Object)\"d\")); ((AdjacencyList)object).a((Comparable)((Object)\"b\"), (Comparable)((Object)\"d\")); ((AdjacencyList)object).a((Comparable)((Object)\"c\"), (Comparable)((Object)\"u\")); ((AdjacencyList)object).a((Comparable)((Object)\"u\"), (Comparable)((Object)\"b\")); TopologicalSort topologicalSort = new TopologicalSort((AdjacencyList)object); object = topologicalSort; object = topologicalSort; Object object3 = topologicalSort; topologicalSort.b = new HashMap(); for (Comparable n : ((TopologicalSort)object3).a.a()) { ((TopologicalSort)object3).b.putIfAbsent(n, 0); for (Object object2 : ((TopologicalSort)object3).a.a(n)) { ((TopologicalSort)object3).b.put(object2, ((TopologicalSort)object3).b.getOrDefault(object2, 0) + 1); } } object3 = new LinkedList(); for (Map.Entry entry : ((TopologicalSort)object).b.entrySet()) { if ((Integer)entry.getValue() != 0) continue; object3.add((Comparable)entry.getKey()); } ArrayList arrayList = new ArrayList(); boolean bl = false; while (!object3.isEmpty()) { Object object2; object2 = (Comparable)object3.poll(); arrayList.add(object2); ++var3_8; for (Comparable comparable : ((TopologicalSort)object).a.a((Comparable)object2)) { ((TopologicalSort)object).b.put(comparable, (Integer)((TopologicalSort)object).b.get(comparable) - 1); if ((Integer)((TopologicalSort)object).b.get(comparable) != 0) continue; object3.add(comparable); } } if (var3_8 != ((TopologicalSort)object).a.a().size()) { throw new IllegalStateException(\"Graph contains a cycle, topological sort not possible\"); } object = arrayList.iterator(); while (object.hasNext()) { object3 = (String)object.next(); System.out.print((String)object3 + \" \"); } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.HashMap; import java.util.LinkedHashMap; import java.util.LinkedList; import java.util.Map; import java.util.Queue; import java.util.Set; /** * A class representing the adjacency list of a directed graph. The adjacency list * maintains a mapping of vertices to their adjacent vertices. * * @param <E> the type of vertices, extending Comparable to ensure that vertices * can be compared */ class AdjacencyList<E extends Comparable<E>> { Map<E, ArrayList<E>> adj; /** * Constructor to initialize the adjacency list. */ AdjacencyList() { adj = new LinkedHashMap<>(); } /** * Adds a directed edge from one vertex to another in the adjacency list. * If the vertex does not exist, it will be added to the list. * * @param from the starting vertex of the directed edge * @param to the destination vertex of the directed edge */ void addEdge(E from, E to) { if (!adj.containsKey(from)) { adj.put(from, new ArrayList<>()); } adj.get(from).add(to); if (!adj.containsKey(to)) { adj.put(to, new ArrayList<>()); } } /** * Retrieves the list of adjacent vertices for a given vertex. * * @param v the vertex whose adjacent vertices are to be fetched * @return an ArrayList of adjacent vertices for vertex v */ ArrayList<E> getAdjacents(E v) { return adj.get(v); } /** * Retrieves the set of all vertices present in the graph. * * @return a set containing all vertices in the graph */ Set<E> getVertices() { return adj.keySet(); } } /** * A class that performs topological sorting on a directed graph using Kahn's algorithm. * * @param <E> the type of vertices, extending Comparable to ensure that vertices * can be compared */ class TopologicalSort<E extends Comparable<E>> { AdjacencyList<E> graph; Map<E, Integer> inDegree; /** * Constructor to initialize the topological sorting class with a given graph. * * @param graph the directed graph represented as an adjacency list */ TopologicalSort(AdjacencyList<E> graph) { this.graph = graph; } /** * Calculates the in-degree of all vertices in the graph. The in-degree is * the number of edges directed into a vertex. */ void calculateInDegree() { inDegree = new HashMap<>(); for (E vertex : graph.getVertices()) { inDegree.putIfAbsent(vertex, 0); for (E adjacent : graph.getAdjacents(vertex)) { inDegree.put(adjacent, inDegree.getOrDefault(adjacent, 0) + 1); } } } /** * Returns an ArrayList containing the vertices of the graph arranged in * topological order. Topological sorting ensures that for any directed edge * (u, v), vertex u appears before vertex v in the ordering. * * @return an ArrayList of vertices in topological order * @throws IllegalStateException if the graph contains a cycle */ ArrayList<E> topSortOrder() { calculateInDegree(); Queue<E> q = new LinkedList<>(); for (var entry : inDegree.entrySet()) { if (entry.getValue() == 0) { q.add(entry.getKey()); } } ArrayList<E> answer = new ArrayList<>(); int processedVertices = 0; while (!q.isEmpty()) { E current = q.poll(); answer.add(current); processedVertices++; for (E adjacent : graph.getAdjacents(current)) { inDegree.put(adjacent, inDegree.get(adjacent) - 1); if (inDegree.get(adjacent) == 0) { q.add(adjacent); } } } if (processedVertices != graph.getVertices().size()) { throw new IllegalStateException(\"Graph contains a cycle, topological sort not possible\"); } return answer; } } /** * A driver class that sorts a given graph in topological order using Kahn's algorithm. */ public final class KahnsAlgorithm { private KahnsAlgorithm() { } public static void main(String[] args) { // Graph definition and initialization AdjacencyList<String> graph = new AdjacencyList<>(); graph.addEdge(\"a\", \"b\"); graph.addEdge(\"c\", \"a\"); graph.addEdge(\"a\", \"d\"); graph.addEdge(\"b\", \"d\"); graph.addEdge(\"c\", \"u\"); graph.addEdge(\"u\", \"b\"); TopologicalSort<String> topSort = new TopologicalSort<>(graph); // Printing the topological order for (String s : topSort.topSortOrder()) { System.out.print(s + \" \"); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.math.BigInteger; import java.util.ArrayList; import java.util.List; public final class KaprekarNumbers { private KaprekarNumbers() { } public static List kaprekarNumberInRange(long l, long l2) { long l3 = l2 - l; if (l3 < 0L) { throw new Exception(\"Invalid range\"); } ArrayList<Long> arrayList = new ArrayList<Long>(); for (long i = l; i <= l2; ++i) { if (!KaprekarNumbers.isKaprekarNumber(i)) continue; arrayList.add(i); } return arrayList; } public static boolean isKaprekarNumber(long l) { String string = Long.toString(l); Object object = BigInteger.valueOf(l); object = ((BigInteger)object).multiply((BigInteger)object); if (string.length() == ((BigInteger)object).toString().length()) { return string.equals(((BigInteger)object).toString()); } Object object2 = BigInteger.ZERO; if (((BigInteger)object).toString().contains(\"0\")) { object2 = new BigInteger(((BigInteger)object).toString().substring(0, ((BigInteger)object).toString().indexOf(\"0\"))); } BigInteger bigInteger = new BigInteger(((BigInteger)object).toString().substring(0, ((BigInteger)object).toString().length() - string.length())); object = new BigInteger(((BigInteger)object).toString().substring(((BigInteger)object).toString().length() - string.length())); object2 = ((BigInteger)object2).add((BigInteger)object).toString(); object = bigInteger.add((BigInteger)object).toString(); return string.equals(object2) || string.equals(object); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.math.BigInteger; import java.util.ArrayList; import java.util.List; public final class KaprekarNumbers { private KaprekarNumbers() { } /* This program demonstrates if a given number is Kaprekar Number or not. Kaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n digits and sum of these parts is equal to the original number. */ // Provides a list of kaprekarNumber in a range public static List<Long> kaprekarNumberInRange(long start, long end) throws Exception { long n = end - start; if (n < 0) { throw new Exception(\"Invalid range\"); } ArrayList<Long> list = new ArrayList<>(); for (long i = start; i <= end; i++) { if (isKaprekarNumber(i)) { list.add(i); } } return list; } // Checks whether a given number is Kaprekar Number or not public static boolean isKaprekarNumber(long num) { String number = Long.toString(num); BigInteger originalNumber = BigInteger.valueOf(num); BigInteger numberSquared = originalNumber.multiply(originalNumber); if (number.length() == numberSquared.toString().length()) { return number.equals(numberSquared.toString()); } else { BigInteger leftDigits1 = BigInteger.ZERO; BigInteger leftDigits2; if (numberSquared.toString().contains(\"0\")) { leftDigits1 = new BigInteger(numberSquared.toString().substring(0, numberSquared.toString().indexOf(\"0\"))); } leftDigits2 = new BigInteger(numberSquared.toString().substring(0, (numberSquared.toString().length() - number.length()))); BigInteger rightDigits = new BigInteger(numberSquared.toString().substring(numberSquared.toString().length() - number.length())); String x = leftDigits1.add(rightDigits).toString(); String y = leftDigits2.add(rightDigits).toString(); return (number.equals(x)) || (number.equals(y)); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.math.BigInteger; public final class KaratsubaMultiplication { private KaratsubaMultiplication() { } public static BigInteger karatsuba(BigInteger bigInteger, BigInteger bigInteger2) { if (bigInteger.bitLength() <= 4 || bigInteger2.bitLength() <= 4) { return bigInteger.multiply(bigInteger2); } int n = Math.max(bigInteger.bitLength(), bigInteger2.bitLength()); BigInteger bigInteger3 = bigInteger.shiftRight(n /= 2); bigInteger = bigInteger.subtract(bigInteger3.shiftLeft(n)); BigInteger bigInteger4 = bigInteger2.shiftRight(n); bigInteger2 = bigInteger2.subtract(bigInteger4.shiftLeft(n)); BigInteger bigInteger5 = KaratsubaMultiplication.karatsuba(bigInteger, bigInteger2); bigInteger = KaratsubaMultiplication.karatsuba(bigInteger.add(bigInteger3), bigInteger2.add(bigInteger4)); bigInteger2 = KaratsubaMultiplication.karatsuba(bigInteger3, bigInteger4); return bigInteger2.shiftLeft(2 * n).add(bigInteger.subtract(bigInteger2).subtract(bigInteger5).shiftLeft(n)).add(bigInteger5); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.math.BigInteger; /** * This class provides an implementation of the Karatsuba multiplication algorithm. * * <p> * Karatsuba multiplication is a divide-and-conquer algorithm for multiplying two large * numbers. It is faster than the classical multiplication algorithm and reduces the * time complexity to O(n^1.585) by breaking the multiplication of two n-digit numbers * into three multiplications of n/2-digit numbers. * </p> * * <p> * The main idea of the Karatsuba algorithm is based on the following observation: * </p> * * <pre> * Let x and y be two numbers: * x = a * 10^m + b * y = c * 10^m + d * * Then, the product of x and y can be expressed as: * x * y = (a * c) * 10^(2*m) + ((a * d) + (b * c)) * 10^m + (b * d) * </pre> * * The Karatsuba algorithm calculates this more efficiently by reducing the number of * multiplications from four to three by using the identity: * * <pre> * (a + b)(c + d) = ac + ad + bc + bd * </pre> * * <p> * The recursion continues until the numbers are small enough to multiply directly using * the traditional method. * </p> */ public final class KaratsubaMultiplication { /** * Private constructor to hide the implicit public constructor */ private KaratsubaMultiplication() { } /** * Multiplies two large numbers using the Karatsuba algorithm. * * <p> * This method recursively splits the numbers into smaller parts until they are * small enough to be multiplied directly using the traditional method. * </p> * * @param x The first large number to be multiplied (BigInteger). * @param y The second large number to be multiplied (BigInteger). * @return The product of the two numbers (BigInteger). */ public static BigInteger karatsuba(BigInteger x, BigInteger y) { // Base case: when numbers are small enough, use direct multiplication // If the number is 4 bits or smaller, switch to the classical method if (x.bitLength() <= 4 || y.bitLength() <= 4) { return x.multiply(y); } // Find the maximum bit length of the two numbers int n = Math.max(x.bitLength(), y.bitLength()); // Split the numbers in the middle int m = n / 2; // High and low parts of the first number x (x = a * 10^m + b) BigInteger high1 = x.shiftRight(m); // a = x / 2^m (higher part) BigInteger low1 = x.subtract(high1.shiftLeft(m)); // b = x - a * 2^m (lower part) // High and low parts of the second number y (y = c * 10^m + d) BigInteger high2 = y.shiftRight(m); // c = y / 2^m (higher part) BigInteger low2 = y.subtract(high2.shiftLeft(m)); // d = y - c * 2^m (lower part) // Recursively calculate three products BigInteger z0 = karatsuba(low1, low2); // z0 = b * d (low1 * low2) BigInteger z1 = karatsuba(low1.add(high1), low2.add(high2)); // z1 = (a + b) * (c + d) BigInteger z2 = karatsuba(high1, high2); // z2 = a * c (high1 * high2) // Combine the results using Karatsuba's formula // z0 + ((z1 - z2 - z0) << m) + (z2 << 2m) return z2 .shiftLeft(2 * m) // z2 * 10^(2*m) .add(z1.subtract(z2).subtract(z0).shiftLeft(m)) // (z1 - z2 - z0) * 10^m .add(z0); // z0 } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import java.util.HashSet; import java.util.Set; class KargerMinCut$DisjointSetUnion { private final int[] b; int a; KargerMinCut$DisjointSetUnion(int n) { this.b = new int[n]; int n2 = 0; while (n2 < n) { int n3 = n2++; this.b[n3] = n3; } this.a = n; } private int a(int n) { if (this.b[n] != n) { KargerMinCut$DisjointSetUnion kargerMinCut$DisjointSetUnion = this; this.b[n] = kargerMinCut$DisjointSetUnion.a(kargerMinCut$DisjointSetUnion.b[n]); } return this.b[n]; } final void a(int n, int n2) { if ((n = this.a(n)) != (n2 = this.a(n2))) { this.b[n2] = n; --this.a; } } final boolean b(int n, int n2) { return this.a(n) == this.a(n2); } final Set a() { int n = this.a(0); HashSet<Integer> hashSet = new HashSet<Integer>(); for (int i = 0; i < this.b.length; ++i) { if (this.a(i) != n) continue; hashSet.add(i); } return hashSet; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import java.util.HashSet; import java.util.Set; class KargerMinCut$DisjointSetUnion { private final int[] b; int a; KargerMinCut$DisjointSetUnion(int n) { this.b = new int[n]; int n2 = 0; while (n2 < n) { int n3 = n2++; this.b[n3] = n3; } this.a = n; } private int a(int n) { if (this.b[n] != n) { KargerMinCut$DisjointSetUnion kargerMinCut$DisjointSetUnion = this; this.b[n] = kargerMinCut$DisjointSetUnion.a(kargerMinCut$DisjointSetUnion.b[n]); } return this.b[n]; } final void a(int n, int n2) { if ((n = this.a(n)) != (n2 = this.a(n2))) { this.b[n2] = n; --this.a; } } final boolean b(int n, int n2) { return this.a(n) == this.a(n2); } final Set a() { int n = this.a(0); HashSet<Integer> hashSet = new HashSet<Integer>(); for (int i = 0; i < this.b.length; ++i) { if (this.a(i) != n) continue; hashSet.add(i); } return hashSet; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import com.thealgorithms.randomized.KargerMinCut$DisjointSetUnion; import com.thealgorithms.randomized.KargerMinCut$KargerOutput; import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Random; class KargerMinCut$Graph { private final List a; private final List b; KargerMinCut$Graph(Collection object, List object2) { this.a = new ArrayList(object); this.b = new ArrayList(); object = object2.iterator(); while (object.hasNext()) { object2 = (int[])object.next(); this.b.add(new int[]{(int)object2[0], (int)object2[1]}); } } final KargerMinCut$Graph a() { return new KargerMinCut$Graph(this.a, this.b); } final KargerMinCut$KargerOutput b() { Object object = new KargerMinCut$DisjointSetUnion(this.a.size()); Object object2 = new ArrayList(this.b); Object object3 = new Random(); while (((KargerMinCut$DisjointSetUnion)object).a > 2) { int[] nArray = (int[])object2.get(((Random)object3).nextInt(object2.size())); if (((KargerMinCut$DisjointSetUnion)object).b(nArray[0], nArray[1])) continue; ((KargerMinCut$DisjointSetUnion)object).a(nArray[0], nArray[1]); } int n = 0; object2 = this.b.iterator(); while (object2.hasNext()) { object3 = (int[])object2.next(); if (((KargerMinCut$DisjointSetUnion)object).b((int)object3[0], (int)object3[1])) continue; ++n; } int n2 = n; object2 = object; object = this; object2 = ((KargerMinCut$DisjointSetUnion)object2).a(); HashSet<Integer> hashSet = new HashSet<Integer>(); HashSet<Integer> hashSet2 = new HashSet<Integer>(); for (int i = 0; i < ((KargerMinCut$Graph)object).a.size(); ++i) { if (object2.contains(i)) { hashSet.add((Integer)((KargerMinCut$Graph)object).a.get(i)); continue; } hashSet2.add((Integer)((KargerMinCut$Graph)object).a.get(i)); } return new KargerMinCut$KargerOutput(hashSet, hashSet2, n2); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import com.thealgorithms.randomized.KargerMinCut$DisjointSetUnion; import com.thealgorithms.randomized.KargerMinCut$KargerOutput; import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Random; class KargerMinCut$Graph { private final List a; private final List b; KargerMinCut$Graph(Collection object, List object2) { this.a = new ArrayList(object); this.b = new ArrayList(); object = object2.iterator(); while (object.hasNext()) { object2 = (int[])object.next(); this.b.add(new int[]{(int)object2[0], (int)object2[1]}); } } final KargerMinCut$Graph a() { return new KargerMinCut$Graph(this.a, this.b); } final KargerMinCut$KargerOutput b() { Object object = new KargerMinCut$DisjointSetUnion(this.a.size()); Object object2 = new ArrayList(this.b); Object object3 = new Random(); while (((KargerMinCut$DisjointSetUnion)object).a > 2) { int[] nArray = (int[])object2.get(((Random)object3).nextInt(object2.size())); if (((KargerMinCut$DisjointSetUnion)object).b(nArray[0], nArray[1])) continue; ((KargerMinCut$DisjointSetUnion)object).a(nArray[0], nArray[1]); } int n = 0; object2 = this.b.iterator(); while (object2.hasNext()) { object3 = (int[])object2.next(); if (((KargerMinCut$DisjointSetUnion)object).b((int)object3[0], (int)object3[1])) continue; ++n; } int n2 = n; object2 = object; object = this; object2 = ((KargerMinCut$DisjointSetUnion)object2).a(); HashSet<Integer> hashSet = new HashSet<Integer>(); HashSet<Integer> hashSet2 = new HashSet<Integer>(); for (int i = 0; i < ((KargerMinCut$Graph)object).a.size(); ++i) { if (object2.contains(i)) { hashSet.add((Integer)((KargerMinCut$Graph)object).a.get(i)); continue; } hashSet2.add((Integer)((KargerMinCut$Graph)object).a.get(i)); } return new KargerMinCut$KargerOutput(hashSet, hashSet2, n2); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; import java.util.Set; public final class KargerMinCut$KargerOutput extends Record { private final Set a; private final Set b; private final int c; public KargerMinCut$KargerOutput(Set set, Set set2, int n) { this.a = set; this.b = set2; this.c = n; } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{KargerMinCut$KargerOutput.class, \"first;second;minCut\", \"a\", \"b\", \"c\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{KargerMinCut$KargerOutput.class, \"first;second;minCut\", \"a\", \"b\", \"c\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{KargerMinCut$KargerOutput.class, \"first;second;minCut\", \"a\", \"b\", \"c\"}, this, object); } public final Set first() { return this.a; } public final Set second() { return this.b; } public final int minCut() { return this.c; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; import java.util.Set; public final class KargerMinCut$KargerOutput extends Record { private final Set a; private final Set b; private final int c; public KargerMinCut$KargerOutput(Set set, Set set2, int n) { this.a = set; this.b = set2; this.c = n; } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{KargerMinCut$KargerOutput.class, \"first;second;minCut\", \"a\", \"b\", \"c\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{KargerMinCut$KargerOutput.class, \"first;second;minCut\", \"a\", \"b\", \"c\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{KargerMinCut$KargerOutput.class, \"first;second;minCut\", \"a\", \"b\", \"c\"}, this, object); } public final Set first() { return this.a; } public final Set second() { return this.b; } public final int minCut() { return this.c; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import com.thealgorithms.randomized.KargerMinCut$Graph; import com.thealgorithms.randomized.KargerMinCut$KargerOutput; import java.util.Collection; import java.util.HashSet; import java.util.List; public final class KargerMinCut { private KargerMinCut() { } public static KargerMinCut$KargerOutput findMinCut(Collection collection, List list) { return KargerMinCut.findMinCut(collection, list, 100); } public static KargerMinCut$KargerOutput findMinCut(Collection object, List object2, int n) { object = new KargerMinCut$Graph((Collection)object, (List)object2); object2 = new KargerMinCut$KargerOutput(new HashSet(), new HashSet(), Integer.MAX_VALUE); for (int i = 0; i < n; ++i) { Object object3 = ((KargerMinCut$Graph)object).a(); object3 = ((KargerMinCut$Graph)object3).b(); if (((KargerMinCut$KargerOutput)object3).c >= ((KargerMinCut$KargerOutput)object2).c) continue; object2 = object3; } return object2; } }", "deobfuscated_code": "package com.thealgorithms.randomized; import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Random; import java.util.Set; /** * Implementation of Karger's Minimum Cut algorithm. * * <p>Karger's algorithm is a randomized algorithm to compute the minimum cut of a connected graph. * A minimum cut is the smallest set of edges that, if removed, would split the graph into two * disconnected components. * * <p>The algorithm works by repeatedly contracting random edges in the graph until only two * nodes remain. The edges between these two nodes represent a cut. By running the algorithm * multiple times and keeping track of the smallest cut found, the probability of finding the * true minimum cut increases. * * <p>Key steps of the algorithm: * <ol> * <li>Randomly select an edge and contract it, merging the two nodes into one.</li> * <li>Repeat the contraction process until only two nodes remain.</li> * <li>Count the edges between the two remaining nodes to determine the cut size.</li> * <li>Repeat the process multiple times to improve the likelihood of finding the true minimum cut.</li> * </ol> * <p> * See more: <a href=\"https://en.wikipedia.org/wiki/Karger%27s_algorithm\">Karger's algorithm</a> * * @author MuhammadEzzatHBK */ public final class KargerMinCut { /** * Output of the Karger algorithm. * * @param first The first set of nodes in the cut. * @param second The second set of nodes in the cut. * @param minCut The size of the minimum cut. */ public record KargerOutput(Set<Integer> first, Set<Integer> second, int minCut) { } private KargerMinCut() { } public static KargerOutput findMinCut(Collection<Integer> nodeSet, List<int[]> edges) { return findMinCut(nodeSet, edges, 100); } /** * Finds the minimum cut of a graph using Karger's algorithm. * * @param nodeSet: Input graph nodes * @param edges: Input graph edges * @param iterations: Iterations to run the algorithms for, more iterations = more accuracy * @return A KargerOutput object containing the two sets of nodes and the size of the minimum cut. */ public static KargerOutput findMinCut(Collection<Integer> nodeSet, List<int[]> edges, int iterations) { Graph graph = new Graph(nodeSet, edges); KargerOutput minCut = new KargerOutput(new HashSet<>(), new HashSet<>(), Integer.MAX_VALUE); KargerOutput output; // Run the algorithm multiple times to increase the probability of finding for (int i = 0; i < iterations; i++) { Graph clone = graph.copy(); output = clone.findMinCut(); if (output.minCut < minCut.minCut) { minCut = output; } } return minCut; } private static class DisjointSetUnion { private final int[] parent; int setCount; DisjointSetUnion(int size) { parent = new int[size]; for (int i = 0; i < size; i++) { parent[i] = i; } setCount = size; } int find(int i) { // If it's not its own parent, then it's not the root of its set if (parent[i] != i) { // Recursively find the root of its parent // and update i's parent to point directly to the root (path compression) parent[i] = find(parent[i]); } // Return the root (representative) of the set return parent[i]; } void union(int u, int v) { // Find the root of each node int rootU = find(u); int rootV = find(v); // If they belong to different sets, merge them if (rootU != rootV) { // Make rootV point to rootU  merge the two sets parent[rootV] = rootU; // Reduce the count of disjoint sets by 1 setCount--; } } boolean inSameSet(int u, int v) { return find(u) == find(v); } /* This is a verbosity method, it's not a part of the core algorithm, But it helps us provide more useful output. */ Set<Integer> getAnySet() { int aRoot = find(0); // Get one of the two roots Set<Integer> set = new HashSet<>(); for (int i = 0; i < parent.length; i++) { if (find(i) == aRoot) { set.add(i); } } return set; } } private static class Graph { private final List<Integer> nodes; private final List<int[]> edges; Graph(Collection<Integer> nodeSet, List<int[]> edges) { this.nodes = new ArrayList<>(nodeSet); this.edges = new ArrayList<>(); for (int[] e : edges) { this.edges.add(new int[] {e[0], e[1]}); } } Graph copy() { return new Graph(this.nodes, this.edges); } KargerOutput findMinCut() { DisjointSetUnion dsu = new DisjointSetUnion(nodes.size()); List<int[]> workingEdges = new ArrayList<>(edges); Random rand = new Random(); while (dsu.setCount > 2) { int[] e = workingEdges.get(rand.nextInt(workingEdges.size())); if (!dsu.inSameSet(e[0], e[1])) { dsu.union(e[0], e[1]); } } int cutEdges = 0; for (int[] e : edges) { if (!dsu.inSameSet(e[0], e[1])) { cutEdges++; } } return collectResult(dsu, cutEdges); } /* This is a verbosity method, it's not a part of the core algorithm, But it helps us provide more useful output. */ private KargerOutput collectResult(DisjointSetUnion dsu, int cutEdges) { Set<Integer> firstIndices = dsu.getAnySet(); Set<Integer> firstSet = new HashSet<>(); Set<Integer> secondSet = new HashSet<>(); for (int i = 0; i < nodes.size(); i++) { if (firstIndices.contains(i)) { firstSet.add(nodes.get(i)); } else { secondSet.add(nodes.get(i)); } } return new KargerOutput(firstSet, secondSet, cutEdges); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.ArrayList; import java.util.Collections; import java.util.Scanner; final class KeithNumber { private KeithNumber() { } public static void main(String[] object) { object = new Scanner(System.in); int n = ((Scanner)object).nextInt(); ArrayList<Integer> arrayList = new ArrayList<Integer>(); int n2 = n; int n3 = 0; while (n2 > 0) { arrayList.add(n2 % 10); n2 /= 10; ++n3; } Collections.reverse(arrayList); n2 = 0; int n4 = n3; while (n2 < n) { n2 = 0; for (int i = 1; i <= n3; ++i) { n2 += ((Integer)arrayList.get(n4 - i)).intValue(); } arrayList.add(n2); ++n4; } if (n2 == n) { System.out.println(\"Yes, the given number is a Keith number.\"); } else { System.out.println(\"No, the given number is not a Keith number.\"); } ((Scanner)object).close(); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; import java.util.Collections; import java.util.Scanner; final class KeithNumber { private KeithNumber() { } // user-defined function that checks if the given number is Keith or not static boolean isKeith(int x) { // List stores all the digits of the X ArrayList<Integer> terms = new ArrayList<>(); // n denotes the number of digits int temp = x; int n = 0; // executes until the condition becomes false while (temp > 0) { // determines the last digit of the number and add it to the List terms.add(temp % 10); // removes the last digit temp = temp / 10; // increments the number of digits (n) by 1 n++; } // reverse the List Collections.reverse(terms); int nextTerm = 0; int i = n; // finds next term for the series // loop executes until the condition returns true while (nextTerm < x) { nextTerm = 0; // next term is the sum of previous n terms (it depends on number of digits the number // has) for (int j = 1; j <= n; j++) { nextTerm = nextTerm + terms.get(i - j); } terms.add(nextTerm); i++; } // when the control comes out of the while loop, there will be two conditions: // either nextTerm will be equal to x or greater than x // if equal, the given number is Keith, else not return (nextTerm == x); } // driver code public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); if (isKeith(n)) { System.out.println(\"Yes, the given number is a Keith number.\"); } else { System.out.println(\"No, the given number is not a Keith number.\"); } in.close(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import java.util.Arrays; public final class Knapsack { private Knapsack() { } public static int knapSack(int n2, int[] nArray, int[] nArray2) { int[] nArray3 = nArray2; int[] nArray4 = nArray; int n3 = n2; if (n3 < 0) { throw new IllegalArgumentException(\"Weight capacity should not be negative.\"); } if (nArray4 == null || nArray3 == null || nArray4.length != nArray3.length) { throw new IllegalArgumentException(\"Input arrays must not be null and must have the same length.\"); } if (Arrays.stream(nArray4).anyMatch(n -> n <= 0)) { throw new IllegalArgumentException(\"Input array should not contain non-positive weight(s).\"); } int[] nArray5 = new int[n2 + 1]; for (int i = 0; i < nArray2.length; ++i) { for (int j = n2; j > 0; --j) { if (nArray[i] > j) continue; nArray5[j] = Math.max(nArray5[j], nArray5[j - nArray[i]] + nArray2[i]); } } return nArray5[n2]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.Arrays; /** * A Dynamic Programming based solution for the 0-1 Knapsack problem. * This class provides a method, `knapSack`, that calculates the maximum value that can be * obtained from a given set of items with weights and values, while not exceeding a * given weight capacity. * * @see <a href=\"https://en.wikipedia.org/?title=0-1_Knapsack_problem\">0-1 Knapsack Problem </a> */ public final class Knapsack { private Knapsack() { } private static void throwIfInvalidInput(final int weightCapacity, final int[] weights, final int[] values) { if (weightCapacity < 0) { throw new IllegalArgumentException(\"Weight capacity should not be negative.\"); } if (weights == null || values == null || weights.length != values.length) { throw new IllegalArgumentException(\"Input arrays must not be null and must have the same length.\"); } if (Arrays.stream(weights).anyMatch(w -> w <= 0)) { throw new IllegalArgumentException(\"Input array should not contain non-positive weight(s).\"); } } /** * Solves the 0-1 Knapsack problem using Dynamic Programming. * * @param weightCapacity The maximum weight capacity of the knapsack. * @param weights An array of item weights. * @param values An array of item values. * @return The maximum value that can be obtained without exceeding the weight capacity. * @throws IllegalArgumentException If the input arrays are null or have different lengths. */ public static int knapSack(final int weightCapacity, final int[] weights, final int[] values) throws IllegalArgumentException { throwIfInvalidInput(weightCapacity, weights, values); // DP table to store the state of the maximum possible return for a given weight capacity. int[] dp = new int[weightCapacity + 1]; for (int i = 0; i < values.length; i++) { for (int w = weightCapacity; w > 0; w--) { if (weights[i] <= w) { dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); } } } return dp[weightCapacity]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public class KnapsackMemoization { }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.Arrays; /** * Recursive Solution for 0-1 knapsack with memoization * This method is basically an extension to the recursive approach so that we * can overcome the problem of calculating redundant cases and thus increased * complexity. We can solve this problem by simply creating a 2-D array that can * store a particular state (n, w) if we get it the first time. */ public class KnapsackMemoization { int knapSack(int capacity, int[] weights, int[] profits, int numOfItems) { // Declare the table dynamically int[][] dpTable = new int[numOfItems + 1][capacity + 1]; // Loop to initially fill the table with -1 for (int[] table : dpTable) { Arrays.fill(table, -1); } return solveKnapsackRecursive(capacity, weights, profits, numOfItems, dpTable); } // Returns the value of maximum profit using recursive approach int solveKnapsackRecursive(int capacity, int[] weights, int[] profits, int numOfItems, int[][] dpTable) { // Base condition if (numOfItems == 0 || capacity == 0) { return 0; } if (dpTable[numOfItems][capacity] != -1) { return dpTable[numOfItems][capacity]; } if (weights[numOfItems - 1] > capacity) { // Store the value of function call stack in table dpTable[numOfItems][capacity] = solveKnapsackRecursive(capacity, weights, profits, numOfItems - 1, dpTable); } else { // case 1. include the item, if it is less than the capacity final int includeCurrentItem = profits[numOfItems - 1] + solveKnapsackRecursive(capacity - weights[numOfItems - 1], weights, profits, numOfItems - 1, dpTable); // case 2. exclude the item if it is more than the capacity final int excludeCurrentItem = solveKnapsackRecursive(capacity, weights, profits, numOfItems - 1, dpTable); // Store the value of function call stack in table and return dpTable[numOfItems][capacity] = Math.max(includeCurrentItem, excludeCurrentItem); } return dpTable[numOfItems][capacity]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class KnapsackZeroOne { private KnapsackZeroOne() { } public static int compute(int[] nArray, int[] nArray2, int n, int n2) { while (true) { if (nArray == null || nArray2 == null) { throw new IllegalArgumentException(\"Input arrays cannot be null.\"); } if (nArray.length != nArray2.length) { throw new IllegalArgumentException(\"Value and weight arrays must be of the same length.\"); } if (n < 0 || n2 < 0) { throw new IllegalArgumentException(\"Invalid input: arrays must be non-empty and capacity/n non-negative.\"); } if (n2 == 0 || n == 0 || nArray.length == 0) { return 0; } if (nArray2[n2 - 1] <= n) { int n3 = nArray[n2 - 1] + KnapsackZeroOne.compute(nArray, nArray2, n - nArray2[n2 - 1], n2 - 1); int n4 = KnapsackZeroOne.compute(nArray, nArray2, n, n2 - 1); return Math.max(n3, n4); } --n2; } } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * The {@code KnapsackZeroOne} provides Recursive solution for the 0/1 Knapsack * problem. Solves by exploring all combinations of items using recursion. No * memoization or dynamic programming optimizations are applied. * * Time Complexity: O(2^n)  explores all subsets. * Space Complexity: O(n)  due to recursive call stack. * * Problem Reference: https://en.wikipedia.org/wiki/Knapsack_problem */ public final class KnapsackZeroOne { private KnapsackZeroOne() { // Prevent instantiation } /** * Solves the 0/1 Knapsack problem using recursion. * * @param values the array containing values of the items * @param weights the array containing weights of the items * @param capacity the total capacity of the knapsack * @param n the number of items * @return the maximum total value achievable within the given weight limit * @throws IllegalArgumentException if input arrays are null, empty, or * lengths mismatch */ public static int compute(final int[] values, final int[] weights, final int capacity, final int n) { if (values == null || weights == null) { throw new IllegalArgumentException(\"Input arrays cannot be null.\"); } if (values.length != weights.length) { throw new IllegalArgumentException(\"Value and weight arrays must be of the same length.\"); } if (capacity < 0 || n < 0) { throw new IllegalArgumentException(\"Invalid input: arrays must be non-empty and capacity/n \" + \"non-negative.\"); } if (n == 0 || capacity == 0 || values.length == 0) { return 0; } if (weights[n - 1] <= capacity) { final int include = values[n - 1] + compute(values, weights, capacity - weights[n - 1], n - 1); final int exclude = compute(values, weights, capacity, n - 1); return Math.max(include, exclude); } else { return compute(values, weights, capacity, n - 1); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class KnapsackZeroOneTabulation { private KnapsackZeroOneTabulation() { } public static int compute(int[] nArray, int[] nArray2, int n, int n2) { if (nArray == null || nArray2 == null) { throw new IllegalArgumentException(\"Values and weights arrays must not be null.\"); } if (nArray.length != nArray2.length) { throw new IllegalArgumentException(\"Values and weights arrays must be non-null and of same length.\"); } if (n < 0) { throw new IllegalArgumentException(\"Capacity must not be negative.\"); } if (n2 < 0 || n2 > nArray.length) { throw new IllegalArgumentException(\"Item count must be between 0 and the length of the values array.\"); } int[][] nArray3 = new int[n2 + 1][n + 1]; for (int i = 1; i <= n2; ++i) { int n3 = nArray[i - 1]; int n4 = nArray2[i - 1]; for (int j = 1; j <= n; ++j) { if (n4 <= j) { int n5 = n3 + nArray3[i - 1][j - n4]; int n6 = nArray3[i - 1][j]; nArray3[i][j] = Math.max(n5, n6); continue; } nArray3[i][j] = nArray3[i - 1][j]; } } return nArray3[n2][n]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Tabulation (Bottom-Up) Solution for 0-1 Knapsack Problem. * This method uses dynamic programming to build up a solution iteratively, * filling a 2-D array where each entry dp[i][w] represents the maximum value * achievable with the first i items and a knapsack capacity of w. * * The tabulation approach is efficient because it avoids redundant calculations * by solving all subproblems in advance and storing their results, ensuring * each subproblem is solved only once. This is a key technique in dynamic programming, * making it possible to solve problems that would otherwise be infeasible due to * exponential time complexity in naive recursive solutions. * * Time Complexity: O(n * W), where n is the number of items and W is the knapsack capacity. * Space Complexity: O(n * W) for the DP table. * * For more information, see: * https://en.wikipedia.org/wiki/Knapsack_problem#Dynamic_programming */ public final class KnapsackZeroOneTabulation { private KnapsackZeroOneTabulation() { // Prevent instantiation } /** * Solves the 0-1 Knapsack problem using the bottom-up tabulation technique. * @param values the values of the items * @param weights the weights of the items * @param capacity the total capacity of the knapsack * @param itemCount the number of items * @return the maximum value that can be put in the knapsack * @throws IllegalArgumentException if input arrays are null, of different lengths,or if capacity or itemCount is invalid */ public static int compute(final int[] values, final int[] weights, final int capacity, final int itemCount) { if (values == null || weights == null) { throw new IllegalArgumentException(\"Values and weights arrays must not be null.\"); } if (values.length != weights.length) { throw new IllegalArgumentException(\"Values and weights arrays must be non-null and of same length.\"); } if (capacity < 0) { throw new IllegalArgumentException(\"Capacity must not be negative.\"); } if (itemCount < 0 || itemCount > values.length) { throw new IllegalArgumentException(\"Item count must be between 0 and the length of the values array.\"); } final int[][] dp = new int[itemCount + 1][capacity + 1]; for (int i = 1; i <= itemCount; i++) { final int currentValue = values[i - 1]; final int currentWeight = weights[i - 1]; for (int w = 1; w <= capacity; w++) { if (currentWeight <= w) { final int includeItem = currentValue + dp[i - 1][w - currentWeight]; final int excludeItem = dp[i - 1][w]; dp[i][w] = Math.max(includeItem, excludeItem); } else { dp[i][w] = dp[i - 1][w]; } } } return dp[itemCount][capacity]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; public final class KnightsTour { private static int[][] a; private KnightsTour() { } public static void resetBoard() { a = new int[12][12]; for (int i = 0; i < 12; ++i) { for (int j = 0; j < 12; ++j) { if (i >= 2 && i <= 9 && j >= 2 && j <= 9) continue; KnightsTour.a[i][j] = -1; } } } static { int[][] nArrayArray = new int[][]{{1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}}; } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.Comparator; import java.util.List; /** * The KnightsTour class solves the Knight's Tour problem using backtracking. * * Problem Statement: * Given an N*N board with a knight placed on the first block, the knight must * move according to chess rules and visit each square on the board exactly once. * The class outputs the sequence of moves for the knight. * * Example: * Input: N = 8 (8x8 chess board) * Output: The sequence of numbers representing the order in which the knight visits each square. */ public final class KnightsTour { private KnightsTour() { } // The size of the chess board (12x12 grid, with 2 extra rows/columns as a buffer around a 8x8 area) private static final int BASE = 12; // Possible moves for a knight in chess private static final int[][] MOVES = { {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, }; // Chess grid representing the board static int[][] grid; // Total number of cells the knight needs to visit static int total; /** * Resets the chess board to its initial state. * Initializes the grid with boundary cells marked as -1 and internal cells as 0. * Sets the total number of cells the knight needs to visit. */ public static void resetBoard() { grid = new int[BASE][BASE]; total = (BASE - 4) * (BASE - 4); for (int r = 0; r < BASE; r++) { for (int c = 0; c < BASE; c++) { if (r < 2 || r > BASE - 3 || c < 2 || c > BASE - 3) { grid[r][c] = -1; // Mark boundary cells } } } } /** * Recursive method to solve the Knight's Tour problem. * * @param row The current row of the knight * @param column The current column of the knight * @param count The current move number * @return True if a solution is found, False otherwise */ static boolean solve(int row, int column, int count) { if (count > total) { return true; } List<int[]> neighbor = neighbors(row, column); if (neighbor.isEmpty() && count != total) { return false; } // Sort neighbors by Warnsdorff's rule (fewest onward moves) neighbor.sort(Comparator.comparingInt(a -> a[2])); for (int[] nb : neighbor) { int nextRow = nb[0]; int nextCol = nb[1]; grid[nextRow][nextCol] = count; if (!orphanDetected(count, nextRow, nextCol) && solve(nextRow, nextCol, count + 1)) { return true; } grid[nextRow][nextCol] = 0; // Backtrack } return false; } /** * Returns a list of valid neighboring cells where the knight can move. * * @param row The current row of the knight * @param column The current column of the knight * @return A list of arrays representing valid moves, where each array contains: * {nextRow, nextCol, numberOfPossibleNextMoves} */ static List<int[]> neighbors(int row, int column) { List<int[]> neighbour = new ArrayList<>(); for (int[] m : MOVES) { int x = m[0]; int y = m[1]; if (row + y >= 0 && row + y < BASE && column + x >= 0 && column + x < BASE && grid[row + y][column + x] == 0) { int num = countNeighbors(row + y, column + x); neighbour.add(new int[] {row + y, column + x, num}); } } return neighbour; } /** * Counts the number of possible valid moves for a knight from a given position. * * @param row The row of the current position * @param column The column of the current position * @return The number of valid neighboring moves */ static int countNeighbors(int row, int column) { int num = 0; for (int[] m : MOVES) { int x = m[0]; int y = m[1]; if (row + y >= 0 && row + y < BASE && column + x >= 0 && column + x < BASE && grid[row + y][column + x] == 0) { num++; } } return num; } /** * Detects if moving to a given position will create an orphan (a position with no further valid moves). * * @param count The current move number * @param row The row of the current position * @param column The column of the current position * @return True if an orphan is detected, False otherwise */ static boolean orphanDetected(int count, int row, int column) { if (count < total - 1) { List<int[]> neighbor = neighbors(row, column); for (int[] nb : neighbor) { if (countNeighbors(nb[0], nb[1]) == 0) { return true; } } } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; class KochSnowflake$Vector2 { double a; double b; KochSnowflake$Vector2(double d, double d2) { this.a = d; this.b = d2; } public String toString() { return String.format(\"[%f, %f]\", this.a, this.b); } public KochSnowflake$Vector2 add(KochSnowflake$Vector2 kochSnowflake$Vector2) { double d = this.a + kochSnowflake$Vector2.a; double d2 = this.b + kochSnowflake$Vector2.b; return new KochSnowflake$Vector2(d, d2); } public KochSnowflake$Vector2 subtract(KochSnowflake$Vector2 kochSnowflake$Vector2) { double d = this.a - kochSnowflake$Vector2.a; double d2 = this.b - kochSnowflake$Vector2.b; return new KochSnowflake$Vector2(d, d2); } public KochSnowflake$Vector2 multiply(double d) { double d2 = this.a * d; double d3 = this.b * d; return new KochSnowflake$Vector2(d2, d3); } public KochSnowflake$Vector2 rotate(double d) { double d2 = d * Math.PI / 180.0; double d3 = Math.cos(d2); double d4 = Math.sin(d2); double d5 = d3 * this.a - d4 * this.b; double d6 = d4 * this.a + d3 * this.b; return new KochSnowflake$Vector2(d5, d6); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; class KochSnowflake$Vector2 { double a; double b; KochSnowflake$Vector2(double d, double d2) { this.a = d; this.b = d2; } public String toString() { return String.format(\"[%f, %f]\", this.a, this.b); } public KochSnowflake$Vector2 add(KochSnowflake$Vector2 kochSnowflake$Vector2) { double d = this.a + kochSnowflake$Vector2.a; double d2 = this.b + kochSnowflake$Vector2.b; return new KochSnowflake$Vector2(d, d2); } public KochSnowflake$Vector2 subtract(KochSnowflake$Vector2 kochSnowflake$Vector2) { double d = this.a - kochSnowflake$Vector2.a; double d2 = this.b - kochSnowflake$Vector2.b; return new KochSnowflake$Vector2(d, d2); } public KochSnowflake$Vector2 multiply(double d) { double d2 = this.a * d; double d3 = this.b * d; return new KochSnowflake$Vector2(d2, d3); } public KochSnowflake$Vector2 rotate(double d) { double d2 = d * Math.PI / 180.0; double d3 = Math.cos(d2); double d4 = Math.sin(d2); double d5 = d3 * this.a - d4 * this.b; double d6 = d4 * this.a + d3 * this.b; return new KochSnowflake$Vector2(d5, d6); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.KochSnowflake$Vector2; import java.awt.BasicStroke; import java.awt.Color; import java.awt.Graphics2D; import java.awt.image.BufferedImage; import java.awt.image.RenderedImage; import java.io.File; import java.io.IOException; import java.util.ArrayList; import javax.imageio.ImageIO; public final class KochSnowflake { private KochSnowflake() { } public static void main(String[] object) { object = new ArrayList<KochSnowflake$Vector2>(); ((ArrayList)object).add(new KochSnowflake$Vector2(0.0, 0.0)); ((ArrayList)object).add(new KochSnowflake$Vector2(1.0, 0.0)); object = KochSnowflake.iterate((ArrayList)object, 1); assert (((KochSnowflake$Vector2)((ArrayList)object).get((int)0)).a == 0.0); assert (((KochSnowflake$Vector2)((ArrayList)object).get((int)0)).b == 0.0); assert (((KochSnowflake$Vector2)((ArrayList)object).get((int)1)).a == 0.3333333333333333); assert (((KochSnowflake$Vector2)((ArrayList)object).get((int)1)).b == 0.0); assert (((KochSnowflake$Vector2)((ArrayList)object).get((int)2)).a == 0.5); assert (((KochSnowflake$Vector2)((ArrayList)object).get((int)2)).b == Math.sin(1.0471975511965976) / 3.0); assert (((KochSnowflake$Vector2)((ArrayList)object).get((int)3)).a == 0.6666666666666666); assert (((KochSnowflake$Vector2)((ArrayList)object).get((int)3)).b == 0.0); assert (((KochSnowflake$Vector2)((ArrayList)object).get((int)4)).a == 1.0); assert (((KochSnowflake$Vector2)((ArrayList)object).get((int)4)).b == 0.0); double cfr_ignored_0 = 600.0 / 10.0; double cfr_ignored_1 = 600.0 / 3.7; object = KochSnowflake.getKochSnowflake(600, 5); assert (((BufferedImage)object).getRGB(0, 0) == new Color(255, 255, 255).getRGB()); assert (((BufferedImage)object).getRGB(60, 162) == new Color(0, 0, 0).getRGB()); try { ImageIO.write((RenderedImage)object, \"png\", new File(\"KochSnowflake.png\")); return; } catch (IOException iOException) { object = iOException; iOException.printStackTrace(); return; } } public static ArrayList iterate(ArrayList arrayList, int n) { for (int i = 0; i < n; ++i) { ArrayList<KochSnowflake$Vector2> arrayList2 = new ArrayList<KochSnowflake$Vector2>(); for (int j = 0; j < arrayList.size() - 1; ++j) { KochSnowflake$Vector2 kochSnowflake$Vector2 = (KochSnowflake$Vector2)arrayList.get(j); KochSnowflake$Vector2 kochSnowflake$Vector22 = (KochSnowflake$Vector2)arrayList.get(j + 1); arrayList2.add(kochSnowflake$Vector2); kochSnowflake$Vector22 = kochSnowflake$Vector22.subtract(kochSnowflake$Vector2).multiply(0.3333333333333333); arrayList2.add(kochSnowflake$Vector2.add(kochSnowflake$Vector22)); arrayList2.add(kochSnowflake$Vector2.add(kochSnowflake$Vector22).add(kochSnowflake$Vector22.rotate(60.0))); arrayList2.add(kochSnowflake$Vector2.add(kochSnowflake$Vector22.multiply(2.0))); } ArrayList<KochSnowflake$Vector2> arrayList3 = arrayList; arrayList2.add((KochSnowflake$Vector2)arrayList3.get(arrayList3.size() - 1)); arrayList = arrayList2; } return arrayList; } public static BufferedImage getKochSnowflake(int n, int n2) { int n3; if (n <= 0) { throw new IllegalArgumentException(\"imageWidth should be greater than zero\"); } double d = (double)n / 10.0; double d2 = (double)n / 3.7; KochSnowflake$Vector2 kochSnowflake$Vector2 = new KochSnowflake$Vector2(d, d2); KochSnowflake$Vector2 kochSnowflake$Vector22 = new KochSnowflake$Vector2((double)n / 2.0, Math.sin(1.0471975511965976) * (double)n * 0.8 + d2); KochSnowflake$Vector2 kochSnowflake$Vector23 = new KochSnowflake$Vector2((double)n - d, d2); Object object = new ArrayList<KochSnowflake$Vector2>(); ((ArrayList)object).add(kochSnowflake$Vector2); ((ArrayList)object).add(kochSnowflake$Vector22); ((ArrayList)object).add(kochSnowflake$Vector23); ((ArrayList)object).add(kochSnowflake$Vector2); ArrayList arrayList = KochSnowflake.iterate(object, n2); int n4 = n3 = n; ArrayList arrayList2 = arrayList; object = new BufferedImage(n4, n3, 1); Graphics2D graphics2D = ((BufferedImage)object).createGraphics(); graphics2D.setBackground(Color.WHITE); graphics2D.fillRect(0, 0, n4, n3); graphics2D.setColor(Color.BLACK); BasicStroke basicStroke = new BasicStroke(1.0f); graphics2D.setStroke(basicStroke); for (int i = 0; i < arrayList2.size() - 1; ++i) { n3 = (int)((KochSnowflake$Vector2)arrayList2.get((int)i)).a; int n5 = (int)((KochSnowflake$Vector2)arrayList2.get((int)i)).b; int n6 = (int)((KochSnowflake$Vector2)arrayList2.get((int)(i + 1))).a; int n7 = (int)((KochSnowflake$Vector2)arrayList2.get((int)(i + 1))).b; graphics2D.drawLine(n3, n5, n6, n7); } return object; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.awt.BasicStroke; import java.awt.Color; import java.awt.Graphics2D; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.List; import javax.imageio.ImageIO; /** * The Koch snowflake is a fractal curve and one of the earliest fractals to * have been described. The Koch snowflake can be built up iteratively, in a * sequence of stages. The first stage is an equilateral triangle, and each * successive stage is formed by adding outward bends to each side of the * previous stage, making smaller equilateral triangles. This can be achieved * through the following steps for each line: 1. divide the line segment into * three segments of equal length. 2. draw an equilateral triangle that has the * middle segment from step 1 as its base and points outward. 3. remove the line * segment that is the base of the triangle from step 2. (description adapted * from https://en.wikipedia.org/wiki/Koch_snowflake ) (for a more detailed * explanation and an implementation in the Processing language, see * https://natureofcode.com/book/chapter-8-fractals/ * #84-the-koch-curve-and-the-arraylist-technique ). */ public final class KochSnowflake { private KochSnowflake() { } public static void main(String[] args) { // Test Iterate-method ArrayList<Vector2> vectors = new ArrayList<Vector2>(); vectors.add(new Vector2(0, 0)); vectors.add(new Vector2(1, 0)); ArrayList<Vector2> result = iterate(vectors, 1); assert result.get(0).x == 0; assert result.get(0).y == 0; assert result.get(1).x == 1. / 3; assert result.get(1).y == 0; assert result.get(2).x == 1. / 2; assert result.get(2).y == Math.sin(Math.PI / 3) / 3; assert result.get(3).x == 2. / 3; assert result.get(3).y == 0; assert result.get(4).x == 1; assert result.get(4).y == 0; // Test GetKochSnowflake-method int imageWidth = 600; double offsetX = imageWidth / 10.; double offsetY = imageWidth / 3.7; BufferedImage image = getKochSnowflake(imageWidth, 5); // The background should be white assert image.getRGB(0, 0) == new Color(255, 255, 255).getRGB(); // The snowflake is drawn in black and this is the position of the first vector assert image.getRGB((int) offsetX, (int) offsetY) == new Color(0, 0, 0).getRGB(); // Save image try { ImageIO.write(image, \"png\", new File(\"KochSnowflake.png\")); } catch (IOException e) { e.printStackTrace(); } } /** * Go through the number of iterations determined by the argument \"steps\". * Be careful with high values (above 5) since the time to calculate * increases exponentially. * * @param initialVectors The vectors composing the shape to which the * algorithm is applied. * @param steps The number of iterations. * @return The transformed vectors after the iteration-steps. */ public static ArrayList<Vector2> iterate(ArrayList<Vector2> initialVectors, int steps) { ArrayList<Vector2> vectors = initialVectors; for (int i = 0; i < steps; i++) { vectors = iterationStep(vectors); } return vectors; } /** * Method to render the Koch snowflake to a image. * * @param imageWidth The width of the rendered image. * @param steps The number of iterations. * @return The image of the rendered Koch snowflake. */ public static BufferedImage getKochSnowflake(int imageWidth, int steps) { if (imageWidth <= 0) { throw new IllegalArgumentException(\"imageWidth should be greater than zero\"); } double offsetX = imageWidth / 10.; double offsetY = imageWidth / 3.7; Vector2 vector1 = new Vector2(offsetX, offsetY); Vector2 vector2 = new Vector2(imageWidth / 2.0, Math.sin(Math.PI / 3.0) * imageWidth * 0.8 + offsetY); Vector2 vector3 = new Vector2(imageWidth - offsetX, offsetY); ArrayList<Vector2> initialVectors = new ArrayList<Vector2>(); initialVectors.add(vector1); initialVectors.add(vector2); initialVectors.add(vector3); initialVectors.add(vector1); ArrayList<Vector2> vectors = iterate(initialVectors, steps); return getImage(vectors, imageWidth, imageWidth); } /** * Loops through each pair of adjacent vectors. Each line between two * adjacent vectors is divided into 4 segments by adding 3 additional * vectors in-between the original two vectors. The vector in the middle is * constructed through a 60 degree rotation so it is bent outwards. * * @param vectors The vectors composing the shape to which the algorithm is * applied. * @return The transformed vectors after the iteration-step. */ private static ArrayList<Vector2> iterationStep(List<Vector2> vectors) { ArrayList<Vector2> newVectors = new ArrayList<Vector2>(); for (int i = 0; i < vectors.size() - 1; i++) { Vector2 startVector = vectors.get(i); Vector2 endVector = vectors.get(i + 1); newVectors.add(startVector); Vector2 differenceVector = endVector.subtract(startVector).multiply(1. / 3); newVectors.add(startVector.add(differenceVector)); newVectors.add(startVector.add(differenceVector).add(differenceVector.rotate(60))); newVectors.add(startVector.add(differenceVector.multiply(2))); } newVectors.add(vectors.get(vectors.size() - 1)); return newVectors; } /** * Utility-method to render the Koch snowflake to an image. * * @param vectors The vectors defining the edges to be rendered. * @param imageWidth The width of the rendered image. * @param imageHeight The height of the rendered image. * @return The image of the rendered edges. */ private static BufferedImage getImage(ArrayList<Vector2> vectors, int imageWidth, int imageHeight) { BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2d = image.createGraphics(); // Set the background white g2d.setBackground(Color.WHITE); g2d.fillRect(0, 0, imageWidth, imageHeight); // Draw the edges g2d.setColor(Color.BLACK); BasicStroke bs = new BasicStroke(1); g2d.setStroke(bs); for (int i = 0; i < vectors.size() - 1; i++) { int x1 = (int) vectors.get(i).x; int y1 = (int) vectors.get(i).y; int x2 = (int) vectors.get(i + 1).x; int y2 = (int) vectors.get(i + 1).y; g2d.drawLine(x1, y1, x2, y2); } return image; } /** * Inner class to handle the vector calculations. */ private static class Vector2 { double x; double y; Vector2(double x, double y) { this.x = x; this.y = y; } @Override public String toString() { return String.format(\"[%f, %f]\", this.x, this.y); } /** * Vector addition * * @param vector The vector to be added. * @return The sum-vector. */ public Vector2 add(Vector2 vector) { double x = this.x + vector.x; double y = this.y + vector.y; return new Vector2(x, y); } /** * Vector subtraction * * @param vector The vector to be subtracted. * @return The difference-vector. */ public Vector2 subtract(Vector2 vector) { double x = this.x - vector.x; double y = this.y - vector.y; return new Vector2(x, y); } /** * Vector scalar multiplication * * @param scalar The factor by which to multiply the vector. * @return The scaled vector. */ public Vector2 multiply(double scalar) { double x = this.x * scalar; double y = this.y * scalar; return new Vector2(x, y); } /** * Vector rotation (see https://en.wikipedia.org/wiki/Rotation_matrix) * * @param angleInDegrees The angle by which to rotate the vector. * @return The rotated vector. */ public Vector2 rotate(double angleInDegrees) { double radians = angleInDegrees * Math.PI / 180; double ca = Math.cos(radians); double sa = Math.sin(radians); double x = ca * this.x - sa * this.y; double y = sa * this.x + ca * this.y; return new Vector2(x, y); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.List; import java.util.Stack; public class Kosaraju { private final Stack a = new Stack(); private List b = new ArrayList(); private final List c = new ArrayList(); public List kosaraju(int n, List iterator) { int n2; Object object3 = iterator; int n3 = n; Kosaraju kosaraju = this; Object object2 = new int[n3]; for (n2 = 0; n2 < n3; ++n2) { if (object2[n2] != 0) continue; kosaraju.a(n2, (int[])object2, (List)object3); } List list = iterator; int n4 = n; object2 = new ArrayList(n4); for (n2 = 0; n2 < n4; ++n2) { object2.add(new ArrayList()); } for (n2 = 0; n2 < n4; ++n2) { for (Object object3 : (List)list.get(n2)) { ((List)object2.get((Integer)object3)).add(n2); } } iterator = object2; this.findStronglyConnectedComponents(n, (List)((Object)iterator)); return this.c; } public void findStronglyConnectedComponents(int n, List list) { int[] nArray = new int[n]; while (!this.a.isEmpty()) { int n2 = (Integer)this.a.pop(); if (nArray[n2] != 0) continue; this.b(n2, nArray, list); this.c.add(this.b); this.b = new ArrayList(); } } private void a(int n, int[] nArray, List list) { nArray[n] = 1; for (Integer n2 : (List)list.get(n)) { if (nArray[n2] != 0) continue; this.a(n2, nArray, list); } this.a.push(n); } private void b(int n, int[] nArray, List list) { nArray[n] = 1; for (Integer n2 : (List)list.get(n)) { if (nArray[n2] != 0) continue; this.b(n2, nArray, list); } this.b.add(n); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.List; import java.util.Stack; /** * This class implements the Kosaraju Algorithm to find all the Strongly Connected Components (SCCs) * of a directed graph. Kosaraju's algorithm runs in linear time and leverages the concept that * the SCCs of a directed graph remain the same in its transpose (reverse) graph. * * <p> * A strongly connected component (SCC) of a directed graph is a subgraph where every vertex * is reachable from every other vertex in the subgraph. The Kosaraju algorithm is particularly * efficient for finding SCCs because it performs two Depth First Search (DFS) passes on the * graph and its transpose. * </p> * * <p><strong>Algorithm:</strong></p> * <ol> * <li>Perform DFS on the original graph and push nodes to a stack in the order of their finishing time.</li> * <li>Generate the transpose (reversed edges) of the original graph.</li> * <li>Perform DFS on the transpose graph, using the stack from the first DFS. Each DFS run on the transpose graph gives a SCC.</li> * </ol> * * <p><strong>Example Graph:</strong></p> * <pre> * 0 <--- 2 -------> 3 -------- > 4 ---- > 7 * | ^ | ^ ^ * | / | \\ / * | / | \\ / * v / v \\ / * 1 5 --> 6 * </pre> * * <p><strong>SCCs in the example:</strong></p> * <ul> * <li>{0, 1, 2}</li> * <li>{3}</li> * <li>{4, 5, 6}</li> * <li>{7}</li> * </ul> * * <p>The order of nodes in an SCC does not matter because every node in an SCC is reachable from every other node within the same SCC.</p> * * <p><strong>Graph Transpose Example:</strong></p> * <pre> * 0 ---> 2 <------- 3 <------- 4 <------ 7 * ^ / ^ \\ / * | / | \\ / * | / | \\ / * | v | v v * 1 5 <--- 6 * </pre> * * The SCCs of this transpose graph are the same as the original graph. */ public class Kosaraju { // Stack to sort edges by the lowest finish time (used in the first DFS) private final Stack<Integer> stack = new Stack<>(); // Store each strongly connected component private List<Integer> scc = new ArrayList<>(); // List of all SCCs private final List<List<Integer>> sccsList = new ArrayList<>(); /** * Main function to perform Kosaraju's Algorithm. * Steps: * 1. Sort nodes by the lowest finishing time * 2. Create the transpose (reverse edges) of the original graph * 3. Find SCCs by performing DFS on the transpose graph * 4. Return the list of SCCs * * @param v the number of vertices in the graph * @param list the adjacency list representing the directed graph * @return a list of SCCs where each SCC is a list of vertices */ public List<List<Integer>> kosaraju(int v, List<List<Integer>> list) { sortEdgesByLowestFinishTime(v, list); List<List<Integer>> transposeGraph = createTransposeMatrix(v, list); findStronglyConnectedComponents(v, transposeGraph); return sccsList; } /** * Performs DFS on the original graph to sort nodes by their finishing times. * @param v the number of vertices in the graph * @param list the adjacency list representing the original graph */ private void sortEdgesByLowestFinishTime(int v, List<List<Integer>> list) { int[] vis = new int[v]; for (int i = 0; i < v; i++) { if (vis[i] == 0) { dfs(i, vis, list); } } } /** * Creates the transpose (reverse) of the original graph. * @param v the number of vertices in the graph * @param list the adjacency list representing the original graph * @return the adjacency list representing the transposed graph */ private List<List<Integer>> createTransposeMatrix(int v, List<List<Integer>> list) { List<List<Integer>> transposeGraph = new ArrayList<>(v); for (int i = 0; i < v; i++) { transposeGraph.add(new ArrayList<>()); } for (int i = 0; i < v; i++) { for (Integer neigh : list.get(i)) { transposeGraph.get(neigh).add(i); } } return transposeGraph; } /** * Finds the strongly connected components (SCCs) by performing DFS on the transposed graph. * @param v the number of vertices in the graph * @param transposeGraph the adjacency list representing the transposed graph */ public void findStronglyConnectedComponents(int v, List<List<Integer>> transposeGraph) { int[] vis = new int[v]; while (!stack.isEmpty()) { int node = stack.pop(); if (vis[node] == 0) { dfs2(node, vis, transposeGraph); sccsList.add(scc); scc = new ArrayList<>(); } } } /** * Performs DFS on the original graph and pushes nodes onto the stack in order of their finish time. * @param node the current node being visited * @param vis array to keep track of visited nodes * @param list the adjacency list of the graph */ private void dfs(int node, int[] vis, List<List<Integer>> list) { vis[node] = 1; for (Integer neighbour : list.get(node)) { if (vis[neighbour] == 0) { dfs(neighbour, vis, list); } } stack.push(node); } /** * Performs DFS on the transposed graph to find the strongly connected components. * @param node the current node being visited * @param vis array to keep track of visited nodes * @param list the adjacency list of the transposed graph */ private void dfs2(int node, int[] vis, List<List<Integer>> list) { vis[node] = 1; for (Integer neighbour : list.get(node)) { if (vis[neighbour] == 0) { dfs2(neighbour, vis, list); } } scc.add(node); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Scanner; final class Krishnamurthy { private Krishnamurthy() { } public static void main(String[] object) { int n; object = new Scanner(System.in); int n2 = 0; System.out.print(\"Enter the number : \"); int n3 = n = ((Scanner)object).nextInt(); while (n > 0) { int n4 = n % 10; int n5 = n2; n2 = 1; while (n4 > 0) { n2 *= n4; --n4; } n2 = n5 + n2; n /= 10; } if (n2 == n3) { System.out.print(n3 + \" is a krishnamurthy number\"); } else { System.out.print(n3 + \" is not a krishnamurthy number\"); } ((Scanner)object).close(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Scanner; final class Krishnamurthy { private Krishnamurthy() { } static int fact(int n) { int i; int p = 1; for (i = n; i >= 1; i--) { p = p * i; } return p; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a; int b; int s = 0; System.out.print(\"Enter the number : \"); a = sc.nextInt(); int n = a; while (a > 0) { b = a % 10; s = s + fact(b); a = a / 10; } if (s == n) { System.out.print(n + \" is a krishnamurthy number\"); } else { System.out.print(n + \" is not a krishnamurthy number\"); } sc.close(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class KrishnamurthyNumber { private KrishnamurthyNumber() { } public static boolean isKrishnamurthy(int n) { int n2 = n; int n3 = 0; if (n <= 0) { return false; } while (n != 0) { int n4 = 1; for (int i = 1; i <= n % 10; ++i) { n4 *= i; } n3 += n4; n /= 10; } return n2 == n3; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Utility class for checking if a number is a Krishnamurthy number. * * A Krishnamurthy number (also known as a Strong number) is a number whose sum of the factorials of its digits is equal to the number itself. * * For example, 145 is a Krishnamurthy number because 1! + 4! + 5! = 1 + 24 + 120 = 145. * <b>Example usage:</b> * <pre> * boolean isKrishnamurthy = KrishnamurthyNumber.isKrishnamurthy(145); * System.out.println(isKrishnamurthy); // Output: true * * isKrishnamurthy = KrishnamurthyNumber.isKrishnamurthy(123); * System.out.println(isKrishnamurthy); // Output: false * </pre> */ public final class KrishnamurthyNumber { private KrishnamurthyNumber() { } /** * Checks if a number is a Krishnamurthy number. * * @param n The number to check * @return true if the number is a Krishnamurthy number, false otherwise */ public static boolean isKrishnamurthy(int n) { int tmp = n; int s = 0; if (n <= 0) { return false; } else { while (n != 0) { // initialising the variable fact that will store the factorials of the digits int fact = 1; // computing factorial of each digit for (int i = 1; i <= n % 10; i++) { fact = fact * i; } // computing the sum of the factorials s = s + fact; // discarding the digit for which factorial has been calculated n = n / 10; } // evaluating if sum of the factorials of the digits equals the number itself return tmp == s; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class Kruskal$Edge { int a; int b; int c; Kruskal$Edge(int n, int n2, int n3) { this.a = n; this.b = n2; this.c = n3; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; class Kruskal$Edge { int a; int b; int c; Kruskal$Edge(int n, int n2, int n3) { this.a = n; this.b = n2; this.c = n3; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.Kruskal$Edge; import java.util.Comparator; import java.util.HashSet; import java.util.PriorityQueue; public class Kruskal { public HashSet[] kruskal(HashSet[] object) { int n; int n2 = ((HashSet[])object).length; int[] nArray = new int[n2]; HashSet[] hashSetArray = new HashSet[n2]; HashSet[] hashSetArray2 = new HashSet[n2]; PriorityQueue<Kruskal$Edge> priorityQueue = new PriorityQueue<Kruskal$Edge>(Comparator.comparingInt(kruskal$Edge -> kruskal$Edge.c)); for (n = 0; n < n2; ++n) { hashSetArray2[n] = new HashSet(); hashSetArray[n] = new HashSet(); hashSetArray[n].add(n); int n3 = n; nArray[n3] = n3; priorityQueue.addAll(object[n]); } n = 0; while (n != n2 && !priorityQueue.isEmpty()) { object = priorityQueue.poll(); if (hashSetArray[nArray[object.a]].contains(object.b) || hashSetArray[nArray[object.b]].contains(object.a)) continue; hashSetArray[nArray[object.a]].addAll(hashSetArray[nArray[object.b]]); hashSetArray[nArray[object.a]].forEach(arg_0 -> Kruskal.a(nArray, (Kruskal$Edge)object, arg_0)); int n4 = object.c; int n5 = object.b; int n6 = object.a; HashSet[] hashSetArray3 = hashSetArray2; hashSetArray2[n6].add(new Kruskal$Edge(n6, n5, n4)); n = hashSetArray[nArray[object.a]].size(); } return hashSetArray2; } private static /* synthetic */ void a(int[] nArray, Kruskal$Edge kruskal$Edge, Integer n) { nArray[n.intValue()] = nArray[kruskal$Edge.a]; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.Comparator; import java.util.HashSet; import java.util.PriorityQueue; /** * The Kruskal class implements Kruskal's Algorithm to find the Minimum Spanning Tree (MST) * of a connected, undirected graph. The algorithm constructs the MST by selecting edges * with the least weight, ensuring no cycles are formed, and using union-find to track the * connected components. * * <p><strong>Key Features:</strong></p> * <ul> * <li>The graph is represented using an adjacency list, where each node points to a set of edges.</li> * <li>Each edge is processed in ascending order of weight using a priority queue.</li> * <li>The algorithm stops when all nodes are connected or no more edges are available.</li> * </ul> * * <p><strong>Time Complexity:</strong> O(E log V), where E is the number of edges and V is the number of vertices.</p> */ @SuppressWarnings({\"rawtypes\", \"unchecked\"}) public class Kruskal { /** * Represents an edge in the graph with a source, destination, and weight. */ static class Edge { int from; int to; int weight; Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } } /** * Adds an edge to the graph. * * @param graph the adjacency list representing the graph * @param from the source vertex of the edge * @param to the destination vertex of the edge * @param weight the weight of the edge */ static void addEdge(HashSet<Edge>[] graph, int from, int to, int weight) { graph[from].add(new Edge(from, to, weight)); } /** * Kruskal's algorithm to find the Minimum Spanning Tree (MST) of a graph. * * @param graph the adjacency list representing the input graph * @return the adjacency list representing the MST */ public HashSet<Edge>[] kruskal(HashSet<Edge>[] graph) { int nodes = graph.length; int[] captain = new int[nodes]; // Stores the \"leader\" of each node's connected component HashSet<Integer>[] connectedGroups = new HashSet[nodes]; HashSet<Edge>[] minGraph = new HashSet[nodes]; PriorityQueue<Edge> edges = new PriorityQueue<>(Comparator.comparingInt(edge -> edge.weight)); for (int i = 0; i < nodes; i++) { minGraph[i] = new HashSet<>(); connectedGroups[i] = new HashSet<>(); connectedGroups[i].add(i); captain[i] = i; edges.addAll(graph[i]); } int connectedElements = 0; while (connectedElements != nodes && !edges.isEmpty()) { Edge edge = edges.poll(); // Avoid forming cycles by checking if the nodes belong to different connected components if (!connectedGroups[captain[edge.from]].contains(edge.to) && !connectedGroups[captain[edge.to]].contains(edge.from)) { // Merge the two sets of nodes connected by the edge connectedGroups[captain[edge.from]].addAll(connectedGroups[captain[edge.to]]); // Update the captain for each merged node connectedGroups[captain[edge.from]].forEach(i -> captain[i] = captain[edge.from]); // Add the edge to the resulting MST graph addEdge(minGraph, edge.from, edge.to, edge.weight); // Update the count of connected nodes connectedElements = connectedGroups[captain[edge.from]].size(); } } return minGraph; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import java.util.PriorityQueue; public final class KthElementFinder { private KthElementFinder() { } public static int findKthLargest(int[] nArray, int n) { PriorityQueue<Integer> priorityQueue = new PriorityQueue<Integer>(n); for (int n2 : nArray) { priorityQueue.offer(n2); if (priorityQueue.size() <= n) continue; priorityQueue.poll(); } return (Integer)priorityQueue.peek(); } public static int findKthSmallest(int[] nArray, int n3) { PriorityQueue<Integer> priorityQueue = new PriorityQueue<Integer>((n, n2) -> n2 - n); for (int n4 : nArray) { priorityQueue.offer(n4); if (priorityQueue.size() <= n3) continue; priorityQueue.poll(); } return (Integer)priorityQueue.peek(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; import java.util.PriorityQueue; /** * This class provides methods to find the Kth largest or Kth smallest element * in an array using heaps. It leverages a min-heap to find the Kth largest element * and a max-heap to find the Kth smallest element efficiently. * * @author Hardvan */ public final class KthElementFinder { private KthElementFinder() { } /** * Finds the Kth largest element in the given array. * Uses a min-heap of size K to track the largest K elements. * * Time Complexity: O(n * log(k)), where n is the size of the input array. * Space Complexity: O(k), as we maintain a heap of size K. * * @param nums the input array of integers * @param k the desired Kth position (1-indexed, i.e., 1 means the largest element) * @return the Kth largest element in the array */ public static int findKthLargest(int[] nums, int k) { PriorityQueue<Integer> minHeap = new PriorityQueue<>(k); for (int num : nums) { minHeap.offer(num); if (minHeap.size() > k) { minHeap.poll(); } } return minHeap.peek(); } /** * Finds the Kth smallest element in the given array. * Uses a max-heap of size K to track the smallest K elements. * * Time Complexity: O(n * log(k)), where n is the size of the input array. * Space Complexity: O(k), as we maintain a heap of size K. * * @param nums the input array of integers * @param k the desired Kth position (1-indexed, i.e., 1 means the smallest element) * @return the Kth smallest element in the array */ public static int findKthSmallest(int[] nums, int k) { PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); for (int num : nums) { maxHeap.offer(num); if (maxHeap.size() > k) { maxHeap.poll(); } } return maxHeap.peek(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import java.util.ArrayList; import java.util.Iterator; import java.util.Scanner; public final class LCA { private static final Scanner a = new Scanner(System.in); private LCA() { } public static void main(String[] object) { int n; int n2; object = new ArrayList(); int n3 = a.nextInt(); int n4 = n3 - 1; for (n2 = 0; n2 < n3; ++n2) { ((ArrayList)object).add(new ArrayList()); } for (int i = 0; i < n4; ++i) { n2 = a.nextInt(); n = a.nextInt(); ((ArrayList)((ArrayList)object).get(n2)).add(n); ((ArrayList)((ArrayList)object).get(n)).add(n2); } int[] nArray = new int[n3]; int[] nArray2 = new int[n3]; LCA.a((ArrayList)object, 0, -1, nArray, nArray2); int n5 = a.nextInt(); n4 = a.nextInt(); int[] nArray3 = nArray; int[] nArray4 = nArray2; int n6 = n4; if (nArray4[n5] < nArray4[n6]) { n = n5; n5 = n6; n6 = n; } while (nArray4[n5] != nArray4[n6]) { n5 = nArray3[n5]; } if (n5 != n6) { while (n5 != n6) { n5 = nArray3[n5]; n6 = nArray3[n6]; } } System.out.println(n5); } private static void a(ArrayList arrayList, int n, int n2, int[] nArray, int[] nArray2) { Iterator iterator = ((ArrayList)arrayList.get(n)).iterator(); while (iterator.hasNext()) { int n3 = (Integer)iterator.next(); if (n3 == n2) continue; nArray[n3] = n; nArray2[n3] = 1 + nArray2[n]; LCA.a(arrayList, n3, n, nArray, nArray2); } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayList; import java.util.Scanner; public final class LCA { private LCA() { } private static final Scanner SCANNER = new Scanner(System.in); public static void main(String[] args) { // The adjacency list representation of a tree: ArrayList<ArrayList<Integer>> adj = new ArrayList<>(); // v is the number of vertices and e is the number of edges int v = SCANNER.nextInt(); int e = v - 1; for (int i = 0; i < v; i++) { adj.add(new ArrayList<Integer>()); } // Storing the given tree as an adjacency list int to; int from; for (int i = 0; i < e; i++) { to = SCANNER.nextInt(); from = SCANNER.nextInt(); adj.get(to).add(from); adj.get(from).add(to); } // parent[v1] gives parent of a vertex v1 int[] parent = new int[v]; // depth[v1] gives depth of vertex v1 with respect to the root int[] depth = new int[v]; // Assuming the tree to be rooted at 0, hence calculating parent and depth of every vertex dfs(adj, 0, -1, parent, depth); // Inputting the two vertices whose LCA is to be calculated int v1 = SCANNER.nextInt(); int v2 = SCANNER.nextInt(); // Outputting the LCA System.out.println(getLCA(v1, v2, depth, parent)); } /** * Depth first search to calculate parent and depth of every vertex * * @param adj The adjacency list representation of the tree * @param s The source vertex * @param p Parent of source * @param parent An array to store parents of all vertices * @param depth An array to store depth of all vertices */ private static void dfs(ArrayList<ArrayList<Integer>> adj, int s, int p, int[] parent, int[] depth) { for (int adjacent : adj.get(s)) { if (adjacent != p) { parent[adjacent] = s; depth[adjacent] = 1 + depth[s]; dfs(adj, adjacent, s, parent, depth); } } } /** * Method to calculate Lowest Common Ancestor * * @param v1 The first vertex * @param v2 The second vertex * @param depth An array with depths of all vertices * @param parent An array with parents of all vertices * @return Returns a vertex that is LCA of v1 and v2 */ private static int getLCA(int v1, int v2, int[] depth, int[] parent) { if (depth[v1] < depth[v2]) { int temp = v1; v1 = v2; v2 = temp; } while (depth[v1] != depth[v2]) { v1 = parent[v1]; } if (v1 == v2) { return v1; } while (v1 != v2) { v1 = parent[v1]; v2 = parent[v2]; } return v1; } } /* * Input: * 10 * 0 1 * 0 2 * 1 5 * 5 6 * 2 4 * 2 3 * 3 7 * 7 9 * 7 8 * 9 4 * Output: * 2 */"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers.a5; import com.thealgorithms.ciphers.a5.BaseLFSR; import java.util.BitSet; public class LFSR implements BaseLFSR { private final BitSet a; private final int b; private final int c; private final int[] d; public LFSR(int n, int n2, int[] nArray) { this.b = n; this.c = n2; this.d = nArray; this.a = new BitSet(n); } @Override public void initialize(BitSet bitSet, BitSet bitSet2) { this.a.clear(); this.a(bitSet, 64); this.a(bitSet2, 22); } private void a(BitSet bitSet, int n) { --n; while (n >= 0) { boolean bl = bitSet.get(n) ^ this.a(); this.a(bl); --n; } } @Override public boolean clock() { LFSR lFSR = this; return lFSR.a(lFSR.a()); } public boolean getClockBit() { return this.a.get(this.c); } public boolean get(int n) { return this.a.get(n); } public boolean getLastBit() { return this.a.get(this.b - 1); } private boolean a() { boolean bl = false; int[] nArray = this.d; int n = this.d.length; for (int i = 0; i < n; ++i) { int n2 = nArray[i]; bl ^= this.a.get(n2); } return bl; } private boolean a(boolean bl) { boolean bl2 = this.b(); this.a.set(0, bl); return bl2; } private boolean b() { LFSR lFSR = this; boolean bl = lFSR.get(lFSR.b - 1); for (int i = this.b - 1; i > 0; --i) { this.a.set(i, this.get(i - 1)); } this.a.set(0, false); return bl; } public String toString() { return this.a.toString(); } }", "deobfuscated_code": "package com.thealgorithms.ciphers.a5; import java.util.BitSet; public class LFSR implements BaseLFSR { private final BitSet register; private final int length; private final int clockBitIndex; private final int[] tappingBitsIndices; public LFSR(int length, int clockBitIndex, int[] tappingBitsIndices) { this.length = length; this.clockBitIndex = clockBitIndex; this.tappingBitsIndices = tappingBitsIndices; register = new BitSet(length); } @Override public void initialize(BitSet sessionKey, BitSet frameCounter) { register.clear(); clock(sessionKey, SESSION_KEY_LENGTH); clock(frameCounter, FRAME_COUNTER_LENGTH); } private void clock(BitSet key, int keyLength) { // We start from reverse because LFSR 0 index is the left most bit // while key 0 index is right most bit, so we reverse it for (int i = keyLength - 1; i >= 0; --i) { var newBit = key.get(i) ^ xorTappingBits(); pushBit(newBit); } } @Override public boolean clock() { return pushBit(xorTappingBits()); } public boolean getClockBit() { return register.get(clockBitIndex); } public boolean get(int bitIndex) { return register.get(bitIndex); } public boolean getLastBit() { return register.get(length - 1); } private boolean xorTappingBits() { boolean result = false; for (int i : tappingBitsIndices) { result ^= register.get(i); } return result; } private boolean pushBit(boolean bit) { boolean discardedBit = rightShift(); register.set(0, bit); return discardedBit; } private boolean rightShift() { boolean discardedBit = get(length - 1); for (int i = length - 1; i > 0; --i) { register.set(i, get(i - 1)); } register.set(0, false); return discardedBit; } @Override public String toString() { return register.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; class LFUCache$Node { private final Object a; private Object b; private int c; private LFUCache$Node d; private LFUCache$Node e; LFUCache$Node(Object object, Object object2, int n) { this.a = object; this.b = object2; this.c = 1; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; class LFUCache$Node { private final Object a; private Object b; private int c; private LFUCache$Node d; private LFUCache$Node e; LFUCache$Node(Object object, Object object2, int n) { this.a = object; this.b = object2; this.c = 1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LFUCache$Node; import java.util.HashMap; import java.util.Map; public class LFUCache { private LFUCache$Node a; private LFUCache$Node b; private final Map c; private final int d; public LFUCache() { this(100); } public LFUCache(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Capacity must be greater than zero.\"); } this.d = n; this.c = new HashMap(); } public Object get(Object object) { if ((object = (LFUCache$Node)this.c.get(object)) == null) { return null; } this.b((LFUCache$Node)object); ++((LFUCache$Node)object).c; this.a((LFUCache$Node)object); return ((LFUCache$Node)object).b; } public void put(Object object, Object object2) { if (this.c.containsKey(object)) { LFUCache$Node lFUCache$Node = (LFUCache$Node)this.c.get(object); ((LFUCache$Node)this.c.get(object)).b = object2; ++lFUCache$Node.c; this.b(lFUCache$Node); this.a(lFUCache$Node); return; } if (this.c.size() >= this.d) { this.c.remove(this.a.a); LFUCache lFUCache = this; lFUCache.b(lFUCache.a); } LFUCache$Node lFUCache$Node = new LFUCache$Node(object, object2, 1); this.a(lFUCache$Node); this.c.put(object, lFUCache$Node); } private void a(LFUCache$Node lFUCache$Node) { block5: { if (this.b != null && this.a != null) { LFUCache$Node lFUCache$Node2 = this.a; while (lFUCache$Node2 != null) { if (lFUCache$Node2.c > lFUCache$Node.c) { if (lFUCache$Node2 == this.a) { lFUCache$Node.e = lFUCache$Node2; lFUCache$Node2.d = lFUCache$Node; this.a = lFUCache$Node; } else { lFUCache$Node.e = lFUCache$Node2; lFUCache$Node.d = lFUCache$Node2.d; lFUCache$Node2.d.e = lFUCache$Node; lFUCache$Node2.d = lFUCache$Node; } break block5; } lFUCache$Node2 = lFUCache$Node2.e; if (lFUCache$Node2 != null) continue; this.b.e = lFUCache$Node; lFUCache$Node.d = this.b; lFUCache$Node.e = null; this.b = lFUCache$Node; break; } return; } this.a = this.b = lFUCache$Node; } } private void b(LFUCache$Node lFUCache$Node) { if (lFUCache$Node.d != null) { lFUCache$Node.d.e = lFUCache$Node.e; } else { this.a = lFUCache$Node.e; } if (lFUCache$Node.e != null) { lFUCache$Node.e.d = lFUCache$Node.d; return; } this.b = lFUCache$Node.d; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.caches; import java.util.HashMap; import java.util.Map; /** * The {@code LFUCache} class implements a Least Frequently Used (LFU) cache. * An LFU cache evicts the least frequently used item when the cache reaches its capacity. * It maintains a mapping of keys to nodes, where each node contains the key, its associated value, * and a frequency count that tracks how many times the item has been accessed. A doubly linked list * is used to efficiently manage the ordering of items based on their usage frequency. * * <p>This implementation is designed to provide O(1) time complexity for both the {@code get} and * {@code put} operations, which is achieved through the use of a hashmap for quick access and a * doubly linked list for maintaining the order of item frequencies.</p> * * <p> * Reference: <a href=\"https://en.wikipedia.org/wiki/Least_frequently_used\">LFU Cache - Wikipedia</a> * </p> * * @param <K> The type of keys maintained by this cache. * @param <V> The type of mapped values. * * @author Akshay Dubey (https://github.com/itsAkshayDubey) */ public class LFUCache<K, V> { /** * The {@code Node} class represents an element in the LFU cache. * Each node contains a key, a value, and a frequency count. * It also has pointers to the previous and next nodes in the doubly linked list. */ private class Node { private final K key; private V value; private int frequency; private Node previous; private Node next; /** * Constructs a new {@code Node} with the specified key, value, and frequency. * * @param key The key associated with this node. * @param value The value stored in this node. * @param frequency The frequency of usage of this node. */ Node(K key, V value, int frequency) { this.key = key; this.value = value; this.frequency = frequency; } } private Node head; private Node tail; private final Map<K, Node> cache; private final int capacity; private static final int DEFAULT_CAPACITY = 100; /** * Constructs an LFU cache with the default capacity. */ public LFUCache() { this(DEFAULT_CAPACITY); } /** * Constructs an LFU cache with the specified capacity. * * @param capacity The maximum number of items that the cache can hold. * @throws IllegalArgumentException if the specified capacity is less than or equal to zero. */ public LFUCache(int capacity) { if (capacity <= 0) { throw new IllegalArgumentException(\"Capacity must be greater than zero.\"); } this.capacity = capacity; this.cache = new HashMap<>(); } /** * Retrieves the value associated with the given key from the cache. * If the key exists, the node's frequency is incremented, and the node is repositioned * in the linked list based on its updated frequency. * * @param key The key whose associated value is to be returned. * @return The value associated with the key, or {@code null} if the key is not present in the cache. */ public V get(K key) { Node node = cache.get(key); if (node == null) { return null; } removeNode(node); node.frequency += 1; addNodeWithUpdatedFrequency(node); return node.value; } /** * Inserts or updates a key-value pair in the cache. * If the key already exists, the value is updated and its frequency is incremented. * If the cache is full, the least frequently used item is removed before inserting the new item. * * @param key The key associated with the value to be inserted or updated. * @param value The value to be inserted or updated. */ public void put(K key, V value) { if (cache.containsKey(key)) { Node node = cache.get(key); node.value = value; node.frequency += 1; removeNode(node); addNodeWithUpdatedFrequency(node); } else { if (cache.size() >= capacity) { cache.remove(this.head.key); // Evict least frequently used item removeNode(head); } Node node = new Node(key, value, 1); addNodeWithUpdatedFrequency(node); cache.put(key, node); } } /** * Adds a node to the linked list in the correct position based on its frequency. * The linked list is ordered by frequency, with the least frequently used node at the head. * * @param node The node to be inserted into the list. */ private void addNodeWithUpdatedFrequency(Node node) { if (tail != null && head != null) { Node temp = this.head; while (temp != null) { if (temp.frequency > node.frequency) { if (temp == head) { node.next = temp; temp.previous = node; this.head = node; break; } else { node.next = temp; node.previous = temp.previous; temp.previous.next = node; temp.previous = node; break; } } else { temp = temp.next; if (temp == null) { tail.next = node; node.previous = tail; node.next = null; tail = node; break; } } } } else { tail = node; head = tail; } } /** * Removes a node from the doubly linked list. * This method ensures that the pointers of neighboring nodes are properly updated. * * @param node The node to be removed from the list. */ private void removeNode(Node node) { if (node.previous != null) { node.previous.next = node.next; } else { this.head = node.next; } if (node.next != null) { node.next.previous = node.previous; } else { this.tail = node.previous; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LIFOCache; import com.thealgorithms.datastructures.caches.LIFOCache$EvictionStrategy; import com.thealgorithms.datastructures.caches.LIFOCache$ImmediateEvictionStrategy; import java.util.function.BiConsumer; public class LIFOCache$Builder { private final int a; private long b = 0L; private BiConsumer c; private LIFOCache$EvictionStrategy d = new LIFOCache$ImmediateEvictionStrategy(); public LIFOCache$Builder(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Capacity must be > 0\"); } this.a = n; } public LIFOCache$Builder defaultTTL(long l) { if (l < 0L) { throw new IllegalArgumentException(\"Default TTL must be >= 0\"); } this.b = l; return this; } public LIFOCache$Builder evictionListener(BiConsumer biConsumer) { if (biConsumer == null) { throw new IllegalArgumentException(\"Listener must not be null\"); } this.c = biConsumer; return this; } public LIFOCache build() { return new LIFOCache(this); } public LIFOCache$Builder evictionStrategy(LIFOCache$EvictionStrategy lIFOCache$EvictionStrategy) { if (lIFOCache$EvictionStrategy == null) { throw new IllegalArgumentException(\"Eviction strategy must not be null\"); } this.d = lIFOCache$EvictionStrategy; return this; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LIFOCache; import com.thealgorithms.datastructures.caches.LIFOCache$EvictionStrategy; import com.thealgorithms.datastructures.caches.LIFOCache$ImmediateEvictionStrategy; import java.util.function.BiConsumer; public class LIFOCache$Builder { private final int a; private long b = 0L; private BiConsumer c; private LIFOCache$EvictionStrategy d = new LIFOCache$ImmediateEvictionStrategy(); public LIFOCache$Builder(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Capacity must be > 0\"); } this.a = n; } public LIFOCache$Builder defaultTTL(long l) { if (l < 0L) { throw new IllegalArgumentException(\"Default TTL must be >= 0\"); } this.b = l; return this; } public LIFOCache$Builder evictionListener(BiConsumer biConsumer) { if (biConsumer == null) { throw new IllegalArgumentException(\"Listener must not be null\"); } this.c = biConsumer; return this; } public LIFOCache build() { return new LIFOCache(this); } public LIFOCache$Builder evictionStrategy(LIFOCache$EvictionStrategy lIFOCache$EvictionStrategy) { if (lIFOCache$EvictionStrategy == null) { throw new IllegalArgumentException(\"Eviction strategy must not be null\"); } this.d = lIFOCache$EvictionStrategy; return this; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; class LIFOCache$CacheEntry { Object a; private long b; LIFOCache$CacheEntry(Object object, long l) { this.a = object; if (l == 0L) { this.b = Long.MAX_VALUE; return; } this.b = System.currentTimeMillis() + l; } final boolean a() { return System.currentTimeMillis() > this.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; class LIFOCache$CacheEntry { Object a; private long b; LIFOCache$CacheEntry(Object object, long l) { this.a = object; if (l == 0L) { this.b = Long.MAX_VALUE; return; } this.b = System.currentTimeMillis() + l; } final boolean a() { return System.currentTimeMillis() > this.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LIFOCache; public interface LIFOCache$EvictionStrategy { public int onAccess(LIFOCache var1); }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LIFOCache; public interface LIFOCache$EvictionStrategy { public int onAccess(LIFOCache var1); }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LIFOCache; import com.thealgorithms.datastructures.caches.LIFOCache$EvictionStrategy; public class LIFOCache$ImmediateEvictionStrategy implements LIFOCache$EvictionStrategy { @Override public int onAccess(LIFOCache lIFOCache) { return lIFOCache.a(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LIFOCache; import com.thealgorithms.datastructures.caches.LIFOCache$EvictionStrategy; public class LIFOCache$ImmediateEvictionStrategy implements LIFOCache$EvictionStrategy { @Override public int onAccess(LIFOCache lIFOCache) { return lIFOCache.a(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LIFOCache; import com.thealgorithms.datastructures.caches.LIFOCache$EvictionStrategy; import java.util.concurrent.atomic.AtomicInteger; public class LIFOCache$PeriodicEvictionStrategy implements LIFOCache$EvictionStrategy { private final int a; private final AtomicInteger b = new AtomicInteger(); public LIFOCache$PeriodicEvictionStrategy(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Interval must be > 0\"); } this.a = n; } @Override public int onAccess(LIFOCache lIFOCache) { if (this.b.incrementAndGet() % this.a == 0) { return lIFOCache.a(); } return 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LIFOCache; import com.thealgorithms.datastructures.caches.LIFOCache$EvictionStrategy; import java.util.concurrent.atomic.AtomicInteger; public class LIFOCache$PeriodicEvictionStrategy implements LIFOCache$EvictionStrategy { private final int a; private final AtomicInteger b = new AtomicInteger(); public LIFOCache$PeriodicEvictionStrategy(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Interval must be > 0\"); } this.a = n; } @Override public int onAccess(LIFOCache lIFOCache) { if (this.b.incrementAndGet() % this.a == 0) { return lIFOCache.a(); } return 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LIFOCache$Builder; import com.thealgorithms.datastructures.caches.LIFOCache$CacheEntry; import com.thealgorithms.datastructures.caches.LIFOCache$EvictionStrategy; import java.util.ArrayDeque; import java.util.Deque; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; import java.util.Set; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.function.BiConsumer; public final class LIFOCache { private final int a; private final long b; private final Map c; private final Lock d; private final Deque e; private long f = 0L; private long g = 0L; private final BiConsumer h; private final LIFOCache$EvictionStrategy i; private LIFOCache(LIFOCache$Builder lIFOCache$Builder) { this.a = lIFOCache$Builder.a; this.b = lIFOCache$Builder.b; this.c = new HashMap(lIFOCache$Builder.a); this.e = new ArrayDeque(lIFOCache$Builder.a); this.d = new ReentrantLock(); this.h = lIFOCache$Builder.c; this.i = lIFOCache$Builder.d; } public final Object get(Object object) { if (object == null) { throw new IllegalArgumentException(\"Key must not be null\"); } this.d.lock(); try { this.i.onAccess(this); LIFOCache$CacheEntry lIFOCache$CacheEntry = (LIFOCache$CacheEntry)this.c.get(object); if (lIFOCache$CacheEntry == null || lIFOCache$CacheEntry.a()) { if (lIFOCache$CacheEntry != null) { this.c.remove(object); this.e.remove(object); this.a(object, lIFOCache$CacheEntry.a); } ++this.g; return null; } ++this.f; object = lIFOCache$CacheEntry.a; return object; } finally { this.d.unlock(); } } public final void put(Object object, Object object2) { this.put(object, object2, this.b); } public final void put(Object object, Object object2, long l) { if (object == null || object2 == null) { throw new IllegalArgumentException(\"Key and value must not be null\"); } if (l < 0L) { throw new IllegalArgumentException(\"TTL must be >= 0\"); } this.d.lock(); try { this.e.remove(object); LIFOCache$CacheEntry lIFOCache$CacheEntry = (LIFOCache$CacheEntry)this.c.remove(object); if (lIFOCache$CacheEntry != null && !lIFOCache$CacheEntry.a()) { this.a(object, lIFOCache$CacheEntry.a); } this.a(); if (this.c.size() >= this.a) { lIFOCache$CacheEntry = this.e.pollLast(); LIFOCache$CacheEntry lIFOCache$CacheEntry2 = (LIFOCache$CacheEntry)this.c.remove(lIFOCache$CacheEntry); this.a(lIFOCache$CacheEntry, lIFOCache$CacheEntry2.a); } this.e.add(object); this.c.put(object, new LIFOCache$CacheEntry(object2, l)); return; } finally { this.d.unlock(); } } private int a() { int n = 0; Iterator iterator = this.e.iterator(); while (iterator.hasNext()) { Object e = iterator.next(); LIFOCache$CacheEntry lIFOCache$CacheEntry = (LIFOCache$CacheEntry)this.c.get(e); if (lIFOCache$CacheEntry == null || !lIFOCache$CacheEntry.a()) continue; iterator.remove(); this.c.remove(e); this.a(e, lIFOCache$CacheEntry.a); ++n; } return n; } public final Object removeKey(Object object) { if (object == null) { throw new IllegalArgumentException(\"Key cannot be null\"); } this.d.lock(); try { LIFOCache$CacheEntry lIFOCache$CacheEntry = (LIFOCache$CacheEntry)this.c.remove(object); this.e.remove(object); if (lIFOCache$CacheEntry == null) { return null; } this.a(object, lIFOCache$CacheEntry.a); object = lIFOCache$CacheEntry.a; return object; } finally { this.d.unlock(); } } private void a(Object object, Object object2) { if (this.h != null) { try { this.h.accept(object, object2); return; } catch (Exception exception) { System.err.println(\"Eviction listener failed: \" + exception.getMessage()); } } } public final long getHits() { this.d.lock(); try { long l = this.f; return l; } finally { this.d.unlock(); } } public final long getMisses() { this.d.lock(); try { long l = this.g; return l; } finally { this.d.unlock(); } } public final int size() { this.d.lock(); try { this.i.onAccess(this); int n = 0; for (LIFOCache$CacheEntry lIFOCache$CacheEntry : this.c.values()) { if (lIFOCache$CacheEntry.a()) continue; ++n; } int n2 = n; return n2; } finally { this.d.unlock(); } } public final void clear() { this.d.lock(); try { for (Map.Entry entry : this.c.entrySet()) { this.a(entry.getKey(), ((LIFOCache$CacheEntry)entry.getValue()).a); } this.e.clear(); this.c.clear(); this.f = 0L; this.g = 0L; return; } finally { this.d.unlock(); } } public final Set getAllKeys() { this.d.lock(); try { HashSet hashSet = new HashSet(); for (Map.Entry entry : this.c.entrySet()) { if (((LIFOCache$CacheEntry)entry.getValue()).a()) continue; hashSet.add(entry.getKey()); } HashSet hashSet2 = hashSet; return hashSet2; } finally { this.d.unlock(); } } public final LIFOCache$EvictionStrategy getEvictionStrategy() { return this.i; } public final String toString() { this.d.lock(); try { LinkedHashMap linkedHashMap = new LinkedHashMap(); for (Map.Entry entry : this.c.entrySet()) { if (((LIFOCache$CacheEntry)entry.getValue()).a()) continue; linkedHashMap.put(entry.getKey(), ((LIFOCache$CacheEntry)entry.getValue()).a); } String string = String.format(\"Cache(capacity=%d, size=%d, hits=%d, misses=%d, entries=%s)\", this.a, linkedHashMap.size(), this.f, this.g, linkedHashMap); return string; } finally { this.d.unlock(); } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.caches; import java.util.ArrayDeque; import java.util.Deque; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; import java.util.Set; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.function.BiConsumer; /** * A thread-safe generic cache implementation using the Last-In-First-Out eviction policy. * <p> * The cache holds a fixed number of entries, defined by its capacity. When the cache is full and a * new entry is added, the youngest entry in the cache is selected and evicted to make space. * <p> * Optionally, entries can have a time-to-live (TTL) in milliseconds. If a TTL is set, entries will * automatically expire and be removed upon access or insertion attempts. * <p> * Features: * <ul> * <li>Removes youngest entry when capacity is exceeded</li> * <li>Optional TTL (time-to-live in milliseconds) per entry or default TTL for all entries</li> * <li>Thread-safe access using locking</li> * <li>Hit and miss counters for cache statistics</li> * <li>Eviction listener callback support</li> * </ul> * * @param <K> the type of keys maintained by this cache * @param <V> the type of mapped values * See <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#Last_in_first_out_(LIFO)_or_First_in_last_out_(FILO)\">LIFO</a> * @author Kevin Babu (<a href=\"https://www.github.com/KevinMwita7\">GitHub</a>) */ public final class LIFOCache<K, V> { private final int capacity; private final long defaultTTL; private final Map<K, CacheEntry<V>> cache; private final Lock lock; private final Deque<K> keys; private long hits = 0; private long misses = 0; private final BiConsumer<K, V> evictionListener; private final EvictionStrategy<K, V> evictionStrategy; /** * Internal structure to store value + expiry timestamp. * * @param <V> the type of the value being cached */ private static class CacheEntry<V> { V value; long expiryTime; /** * Constructs a new {@code CacheEntry} with the specified value and time-to-live (TTL). * If TTL is 0, the entry is kept indefinitely, that is, unless it is the first value, * then it will be removed according to the LIFO principle * * @param value the value to cache * @param ttlMillis the time-to-live in milliseconds */ CacheEntry(V value, long ttlMillis) { this.value = value; if (ttlMillis == 0) { this.expiryTime = Long.MAX_VALUE; } else { this.expiryTime = System.currentTimeMillis() + ttlMillis; } } /** * Checks if the cache entry has expired. * * @return {@code true} if the current time is past the expiration time; {@code false} otherwise */ boolean isExpired() { return System.currentTimeMillis() > expiryTime; } } /** * Constructs a new {@code LIFOCache} instance using the provided {@link Builder}. * * <p>This constructor initializes the cache with the specified capacity and default TTL, * sets up internal data structures (a {@code HashMap} for cache entries, * {an @code ArrayDeque}, for key storage, and configures eviction. * * @param builder the {@code Builder} object containing configuration parameters */ private LIFOCache(Builder<K, V> builder) { this.capacity = builder.capacity; this.defaultTTL = builder.defaultTTL; this.cache = new HashMap<>(builder.capacity); this.keys = new ArrayDeque<>(builder.capacity); this.lock = new ReentrantLock(); this.evictionListener = builder.evictionListener; this.evictionStrategy = builder.evictionStrategy; } /** * Retrieves the value associated with the specified key from the cache. * * <p>If the key is not present or the corresponding entry has expired, this method * returns {@code null}. If an expired entry is found, it will be removed and the * eviction listener (if any) will be notified. Cache hit-and-miss statistics are * also updated accordingly. * * @param key the key whose associated value is to be returned; must not be {@code null} * @return the cached value associated with the key, or {@code null} if not present or expired * @throws IllegalArgumentException if {@code key} is {@code null} */ public V get(K key) { if (key == null) { throw new IllegalArgumentException(\"Key must not be null\"); } lock.lock(); try { evictionStrategy.onAccess(this); final CacheEntry<V> entry = cache.get(key); if (entry == null || entry.isExpired()) { if (entry != null) { cache.remove(key); keys.remove(key); notifyEviction(key, entry.value); } misses++; return null; } hits++; return entry.value; } finally { lock.unlock(); } } /** * Adds a key-value pair to the cache using the default time-to-live (TTL). * * <p>The key may overwrite an existing entry. The actual insertion is delegated * to the overloaded {@link #put(K, V, long)} method. * * @param key the key to cache the value under * @param value the value to be cached */ public void put(K key, V value) { put(key, value, defaultTTL); } /** * Adds a key-value pair to the cache with a specified time-to-live (TTL). * * <p>If the key already exists, its value is removed, re-inserted at tail and its TTL is reset. * If the key does not exist and the cache is full, the youngest entry is evicted to make space. * Expired entries are also cleaned up prior to any eviction. The eviction listener * is notified when an entry gets evicted. * * @param key the key to associate with the cached value; must not be {@code null} * @param value the value to be cached; must not be {@code null} * @param ttlMillis the time-to-live for this entry in milliseconds; must be >= 0 * @throws IllegalArgumentException if {@code key} or {@code value} is {@code null}, or if {@code ttlMillis} is negative */ public void put(K key, V value, long ttlMillis) { if (key == null || value == null) { throw new IllegalArgumentException(\"Key and value must not be null\"); } if (ttlMillis < 0) { throw new IllegalArgumentException(\"TTL must be >= 0\"); } lock.lock(); try { // If key already exists, remove it. It will later be re-inserted at top of stack keys.remove(key); final CacheEntry<V> oldEntry = cache.remove(key); if (oldEntry != null && !oldEntry.isExpired()) { notifyEviction(key, oldEntry.value); } // Evict expired entries to make space for new entry evictExpired(); // If no expired entry was removed, remove the youngest if (cache.size() >= capacity) { final K youngestKey = keys.pollLast(); final CacheEntry<V> youngestEntry = cache.remove(youngestKey); notifyEviction(youngestKey, youngestEntry.value); } // Insert new entry at tail keys.add(key); cache.put(key, new CacheEntry<>(value, ttlMillis)); } finally { lock.unlock(); } } /** * Removes all expired entries from the cache. * * <p>This method iterates through the list of cached keys and checks each associated * entry for expiration. Expired entries are removed the cache map. For each eviction, * the eviction listener is notified. */ private int evictExpired() { int count = 0; final Iterator<K> it = keys.iterator(); while (it.hasNext()) { final K k = it.next(); final CacheEntry<V> entry = cache.get(k); if (entry != null && entry.isExpired()) { it.remove(); cache.remove(k); notifyEviction(k, entry.value); count++; } } return count; } /** * Removes the specified key and its associated entry from the cache. * * @param key the key to remove from the cache; * @return the value associated with the key; or {@code null} if no such key exists */ public V removeKey(K key) { if (key == null) { throw new IllegalArgumentException(\"Key cannot be null\"); } lock.lock(); try { final CacheEntry<V> entry = cache.remove(key); keys.remove(key); // No such key in cache if (entry == null) { return null; } notifyEviction(key, entry.value); return entry.value; } finally { lock.unlock(); } } /** * Notifies the eviction listener, if one is registered, that a key-value pair has been evicted. * * <p>If the {@code evictionListener} is not {@code null}, it is invoked with the provided key * and value. Any exceptions thrown by the listener are caught and logged to standard error, * preventing them from disrupting cache operations. * * @param key the key that was evicted * @param value the value that was associated with the evicted key */ private void notifyEviction(K key, V value) { if (evictionListener != null) { try { evictionListener.accept(key, value); } catch (Exception e) { System.err.println(\"Eviction listener failed: \" + e.getMessage()); } } } /** * Returns the number of successful cache lookups (hits). * * @return the number of cache hits */ public long getHits() { lock.lock(); try { return hits; } finally { lock.unlock(); } } /** * Returns the number of failed cache lookups (misses), including expired entries. * * @return the number of cache misses */ public long getMisses() { lock.lock(); try { return misses; } finally { lock.unlock(); } } /** * Returns the current number of entries in the cache, excluding expired ones. * * @return the current cache size */ public int size() { lock.lock(); try { evictionStrategy.onAccess(this); int count = 0; for (CacheEntry<V> entry : cache.values()) { if (!entry.isExpired()) { ++count; } } return count; } finally { lock.unlock(); } } /** * Removes all entries from the cache, regardless of their expiration status. * * <p>This method clears the internal cache map entirely, resets the hit-and-miss counters, * and notifies the eviction listener (if any) for each removed entry. * Note that expired entries are treated the same as active ones for the purpose of clearing. * * <p>This operation acquires the internal lock to ensure thread safety. */ public void clear() { lock.lock(); try { for (Map.Entry<K, CacheEntry<V>> entry : cache.entrySet()) { notifyEviction(entry.getKey(), entry.getValue().value); } keys.clear(); cache.clear(); hits = 0; misses = 0; } finally { lock.unlock(); } } /** * Returns a set of all keys currently stored in the cache that have not expired. * * <p>This method iterates through the cache and collects the keys of all non-expired entries. * Expired entries are ignored but not removed. If you want to ensure expired entries are cleaned up, * consider invoking {@link EvictionStrategy#onAccess(LIFOCache)} or calling {@link #evictExpired()} manually. * * <p>This operation acquires the internal lock to ensure thread safety. * * @return a set containing all non-expired keys currently in the cache */ public Set<K> getAllKeys() { lock.lock(); try { final Set<K> result = new HashSet<>(); for (Map.Entry<K, CacheEntry<V>> entry : cache.entrySet()) { if (!entry.getValue().isExpired()) { result.add(entry.getKey()); } } return result; } finally { lock.unlock(); } } /** * Returns the current {@link EvictionStrategy} used by this cache instance. * @return the eviction strategy currently assigned to this cache */ public EvictionStrategy<K, V> getEvictionStrategy() { return evictionStrategy; } /** * Returns a string representation of the cache, including metadata and current non-expired entries. * * <p>The returned string includes the cache's capacity, current size (excluding expired entries), * hit-and-miss counts, and a map of all non-expired key-value pairs. This method acquires a lock * to ensure thread-safe access. * * @return a string summarizing the state of the cache */ @Override public String toString() { lock.lock(); try { final Map<K, V> visible = new LinkedHashMap<>(); for (Map.Entry<K, CacheEntry<V>> entry : cache.entrySet()) { if (!entry.getValue().isExpired()) { visible.put(entry.getKey(), entry.getValue().value); } } return String.format(\"Cache(capacity=%d, size=%d, hits=%d, misses=%d, entries=%s)\", capacity, visible.size(), hits, misses, visible); } finally { lock.unlock(); } } /** * A strategy interface for controlling when expired entries are evicted from the cache. * * <p>Implementations decide whether and when to trigger {@link LIFOCache#evictExpired()} based * on cache usage patterns. This allows for flexible eviction behaviour such as periodic cleanup, * or no automatic cleanup. * * @param <K> the type of keys maintained by the cache * @param <V> the type of cached values */ public interface EvictionStrategy<K, V> { /** * Called on each cache access (e.g., {@link LIFOCache#get(Object)}) to optionally trigger eviction. * * @param cache the cache instance on which this strategy is applied * @return the number of expired entries evicted during this access */ int onAccess(LIFOCache<K, V> cache); } /** * An eviction strategy that performs eviction of expired entries on each call. * * @param <K> the type of keys * @param <V> the type of values */ public static class ImmediateEvictionStrategy<K, V> implements EvictionStrategy<K, V> { @Override public int onAccess(LIFOCache<K, V> cache) { return cache.evictExpired(); } } /** * An eviction strategy that triggers eviction on every fixed number of accesses. * * <p>This deterministic strategy ensures cleanup occurs at predictable intervals, * ideal for moderately active caches where memory usage is a concern. * * @param <K> the type of keys * @param <V> the type of values */ public static class PeriodicEvictionStrategy<K, V> implements EvictionStrategy<K, V> { private final int interval; private final AtomicInteger counter = new AtomicInteger(); /** * Constructs a periodic eviction strategy. * * @param interval the number of accesses between evictions; must be > 0 * @throws IllegalArgumentException if {@code interval} is less than or equal to 0 */ public PeriodicEvictionStrategy(int interval) { if (interval <= 0) { throw new IllegalArgumentException(\"Interval must be > 0\"); } this.interval = interval; } @Override public int onAccess(LIFOCache<K, V> cache) { if (counter.incrementAndGet() % interval == 0) { return cache.evictExpired(); } return 0; } } /** * A builder for constructing a {@link LIFOCache} instance with customizable settings. * * <p>Allows configuring capacity, default TTL, eviction listener, and a pluggable eviction * strategy. Call {@link #build()} to create the configured cache instance. * * @param <K> the type of keys maintained by the cache * @param <V> the type of values stored in the cache */ public static class Builder<K, V> { private final int capacity; private long defaultTTL = 0; private BiConsumer<K, V> evictionListener; private EvictionStrategy<K, V> evictionStrategy = new LIFOCache.ImmediateEvictionStrategy<>(); /** * Creates a new {@code Builder} with the specified cache capacity. * * @param capacity the maximum number of entries the cache can hold; must be > 0 * @throws IllegalArgumentException if {@code capacity} is less than or equal to 0 */ public Builder(int capacity) { if (capacity <= 0) { throw new IllegalArgumentException(\"Capacity must be > 0\"); } this.capacity = capacity; } /** * Sets the default time-to-live (TTL) in milliseconds for cache entries. * * @param ttlMillis the TTL duration in milliseconds; must be >= 0 * @return this builder instance for chaining * @throws IllegalArgumentException if {@code ttlMillis} is negative */ public Builder<K, V> defaultTTL(long ttlMillis) { if (ttlMillis < 0) { throw new IllegalArgumentException(\"Default TTL must be >= 0\"); } this.defaultTTL = ttlMillis; return this; } /** * Sets an eviction listener to be notified when entries are evicted from the cache. * * @param listener a {@link BiConsumer} that accepts evicted keys and values; must not be {@code null} * @return this builder instance for chaining * @throws IllegalArgumentException if {@code listener} is {@code null} */ public Builder<K, V> evictionListener(BiConsumer<K, V> listener) { if (listener == null) { throw new IllegalArgumentException(\"Listener must not be null\"); } this.evictionListener = listener; return this; } /** * Builds and returns a new {@link LIFOCache} instance with the configured parameters. * * @return a fully configured {@code LIFOCache} instance */ public LIFOCache<K, V> build() { return new LIFOCache<>(this); } /** * Sets the eviction strategy used to determine when to clean up expired entries. * * @param strategy an {@link EvictionStrategy} implementation; must not be {@code null} * @return this builder instance * @throws IllegalArgumentException if {@code strategy} is {@code null} */ public Builder<K, V> evictionStrategy(EvictionStrategy<K, V> strategy) { if (strategy == null) { throw new IllegalArgumentException(\"Eviction strategy must not be null\"); } this.evictionStrategy = strategy; return this; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; final class LRUCache$Entry { private LRUCache$Entry a; private LRUCache$Entry b; private Object c; private Object d; LRUCache$Entry() { } public final LRUCache$Entry getPreEntry() { return this.a; } public final void setPreEntry(LRUCache$Entry lRUCache$Entry) { this.a = lRUCache$Entry; } public final LRUCache$Entry getNextEntry() { return this.b; } public final void setNextEntry(LRUCache$Entry lRUCache$Entry) { this.b = lRUCache$Entry; } public final Object getKey() { return this.c; } public final void setKey(Object object) { this.c = object; } public final Object getValue() { return this.d; } public final void setValue(Object object) { this.d = object; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; final class LRUCache$Entry { private LRUCache$Entry a; private LRUCache$Entry b; private Object c; private Object d; LRUCache$Entry() { } public final LRUCache$Entry getPreEntry() { return this.a; } public final void setPreEntry(LRUCache$Entry lRUCache$Entry) { this.a = lRUCache$Entry; } public final LRUCache$Entry getNextEntry() { return this.b; } public final void setNextEntry(LRUCache$Entry lRUCache$Entry) { this.b = lRUCache$Entry; } public final Object getKey() { return this.c; } public final void setKey(Object object) { this.c = object; } public final Object getValue() { return this.d; } public final void setValue(Object object) { this.d = object; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.LRUCache$Entry; import java.util.HashMap; import java.util.Map; public class LRUCache { private final Map a = new HashMap(); private LRUCache$Entry b; private LRUCache$Entry c; private int d; public LRUCache() { this.a(100); } public LRUCache(int n) { this.a(n); } private void a(int n) { LRUCache.b(n); for (int i = this.a.size(); i > n; --i) { LRUCache$Entry lRUCache$Entry = this.a(); this.a.remove(lRUCache$Entry.getKey()); } this.d = n; } private LRUCache$Entry a() { if (this.b == null) { throw new RuntimeException(\"cache cannot be empty!\"); } LRUCache$Entry lRUCache$Entry = this.b; this.b = lRUCache$Entry.getNextEntry(); this.b.setPreEntry(null); lRUCache$Entry.setNextEntry(null); return lRUCache$Entry; } private static void b(int n) { if (n <= 0) { throw new RuntimeException(\"capacity must greater than 0!\"); } } public Object get(Object object) { if (!this.a.containsKey(object)) { return null; } object = (LRUCache$Entry)this.a.get(object); this.a((LRUCache$Entry)object); return ((LRUCache$Entry)object).getValue(); } private void a(LRUCache$Entry lRUCache$Entry) { if (this.c == lRUCache$Entry) { return; } LRUCache$Entry lRUCache$Entry2 = lRUCache$Entry.getPreEntry(); LRUCache$Entry lRUCache$Entry3 = lRUCache$Entry.getNextEntry(); if (lRUCache$Entry2 != null) { lRUCache$Entry2.setNextEntry(lRUCache$Entry3); } if (lRUCache$Entry3 != null) { lRUCache$Entry3.setPreEntry(lRUCache$Entry2); } if (this.b == lRUCache$Entry) { this.b = lRUCache$Entry3; } this.c.setNextEntry(lRUCache$Entry); lRUCache$Entry.setPreEntry(this.c); lRUCache$Entry.setNextEntry(null); this.c = lRUCache$Entry; } public void put(Object object, Object object2) { LRUCache$Entry lRUCache$Entry; if (this.a.containsKey(object)) { LRUCache$Entry lRUCache$Entry2 = (LRUCache$Entry)this.a.get(object); lRUCache$Entry2.setValue(object2); this.a(lRUCache$Entry2); return; } if (this.a.size() == this.d) { lRUCache$Entry = this.a(); this.a.remove(lRUCache$Entry.getKey()); } else { lRUCache$Entry = new LRUCache$Entry(); } lRUCache$Entry.setKey(object); lRUCache$Entry.setValue(object2); LRUCache$Entry lRUCache$Entry3 = lRUCache$Entry; object2 = this; if (((LRUCache)object2).a.isEmpty()) { ((LRUCache)object2).b = lRUCache$Entry3; ((LRUCache)object2).c = lRUCache$Entry3; } else { ((LRUCache)object2).c.setNextEntry(lRUCache$Entry3); lRUCache$Entry3.setPreEntry(((LRUCache)object2).c); lRUCache$Entry3.setNextEntry(null); ((LRUCache)object2).c = lRUCache$Entry3; } this.a.put(object, lRUCache$Entry); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.caches; import java.util.HashMap; import java.util.Map; /** * A Least Recently Used (LRU) Cache implementation. * * <p>An LRU cache is a fixed-size cache that maintains items in order of use. When the cache reaches * its capacity and a new item needs to be added, it removes the least recently used item first. * This implementation provides O(1) time complexity for both get and put operations.</p> * * <p>Features:</p> * <ul> * <li>Fixed-size cache with configurable capacity</li> * <li>Constant time O(1) operations for get and put</li> * <li>Thread-unsafe - should be externally synchronized if used in concurrent environments</li> * <li>Supports null values but not null keys</li> * </ul> * * <p>Implementation Details:</p> * <ul> * <li>Uses a HashMap for O(1) key-value lookups</li> * <li>Maintains a doubly-linked list for tracking access order</li> * <li>The head of the list contains the least recently used item</li> * <li>The tail of the list contains the most recently used item</li> * </ul> * * <p>Example usage:</p> * <pre> * LRUCache<String, Integer> cache = new LRUCache<>(3); // Create cache with capacity 3 * cache.put(\"A\", 1); // Cache: A=1 * cache.put(\"B\", 2); // Cache: A=1, B=2 * cache.put(\"C\", 3); // Cache: A=1, B=2, C=3 * cache.get(\"A\"); // Cache: B=2, C=3, A=1 (A moved to end) * cache.put(\"D\", 4); // Cache: C=3, A=1, D=4 (B evicted) * </pre> * * @param <K> the type of keys maintained by this cache * @param <V> the type of mapped values */ public class LRUCache<K, V> { private final Map<K, Entry<K, V>> data = new HashMap<>(); private Entry<K, V> head; private Entry<K, V> tail; private int cap; private static final int DEFAULT_CAP = 100; public LRUCache() { setCapacity(DEFAULT_CAP); } public LRUCache(int cap) { setCapacity(cap); } /** * Returns the current capacity of the cache. * * @param newCapacity the new capacity of the cache */ private void setCapacity(int newCapacity) { checkCapacity(newCapacity); for (int i = data.size(); i > newCapacity; i--) { Entry<K, V> evicted = evict(); data.remove(evicted.getKey()); } this.cap = newCapacity; } /** * Evicts the least recently used item from the cache. * * @return the evicted entry */ private Entry<K, V> evict() { if (head == null) { throw new RuntimeException(\"cache cannot be empty!\"); } Entry<K, V> evicted = head; head = evicted.getNextEntry(); head.setPreEntry(null); evicted.setNextEntry(null); return evicted; } /** * Checks if the capacity is valid. * * @param capacity the capacity to check */ private void checkCapacity(int capacity) { if (capacity <= 0) { throw new RuntimeException(\"capacity must greater than 0!\"); } } /** * Returns the value to which the specified key is mapped, or null if this cache contains no * mapping for the key. * * @param key the key whose associated value is to be returned * @return the value to which the specified key is mapped, or null if this cache contains no * mapping for the key */ public V get(K key) { if (!data.containsKey(key)) { return null; } final Entry<K, V> entry = data.get(key); moveNodeToLast(entry); return entry.getValue(); } /** * Moves the specified entry to the end of the list. * * @param entry the entry to move */ private void moveNodeToLast(Entry<K, V> entry) { if (tail == entry) { return; } final Entry<K, V> preEntry = entry.getPreEntry(); final Entry<K, V> nextEntry = entry.getNextEntry(); if (preEntry != null) { preEntry.setNextEntry(nextEntry); } if (nextEntry != null) { nextEntry.setPreEntry(preEntry); } if (head == entry) { head = nextEntry; } tail.setNextEntry(entry); entry.setPreEntry(tail); entry.setNextEntry(null); tail = entry; } /** * Associates the specified value with the specified key in this cache. * * @param key the key with which the specified value is to be associated * @param value the value to be associated with the specified key */ public void put(K key, V value) { if (data.containsKey(key)) { final Entry<K, V> existingEntry = data.get(key); existingEntry.setValue(value); moveNodeToLast(existingEntry); return; } Entry<K, V> newEntry; if (data.size() == cap) { newEntry = evict(); data.remove(newEntry.getKey()); } else { newEntry = new Entry<>(); } newEntry.setKey(key); newEntry.setValue(value); addNewEntry(newEntry); data.put(key, newEntry); } /** * Adds a new entry to the end of the list. * * @param newEntry the entry to add */ private void addNewEntry(Entry<K, V> newEntry) { if (data.isEmpty()) { head = newEntry; tail = newEntry; return; } tail.setNextEntry(newEntry); newEntry.setPreEntry(tail); newEntry.setNextEntry(null); tail = newEntry; } static final class Entry<I, J> { private Entry<I, J> preEntry; private Entry<I, J> nextEntry; private I key; private J value; Entry() { } Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) { this.preEntry = preEntry; this.nextEntry = nextEntry; this.key = key; this.value = value; } public Entry<I, J> getPreEntry() { return preEntry; } public void setPreEntry(Entry<I, J> preEntry) { this.preEntry = preEntry; } public Entry<I, J> getNextEntry() { return nextEntry; } public void setNextEntry(Entry<I, J> nextEntry) { this.nextEntry = nextEntry; } public I getKey() { return key; } public void setKey(I key) { this.key = key; } public J getValue() { return value; } public void setValue(J value) { this.value = value; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.crdt; import com.thealgorithms.datastructures.crdt.Element; import java.time.Instant; import java.util.HashMap; import java.util.Map; class LWWElementSet { private Map a = new HashMap(); private Map b = new HashMap(); LWWElementSet() { } public void add(Object object) { this.a.put(object, new Element(object, Instant.now())); } public void remove(Object object) { this.b.put(object, new Element(object, Instant.now())); } public boolean lookup(Object object) { Element element = (Element)this.a.get(object); object = (Element)this.b.get(object); return element != null && (object == null || element.a.isAfter(((Element)object).a)); } public void merge(LWWElementSet lWWElementSet) { for (Map.Entry entry : lWWElementSet.a.entrySet()) { this.a.merge(entry.getKey(), (Element)entry.getValue(), this::a); } for (Map.Entry entry : lWWElementSet.b.entrySet()) { this.b.merge(entry.getKey(), (Element)entry.getValue(), this::a); } } private Element a(Element element, Element element2) { if (element.a.isAfter(element2.a)) { return element; } return element2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.crdt; import java.time.Instant; import java.util.HashMap; import java.util.Map; /** * Last-Write-Wins Element Set (LWWElementSet) is a state-based CRDT (Conflict-free Replicated Data * Type) designed for managing sets in a distributed and concurrent environment. It supports the * addition and removal of elements, using timestamps to determine the order of operations. The set * is split into two subsets: the add set for elements to be added and the remove set for elements * to be removed. The LWWElementSet ensures that the most recent operation (based on the timestamp) * wins in the case of concurrent operations. * * @param <T> The type of the elements in the LWWElementSet. * @author <a href=\"https://github.com/itakurah\">itakurah (GitHub)</a>, <a * href=\"https://www.linkedin.com/in/niklashoefflin/\">Niklas Hoefflin (LinkedIn)</a> * @see <a href=\"https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type\">Conflict free * replicated data type (Wikipedia)</a> * @see <a href=\"https://inria.hal.science/inria-00555588v1/document\">A comprehensive study of * Convergent and Commutative Replicated Data Types</a> */ class LWWElementSet<T> { final Map<T, Element<T>> addSet; final Map<T, Element<T>> removeSet; /** * Constructs an empty LWWElementSet. This constructor initializes the addSet and removeSet as * empty HashMaps. The addSet stores elements that are added, and the removeSet stores elements * that are removed. */ LWWElementSet() { this.addSet = new HashMap<>(); this.removeSet = new HashMap<>(); } /** * Adds an element to the addSet with the current timestamp. This method stores the element in the * addSet, ensuring that the element is added to the set with an associated timestamp that * represents the time of the addition. * * @param key The key of the element to be added. */ public void add(T key) { addSet.put(key, new Element<>(key, Instant.now())); } /** * Removes an element by adding it to the removeSet with the current timestamp. This method adds * the element to the removeSet, marking it as removed with the current timestamp. * * @param key The key of the element to be removed. */ public void remove(T key) { removeSet.put(key, new Element<>(key, Instant.now())); } /** * Checks if an element is in the LWWElementSet. An element is considered present if it exists in * the addSet and either does not exist in the removeSet, or its add timestamp is later than any * corresponding remove timestamp. * * @param key The key of the element to be checked. * @return {@code true} if the element is present in the set (i.e., its add timestamp is later * than its remove timestamp, or it is not in the remove set), {@code false} otherwise (i.e., * the element has been removed or its remove timestamp is later than its add timestamp). */ public boolean lookup(T key) { Element<T> inAddSet = addSet.get(key); Element<T> inRemoveSet = removeSet.get(key); return inAddSet != null && (inRemoveSet == null || inAddSet.timestamp.isAfter(inRemoveSet.timestamp)); } /** * Merges another LWWElementSet into this set. This method takes the union of both the add-sets * and remove-sets from the two sets, resolving conflicts by keeping the element with the latest * timestamp. If an element appears in both the add-set and remove-set of both sets, the one with * the later timestamp will be retained. * * @param other The LWWElementSet to merge with the current set. */ public void merge(LWWElementSet<T> other) { for (Map.Entry<T, Element<T>> entry : other.addSet.entrySet()) { addSet.merge(entry.getKey(), entry.getValue(), this::resolveConflict); } for (Map.Entry<T, Element<T>> entry : other.removeSet.entrySet()) { removeSet.merge(entry.getKey(), entry.getValue(), this::resolveConflict); } } /** * Resolves conflicts between two elements by selecting the one with the later timestamp. This * method is used when merging two LWWElementSets to ensure that the most recent operation (based * on timestamps) is kept. * * @param e1 The first element. * @param e2 The second element. * @return The element with the later timestamp. */ private Element<T> resolveConflict(Element<T> e1, Element<T> e2) { return e1.timestamp.isAfter(e2.timestamp) ? e1 : e2; } } /** * Represents an element in the LWWElementSet, consisting of a key and a timestamp. This class is * used to store the elements in both the add and remove sets with their respective timestamps. * * @param <T> The type of the key associated with the element. */ class Element<T> { T key; Instant timestamp; /** * Constructs a new Element with the specified key and timestamp. * * @param key The key of the element. * @param timestamp The timestamp associated with the element. */ Element(T key, Instant timestamp) { this.key = key; this.timestamp = timestamp; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.devutils.nodes; import com.thealgorithms.devutils.nodes.TreeNode; import java.util.Collection; public class LargeTreeNode extends TreeNode { private Collection a; public LargeTreeNode() { } public LargeTreeNode(Object object) { super(object); } public LargeTreeNode(Object object, LargeTreeNode largeTreeNode) { super(object, largeTreeNode); } public LargeTreeNode(Object object, LargeTreeNode largeTreeNode, Collection collection) { super(object, largeTreeNode); this.a = collection; } @Override public boolean isLeafNode() { return this.a == null || this.a.isEmpty(); } public Collection getChildNodes() { return this.a; } public void setChildNodes(Collection collection) { this.a = collection; } }", "deobfuscated_code": "package com.thealgorithms.devutils.nodes; import java.util.Collection; /** * {@link TreeNode} extension that holds a {@link Collection} of refrences to * child Nodes. * * @param <E> The type of the data held in the Node. * * @author <a href=\"https://github.com/aitorfi\">aitorfi</a> */ public class LargeTreeNode<E> extends TreeNode<E> { /** * {@link Collection} that holds the Nodes' child nodes. */ private Collection<LargeTreeNode<E>> childNodes; /** * Empty contructor. */ public LargeTreeNode() { super(); } /** * Initializes the Nodes' data. * * @param data Value to which data will be initialized. * @see TreeNode#TreeNode(Object) */ public LargeTreeNode(E data) { super(data); } /** * Initializes the Nodes' data and parent node reference. * * @param data Value to which data will be initialized. * @param parentNode Value to which the nodes' parent reference will be set. * @see TreeNode#TreeNode(Object, Node) */ public LargeTreeNode(E data, LargeTreeNode<E> parentNode) { super(data, parentNode); } /** * Initializes the Nodes' data and parent and child nodes references. * * @param data Value to which data will be initialized. * @param parentNode Value to which the nodes' parent reference will be set. * @param childNodes {@link Collection} of child Nodes. * @see TreeNode#TreeNode(Object, Node) */ public LargeTreeNode(E data, LargeTreeNode<E> parentNode, Collection<LargeTreeNode<E>> childNodes) { super(data, parentNode); this.childNodes = childNodes; } /** * @return True if the node is a leaf node, otherwise false. * @see TreeNode#isLeafNode() */ @Override public boolean isLeafNode() { return (childNodes == null || childNodes.isEmpty()); } public Collection<LargeTreeNode<E>> getChildNodes() { return childNodes; } public void setChildNodes(Collection<LargeTreeNode<E>> childNodes) { this.childNodes = childNodes; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Stack; public final class LargestRectangle { private LargestRectangle() { } public static String largestRectangleHistogram(int[] nArray) { int n; int n2 = 0; Stack<int[]> stack = new Stack<int[]>(); for (n = 0; n < nArray.length; ++n) { int n3 = n; while (!stack.isEmpty() && ((int[])stack.peek())[1] > nArray[n]) { int[] nArray2 = (int[])stack.pop(); n2 = Math.max(n2, nArray2[1] * (n - nArray2[0])); n3 = nArray2[0]; } stack.push(new int[]{n3, nArray[n]}); } n = nArray.length; while (!stack.isEmpty()) { int[] nArray3 = (int[])stack.pop(); n2 = Math.max(n2, nArray3[1] * (n - nArray3[0])); } return Integer.toString(n2); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; /** * Utility class to calculate the largest rectangle area in a histogram. * Each bar's width is assumed to be 1 unit. * * <p>This implementation uses a monotonic stack to efficiently calculate * the area of the largest rectangle that can be formed from the histogram bars.</p> * * <p>Example usage: * <pre>{@code * int[] heights = {2, 1, 5, 6, 2, 3}; * String area = LargestRectangle.largestRectangleHistogram(heights); * // area is \"10\" * }</pre> */ public final class LargestRectangle { private LargestRectangle() { } /** * Calculates the largest rectangle area in the given histogram. * * @param heights an array of non-negative integers representing bar heights * @return the largest rectangle area as a {@link String} */ public static String largestRectangleHistogram(int[] heights) { int maxArea = 0; Stack<int[]> stack = new Stack<>(); for (int i = 0; i < heights.length; i++) { int start = i; while (!stack.isEmpty() && stack.peek()[1] > heights[i]) { int[] popped = stack.pop(); maxArea = Math.max(maxArea, popped[1] * (i - popped[0])); start = popped[0]; } stack.push(new int[] {start, heights[i]}); } int totalLength = heights.length; while (!stack.isEmpty()) { int[] remaining = stack.pop(); maxArea = Math.max(maxArea, remaining[1] * (totalLength - remaining[0])); } return Integer.toString(maxArea); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class LazySegmentTree$Node { private final int c; private final int d; private int e; private int f; LazySegmentTree$Node a; LazySegmentTree$Node b; LazySegmentTree$Node(int n, int n2, int n3) { this.c = n; this.d = n2; this.e = n3; this.f = 0; this.a = null; this.b = null; } public void applyUpdate(int n) { this.f += n; this.e += (this.d - this.c) * n; } public void shift() { if (this.f == 0) { return; } if (this.a == null && this.b == null) { return; } this.e += this.f; if (this.a != null) { this.a.applyUpdate(this.f); } if (this.b != null) { this.b.applyUpdate(this.f); } this.f = 0; } static LazySegmentTree$Node a(LazySegmentTree$Node lazySegmentTree$Node, LazySegmentTree$Node lazySegmentTree$Node2) { if (lazySegmentTree$Node == null) { return lazySegmentTree$Node2; } if (lazySegmentTree$Node2 == null) { return lazySegmentTree$Node; } LazySegmentTree$Node lazySegmentTree$Node3 = new LazySegmentTree$Node(lazySegmentTree$Node.c, lazySegmentTree$Node2.d, lazySegmentTree$Node.e + lazySegmentTree$Node2.e); new LazySegmentTree$Node(lazySegmentTree$Node.c, lazySegmentTree$Node2.d, lazySegmentTree$Node.e + lazySegmentTree$Node2.e).a = lazySegmentTree$Node; lazySegmentTree$Node3.b = lazySegmentTree$Node2; return lazySegmentTree$Node3; } public int getValue() { return this.e; } public LazySegmentTree$Node getLeft() { return this.a; } public LazySegmentTree$Node getRight() { return this.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class LazySegmentTree$Node { private final int c; private final int d; private int e; private int f; LazySegmentTree$Node a; LazySegmentTree$Node b; LazySegmentTree$Node(int n, int n2, int n3) { this.c = n; this.d = n2; this.e = n3; this.f = 0; this.a = null; this.b = null; } public void applyUpdate(int n) { this.f += n; this.e += (this.d - this.c) * n; } public void shift() { if (this.f == 0) { return; } if (this.a == null && this.b == null) { return; } this.e += this.f; if (this.a != null) { this.a.applyUpdate(this.f); } if (this.b != null) { this.b.applyUpdate(this.f); } this.f = 0; } static LazySegmentTree$Node a(LazySegmentTree$Node lazySegmentTree$Node, LazySegmentTree$Node lazySegmentTree$Node2) { if (lazySegmentTree$Node == null) { return lazySegmentTree$Node2; } if (lazySegmentTree$Node2 == null) { return lazySegmentTree$Node; } LazySegmentTree$Node lazySegmentTree$Node3 = new LazySegmentTree$Node(lazySegmentTree$Node.c, lazySegmentTree$Node2.d, lazySegmentTree$Node.e + lazySegmentTree$Node2.e); new LazySegmentTree$Node(lazySegmentTree$Node.c, lazySegmentTree$Node2.d, lazySegmentTree$Node.e + lazySegmentTree$Node2.e).a = lazySegmentTree$Node; lazySegmentTree$Node3.b = lazySegmentTree$Node2; return lazySegmentTree$Node3; } public int getValue() { return this.e; } public LazySegmentTree$Node getLeft() { return this.a; } public LazySegmentTree$Node getRight() { return this.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.LazySegmentTree$Node; public class LazySegmentTree { private final LazySegmentTree$Node a; public LazySegmentTree(int[] nArray) { this.a = this.a(nArray, 0, nArray.length); } private LazySegmentTree$Node a(int[] object, int n, int n2) { if (n2 - n < 2) { return new LazySegmentTree$Node(n, n2, object[n]); } int n3 = n + n2 >> 1; LazySegmentTree$Node lazySegmentTree$Node = this.a((int[])object, n, n3); object = this.a((int[])object, n3, n2); return LazySegmentTree$Node.a(lazySegmentTree$Node, (LazySegmentTree$Node)object); } private void a(int n, int n2, int n3, LazySegmentTree$Node lazySegmentTree$Node) { if (n <= lazySegmentTree$Node.c && lazySegmentTree$Node.d <= n2) { lazySegmentTree$Node.applyUpdate(n3); return; } if (n >= lazySegmentTree$Node.d || n2 <= lazySegmentTree$Node.c) { return; } lazySegmentTree$Node.shift(); this.a(n, n2, n3, lazySegmentTree$Node.a); this.a(n, n2, n3, lazySegmentTree$Node.b); LazySegmentTree$Node lazySegmentTree$Node2 = LazySegmentTree$Node.a(lazySegmentTree$Node.a, lazySegmentTree$Node.b); lazySegmentTree$Node.e = lazySegmentTree$Node2.e; } private LazySegmentTree$Node a(int n, int n2, LazySegmentTree$Node lazySegmentTree$Node) { if (n <= lazySegmentTree$Node.c && lazySegmentTree$Node.d <= n2) { return lazySegmentTree$Node; } if (n >= lazySegmentTree$Node.d || n2 <= lazySegmentTree$Node.c) { return null; } lazySegmentTree$Node.shift(); return LazySegmentTree$Node.a(this.a(n, n2, lazySegmentTree$Node.a), this.a(n, n2, lazySegmentTree$Node.b)); } public int getRange(int n, int n2) { LazySegmentTree$Node lazySegmentTree$Node = this.a(n, n2, this.a); if (lazySegmentTree$Node == null) { return 0; } return lazySegmentTree$Node.getValue(); } public void updateRange(int n, int n2, int n3) { this.a(n, n2, n3, this.a); } public LazySegmentTree$Node getRoot() { return this.a; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; public class LazySegmentTree { /** * Lazy Segment Tree * * @see * <a href=\"https://www.geeksforgeeks.org/lazy-propagation-in-segment-tree/\"> */ static class Node { private final int start; private final int end; // start and end of the segment represented by this node private int value; // value is the sum of all elements in the range [start, end) private int lazy; // lazied value that should be added to children nodes Node left; Node right; // left and right children Node(int start, int end, int value) { this.start = start; this.end = end; this.value = value; this.lazy = 0; this.left = null; this.right = null; } /** * Update the value of this node with the given value diff. * * @param diff The value to add to every index of this node range. */ public void applyUpdate(int diff) { this.lazy += diff; this.value += (this.end - this.start) * diff; } /** * Shift the lazy value of this node to its children. */ public void shift() { if (lazy == 0) { return; } if (this.left == null && this.right == null) { return; } this.value += this.lazy; if (this.left != null) { this.left.applyUpdate(this.lazy); } if (this.right != null) { this.right.applyUpdate(this.lazy); } this.lazy = 0; } /** * Create a new node that is the sum of this node and the given node. * * @param left The left Node of merging * @param right The right Node of merging * @return The new Node. */ static Node merge(Node left, Node right) { if (left == null) { return right; } if (right == null) { return left; } Node result = new Node(left.start, right.end, left.value + right.value); result.left = left; result.right = right; return result; } public int getValue() { return value; } public Node getLeft() { return left; } public Node getRight() { return right; } } private final Node root; /** * Create a new LazySegmentTree with the given array. * * @param array The array to create the LazySegmentTree from. */ public LazySegmentTree(int[] array) { this.root = buildTree(array, 0, array.length); } /** * Build a new LazySegmentTree from the given array in O(n) time. * * @param array The array to build the LazySegmentTree from. * @param start The start index of the current node. * @param end The end index of the current node. * @return The root of the new LazySegmentTree. */ private Node buildTree(int[] array, int start, int end) { if (end - start < 2) { return new Node(start, end, array[start]); } int mid = (start + end) >> 1; Node left = buildTree(array, start, mid); Node right = buildTree(array, mid, end); return Node.merge(left, right); } /** * Update the value of given range with the given value diff in O(log n) time. * * @param left The left index of the range to update. * @param right The right index of the range to update. * @param diff The value to add to every index of the range. * @param curr The current node. */ private void updateRange(int left, int right, int diff, Node curr) { if (left <= curr.start && curr.end <= right) { curr.applyUpdate(diff); return; } if (left >= curr.end || right <= curr.start) { return; } curr.shift(); updateRange(left, right, diff, curr.left); updateRange(left, right, diff, curr.right); Node merge = Node.merge(curr.left, curr.right); curr.value = merge.value; } /** * Get Node of given range in O(log n) time. * * @param left The left index of the range to update. * @param right The right index of the range to update. * @return The Node representing the sum of the given range. */ private Node getRange(int left, int right, Node curr) { if (left <= curr.start && curr.end <= right) { return curr; } if (left >= curr.end || right <= curr.start) { return null; } curr.shift(); return Node.merge(getRange(left, right, curr.left), getRange(left, right, curr.right)); } public int getRange(int left, int right) { Node result = getRange(left, right, root); return result == null ? 0 : result.getValue(); } public void updateRange(int left, int right, int diff) { updateRange(left, right, diff, root); } public Node getRoot() { return root; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class LeastCommonMultiple { private LeastCommonMultiple() { } public static int lcm(int n, int n2) { int n3; int n4; int n5 = 0; if (n > n2) { n4 = n; n3 = n; } else { n4 = n2; n3 = n2; } while (n != 0) { if (n4 % n == 0 && n4 % n2 == 0) { n5 = n4; break; } n4 += n3; } return n5; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Is a common mathematics concept to find the smallest value number * that can be divide using either number without having the remainder. * https://maticschool.blogspot.com/2013/11/find-least-common-multiple-lcm.html * @author LauKinHoong */ public final class LeastCommonMultiple { private LeastCommonMultiple() { } /** * Finds the least common multiple of two numbers. * * @param num1 The first number. * @param num2 The second number. * @return The least common multiple of num1 and num2. */ public static int lcm(int num1, int num2) { int high; int num3; int cmv = 0; if (num1 > num2) { high = num1; num3 = num1; } else { high = num2; num3 = num2; } while (num1 != 0) { if (high % num1 == 0 && high % num2 == 0) { cmv = high; break; } high += num3; } return cmv; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; final class LeftistHeap$Node { private final int a; private int b; private LeftistHeap$Node c; private LeftistHeap$Node d; private LeftistHeap$Node(int n) { this.a = n; this.c = null; this.d = null; this.b = 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; final class LeftistHeap$Node { private final int a; private int b; private LeftistHeap$Node c; private LeftistHeap$Node d; private LeftistHeap$Node(int n) { this.a = n; this.c = null; this.d = null; this.b = 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import com.thealgorithms.datastructures.heaps.LeftistHeap$Node; import java.util.ArrayList; public class LeftistHeap { private LeftistHeap$Node a = null; public boolean isEmpty() { return this.a == null; } public void clear() { this.a = null; } public void merge(LeftistHeap leftistHeap) { this.a = this.merge(this.a, leftistHeap.a); leftistHeap.a = null; } public LeftistHeap$Node merge(LeftistHeap$Node leftistHeap$Node, LeftistHeap$Node leftistHeap$Node2) { LeftistHeap$Node leftistHeap$Node3; if (leftistHeap$Node == null) { return leftistHeap$Node2; } if (leftistHeap$Node2 == null) { return leftistHeap$Node; } if (leftistHeap$Node.a > leftistHeap$Node2.a) { leftistHeap$Node3 = leftistHeap$Node; leftistHeap$Node = leftistHeap$Node2; leftistHeap$Node2 = leftistHeap$Node3; } leftistHeap$Node.d = this.merge(leftistHeap$Node.d, leftistHeap$Node2); if (leftistHeap$Node.c == null) { leftistHeap$Node.c = leftistHeap$Node.d; leftistHeap$Node.d = null; } else { if (leftistHeap$Node.c.b < leftistHeap$Node.d.b) { leftistHeap$Node3 = leftistHeap$Node.c; leftistHeap$Node.c = leftistHeap$Node.d; leftistHeap$Node.d = leftistHeap$Node3; } leftistHeap$Node.b = leftistHeap$Node.d.b + 1; } return leftistHeap$Node; } public void insert(int n) { this.a = this.merge(new LeftistHeap$Node(n), this.a); } public int extractMin() { if (this.isEmpty()) { return -1; } int n = this.a.a; this.a = this.merge(this.a.c, this.a.d); return n; } public ArrayList inOrder() { ArrayList arrayList = new ArrayList(); LeftistHeap leftistHeap = this; leftistHeap.a(leftistHeap.a, arrayList); return new ArrayList(arrayList); } private void a(LeftistHeap$Node leftistHeap$Node, ArrayList arrayList) { while (leftistHeap$Node != null) { this.a(leftistHeap$Node.c, arrayList); arrayList.add(leftistHeap$Node.a); leftistHeap$Node = leftistHeap$Node.d; } return; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; import java.util.ArrayList; /** * This class implements a Leftist Heap, which is a type of priority queue * that follows similar operations to a binary min-heap but allows for * unbalanced structures based on the leftist property. * * <p> * A Leftist Heap maintains the leftist property, which ensures that the * left subtree is heavier than the right subtree based on the * null-path length (npl) values. This allows for efficient merging * of heaps and supports operations like insertion, extraction of * the minimum element, and in-order traversal. * </p> * * <p> * For more information on Leftist Heaps, visit: * <a href=\"https://iq.opengenus.org/leftist-heap/\">OpenGenus</a> * </p> */ public class LeftistHeap { // Node class representing each element in the Leftist Heap private static final class Node { private final int element; private int npl; private Node left; private Node right; // Node constructor that initializes the element and sets child pointers to null private Node(int element) { this.element = element; left = null; right = null; npl = 0; } } private Node root; // Constructor initializing an empty Leftist Heap public LeftistHeap() { root = null; } /** * Checks if the heap is empty. * * @return true if the heap is empty; false otherwise */ public boolean isEmpty() { return root == null; } /** * Resets the heap to its initial state, effectively clearing all elements. */ public void clear() { root = null; // Set root to null to clear the heap } /** * Merges the contents of another Leftist Heap into this one. * * @param h1 the LeftistHeap to be merged into this heap */ public void merge(LeftistHeap h1) { // Merge the current heap with the provided heap and set the provided heap's root to null root = merge(root, h1.root); h1.root = null; } /** * Merges two nodes, maintaining the leftist property. * * @param a the first node * @param b the second node * @return the merged node maintaining the leftist property */ public Node merge(Node a, Node b) { if (a == null) { return b; } if (b == null) { return a; } // Ensure that the leftist property is maintained if (a.element > b.element) { Node temp = a; a = b; b = temp; } // Merge the right child of node a with node b a.right = merge(a.right, b); // If left child is null, make right child the left child if (a.left == null) { a.left = a.right; a.right = null; } else { if (a.left.npl < a.right.npl) { Node temp = a.left; a.left = a.right; a.right = temp; } a.npl = a.right.npl + 1; } return a; } /** * Inserts a new element into the Leftist Heap. * * @param a the element to be inserted */ public void insert(int a) { root = merge(new Node(a), root); } /** * Extracts and removes the minimum element from the heap. * * @return the minimum element in the heap, or -1 if the heap is empty */ public int extractMin() { if (isEmpty()) { return -1; } int min = root.element; root = merge(root.left, root.right); return min; } /** * Returns a list of the elements in the heap in in-order traversal. * * @return an ArrayList containing the elements in in-order */ public ArrayList<Integer> inOrder() { ArrayList<Integer> lst = new ArrayList<>(); inOrderAux(root, lst); return new ArrayList<>(lst); } /** * Auxiliary function for in-order traversal * * @param n the current node * @param lst the list to store the elements in in-order */ private void inOrderAux(Node n, ArrayList<Integer> lst) { if (n == null) { return; } inOrderAux(n.left, lst); lst.add(n.element); inOrderAux(n.right, lst); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class LeonardoNumber { private LeonardoNumber() { } public static int leonardoNumber(int n) { if (n < 0) { throw new ArithmeticException(); } if (n == 0 || n == 1) { return 1; } return LeonardoNumber.leonardoNumber(n - 1) + LeonardoNumber.leonardoNumber(n - 2) + 1; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * https://en.wikipedia.org/wiki/Leonardo_number */ public final class LeonardoNumber { private LeonardoNumber() { } /** * Calculate nth Leonardo Number (1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, ...) * * @param n the index of Leonardo Number to calculate * @return nth number of Leonardo sequences */ public static int leonardoNumber(int n) { if (n < 0) { throw new ArithmeticException(); } if (n == 0 || n == 1) { return 1; } return (leonardoNumber(n - 1) + leonardoNumber(n - 2) + 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.ArrayList; import java.util.Collections; import java.util.List; public final class LetterCombinationsOfPhoneNumber { private static final String[] a = new String[]{\" \", \"\\u0000\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; private LetterCombinationsOfPhoneNumber() { } public static List getCombinations(int[] nArray) { if (nArray == null) { return List.of(\"\"); } return LetterCombinationsOfPhoneNumber.a(nArray, 0, new StringBuilder()); } private static List a(int[] nArray, int n, StringBuilder stringBuilder) { if (n == nArray.length) { return new ArrayList<String>(Collections.singletonList(stringBuilder.toString())); } int n2 = nArray[n]; if (n2 < 0 || n2 > 9) { throw new IllegalArgumentException(\"Input numbers must in the range [0, 9]\"); } ArrayList arrayList = new ArrayList(); for (char c : a[n2].toCharArray()) { if (c != '\\u0000') { stringBuilder.append(c); } arrayList.addAll(LetterCombinationsOfPhoneNumber.a(nArray, n + 1, stringBuilder)); if (c == '\\u0000') continue; StringBuilder stringBuilder2 = stringBuilder; stringBuilder2.deleteCharAt(stringBuilder2.length() - 1); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.ArrayList; import java.util.Collections; import java.util.List; public final class LetterCombinationsOfPhoneNumber { private static final char EMPTY = '\\0'; // Mapping of numbers to corresponding letters on a phone keypad private static final String[] KEYPAD = new String[] {\" \", String.valueOf(EMPTY), \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; private LetterCombinationsOfPhoneNumber() { } /** * Generates a list of all possible letter combinations that the provided * array of numbers could represent on a phone keypad. * * @param numbers an array of integers representing the phone numbers * @return a list of possible letter combinations */ public static List<String> getCombinations(int[] numbers) { if (numbers == null) { return List.of(\"\"); } return generateCombinations(numbers, 0, new StringBuilder()); } /** * Recursive method to generate combinations of letters from the phone keypad. * * @param numbers the input array of phone numbers * @param index the current index in the numbers array being processed * @param current a StringBuilder holding the current combination of letters * @return a list of letter combinations formed from the given numbers */ private static List<String> generateCombinations(int[] numbers, int index, StringBuilder current) { // Base case: if we've processed all numbers, return the current combination if (index == numbers.length) { return new ArrayList<>(Collections.singletonList(current.toString())); } final var number = numbers[index]; if (number < 0 || number > 9) { throw new IllegalArgumentException(\"Input numbers must in the range [0, 9]\"); } List<String> combinations = new ArrayList<>(); // Iterate over each letter and recurse to generate further combinations for (char letter : KEYPAD[number].toCharArray()) { if (letter != EMPTY) { current.append(letter); } combinations.addAll(generateCombinations(numbers, index + 1, current)); if (letter != EMPTY) { current.deleteCharAt(current.length() - 1); // Backtrack by removing the last appended letter } } return combinations; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; public final class LevelOrderTraversal { private LevelOrderTraversal() { } public static List traverse(BinaryTree$Node binaryTree$Node) { if (binaryTree$Node == null) { return List.of(); } ArrayList arrayList = new ArrayList(); LinkedList<BinaryTree$Node> linkedList = new LinkedList<BinaryTree$Node>(); linkedList.add(binaryTree$Node); while (!linkedList.isEmpty()) { int n = linkedList.size(); LinkedList<Integer> linkedList2 = new LinkedList<Integer>(); for (int i = 0; i < n; ++i) { BinaryTree$Node binaryTree$Node2 = (BinaryTree$Node)linkedList.poll(); linkedList2.add(binaryTree$Node2.data); if (binaryTree$Node2.left != null) { linkedList.add(binaryTree$Node2.left); } if (binaryTree$Node2.right == null) continue; linkedList.add(binaryTree$Node2.right); } arrayList.add(linkedList2); } return arrayList; } public static void printGivenLevel(BinaryTree$Node binaryTree$Node, int n) { while (true) { if (binaryTree$Node == null) { System.out.println(\"Root node must not be null! Exiting.\"); return; } if (n == 1) { System.out.print(binaryTree$Node.data + \" \"); return; } if (n <= 1) break; LevelOrderTraversal.printGivenLevel(binaryTree$Node.left, n - 1); --n; binaryTree$Node = binaryTree$Node.right; } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; public final class LevelOrderTraversal { private LevelOrderTraversal() { } public static List<List<Integer>> traverse(BinaryTree.Node root) { if (root == null) { return List.of(); } List<List<Integer>> result = new ArrayList<>(); Queue<BinaryTree.Node> q = new LinkedList<>(); q.add(root); while (!q.isEmpty()) { int nodesOnLevel = q.size(); List<Integer> level = new LinkedList<>(); for (int i = 0; i < nodesOnLevel; i++) { BinaryTree.Node tempNode = q.poll(); level.add(tempNode.data); if (tempNode.left != null) { q.add(tempNode.left); } if (tempNode.right != null) { q.add(tempNode.right); } } result.add(level); } return result; } /* Print nodes at the given level */ public static void printGivenLevel(BinaryTree.Node root, int level) { if (root == null) { System.out.println(\"Root node must not be null! Exiting.\"); return; } if (level == 1) { System.out.print(root.data + \" \"); } else if (level > 1) { printGivenLevel(root.left, level - 1); printGivenLevel(root.right, level - 1); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import java.util.stream.IntStream; public final class LevenshteinDistance { private LevenshteinDistance() { } public static int naiveLevenshteinDistance(String string, String string2) { int[][] nArray = (int[][])IntStream.rangeClosed(0, string.length()).mapToObj(n -> IntStream.rangeClosed(0, string2.length()).map(n2 -> { if (n == 0) { return n2; } if (n2 == 0) { return n; } return 0; }).toArray()).toArray(n -> new int[n][]); IntStream.range(1, string.length() + 1).forEach(n -> IntStream.range(1, string2.length() + 1).forEach(n2 -> { int n3 = string.charAt(n - 1) == string2.charAt(n2 - 1) ? 0 : 1; nArray[n][n2] = Math.min(nArray[n - 1][n2 - 1] + n3, Math.min(nArray[n][n2 - 1] + 1, nArray[n - 1][n2] + 1)); })); return nArray[string.length()][string2.length()]; } public static int optimizedLevenshteinDistance(String string, String string2) { if (string.isEmpty()) { return string2.length(); } int[] nArray = IntStream.rangeClosed(0, string.length()).toArray(); for (int i = 1; i <= string2.length(); ++i) { int n = nArray[0]; nArray[0] = i; for (int j = 1; j <= string.length(); ++j) { int n2 = nArray[j] + 1; int n3 = nArray[j - 1] + 1; int n4 = string.charAt(j - 1) == string2.charAt(i - 1) ? n : n + 1; n = nArray[j]; nArray[j] = Math.min(n2, Math.min(n3, n4)); } } return nArray[string.length()]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.stream.IntStream; /** * Provides functions to calculate the Levenshtein distance between two strings. * * The Levenshtein distance is a measure of the similarity between two strings by calculating the minimum number of single-character * edits (insertions, deletions, or substitutions) required to change one string into the other. */ public final class LevenshteinDistance { private LevenshteinDistance() { } /** * Calculates the Levenshtein distance between two strings using a naive dynamic programming approach. * * This function computes the Levenshtein distance by constructing a dynamic programming matrix and iteratively filling it in. * It follows the standard top-to-bottom, left-to-right approach for filling in the matrix. * * @param string1 The first string. * @param string2 The second string. * @return The Levenshtein distance between the two input strings. * * Time complexity: O(nm), * Space complexity: O(nm), * * where n and m are lengths of `string1` and `string2`. * * Note that this implementation uses a straightforward dynamic programming approach without any space optimization. * It may consume more memory for larger input strings compared to the optimized version. */ public static int naiveLevenshteinDistance(final String string1, final String string2) { int[][] distanceMatrix = IntStream.rangeClosed(0, string1.length()).mapToObj(i -> IntStream.rangeClosed(0, string2.length()).map(j -> (i == 0) ? j : (j == 0) ? i : 0).toArray()).toArray(int[][] ::new); IntStream.range(1, string1.length() + 1).forEach(i -> IntStream.range(1, string2.length() + 1).forEach(j -> { final int cost = (string1.charAt(i - 1) == string2.charAt(j - 1)) ? 0 : 1; distanceMatrix[i][j] = Math.min(distanceMatrix[i - 1][j - 1] + cost, Math.min(distanceMatrix[i][j - 1] + 1, distanceMatrix[i - 1][j] + 1)); })); return distanceMatrix[string1.length()][string2.length()]; } /** * Calculates the Levenshtein distance between two strings using an optimized dynamic programming approach. * * This edit distance is defined as 1 point per insertion, substitution, or deletion required to make the strings equal. * * @param string1 The first string. * @param string2 The second string. * @return The Levenshtein distance between the two input strings. * * Time complexity: O(nm), * Space complexity: O(n), * * where n and m are lengths of `string1` and `string2`. * * Note that this implementation utilizes an optimized dynamic programming approach, significantly reducing the space complexity from O(nm) to O(n), where n and m are the lengths of `string1` and `string2`. * * Additionally, it minimizes space usage by leveraging the shortest string horizontally and the longest string vertically in the computation matrix. */ public static int optimizedLevenshteinDistance(final String string1, final String string2) { if (string1.isEmpty()) { return string2.length(); } int[] previousDistance = IntStream.rangeClosed(0, string1.length()).toArray(); for (int j = 1; j <= string2.length(); j++) { int prevSubstitutionCost = previousDistance[0]; previousDistance[0] = j; for (int i = 1; i <= string1.length(); i++) { final int deletionCost = previousDistance[i] + 1; final int insertionCost = previousDistance[i - 1] + 1; final int substitutionCost = (string1.charAt(i - 1) == string2.charAt(j - 1)) ? prevSubstitutionCost : prevSubstitutionCost + 1; prevSubstitutionCost = previousDistance[i]; previousDistance[i] = Math.min(deletionCost, Math.min(insertionCost, substitutionCost)); } } return previousDistance[string1.length()]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.lineclipping; import com.thealgorithms.lineclipping.utils.Line; import com.thealgorithms.lineclipping.utils.Point; public class LiangBarsky { private double a; private double b; private double c; private double d; public LiangBarsky(double d, double d2, double d3, double d4) { this.a = d; this.c = d2; this.b = d3; this.d = d4; } public Line liangBarskyClip(Line line) { double[] dArray; double d; double d2; Object object; double d3; double d4; block6: { double[] dArray2; d4 = line.end.x - line.start.x; d3 = line.end.y - line.start.y; object = new double[]{-d4, d4, -d3, d3}; double[] dArray3 = dArray2 = new double[]{line.start.x - this.a, this.b - line.start.x, line.start.y - this.c, this.d - line.start.y}; d2 = 0.0; d = 1.0; for (int i = 0; i < 4; ++i) { double d5 = dArray3[i] / object[i]; if (object[i] == 0.0 && dArray3[i] < 0.0) { dArray = null; break block6; } if (object[i] < 0.0) { if (d5 > d) { dArray = null; break block6; } if (!(d5 > d2)) continue; d2 = d5; continue; } if (!(object[i] > 0.0)) continue; if (d5 < d2) { dArray = null; break block6; } if (!(d5 < d)) continue; d = d5; } double[] dArray4 = new double[2]; dArray4[0] = d2; dArray = dArray4; dArray4[1] = d; } object = dArray; if (dArray == null) { return null; } Line line2 = line; double d6 = d3; d = d4; d2 = object[1]; double d7 = object[0]; object = line2; double d8 = line2.start.x + d7 * d; double d9 = object.start.y + d7 * d6; double d10 = object.start.x + d2 * d; double d11 = object.start.y + d2 * d6; return new Line(new Point(d8, d9), new Point(d10, d11)); } }", "deobfuscated_code": "package com.thealgorithms.lineclipping; import com.thealgorithms.lineclipping.utils.Line; import com.thealgorithms.lineclipping.utils.Point; /** * @author shikarisohan * @since 10/5/24 * * * The Liang-Barsky line clipping algorithm is an efficient algorithm for * * line clipping against a rectangular window. It is based on the parametric * * equation of a line and checks the intersections of the line with the * * window boundaries. This algorithm calculates the intersection points, * * if any, and returns the clipped line that lies inside the window. * * * * Reference: * * https://en.wikipedia.org/wiki/Liang%E2%80%93Barsky_algorithm * * Clipping window boundaries are defined as (xMin, yMin) and (xMax, yMax). * The algorithm computes the clipped line segment if it's partially or * fully inside the clipping window. */ public class LiangBarsky { // Define the clipping window double xMin; double xMax; double yMin; double yMax; public LiangBarsky(double xMin, double yMin, double xMax, double yMax) { this.xMin = xMin; this.yMin = yMin; this.xMax = xMax; this.yMax = yMax; } // Liang-Barsky algorithm to return the clipped line public Line liangBarskyClip(Line line) { double dx = line.end.x - line.start.x; double dy = line.end.y - line.start.y; double[] p = {-dx, dx, -dy, dy}; double[] q = {line.start.x - xMin, xMax - line.start.x, line.start.y - yMin, yMax - line.start.y}; double[] resultT = clipLine(p, q); if (resultT == null) { return null; // Line is outside the clipping window } return calculateClippedLine(line, resultT[0], resultT[1], dx, dy); } // clip the line by adjusting t0 and t1 for each edge private double[] clipLine(double[] p, double[] q) { double t0 = 0.0; double t1 = 1.0; for (int i = 0; i < 4; i++) { double t = q[i] / p[i]; if (p[i] == 0 && q[i] < 0) { return null; // Line is outside the boundary } else if (p[i] < 0) { if (t > t1) { return null; } // Line is outside if (t > t0) { t0 = t; } // Update t0 } else if (p[i] > 0) { if (t < t0) { return null; } // Line is outside if (t < t1) { t1 = t; } // Update t1 } } return new double[] {t0, t1}; // Return valid t0 and t1 } // calculate the clipped line based on t0 and t1 private Line calculateClippedLine(Line line, double t0, double t1, double dx, double dy) { double clippedX1 = line.start.x + t0 * dx; double clippedY1 = line.start.y + t0 * dy; double clippedX2 = line.start.x + t1 * dx; double clippedY2 = line.start.y + t1 * dy; return new Line(new Point(clippedX1, clippedY1), new Point(clippedX2, clippedY2)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.lineclipping.utils; import com.thealgorithms.lineclipping.utils.Point; import java.util.Objects; public class Line { public Point start; public Point end; public Line() { } public Line(Point point, Point point2) { this.start = point; this.end = point2; } public boolean equals(Object object) { if (this == object) { return true; } if (!(object instanceof Line)) { return false; } object = (Line)object; return Objects.equals(this.start, ((Line)object).start) && Objects.equals(this.end, ((Line)object).end); } public int hashCode() { return Objects.hash(this.start, this.end); } public String toString() { return \"Line from \" + String.valueOf(this.start) + \" to \" + String.valueOf(this.end); } }", "deobfuscated_code": "package com.thealgorithms.lineclipping.utils; import java.util.Objects; /** * @author moksedursohan * @since 10/4/24 */ public class Line { public Point start; public Point end; public Line() { } public Line(Point start, Point end) { this.start = start; this.end = end; } @Override public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof Line line)) { return false; } return Objects.equals(start, line.start) && Objects.equals(end, line.end); } @Override public int hashCode() { return Objects.hash(start, end); } @Override public String toString() { return \"Line from \" + start + \" to \" + end; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Arrays; import java.util.Comparator; public final class LineSweep { private LineSweep() { } public static int findMaximumEndPoint(int[][] nArray2) { Arrays.sort(nArray2, Comparator.comparingInt(nArray -> nArray[1])); return nArray2[nArray2.length - 1][1]; } public static boolean isOverlap(int[][] nArray) { int n; int n2; if (nArray == null || nArray.length == 0) { return false; } int n3 = LineSweep.findMaximumEndPoint(nArray); int[] nArray2 = new int[n3 + 2]; for (int[] nArray3 : nArray) { n2 = nArray3[0]; n = nArray3[1]; int n4 = n2; nArray2[n4] = nArray2[n4] + 1; int n5 = n + 1; nArray2[n5] = nArray2[n5] - 1; } int n6 = 0; int n7 = 0; int[] nArray4 = nArray2; int n8 = nArray2.length; for (n2 = 0; n2 < n8; ++n2) { n = nArray4[n2]; n7 = Math.max(n7, n6 += n); } return n7 > 1; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Arrays; import java.util.Comparator; /** * The Line Sweep algorithm is used to solve range problems efficiently. It works by: * 1. Sorting a list of ranges by their start values in non-decreasing order. * 2. Sweeping through the number line (x-axis) while updating a count for each point based on the ranges. * * An overlapping range is defined as: * - (StartA <= EndB) AND (EndA >= StartB) * * References: * - https://en.wikipedia.org/wiki/Sweep_line_algorithm * - https://en.wikipedia.org/wiki/De_Morgan%27s_laws */ public final class LineSweep { private LineSweep() { } /** * Finds the maximum endpoint from a list of ranges. * * @param ranges a 2D array where each element is a range represented by [start, end] * @return the maximum endpoint among all ranges */ public static int findMaximumEndPoint(int[][] ranges) { Arrays.sort(ranges, Comparator.comparingInt(range -> range[1])); return ranges[ranges.length - 1][1]; } /** * Determines if any of the given ranges overlap. * * @param ranges a 2D array where each element is a range represented by [start, end] * @return true if any ranges overlap, false otherwise */ public static boolean isOverlap(int[][] ranges) { if (ranges == null || ranges.length == 0) { return false; } int maximumEndPoint = findMaximumEndPoint(ranges); int[] numberLine = new int[maximumEndPoint + 2]; for (int[] range : ranges) { int start = range[0]; int end = range[1]; numberLine[start] += 1; numberLine[end + 1] -= 1; } int currentCount = 0; int maxOverlaps = 0; for (int count : numberLine) { currentCount += count; maxOverlaps = Math.max(maxOverlaps, currentCount); } return maxOverlaps > 1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; public class LinearCongruentialGenerator { private final double a; private final double b; private final double c; private double d; public LinearCongruentialGenerator(double d, double d2, double d3) { this(System.currentTimeMillis(), d, d2, d3); } public LinearCongruentialGenerator(double d, double d2, double d3, double d4) { this.d = d; this.a = d2; this.b = d3; this.c = d4; } public double nextNumber() { this.d = (this.a * this.d + this.b) % this.c; return this.d; } public static void main(String[] object) { object = new LinearCongruentialGenerator(1664525.0, 1.013904223E9, Math.pow(2.0, 32.0)); for (int i = 0; i < 512; ++i) { System.out.println(((LinearCongruentialGenerator)object).nextNumber()); } } }", "deobfuscated_code": "package com.thealgorithms.others; /** * * * A pseudorandom number generator. * * @author Tobias Carryer * @date October 10, 2017 */ public class LinearCongruentialGenerator { private final double a; private final double c; private final double m; private double previousValue; /** * * * These parameters are saved and used when nextNumber() is called. The * current timestamp in milliseconds is used as the seed. * * @param multiplier * @param increment * @param modulo The maximum number that can be generated (exclusive). A * common value is 2^32. */ public LinearCongruentialGenerator(double multiplier, double increment, double modulo) { this(System.currentTimeMillis(), multiplier, increment, modulo); } /** * * * These parameters are saved and used when nextNumber() is called. * * @param seed * @param multiplier * @param increment * @param modulo The maximum number that can be generated (exclusive). A * common value is 2^32. */ public LinearCongruentialGenerator(double seed, double multiplier, double increment, double modulo) { this.previousValue = seed; this.a = multiplier; this.c = increment; this.m = modulo; } /** * The smallest number that can be generated is zero. The largest number * that can be generated is modulo-1. modulo is set in the constructor. * * @return a pseudorandom number. */ public double nextNumber() { previousValue = (a * previousValue + c) % m; return previousValue; } public static void main(String[] args) { // Show the LCG in action. // Decisive proof that the LCG works could be made by adding each number // generated to a Set while checking for duplicates. LinearCongruentialGenerator lcg = new LinearCongruentialGenerator(1664525, 1013904223, Math.pow(2.0, 32.0)); for (int i = 0; i < 512; i++) { System.out.println(lcg.nextNumber()); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; public final class LinearDiophantineEquationsSolver$Equation extends Record { private final int a; private final int b; private final int c; public LinearDiophantineEquationsSolver$Equation(int n, int n2, int n3) { this.a = n; this.b = n2; this.c = n3; } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{LinearDiophantineEquationsSolver$Equation.class, \"a;b;c\", \"a\", \"b\", \"c\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{LinearDiophantineEquationsSolver$Equation.class, \"a;b;c\", \"a\", \"b\", \"c\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{LinearDiophantineEquationsSolver$Equation.class, \"a;b;c\", \"a\", \"b\", \"c\"}, this, object); } public final int a() { return this.a; } public final int b() { return this.b; } public final int c() { return this.c; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; public final class LinearDiophantineEquationsSolver$Equation extends Record { private final int a; private final int b; private final int c; public LinearDiophantineEquationsSolver$Equation(int n, int n2, int n3) { this.a = n; this.b = n2; this.c = n3; } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{LinearDiophantineEquationsSolver$Equation.class, \"a;b;c\", \"a\", \"b\", \"c\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{LinearDiophantineEquationsSolver$Equation.class, \"a;b;c\", \"a\", \"b\", \"c\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{LinearDiophantineEquationsSolver$Equation.class, \"a;b;c\", \"a\", \"b\", \"c\"}, this, object); } public final int a() { return this.a; } public final int b() { return this.b; } public final int c() { return this.c; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.LinearDiophantineEquationsSolver$Solution; import java.util.Objects; public final class LinearDiophantineEquationsSolver$GcdSolutionWrapper { private int a; private LinearDiophantineEquationsSolver$Solution b; public LinearDiophantineEquationsSolver$GcdSolutionWrapper(int n, LinearDiophantineEquationsSolver$Solution solution) { this.a = n; this.b = solution; } public final boolean equals(Object object) { if (object == this) { return true; } if (object == null || object.getClass() != this.getClass()) { return false; } object = (LinearDiophantineEquationsSolver$GcdSolutionWrapper)object; return this.a == ((LinearDiophantineEquationsSolver$GcdSolutionWrapper)object).a && Objects.equals(this.b, ((LinearDiophantineEquationsSolver$GcdSolutionWrapper)object).b); } public final int getGcd() { return this.a; } public final void setGcd(int n) { this.a = n; } public final LinearDiophantineEquationsSolver$Solution getSolution() { return this.b; } public final void setSolution(LinearDiophantineEquationsSolver$Solution linearDiophantineEquationsSolver$Solution) { this.b = linearDiophantineEquationsSolver$Solution; } public final int hashCode() { return Objects.hash(this.a, this.b); } public final String toString() { return \"GcdSolutionWrapper[gcd=\" + this.a + \", solution=\" + String.valueOf(this.b) + \"]\"; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.LinearDiophantineEquationsSolver$Solution; import java.util.Objects; public final class LinearDiophantineEquationsSolver$GcdSolutionWrapper { private int a; private LinearDiophantineEquationsSolver$Solution b; public LinearDiophantineEquationsSolver$GcdSolutionWrapper(int n, LinearDiophantineEquationsSolver$Solution solution) { this.a = n; this.b = solution; } public final boolean equals(Object object) { if (object == this) { return true; } if (object == null || object.getClass() != this.getClass()) { return false; } object = (LinearDiophantineEquationsSolver$GcdSolutionWrapper)object; return this.a == ((LinearDiophantineEquationsSolver$GcdSolutionWrapper)object).a && Objects.equals(this.b, ((LinearDiophantineEquationsSolver$GcdSolutionWrapper)object).b); } public final int getGcd() { return this.a; } public final void setGcd(int n) { this.a = n; } public final LinearDiophantineEquationsSolver$Solution getSolution() { return this.b; } public final void setSolution(LinearDiophantineEquationsSolver$Solution linearDiophantineEquationsSolver$Solution) { this.b = linearDiophantineEquationsSolver$Solution; } public final int hashCode() { return Objects.hash(this.a, this.b); } public final String toString() { return \"GcdSolutionWrapper[gcd=\" + this.a + \", solution=\" + String.valueOf(this.b) + \"]\"; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.Objects; public final class LinearDiophantineEquationsSolver$Solution { public static final LinearDiophantineEquationsSolver$Solution NO_SOLUTION = new LinearDiophantineEquationsSolver$Solution(Integer.MAX_VALUE, Integer.MAX_VALUE); public static final LinearDiophantineEquationsSolver$Solution INFINITE_SOLUTIONS = new LinearDiophantineEquationsSolver$Solution(Integer.MIN_VALUE, Integer.MIN_VALUE); private int a; private int b; public LinearDiophantineEquationsSolver$Solution(int n, int n2) { this.a = n; this.b = n2; } public final int getX() { return this.a; } public final int getY() { return this.b; } public final void setX(int n) { this.a = n; } public final void setY(int n) { this.b = n; } public final boolean equals(Object object) { if (object == this) { return true; } if (object == null || object.getClass() != this.getClass()) { return false; } object = (LinearDiophantineEquationsSolver$Solution)object; return this.a == ((LinearDiophantineEquationsSolver$Solution)object).a && this.b == ((LinearDiophantineEquationsSolver$Solution)object).b; } public final int hashCode() { return Objects.hash(this.a, this.b); } public final String toString() { return \"Solution[x=\" + this.a + \", y=\" + this.b + \"]\"; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.Objects; public final class LinearDiophantineEquationsSolver$Solution { public static final LinearDiophantineEquationsSolver$Solution NO_SOLUTION = new LinearDiophantineEquationsSolver$Solution(Integer.MAX_VALUE, Integer.MAX_VALUE); public static final LinearDiophantineEquationsSolver$Solution INFINITE_SOLUTIONS = new LinearDiophantineEquationsSolver$Solution(Integer.MIN_VALUE, Integer.MIN_VALUE); private int a; private int b; public LinearDiophantineEquationsSolver$Solution(int n, int n2) { this.a = n; this.b = n2; } public final int getX() { return this.a; } public final int getY() { return this.b; } public final void setX(int n) { this.a = n; } public final void setY(int n) { this.b = n; } public final boolean equals(Object object) { if (object == this) { return true; } if (object == null || object.getClass() != this.getClass()) { return false; } object = (LinearDiophantineEquationsSolver$Solution)object; return this.a == ((LinearDiophantineEquationsSolver$Solution)object).a && this.b == ((LinearDiophantineEquationsSolver$Solution)object).b; } public final int hashCode() { return Objects.hash(this.a, this.b); } public final String toString() { return \"Solution[x=\" + this.a + \", y=\" + this.b + \"]\"; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.LinearDiophantineEquationsSolver$Equation; import com.thealgorithms.maths.LinearDiophantineEquationsSolver$GcdSolutionWrapper; import com.thealgorithms.maths.LinearDiophantineEquationsSolver$Solution; public final class LinearDiophantineEquationsSolver { private LinearDiophantineEquationsSolver() { } public static void main(String[] object) { object = new LinearDiophantineEquationsSolver$Equation(3, 4, 7); System.out.println(LinearDiophantineEquationsSolver.findAnySolution((LinearDiophantineEquationsSolver$Equation)object)); } public static LinearDiophantineEquationsSolver$Solution findAnySolution(LinearDiophantineEquationsSolver$Equation linearDiophantineEquationsSolver$Equation) { if (linearDiophantineEquationsSolver$Equation.a() == 0 && linearDiophantineEquationsSolver$Equation.b() == 0 && linearDiophantineEquationsSolver$Equation.c() == 0) { return LinearDiophantineEquationsSolver$Solution.INFINITE_SOLUTIONS; } LinearDiophantineEquationsSolver$GcdSolutionWrapper linearDiophantineEquationsSolver$GcdSolutionWrapper = new LinearDiophantineEquationsSolver$GcdSolutionWrapper(0, new LinearDiophantineEquationsSolver$Solution(0, 0)); Object object = LinearDiophantineEquationsSolver.a(linearDiophantineEquationsSolver$Equation.a(), linearDiophantineEquationsSolver$Equation.b(), linearDiophantineEquationsSolver$GcdSolutionWrapper); if (linearDiophantineEquationsSolver$Equation.c() % ((LinearDiophantineEquationsSolver$GcdSolutionWrapper)object).getGcd() != 0) { return LinearDiophantineEquationsSolver$Solution.NO_SOLUTION; } object = new LinearDiophantineEquationsSolver$Solution(0, 0); int n = linearDiophantineEquationsSolver$GcdSolutionWrapper.getSolution().getX() * (linearDiophantineEquationsSolver$Equation.c() / linearDiophantineEquationsSolver$GcdSolutionWrapper.getGcd()); int n2 = linearDiophantineEquationsSolver$GcdSolutionWrapper.getSolution().getY() * (linearDiophantineEquationsSolver$Equation.c() / linearDiophantineEquationsSolver$GcdSolutionWrapper.getGcd()); ((LinearDiophantineEquationsSolver$Solution)object).setX(n); ((LinearDiophantineEquationsSolver$Solution)object).setY(n2); return object; } private static LinearDiophantineEquationsSolver$GcdSolutionWrapper a(int n, int n2, LinearDiophantineEquationsSolver$GcdSolutionWrapper linearDiophantineEquationsSolver$GcdSolutionWrapper) { if (n2 == 0) { return new LinearDiophantineEquationsSolver$GcdSolutionWrapper(n, new LinearDiophantineEquationsSolver$Solution(1, 0)); } LinearDiophantineEquationsSolver$GcdSolutionWrapper linearDiophantineEquationsSolver$GcdSolutionWrapper2 = new LinearDiophantineEquationsSolver$GcdSolutionWrapper(0, new LinearDiophantineEquationsSolver$Solution(0, 0)); linearDiophantineEquationsSolver$GcdSolutionWrapper2 = LinearDiophantineEquationsSolver.a(n2, n % n2, linearDiophantineEquationsSolver$GcdSolutionWrapper2); linearDiophantineEquationsSolver$GcdSolutionWrapper.getSolution().setX(linearDiophantineEquationsSolver$GcdSolutionWrapper2.getSolution().getY()); linearDiophantineEquationsSolver$GcdSolutionWrapper.getSolution().setY(linearDiophantineEquationsSolver$GcdSolutionWrapper2.getSolution().getX() - n / n2 * linearDiophantineEquationsSolver$GcdSolutionWrapper2.getSolution().getY()); linearDiophantineEquationsSolver$GcdSolutionWrapper.setGcd(linearDiophantineEquationsSolver$GcdSolutionWrapper2.getGcd()); return new LinearDiophantineEquationsSolver$GcdSolutionWrapper(linearDiophantineEquationsSolver$GcdSolutionWrapper2.getGcd(), linearDiophantineEquationsSolver$GcdSolutionWrapper.getSolution()); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.Objects; public final class LinearDiophantineEquationsSolver { private LinearDiophantineEquationsSolver() { } public static void main(String[] args) { // 3x + 4y = 7 final var toSolve = new Equation(3, 4, 7); System.out.println(findAnySolution(toSolve)); } public static Solution findAnySolution(final Equation equation) { if (equation.a() == 0 && equation.b() == 0 && equation.c() == 0) { return Solution.INFINITE_SOLUTIONS; } final var stub = new GcdSolutionWrapper(0, new Solution(0, 0)); final var gcdSolution = gcd(equation.a(), equation.b(), stub); if (equation.c() % gcdSolution.getGcd() != 0) { return Solution.NO_SOLUTION; } final var toReturn = new Solution(0, 0); var xToSet = stub.getSolution().getX() * (equation.c() / stub.getGcd()); var yToSet = stub.getSolution().getY() * (equation.c() / stub.getGcd()); toReturn.setX(xToSet); toReturn.setY(yToSet); return toReturn; } private static GcdSolutionWrapper gcd(final int a, final int b, final GcdSolutionWrapper previous) { if (b == 0) { return new GcdSolutionWrapper(a, new Solution(1, 0)); } // stub wrapper becomes the `previous` of the next recursive call final var stubWrapper = new GcdSolutionWrapper(0, new Solution(0, 0)); final var next = /* recursive call */ gcd(b, a % b, stubWrapper); previous.getSolution().setX(next.getSolution().getY()); previous.getSolution().setY(next.getSolution().getX() - (a / b) * (next.getSolution().getY())); previous.setGcd(next.getGcd()); return new GcdSolutionWrapper(next.getGcd(), previous.getSolution()); } public static final class Solution { public static final Solution NO_SOLUTION = new Solution(Integer.MAX_VALUE, Integer.MAX_VALUE); public static final Solution INFINITE_SOLUTIONS = new Solution(Integer.MIN_VALUE, Integer.MIN_VALUE); private int x; private int y; public Solution(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } @Override public boolean equals(Object obj) { if (obj == this) { return true; } if (obj == null || obj.getClass() != this.getClass()) { return false; } var that = (Solution) obj; return this.x == that.x && this.y == that.y; } @Override public int hashCode() { return Objects.hash(x, y); } @Override public String toString() { return \"Solution[\" + \"x=\" + x + \", \" + \"y=\" + y + ']'; } } public record Equation(int a, int b, int c) { } public static final class GcdSolutionWrapper { private int gcd; private Solution solution; public GcdSolutionWrapper(int gcd, Solution solution) { this.gcd = gcd; this.solution = solution; } @Override public boolean equals(Object obj) { if (obj == this) { return true; } if (obj == null || obj.getClass() != this.getClass()) { return false; } var that = (GcdSolutionWrapper) obj; return (this.gcd == that.gcd && Objects.equals(this.solution, that.solution)); } public int getGcd() { return gcd; } public void setGcd(int gcd) { this.gcd = gcd; } public Solution getSolution() { return solution; } public void setSolution(Solution solution) { this.solution = solution; } @Override public int hashCode() { return Objects.hash(gcd, solution); } @Override public String toString() { return (\"GcdSolutionWrapper[\" + \"gcd=\" + gcd + \", \" + \"solution=\" + solution + ']'); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import com.thealgorithms.datastructures.hashmap.hashing.Map; public class LinearProbingHashMap extends Map { private int a; private Comparable[] b; private Object[] c; private int d; public LinearProbingHashMap() { this(16); } public LinearProbingHashMap(int n) { this.a = n; this.b = new Comparable[n]; this.c = new Object[n]; } public boolean put(Comparable comparable, Object object) { if (comparable == null) { return false; } if (this.d > this.a / 2) { this.b(2 * this.a); } int n = LinearProbingHashMap.a(comparable, this.a); while (this.b[n] != null) { if (comparable.equals(this.b[n])) { this.c[n] = object; return true; } n = this.a(n); } this.b[n] = comparable; this.c[n] = object; ++this.d; return true; } public Object get(Comparable comparable) { if (comparable == null) { return null; } int n = LinearProbingHashMap.a(comparable, this.a); while (this.b[n] != null) { if (comparable.equals(this.b[n])) { return this.c[n]; } n = this.a(n); } return null; } public boolean delete(Comparable comparable) { if (comparable == null || !this.contains(comparable)) { return false; } int n = LinearProbingHashMap.a(comparable, this.a); while (!comparable.equals(this.b[n])) { n = this.a(n); } this.b[n] = null; this.c[n] = null; n = this.a(n); while (this.b[n] != null) { comparable = this.b[n]; Object object = this.c[n]; this.b[n] = null; this.c[n] = null; --this.d; this.put(comparable, object); n = this.a(n); } --this.d; if (this.d > 0 && this.d <= this.a / 8) { LinearProbingHashMap linearProbingHashMap = this; linearProbingHashMap.b(linearProbingHashMap.a / 2); } return true; } public boolean contains(Comparable comparable) { return this.get(comparable) != null; } private int a(int n) { return (n + 1) % this.a; } private void b(int n) { LinearProbingHashMap linearProbingHashMap = new LinearProbingHashMap(n); for (int i = 0; i < this.a; ++i) { if (this.b[i] == null) continue; linearProbingHashMap.put(this.b[i], this.c[i]); } this.b = linearProbingHashMap.b; this.c = linearProbingHashMap.c; this.a = n; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.hashmap.hashing; import java.util.ArrayList; /** * This class implements a hash table using linear probing to resolve collisions. * Linear probing is a collision resolution method where each slot in the hash table is checked in a sequential manner * until an empty slot is found. * * <p> * The class allows for storing key-value pairs, where both the key and value are generic types. * The key must be of a type that implements the Comparable interface to ensure that the keys can be compared for sorting. * </p> * * <p> * This implementation supports basic operations such as: * <ul> * <li><b>put(Key key, Value value)</b>: Adds a key-value pair to the hash table. If the key already exists, its value is updated.</li> * <li><b>get(Key key)</b>: Retrieves the value associated with the given key.</li> * <li><b>delete(Key key)</b>: Removes the key and its associated value from the hash table.</li> * <li><b>contains(Key key)</b>: Checks if the hash table contains a given key.</li> * <li><b>size()</b>: Returns the number of key-value pairs in the hash table.</li> * <li><b>keys()</b>: Returns an iterable collection of keys stored in the hash table.</li> * </ul> * </p> * * <p> * The internal size of the hash table is automatically resized when the load factor exceeds 0.5 or falls below 0.125, * ensuring efficient space utilization. * </p> * * @see <a href=\"https://en.wikipedia.org/wiki/Linear_probing\">Linear Probing Hash Table</a> * * @param <Key> the type of keys maintained by this map * @param <Value> the type of mapped values */ @SuppressWarnings(\"rawtypes\") public class LinearProbingHashMap<Key extends Comparable<Key>, Value> extends Map<Key, Value> { private int hsize; // size of the hash table private Key[] keys; // array to store keys private Value[] values; // array to store values private int size; // number of elements in the hash table // Default constructor initializes the table with a default size of 16 public LinearProbingHashMap() { this(16); } @SuppressWarnings(\"unchecked\") // Constructor to initialize the hash table with a specified size public LinearProbingHashMap(int size) { this.hsize = size; keys = (Key[]) new Comparable[size]; values = (Value[]) new Object[size]; } @Override public boolean put(Key key, Value value) { if (key == null) { return false; } if (size > hsize / 2) { resize(2 * hsize); } int keyIndex = hash(key, hsize); for (; keys[keyIndex] != null; keyIndex = increment(keyIndex)) { if (key.equals(keys[keyIndex])) { values[keyIndex] = value; return true; } } keys[keyIndex] = key; values[keyIndex] = value; size++; return true; } @Override public Value get(Key key) { if (key == null) { return null; } for (int i = hash(key, hsize); keys[i] != null; i = increment(i)) { if (key.equals(keys[i])) { return values[i]; } } return null; } @Override public boolean delete(Key key) { if (key == null || !contains(key)) { return false; } int i = hash(key, hsize); while (!key.equals(keys[i])) { i = increment(i); } keys[i] = null; values[i] = null; i = increment(i); while (keys[i] != null) { // Save the key and value for rehashing Key keyToRehash = keys[i]; Value valToRehash = values[i]; keys[i] = null; values[i] = null; size--; put(keyToRehash, valToRehash); i = increment(i); } size--; if (size > 0 && size <= hsize / 8) { resize(hsize / 2); } return true; } @Override public boolean contains(Key key) { return get(key) != null; } @Override int size() { return size; } @Override Iterable<Key> keys() { ArrayList<Key> listOfKeys = new ArrayList<>(size); for (int i = 0; i < hsize; i++) { if (keys[i] != null) { listOfKeys.add(keys[i]); } } listOfKeys.sort(Comparable::compareTo); return listOfKeys; } private int increment(int i) { return (i + 1) % hsize; } private void resize(int newSize) { LinearProbingHashMap<Key, Value> tmp = new LinearProbingHashMap<>(newSize); for (int i = 0; i < hsize; i++) { if (keys[i] != null) { tmp.put(keys[i], values[i]); } } this.keys = tmp.keys; this.values = tmp.values; this.hsize = newSize; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; public class LinearSearch implements SearchAlgorithm { @Override public int find(Comparable[] comparableArray, Comparable comparable) { for (int i = 0; i < comparableArray.length; ++i) { if (comparableArray[i].compareTo(comparable) != 0) continue; return i; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; /** * Linear search is the easiest search algorithm It works with sorted and * unsorted arrays (an binary search works only with sorted array) This * algorithm just compares all elements of an array to find a value * * <p> * Worst-case performance O(n) Best-case performance O(1) Average performance * O(n) Worst-case space complexity * * @author Varun Upadhyay (https://github.com/varunu28) * @author Podshivalov Nikita (https://github.com/nikitap492) * @see BinarySearch * @see SearchAlgorithm */ public class LinearSearch implements SearchAlgorithm { /** * Generic Linear search method * * @param array List to be searched * @param value Key being searched for * @return Location of the key */ @Override public <T extends Comparable<T>> int find(T[] array, T value) { for (int i = 0; i < array.length; i++) { if (array[i].compareTo(value) == 0) { return i; } } return -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; public final class LinearSearchThread { private LinearSearchThread() { } }", "deobfuscated_code": "package com.thealgorithms.searches; /** * LinearSearchThread is a multithreaded implementation of the linear search algorithm. * It creates multiple threads to search for a specific number in an array. * * <p> * The class generates an array of random integers, prompts the user to enter a number to search for, * and divides the array into four segments, each handled by a separate thread. * The threads run concurrently and search for the specified number within their designated segments. * Finally, it consolidates the results to determine if the number was found. * </p> * * <p> * Example usage: * 1. The program will output the generated array. * 2. The user will be prompted to input a number to search for. * 3. The program will display whether the number was found in the array. * </p> */ public final class LinearSearchThread { private LinearSearchThread() { } } /** * The Searcher class extends Thread and is responsible for searching for a specific * number in a segment of an array. */ class Searcher extends Thread { private final int[] arr; // The array to search in private final int left; // Starting index of the segment private final int right; // Ending index of the segment private final int x; // The number to search for private boolean found; // Result flag /** * Constructor to initialize the Searcher. * * @param arr The array to search in * @param left The starting index of the segment * @param right The ending index of the segment * @param x The number to search for */ Searcher(int[] arr, int left, int right, int x) { this.arr = arr; this.left = left; this.right = right; this.x = x; } /** * The run method for the thread, performing the linear search in its segment. */ @Override public void run() { int k = left; found = false; while (k < right && !found) { if (arr[k++] == x) { found = true; } } } /** * Returns whether the number was found in the segment. * * @return true if the number was found, false otherwise */ boolean getResult() { return found; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.DoublyLinkedList; import com.thealgorithms.datastructures.lists.LinkOperations; class Link { public int value; public Link next; public Link previous; Link(int n) { this.value = n; } public void displayLink() { System.out.print(this.value + \" \"); } public static void main(String[] object) { object = new DoublyLinkedList(); LinkOperations linkOperations = new LinkOperations(); linkOperations.insertHead(13, (DoublyLinkedList)object); linkOperations.insertHead(7, (DoublyLinkedList)object); linkOperations.insertHead(10, (DoublyLinkedList)object); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.insertTail(11, (DoublyLinkedList)object); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.deleteTail(); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.delete(7); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.insertOrdered(23, (DoublyLinkedList)object); linkOperations.insertOrdered(67, (DoublyLinkedList)object); linkOperations.insertOrdered(3, (DoublyLinkedList)object); ((DoublyLinkedList)object).display(); linkOperations.insertElementByIndex(5, 1, (DoublyLinkedList)object); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.reverse(); ((DoublyLinkedList)object).display(); linkOperations.clearList(); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.insertHead(20, (DoublyLinkedList)object); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.DoublyLinkedList; import com.thealgorithms.datastructures.lists.LinkOperations; class Link { public int value; public Link next; public Link previous; Link(int n) { this.value = n; } public void displayLink() { System.out.print(this.value + \" \"); } public static void main(String[] object) { object = new DoublyLinkedList(); LinkOperations linkOperations = new LinkOperations(); linkOperations.insertHead(13, (DoublyLinkedList)object); linkOperations.insertHead(7, (DoublyLinkedList)object); linkOperations.insertHead(10, (DoublyLinkedList)object); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.insertTail(11, (DoublyLinkedList)object); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.deleteTail(); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.delete(7); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.insertOrdered(23, (DoublyLinkedList)object); linkOperations.insertOrdered(67, (DoublyLinkedList)object); linkOperations.insertOrdered(3, (DoublyLinkedList)object); ((DoublyLinkedList)object).display(); linkOperations.insertElementByIndex(5, 1, (DoublyLinkedList)object); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.reverse(); ((DoublyLinkedList)object).display(); linkOperations.clearList(); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); linkOperations.insertHead(20, (DoublyLinkedList)object); ((DoublyLinkedList)object).display(); ((DoublyLinkedList)object).displayBackwards(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.Node; import com.thealgorithms.sorts.Task; import com.thealgorithms.sorts.Task1; import com.thealgorithms.sorts.Task2; import java.util.Arrays; public class LinkListSort { public static boolean isSorted(int[] nArray, int n) { int[] nArray2 = nArray; switch (n) { case 1: { int n2; Object object = new Task(); Node node = null; Node node2 = null; for (n2 = 0; n2 < nArray2.length; ++n2) { Node node3 = new Node(); new Node().a = nArray2[n2]; if (node == null) { node = node3; } else { node2.b = node3; } node2 = node3; } node = ((Task)object).sortByMergeSort(node); n2 = 0; object = node; while (object != null) { nArray2[n2++] = ((Node)object).a; object = ((Node)object).b; } Arrays.sort(nArray); new LinkListSort(); return LinkListSort.a(nArray2, nArray); } case 2: { Node node = null; Node node4 = null; for (int i = 0; i < nArray2.length; ++i) { Node node5 = new Node(); new Node().a = nArray2[i]; if (node == null) { node = node5; } else { node4.b = node5; } node4 = node5; } Task1 task1 = new Task1(); node = task1.sortByInsertionSort(node); int n3 = 0; while (node != null) { nArray2[n3++] = node.a; node = node.b; } new LinkListSort(); return LinkListSort.a(nArray2, nArray); } case 3: { int n4; Object object = new Task2(); Node node = null; Node node6 = null; for (n4 = 0; n4 < nArray2.length; ++n4) { Node node7 = new Node(); new Node().a = nArray2[n4]; if (node == null) { node = node7; } else { node6.b = node7; } node6 = node7; } node = ((Task2)object).sortByHeapSort(node); n4 = 0; object = node; while (object != null) { nArray2[n4++] = ((Node)object).a; object = ((Node)object).b; } Arrays.sort(nArray); new LinkListSort(); return LinkListSort.a(nArray2, nArray); } } System.out.println(\"Wrong choice\"); return false; } private static boolean a(int[] nArray, int[] nArray2) { for (int i = 0; i < nArray.length; ++i) { if (nArray[i] == nArray2[i]) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.Arrays; /** * @author <a href=\"https://github.com/siddhant2002\">Siddhant Swarup Mallick</a> * Program description - To sort the LinkList as per sorting technique */ public class LinkListSort { public static boolean isSorted(int[] p, int option) { int[] a = p; // Array is taken as input from test class int[] b = p; // array similar to a int ch = option; // Choice is choosed as any number from 1 to 3 (So the linked list will be // sorted by Merge sort technique/Insertion sort technique/Heap sort technique) switch (ch) { case 1: Task nm = new Task(); Node start = null; Node prev = null; Node fresh; Node ptr; for (int i = 0; i < a.length; i++) { // New nodes are created and values are added fresh = new Node(); // Node class is called fresh.val = a[i]; // Node val is stored if (start == null) { start = fresh; } else { prev.next = fresh; } prev = fresh; } start = nm.sortByMergeSort(start); // method is being called int i = 0; for (ptr = start; ptr != null; ptr = ptr.next) { a[i++] = ptr.val; // storing the sorted values in the array } Arrays.sort(b); // array b is sorted and it will return true when checked with sorted list LinkListSort uu = new LinkListSort(); return uu.compare(a, b); // The given array and the expected array is checked if both are same then true // is displayed else false is displayed case 2: Node start1 = null; Node prev1 = null; Node fresh1; Node ptr1; for (int i1 = 0; i1 < a.length; i1++) { // New nodes are created and values are added fresh1 = new Node(); // New node is created fresh1.val = a[i1]; // Value is stored in the value part of the node if (start1 == null) { start1 = fresh1; } else { prev1.next = fresh1; } prev1 = fresh1; } Task1 kk = new Task1(); start1 = kk.sortByInsertionSort(start1); // method is being called int i1 = 0; for (ptr1 = start1; ptr1 != null; ptr1 = ptr1.next) { a[i1++] = ptr1.val; // storing the sorted values in the array } LinkListSort uu1 = new LinkListSort(); // array b is not sorted and it will return false when checked with sorted list return uu1.compare(a, b); // The given array and the expected array is checked if both are same then true // is displayed else false is displayed case 3: Task2 mm = new Task2(); Node start2 = null; Node prev2 = null; Node fresh2; Node ptr2; for (int i2 = 0; i2 < a.length; i2++) { // New nodes are created and values are added fresh2 = new Node(); // Node class is created fresh2.val = a[i2]; // Value is stored in the value part of the Node if (start2 == null) { start2 = fresh2; } else { prev2.next = fresh2; } prev2 = fresh2; } start2 = mm.sortByHeapSort(start2); // method is being called int i3 = 0; for (ptr2 = start2; ptr2 != null; ptr2 = ptr2.next) { a[i3++] = ptr2.val; // storing the sorted values in the array } Arrays.sort(b); // array b is sorted and it will return true when checked with sorted list LinkListSort uu2 = new LinkListSort(); return uu2.compare(a, b); // The given array and the expected array is checked if both are same then true // is displayed else false is displayed default: // default is used incase user puts a unauthorized value System.out.println(\"Wrong choice\"); } // Switch case is used to call the classes as per the user requirement return false; } /** * OUTPUT : * Input - {89,56,98,123,26,75,12,40,39,68,91} is same for all the 3 classes * Output: [12 26 39 40 56 68 75 89 91 98 123] is same for all the 3 classes * 1st approach Time Complexity : O(n logn) * Auxiliary Space Complexity : O(n) * 2nd approach Time Complexity : O(n^2) * Auxiliary Space Complexity : O(n) * 3rd approach Time Complexity : O(n logn) * Auxiliary Space Complexity : O(n) */ boolean compare(int[] a, int[] b) { for (int i = 0; i < a.length; i++) { if (a[i] != b[i]) { return false; } } return true; // Both the arrays are checked for equalness. If both are equal then true is // returned else false is returned } } class Node { int val; Node next; // Node class for creation of linklist nodes } class Task { private int[] a; public Node sortByMergeSort(Node head) { if (head == null || head.next == null) { return head; } int c = count(head); a = new int[c]; // Array of size c is created int i = 0; for (Node ptr = head; ptr != null; ptr = ptr.next) { a[i++] = ptr.val; } // values are stored in the array i = 0; task(a, 0, c - 1); // task method will be executed for (Node ptr = head; ptr != null; ptr = ptr.next) { ptr.val = a[i++]; // Value is stored in the linklist after being sorted } return head; } int count(Node head) { int c = 0; Node ptr; for (ptr = head; ptr != null; ptr = ptr.next) { c++; } return c; // This Method is used to count number of elements/nodes present in the linklist // It will return a integer type value denoting the number of nodes present } void task(int[] n, int i, int j) { if (i < j) { int m = (i + j) / 2; task(n, i, m); task(n, m + 1, j); task1(n, i, m, j); // Array is halved and sent for sorting } } void task1(int[] n, int s, int m, int e) { int i = s; int k = 0; int j = m + 1; int[] b = new int[e - s + 1]; while (i <= m && j <= e) { if (n[j] >= n[i]) { b[k++] = n[i++]; } else { b[k++] = n[j++]; } } // Smallest number is stored after checking from both the arrays while (i <= m) { b[k++] = n[i++]; } while (j <= e) { b[k++] = n[j++]; } for (int p = s; p <= e; p++) { a[p] = b[p - s]; } } // The method task and task1 is used to sort the linklist using merge sort } class Task1 { public Node sortByInsertionSort(Node head) { if (head == null || head.next == null) { return head; } int c = count(head); int[] a = new int[c]; // Array of size c is created a[0] = head.val; int i; Node ptr; for (ptr = head.next, i = 1; ptr != null; ptr = ptr.next, i++) { int j = i - 1; while (j >= 0 && a[j] > ptr.val) { // values are stored in the array a[j + 1] = a[j]; j--; } a[j + 1] = ptr.val; } i = 0; for (ptr = head; ptr != null; ptr = ptr.next) { ptr.val = a[i++]; // Value is stored in the linklist after being sorted } return head; } static int count(Node head) { Node ptr; int c = 0; for (ptr = head; ptr != null; ptr = ptr.next) { c++; } return c; // This Method is used to count number of elements/nodes present in the linklist // It will return a integer type value denoting the number of nodes present } // The method task and task1 is used to sort the linklist using insertion sort } class Task2 { public Node sortByHeapSort(Node head) { if (head == null || head.next == null) { return head; } int c = count(head); int[] a = new int[c]; // Array of size c is created int i = 0; for (Node ptr = head; ptr != null; ptr = ptr.next) { a[i++] = ptr.val; // values are stored in the array } i = 0; task(a); for (Node ptr = head; ptr != null; ptr = ptr.next) { ptr.val = a[i++]; // Value is stored in the linklist after being sorted } return head; } int count(Node head) { int c = 0; Node ptr; for (ptr = head; ptr != null; ptr = ptr.next) { c++; } return c; // This Method is used to count number of elements/nodes present in the linklist // It will return a integer type value denoting the number of nodes present } void task(int[] n) { int k = n.length; for (int i = k / 2 - 1; i >= 0; i--) { task1(n, k, i); } for (int i = k - 1; i > 0; i--) { int d = n[0]; n[0] = n[i]; n[i] = d; task1(n, i, 0); // recursive calling of task1 method } } void task1(int[] n, int k, int i) { int p = i; int l = 2 * i + 1; int r = 2 * i + 2; if (l < k && n[l] > n[p]) { p = l; } if (r < k && n[r] > n[p]) { p = r; } if (p != i) { int d = n[p]; n[p] = n[i]; n[i] = d; task1(n, k, p); } } // The method task and task1 is used to sort the linklist using heap sort }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.DoublyLinkedList; import com.thealgorithms.datastructures.lists.Link; class LinkOperations { private Link a; private Link b; private int c; LinkOperations() { } public void insertHead(int n, DoublyLinkedList doublyLinkedList) { Link link = new Link(n); if (doublyLinkedList.isEmpty()) { this.b = link; } else { this.a.previous = link; } link.next = this.a; this.a = link; ++this.c; } public void insertTail(int n, DoublyLinkedList doublyLinkedList) { Link link = new Link(n); new Link(n).next = null; if (doublyLinkedList.isEmpty()) { this.a = this.b = link; } else { this.b.next = link; link.previous = this.b; this.b = link; } ++this.c; } public void insertElementByIndex(int n, int n2, DoublyLinkedList object) { if (n2 > this.c) { throw new IndexOutOfBoundsException(\"Index: \" + n2 + \", Size: \" + this.c); } if (n2 == 0) { this.insertHead(n, (DoublyLinkedList)object); } else if (n2 == this.c) { this.insertTail(n, (DoublyLinkedList)object); } else { Link link = new Link(n); object = this.a; for (int i = 1; i < n2; ++i) { object = ((Link)object).next; } ((Link)object).next.previous = link; link.next = ((Link)object).next; link.previous = object; ((Link)object).next = link; } ++this.c; } public Link deleteHead() { Link link = this.a; this.a = this.a.next; if (this.a == null) { this.b = null; } else { this.a.previous = null; } --this.c; return link; } public Link deleteTail() { Link link = this.b; this.b = this.b.previous; if (this.b == null) { this.a = null; } else { this.b.next = null; } --this.c; return link; } public void delete(int n) { Link link = this.a; while (link.value != n) { if (link != this.b) { link = link.next; continue; } throw new RuntimeException(\"The element to be deleted does not exist!\"); } if (link == this.a) { this.deleteHead(); } else if (link == this.b) { this.deleteTail(); } else { link.previous.next = link.next; link.next.previous = link.previous; } --this.c; } public void insertOrdered(int n, DoublyLinkedList doublyLinkedList) { Link link = new Link(n); Link link2 = this.a; while (link2 != null && n > link2.value) { link2 = link2.next; } if (link2 == this.a) { this.insertHead(n, doublyLinkedList); } else if (link2 == null) { this.insertTail(n, doublyLinkedList); } else { link.previous = link2.previous; link2.previous.next = link; link.next = link2; link2.previous = link; } ++this.c; } public void deleteNode(Link link) { if (link.next == null) { this.deleteTail(); } else if (link == this.a) { this.deleteHead(); } else { link.previous.next = link.next; link.next.previous = link.previous; } --this.c; } public void removeDuplicates(DoublyLinkedList object) { object = ((DoublyLinkedList)object).a; while (((Link)object).next != null) { Link link = ((Link)object).next; while (link.next != null) { if (((Link)object).value == link.value) { this.delete(link.value); } link = link.next; } object = ((Link)object).next; } } public void reverse() { Link link; Link link2 = this.a; this.a = link = this.b; this.b = link2; while (link2 != null) { Link link3; link = link2.next; link2.next = link3 = link2.previous; link2.previous = link; link2 = link; } } public void clearList() { this.a = null; this.b = null; this.c = 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.DoublyLinkedList; import com.thealgorithms.datastructures.lists.Link; class LinkOperations { private Link a; private Link b; private int c; LinkOperations() { } public void insertHead(int n, DoublyLinkedList doublyLinkedList) { Link link = new Link(n); if (doublyLinkedList.isEmpty()) { this.b = link; } else { this.a.previous = link; } link.next = this.a; this.a = link; ++this.c; } public void insertTail(int n, DoublyLinkedList doublyLinkedList) { Link link = new Link(n); new Link(n).next = null; if (doublyLinkedList.isEmpty()) { this.a = this.b = link; } else { this.b.next = link; link.previous = this.b; this.b = link; } ++this.c; } public void insertElementByIndex(int n, int n2, DoublyLinkedList object) { if (n2 > this.c) { throw new IndexOutOfBoundsException(\"Index: \" + n2 + \", Size: \" + this.c); } if (n2 == 0) { this.insertHead(n, (DoublyLinkedList)object); } else if (n2 == this.c) { this.insertTail(n, (DoublyLinkedList)object); } else { Link link = new Link(n); object = this.a; for (int i = 1; i < n2; ++i) { object = ((Link)object).next; } ((Link)object).next.previous = link; link.next = ((Link)object).next; link.previous = object; ((Link)object).next = link; } ++this.c; } public Link deleteHead() { Link link = this.a; this.a = this.a.next; if (this.a == null) { this.b = null; } else { this.a.previous = null; } --this.c; return link; } public Link deleteTail() { Link link = this.b; this.b = this.b.previous; if (this.b == null) { this.a = null; } else { this.b.next = null; } --this.c; return link; } public void delete(int n) { Link link = this.a; while (link.value != n) { if (link != this.b) { link = link.next; continue; } throw new RuntimeException(\"The element to be deleted does not exist!\"); } if (link == this.a) { this.deleteHead(); } else if (link == this.b) { this.deleteTail(); } else { link.previous.next = link.next; link.next.previous = link.previous; } --this.c; } public void insertOrdered(int n, DoublyLinkedList doublyLinkedList) { Link link = new Link(n); Link link2 = this.a; while (link2 != null && n > link2.value) { link2 = link2.next; } if (link2 == this.a) { this.insertHead(n, doublyLinkedList); } else if (link2 == null) { this.insertTail(n, doublyLinkedList); } else { link.previous = link2.previous; link2.previous.next = link; link.next = link2; link2.previous = link; } ++this.c; } public void deleteNode(Link link) { if (link.next == null) { this.deleteTail(); } else if (link == this.a) { this.deleteHead(); } else { link.previous.next = link.next; link.next.previous = link.previous; } --this.c; } public void removeDuplicates(DoublyLinkedList object) { object = ((DoublyLinkedList)object).a; while (((Link)object).next != null) { Link link = ((Link)object).next; while (link.next != null) { if (((Link)object).value == link.value) { this.delete(link.value); } link = link.next; } object = ((Link)object).next; } } public void reverse() { Link link; Link link2 = this.a; this.a = link = this.b; this.b = link2; while (link2 != null) { Link link3; link = link2.next; link2.next = link3 = link2.previous; link2.previous = link; link2 = link; } } public void clearList() { this.a = null; this.b = null; this.c = 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.stacks; import com.thealgorithms.datastructures.stacks.Node; import java.util.NoSuchElementException; class LinkedListStack { private Node a = null; private int b = 0; LinkedListStack() { } public boolean push(int n) { Node node = new Node(n); new Node(n).next = this.a; this.a = node; ++this.b; return true; } public int pop() { if (this.b == 0) { throw new NoSuchElementException(\"Empty stack. Nothing to pop\"); } Node node = this.a; this.a = this.a.next; int n = node.data; --this.b; return n; } public int peek() { if (this.b == 0) { throw new NoSuchElementException(\"Empty stack. Nothing to peek\"); } return this.a.data; } public String toString() { Node node = this.a; StringBuilder stringBuilder = new StringBuilder(); while (node != null) { stringBuilder.append(node.data).append(\"->\"); node = node.next; } StringBuilder stringBuilder2 = stringBuilder; return stringBuilder2.replace(stringBuilder2.length() - 2, stringBuilder.length(), \"\").toString(); } public boolean isEmpty() { return this.b == 0; } public int getSize() { return this.b; } public void makeEmpty() { this.a = null; this.b = 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.stacks; import com.thealgorithms.datastructures.stacks.Node; import java.util.NoSuchElementException; class LinkedListStack { private Node a = null; private int b = 0; LinkedListStack() { } public boolean push(int n) { Node node = new Node(n); new Node(n).next = this.a; this.a = node; ++this.b; return true; } public int pop() { if (this.b == 0) { throw new NoSuchElementException(\"Empty stack. Nothing to pop\"); } Node node = this.a; this.a = this.a.next; int n = node.data; --this.b; return n; } public int peek() { if (this.b == 0) { throw new NoSuchElementException(\"Empty stack. Nothing to peek\"); } return this.a.data; } public String toString() { Node node = this.a; StringBuilder stringBuilder = new StringBuilder(); while (node != null) { stringBuilder.append(node.data).append(\"->\"); node = node.next; } StringBuilder stringBuilder2 = stringBuilder; return stringBuilder2.replace(stringBuilder2.length() - 2, stringBuilder.length(), \"\").toString(); } public boolean isEmpty() { return this.b == 0; } public int getSize() { return this.b; } public void makeEmpty() { this.a = null; this.b = 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; import com.thealgorithms.datastructures.queues.LinkedQueue; import com.thealgorithms.datastructures.queues.LinkedQueue$Node; import java.util.Iterator; import java.util.NoSuchElementException; class LinkedQueue$1 implements Iterator { private LinkedQueue$Node a; private /* synthetic */ LinkedQueue b; LinkedQueue$1(LinkedQueue linkedQueue) { this.b = linkedQueue; this.a = this.b.a; } @Override public boolean hasNext() { return this.a != null; } public Object next() { if (!this.hasNext()) { throw new NoSuchElementException(); } Object object = this.a.a; this.a = this.a.b; return object; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; import com.thealgorithms.datastructures.queues.LinkedQueue; import com.thealgorithms.datastructures.queues.LinkedQueue$Node; import java.util.Iterator; import java.util.NoSuchElementException; class LinkedQueue$1 implements Iterator { private LinkedQueue$Node a; private /* synthetic */ LinkedQueue b; LinkedQueue$1(LinkedQueue linkedQueue) { this.b = linkedQueue; this.a = this.b.a; } @Override public boolean hasNext() { return this.a != null; } public Object next() { if (!this.hasNext()) { throw new NoSuchElementException(); } Object object = this.a.a; this.a = this.a.b; return object; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; class LinkedQueue$Node { Object a; LinkedQueue$Node b; LinkedQueue$Node(Object object) { this.a = object; this.b = null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; class LinkedQueue$Node { Object a; LinkedQueue$Node b; LinkedQueue$Node(Object object) { this.a = object; this.b = null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; import com.thealgorithms.datastructures.queues.LinkedQueue$1; import com.thealgorithms.datastructures.queues.LinkedQueue$Node; import java.util.Iterator; import java.util.NoSuchElementException; public class LinkedQueue implements Iterable { private LinkedQueue$Node a = null; private LinkedQueue$Node b = null; private int c = 0; public boolean isEmpty() { return this.c == 0; } public void enqueue(Object object) { if (object == null) { throw new IllegalArgumentException(\"Cannot enqueue null data\"); } object = new LinkedQueue$Node(object); if (this.isEmpty()) { this.a = object; } else { this.b.b = object; } this.b = object; ++this.c; } public Object dequeue() { if (this.isEmpty()) { throw new NoSuchElementException(\"Queue is empty\"); } Object object = this.a.a; this.a = this.a.b; --this.c; if (this.isEmpty()) { this.b = null; } return object; } public Object peekFront() { if (this.isEmpty()) { throw new NoSuchElementException(\"Queue is empty\"); } return this.a.a; } public Object peekRear() { if (this.isEmpty()) { throw new NoSuchElementException(\"Queue is empty\"); } return this.b.a; } public Object peek(int n) { if (n <= 0 || n > this.c) { throw new IndexOutOfBoundsException(\"Position \" + n + \" out of range!\"); } LinkedQueue$Node linkedQueue$Node = this.a; for (int i = 1; i < n; ++i) { linkedQueue$Node = linkedQueue$Node.b; } return linkedQueue$Node.a; } public Iterator iterator() { return new LinkedQueue$1(this); } public int size() { return this.c; } public void clear() { this.a = null; this.b = null; this.c = 0; } public String toString() { if (this.isEmpty()) { return \"[]\"; } StringBuilder stringBuilder = new StringBuilder(\"[\"); LinkedQueue$Node linkedQueue$Node = this.a; while (linkedQueue$Node != null) { stringBuilder.append(linkedQueue$Node.a); if (linkedQueue$Node.b != null) { stringBuilder.append(\", \"); } linkedQueue$Node = linkedQueue$Node.b; } stringBuilder.append(']'); return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.queues; import java.util.Iterator; import java.util.NoSuchElementException; public class LinkedQueue<T> implements Iterable<T> { /** * Node class representing each element in the queue. */ private static class Node<T> { T data; Node<T> next; Node(T data) { this.data = data; this.next = null; } } private Node<T> front; // Front of the queue private Node<T> rear; // Rear of the queue private int size; // Size of the queue /** * Initializes an empty LinkedQueue. */ public LinkedQueue() { front = null; rear = null; size = 0; } /** * Checks if the queue is empty. * * @return true if the queue is empty, otherwise false. */ public boolean isEmpty() { return size == 0; } /** * Adds an element to the rear of the queue. * * @param data the element to insert. * @throws IllegalArgumentException if data is null. */ public void enqueue(T data) { if (data == null) { throw new IllegalArgumentException(\"Cannot enqueue null data\"); } Node<T> newNode = new Node<>(data); if (isEmpty()) { front = newNode; } else { rear.next = newNode; } rear = newNode; size++; } /** * Removes and returns the element at the front of the queue. * * @return the element at the front of the queue. * @throws NoSuchElementException if the queue is empty. */ public T dequeue() { if (isEmpty()) { throw new NoSuchElementException(\"Queue is empty\"); } T retValue = front.data; front = front.next; size--; if (isEmpty()) { rear = null; } return retValue; } /** * Returns the element at the front of the queue without removing it. * * @return the element at the front of the queue. * @throws NoSuchElementException if the queue is empty. */ public T peekFront() { if (isEmpty()) { throw new NoSuchElementException(\"Queue is empty\"); } return front.data; } /** * Returns the element at the rear of the queue without removing it. * * @return the element at the rear of the queue. * @throws NoSuchElementException if the queue is empty. */ public T peekRear() { if (isEmpty()) { throw new NoSuchElementException(\"Queue is empty\"); } return rear.data; } /** * Returns the element at the specified position (1-based index). * * @param pos the position to peek at (1-based index). * @return the element at the specified position. * @throws IndexOutOfBoundsException if the position is out of range. */ public T peek(int pos) { if (pos < 1 || pos > size) { throw new IndexOutOfBoundsException(\"Position \" + pos + \" out of range!\"); } Node<T> node = front; for (int i = 1; i < pos; i++) { node = node.next; } return node.data; } /** * Returns an iterator over the elements in the queue. * * @return an iterator over the elements in the queue. */ @Override public Iterator<T> iterator() { return new Iterator<>() { private Node<T> current = front; @Override public boolean hasNext() { return current != null; } @Override public T next() { if (!hasNext()) { throw new NoSuchElementException(); } T data = current.data; current = current.next; return data; } }; } /** * Returns the size of the queue. * * @return the size of the queue. */ public int size() { return size; } /** * Clears all elements from the queue. */ public void clear() { front = null; rear = null; size = 0; } /** * Returns a string representation of the queue. * * @return a string representation of the queue. */ @Override public String toString() { if (isEmpty()) { return \"[]\"; } StringBuilder sb = new StringBuilder(\"[\"); Node<T> current = front; while (current != null) { sb.append(current.data); if (current.next != null) { sb.append(\", \"); } current = current.next; } sb.append(']'); return sb.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths.Prime; import com.thealgorithms.maths.Prime.PrimeFactorization; public final class LiouvilleLambdaFunction { private LiouvilleLambdaFunction() { } public static int liouvilleLambda(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Number must be greater than zero.\"); } if (PrimeFactorization.pfactors(n).size() % 2 == 0) { return 1; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.maths.Prime; /* * Java program for liouville lambda function * For any positive integer n, define (n) as the sum of the primitive nth roots of unity. * It has values in {1, 1} depending on the factorization of n into prime factors: * (n) = +1 if n is a positive integer with an even number of prime factors. * (n) = 1 if n is a positive integer with an odd number of prime factors. * Wikipedia: https://en.wikipedia.org/wiki/Liouville_function * * Author: Akshay Dubey (https://github.com/itsAkshayDubey) * * */ public final class LiouvilleLambdaFunction { private LiouvilleLambdaFunction() { } /** * This method returns (n) of given number n * * @param number Integer value which (n) is to be calculated * @return 1 when number has even number of prime factors * -1 when number has odd number of prime factors * @throws IllegalArgumentException when number is negative */ public static int liouvilleLambda(int number) { if (number <= 0) { // throw exception when number is less than or is zero throw new IllegalArgumentException(\"Number must be greater than zero.\"); } // return 1 if size of prime factor list is even, -1 otherwise return PrimeFactorization.pfactors(number).size() % 2 == 0 ? 1 : -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class LongDivision { private LongDivision() { } public static int divide(int n, int n2) { long l = n; long l2 = n2; if (n2 == 0) { return 0; } if (n < 0) { l = -l; } if (n2 < 0) { l2 = -l2; } if (n == 0 || l < l2) { return 0; } StringBuilder stringBuilder = new StringBuilder(); String string = \"\" + l; int n3 = 0; Object object = \"\"; for (int i = 0; i < string.length(); ++i) { long l3 = Long.parseLong((String)(object = (String)object + string.substring(n3, i + 1))); if (l3 > l2) { int n4 = 0; while (l3 >= l2) { l3 -= l2; ++n4; } stringBuilder.append(n4); } else if (l3 == l2) { int n5 = 0; while (l3 >= l2) { l3 -= l2; ++n5; } stringBuilder.append(n5); } else if (l3 == 0L) { stringBuilder.append(0); } else if (l3 < l2) { stringBuilder.append(0); } object = l3 != 0L ? String.valueOf(l3) : \"\"; ++n3; } if (n < 0 && n2 > 0 || n > 0 && n2 < 0) { try { return -Integer.parseInt(stringBuilder.toString()); } catch (NumberFormatException numberFormatException) { return Integer.MIN_VALUE; } } try { return Integer.parseInt(stringBuilder.toString()); } catch (NumberFormatException numberFormatException) { return Integer.MAX_VALUE; } } }", "deobfuscated_code": "// Given two integers dividend and divisor, divide two integers without using multiplication, // division, and mod operator. // // The integer division should truncate toward zero, which means losing its fractional part. // For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2. My // method used Long Division, here is the source // \"https://en.wikipedia.org/wiki/Long_division\" package com.thealgorithms.maths; public final class LongDivision { private LongDivision() { } public static int divide(int dividend, int divisor) { long newDividend1 = dividend; long newDivisor1 = divisor; if (divisor == 0) { return 0; } if (dividend < 0) { newDividend1 = newDividend1 * -1; } if (divisor < 0) { newDivisor1 = newDivisor1 * -1; } if (dividend == 0 || newDividend1 < newDivisor1) { return 0; } StringBuilder answer = new StringBuilder(); String dividendString = \"\" + newDividend1; int lastIndex = 0; String remainder = \"\"; for (int i = 0; i < dividendString.length(); i++) { String partV1 = remainder + \"\" + dividendString.substring(lastIndex, i + 1); long part1 = Long.parseLong(partV1); if (part1 > newDivisor1) { int quotient = 0; while (part1 >= newDivisor1) { part1 = part1 - newDivisor1; quotient++; } answer.append(quotient); } else if (part1 == newDivisor1) { int quotient = 0; while (part1 >= newDivisor1) { part1 = part1 - newDivisor1; quotient++; } answer.append(quotient); } else if (part1 == 0) { answer.append(0); } else if (part1 < newDivisor1) { answer.append(0); } if (!(part1 == 0)) { remainder = String.valueOf(part1); } else { remainder = \"\"; } lastIndex++; } if ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) { try { return Integer.parseInt(answer.toString()) * (-1); } catch (NumberFormatException e) { return -2147483648; } } try { return Integer.parseInt(answer.toString()); } catch (NumberFormatException e) { return 2147483647; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class LongestAlternatingSubsequence { private LongestAlternatingSubsequence() { } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Class for finding the length of the longest alternating subsequence in an array. * * <p>An alternating sequence is a sequence of numbers where the elements alternate * between increasing and decreasing. Specifically, a sequence is alternating if its elements * satisfy one of the following relations: * * <ul> * <li>{@code x1 < x2 > x3 < x4 > x5 < ... < xn}</li> * <li>{@code x1 > x2 < x3 > x4 < x5 > ... > xn}</li> * </ul> * * <p>This class provides a method to compute the length of the longest such subsequence * from a given array of integers. */ public final class LongestAlternatingSubsequence { private LongestAlternatingSubsequence() { } /** * Finds the length of the longest alternating subsequence in the given array. * * @param arr an array of integers where the longest alternating subsequence is to be found * @param n the length of the array {@code arr} * @return the length of the longest alternating subsequence * * <p>The method uses dynamic programming to solve the problem. It maintains a 2D array * {@code las} where: * <ul> * <li>{@code las[i][0]} represents the length of the longest alternating subsequence * ending at index {@code i} with the last element being greater than the previous element.</li> * <li>{@code las[i][1]} represents the length of the longest alternating subsequence * ending at index {@code i} with the last element being smaller than the previous element.</li> * </ul> * * <p>The method iterates through the array and updates the {@code las} array based on * whether the current element is greater or smaller than the previous elements. * The result is the maximum value found in the {@code las} array. */ static int alternatingLength(int[] arr, int n) { int[][] las = new int[n][2]; // las = LongestAlternatingSubsequence // Initialize the dp array for (int i = 0; i < n; i++) { las[i][0] = 1; las[i][1] = 1; } int result = 1; // Initialize result // Compute values in a bottom-up manner for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { // If arr[i] is greater than arr[j], update las[i][0] if (arr[j] < arr[i] && las[i][0] < las[j][1] + 1) { las[i][0] = las[j][1] + 1; } // If arr[i] is smaller than arr[j], update las[i][1] if (arr[j] > arr[i] && las[i][1] < las[j][0] + 1) { las[i][1] = las[j][0] + 1; } } // Pick the maximum of both values at index i result = Math.max(result, Math.max(las[i][0], las[i][1])); } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import java.util.HashMap; final class LongestArithmeticSubsequence { private LongestArithmeticSubsequence() { } public static int getLongestArithmeticSubsequenceLength(int[] nArray) { if (nArray == null) { throw new IllegalArgumentException(\"Input array cannot be null\"); } if (nArray.length <= 1) { return nArray.length; } HashMap[] hashMapArray = new HashMap[nArray.length]; int n = 2; for (int i = 0; i < nArray.length; ++i) { hashMapArray[i] = new HashMap(); for (int j = 0; j < i; ++j) { int n2 = nArray[i] - nArray[j]; hashMapArray[i].put(n2, hashMapArray[j].getOrDefault(n2, 1) + 1); n = Math.max(n, (Integer)hashMapArray[i].get(n2)); } } return n; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.HashMap; @SuppressWarnings({\"rawtypes\", \"unchecked\"}) final class LongestArithmeticSubsequence { private LongestArithmeticSubsequence() { } /** * Returns the length of the longest arithmetic subsequence in the given array. * * A sequence seq is arithmetic if seq[i + 1] - seq[i] are all the same value * (for 0 <= i < seq.length - 1). * * @param nums the input array of integers * @return the length of the longest arithmetic subsequence */ public static int getLongestArithmeticSubsequenceLength(int[] nums) { if (nums == null) { throw new IllegalArgumentException(\"Input array cannot be null\"); } if (nums.length <= 1) { return nums.length; } HashMap<Integer, Integer>[] dp = new HashMap[nums.length]; int maxLength = 2; // fill the dp array for (int i = 0; i < nums.length; i++) { dp[i] = new HashMap<>(); for (int j = 0; j < i; j++) { final int diff = nums[i] - nums[j]; dp[i].put(diff, dp[j].getOrDefault(diff, 1) + 1); maxLength = Math.max(maxLength, dp[i].get(diff)); } } return maxLength; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.Arrays; public final class LongestCommonPrefix { private LongestCommonPrefix() { } public static String longestCommonPrefix(String[] object) { int n; if (object == null || ((String[])object).length == 0) { return \"\"; } Arrays.sort((Object[])object); String string = object[0]; object = object[((String[])object).length - 1]; for (n = 0; n < string.length() && n < ((String)object).length() && string.charAt(n) == ((String)object).charAt(n); ++n) { } return string.substring(0, n); } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.Arrays; /** * Utility class for string operations. * <p> * This class provides a method to find the longest common prefix (LCP) * among an array of strings. * </p> * * @see <a href=\"https://en.wikipedia.org/wiki/Longest_common_prefix\">Longest Common Prefix - Wikipedia</a> */ public final class LongestCommonPrefix { private LongestCommonPrefix() { } /** * Finds the longest common prefix among a list of strings using lexicographical sorting. * The prefix is common to the first and last elements after sorting the array. * * @param strs array of input strings * @return the longest common prefix, or empty string if none exists */ public static String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } Arrays.sort(strs); String first = strs[0]; String last = strs[strs.length - 1]; int index = 0; while (index < first.length() && index < last.length() && first.charAt(index) == last.charAt(index)) { index++; } return first.substring(0, index); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; final class LongestCommonSubsequence { private LongestCommonSubsequence() { } public static String getLCS(String string, String string2) { int n; if (string == null || string2 == null) { return null; } if (string.length() == 0 || string2.length() == 0) { return \"\"; } String[] stringArray = string.split(\"\"); String[] stringArray2 = string2.split(\"\"); int[][] nArray = new int[stringArray.length + 1][stringArray2.length + 1]; for (n = 0; n < stringArray.length + 1; ++n) { nArray[n][0] = 0; } for (n = 1; n < stringArray2.length + 1; ++n) { nArray[0][n] = 0; } for (n = 1; n < stringArray.length + 1; ++n) { for (int i = 1; i < stringArray2.length + 1; ++i) { nArray[n][i] = stringArray[n - 1].equals(stringArray2[i - 1]) ? nArray[n - 1][i - 1] + 1 : Math.max(nArray[n - 1][i], nArray[n][i - 1]); } } return LongestCommonSubsequence.lcsString(string, string2, nArray); } public static String lcsString(String string, String string2, int[][] nArray) { StringBuilder stringBuilder = new StringBuilder(); int n = string.length(); int n2 = string2.length(); while (n > 0 && n2 > 0) { if (string.charAt(n - 1) == string2.charAt(n2 - 1)) { stringBuilder.append(string.charAt(n - 1)); --n; --n2; continue; } if (nArray[n - 1][n2] > nArray[n][n2 - 1]) { --n; continue; } --n2; } return stringBuilder.reverse().toString(); } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * This class implements the Longest Common Subsequence (LCS) problem. * The LCS of two sequences is the longest sequence that appears in both * sequences * in the same order, but not necessarily consecutively. * * This implementation uses dynamic programming to find the LCS of two strings. */ final class LongestCommonSubsequence { private LongestCommonSubsequence() { } /** * Returns the Longest Common Subsequence (LCS) of two given strings. * * @param str1 The first string. * @param str2 The second string. * @return The LCS of the two strings, or null if one of the strings is null. */ public static String getLCS(String str1, String str2) { // If either string is null, return null as LCS can't be computed. if (str1 == null || str2 == null) { return null; } // If either string is empty, return an empty string as LCS. if (str1.length() == 0 || str2.length() == 0) { return \"\"; } // Convert the strings into arrays of characters String[] arr1 = str1.split(\"\"); String[] arr2 = str2.split(\"\"); // lcsMatrix[i][j] = LCS(first i characters of str1, first j characters of str2) int[][] lcsMatrix = new int[arr1.length + 1][arr2.length + 1]; // Base Case: Fill the LCS matrix 0th row & 0th column with 0s // as LCS of any string with an empty string is 0. for (int i = 0; i < arr1.length + 1; i++) { lcsMatrix[i][0] = 0; } for (int j = 1; j < arr2.length + 1; j++) { lcsMatrix[0][j] = 0; } // Build the LCS matrix by comparing characters of str1 & str2 for (int i = 1; i < arr1.length + 1; i++) { for (int j = 1; j < arr2.length + 1; j++) { // If characters match, the LCS increases by 1 if (arr1[i - 1].equals(arr2[j - 1])) { lcsMatrix[i][j] = lcsMatrix[i - 1][j - 1] + 1; } else { // Otherwise, take the maximum of the left or above values lcsMatrix[i][j] = Math.max(lcsMatrix[i - 1][j], lcsMatrix[i][j - 1]); } } } // Call helper function to reconstruct the LCS from the matrix return lcsString(str1, str2, lcsMatrix); } /** * Reconstructs the LCS string from the LCS matrix. * * @param str1 The first string. * @param str2 The second string. * @param lcsMatrix The matrix storing the lengths of LCSs * of substrings of str1 and str2. * @return The LCS string. */ public static String lcsString(String str1, String str2, int[][] lcsMatrix) { StringBuilder lcs = new StringBuilder(); // Hold the LCS characters. int i = str1.length(); // Start from the end of str1. int j = str2.length(); // Start from the end of str2. // Trace back through the LCS matrix to reconstruct the LCS while (i > 0 && j > 0) { // If characters match, add to the LCS and move diagonally in the matrix if (str1.charAt(i - 1) == str2.charAt(j - 1)) { lcs.append(str1.charAt(i - 1)); i--; j--; } else if (lcsMatrix[i - 1][j] > lcsMatrix[i][j - 1]) { // If the value above is larger, move up i--; } else { // If the value to the left is larger, move left j--; } } return lcs.reverse().toString(); // LCS built in reverse, so reverse it back } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class LongestIncreasingSubsequence { private LongestIncreasingSubsequence() { } public static int lis(int[] nArray) { int n = nArray.length; if (n == 0) { return 0; } int[] nArray2 = new int[n]; int n2 = 1; nArray2[0] = nArray[0]; for (int i = 1; i < n; ++i) { if (nArray[i] < nArray2[0]) { nArray2[0] = nArray[i]; continue; } if (nArray[i] > nArray2[n2 - 1]) { nArray2[n2++] = nArray[i]; continue; } int n3 = nArray[i]; int n4 = n2 - 1; int n5 = -1; int[] nArray3 = nArray2; while (n5 < n4 - 1) { int n6 = n5 + n4 >>> 1; if (nArray3[n6] >= n3) { n4 = n6; continue; } n5 = n6; } nArray2[n4] = nArray[i]; } return n2; } public static int findLISLen(int[] nArray) { int n = nArray.length; if (n == 0) { return 0; } int[] nArray2 = new int[n]; int[] nArray3 = nArray2; nArray2[0] = nArray[0]; int n2 = 1; for (int i = 1; i < n; ++i) { int n3; int n4 = nArray[i]; int n5 = n2 - 1; int[] nArray4 = nArray3; int n6 = 0; int n7 = n5; if (n4 < nArray4[0]) { n3 = 0; } else if (n4 > nArray4[n5]) { n3 = n5 + 1; } else { while (n6 < n7 - 1) { n5 = n6 + n7 >>> 1; if (nArray4[n5] < n4) { n6 = n5; continue; } n7 = n5; } n3 = n7; } int n8 = n3; nArray3[n8] = nArray[i]; if (n8 != n2) continue; ++n2; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * @author Afrizal Fikri (https://github.com/icalF) */ public final class LongestIncreasingSubsequence { private LongestIncreasingSubsequence() { } private static int upperBound(int[] ar, int l, int r, int key) { while (l < r - 1) { int m = (l + r) >>> 1; if (ar[m] >= key) { r = m; } else { l = m; } } return r; } public static int lis(int[] array) { int len = array.length; if (len == 0) { return 0; } int[] tail = new int[len]; // always points empty slot in tail int length = 1; tail[0] = array[0]; for (int i = 1; i < len; i++) { // new smallest value if (array[i] < tail[0]) { tail[0] = array[i]; } // array[i] extends largest subsequence else if (array[i] > tail[length - 1]) { tail[length++] = array[i]; } // array[i] will become end candidate of an existing subsequence or // Throw away larger elements in all LIS, to make room for upcoming grater elements than // array[i] // (and also, array[i] would have already appeared in one of LIS, identify the location // and replace it) else { tail[upperBound(tail, -1, length - 1, array[i])] = array[i]; } } return length; } /** * @author Alon Firestein (https://github.com/alonfirestein) */ // A function for finding the length of the LIS algorithm in O(nlogn) complexity. public static int findLISLen(int[] a) { final int size = a.length; if (size == 0) { return 0; } int[] arr = new int[size]; arr[0] = a[0]; int lis = 1; for (int i = 1; i < size; i++) { int index = binarySearchBetween(arr, lis - 1, a[i]); arr[index] = a[i]; if (index == lis) { lis++; } } return lis; } // O(logn) private static int binarySearchBetween(int[] t, int end, int key) { int left = 0; int right = end; if (key < t[0]) { return 0; } if (key > t[end]) { return end + 1; } while (left < right - 1) { final int middle = (left + right) >>> 1; if (t[middle] < key) { left = middle; } else { right = middle; } } return right; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class LongestIncreasingSubsequenceNLogN { private LongestIncreasingSubsequenceNLogN() { } public static int lengthOfLIS(int[] nArray) { if (nArray == null || nArray.length == 0) { return 0; } int[] nArray2 = new int[nArray.length]; int n = 0; for (int n2 : nArray) { int n3 = n; int n4 = n2; int[] nArray3 = nArray2; int n5 = 0; while (n5 < n3) { int n6 = n5 + (n3 - n5) / 2; if (n4 > nArray3[n6]) { n5 = n6 + 1; continue; } n3 = n6; } int n7 = n5; nArray2[n7] = n2; if (n7 != n) continue; ++n; } return n; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Implementation of the Longest Increasing Subsequence (LIS) problem using * an O(n log n) dynamic programming solution enhanced with binary search. * * @author Vusal Huseynov (https://github.com/huseynovvusal) */ public final class LongestIncreasingSubsequenceNLogN { private LongestIncreasingSubsequenceNLogN() { } /** * Finds the index of the smallest element in the array that is greater than * or equal to the target using binary search. The search is restricted to * the first `size` elements of the array. * * @param arr The array to search in (assumed to be sorted up to `size`). * @param size The number of valid elements in the array. * @param target The target value to find the lower bound for. * @return The index of the lower bound. */ private static int lowerBound(int[] arr, int target, int size) { int l = 0; int r = size; while (l < r) { int mid = l + (r - l) / 2; if (target > arr[mid]) { // Move right if target is greater than mid element l = mid + 1; } else { // Move left if target is less than or equal to mid element r = mid; } } // Return the index where the target can be inserted return l; } /** * Calculates the length of the Longest Increasing Subsequence (LIS) in the given array. * * @param arr The input array of integers. * @return The length of the LIS. */ public static int lengthOfLIS(int[] arr) { if (arr == null || arr.length == 0) { return 0; // Return 0 for empty or null arrays } // tails[i] - the smallest end element of an increasing subsequence of length i+1 int[] tails = new int[arr.length]; // size - the length of the longest increasing subsequence found so far int size = 0; for (int x : arr) { // Find the position to replace or extend the subsequence int index = lowerBound(tails, x, size); // Update the tails array with the current element tails[index] = x; // If the element extends the subsequence, increase the size if (index == size) { size++; } } // Return the length of the LIS return size; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.HashMap; final class LongestNonRepetitiveSubstring { private LongestNonRepetitiveSubstring() { } public static int lengthOfLongestSubstring(String string) { int n = 0; int n2 = 0; HashMap<Character, Integer> hashMap = new HashMap<Character, Integer>(); for (int i = 0; i < string.length(); ++i) { char c = string.charAt(i); if (hashMap.containsKey(Character.valueOf(c)) && (Integer)hashMap.get(Character.valueOf(c)) >= n2) { n2 = (Integer)hashMap.get(Character.valueOf(c)) + 1; } hashMap.put(Character.valueOf(c), i); n = Math.max(n, i - n2 + 1); } return n; } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.HashMap; import java.util.Map; /** * Class for finding the length of the longest substring without repeating characters. */ final class LongestNonRepetitiveSubstring { private LongestNonRepetitiveSubstring() { } /** * Finds the length of the longest substring without repeating characters. * * @param s the input string * @return the length of the longest non-repetitive substring */ public static int lengthOfLongestSubstring(String s) { int maxLength = 0; int start = 0; Map<Character, Integer> charIndexMap = new HashMap<>(); for (int i = 0; i < s.length(); i++) { char currentChar = s.charAt(i); // If the character is already in the map and its index is within the current window if (charIndexMap.containsKey(currentChar) && charIndexMap.get(currentChar) >= start) { // Move the start to the position right after the last occurrence of the current character start = charIndexMap.get(currentChar) + 1; } // Update the last seen index of the current character charIndexMap.put(currentChar, i); // Calculate the maximum length of the substring without repeating characters maxLength = Math.max(maxLength, i - start + 1); } return maxLength; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class LongestPalindromicSubsequence { private LongestPalindromicSubsequence() { } public static void main(String[] object) { object = \"BBABCBCAB\"; String string = \"BABCBAB\"; String string2 = LongestPalindromicSubsequence.lps((String)object); String string3 = LongestPalindromicSubsequence.lps(string); System.out.println((String)object + \" => \" + string2); System.out.println(string + \" => \" + string3); } public static String lps(String string) { StringBuilder stringBuilder = new StringBuilder(string); stringBuilder = stringBuilder.reverse(); return LongestPalindromicSubsequence.a(string, stringBuilder.toString()); } private static String a(String object, String string) { block1: { block2: { block0: { if (((String)object).length() != 0 && string.length() != 0) break block0; object = \"\"; break block1; } String string2 = object; String string3 = string; if (string2.charAt(string2.length() - 1) != string3.charAt(string3.length() - 1)) break block2; String string4 = LongestPalindromicSubsequence.a(((String)object).substring(0, ((String)object).length() - 1), string.substring(0, string.length() - 1)); String string5 = string; object = string5.charAt(string5.length() - 1) + string4; break block1; } String string6 = LongestPalindromicSubsequence.a((String)object, string.substring(0, string.length() - 1)); object = LongestPalindromicSubsequence.a(((String)object).substring(0, ((String)object).length() - 1), string); if (string6.length() <= ((String)object).length()) break block1; object = string6; } return object; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Algorithm explanation * https://www.educative.io/edpresso/longest-palindromic-subsequence-algorithm */ public final class LongestPalindromicSubsequence { private LongestPalindromicSubsequence() { } public static void main(String[] args) { String a = \"BBABCBCAB\"; String b = \"BABCBAB\"; String aLPS = lps(a); String bLPS = lps(b); System.out.println(a + \" => \" + aLPS); System.out.println(b + \" => \" + bLPS); } public static String lps(String original) throws IllegalArgumentException { StringBuilder reverse = new StringBuilder(original); reverse = reverse.reverse(); return recursiveLPS(original, reverse.toString()); } private static String recursiveLPS(String original, String reverse) { String bestResult = \"\"; // no more chars, then return empty if (original.length() == 0 || reverse.length() == 0) { bestResult = \"\"; } else { // if the last chars match, then remove it from both strings and recur if (original.charAt(original.length() - 1) == reverse.charAt(reverse.length() - 1)) { String bestSubResult = recursiveLPS(original.substring(0, original.length() - 1), reverse.substring(0, reverse.length() - 1)); bestResult = reverse.charAt(reverse.length() - 1) + bestSubResult; } else { // otherwise (1) ignore the last character of reverse, and recur on original and // updated reverse again (2) ignore the last character of original and recur on the // updated original and reverse again then select the best result from these two // subproblems. String bestSubResult1 = recursiveLPS(original, reverse.substring(0, reverse.length() - 1)); String bestSubResult2 = recursiveLPS(original.substring(0, original.length() - 1), reverse); if (bestSubResult1.length() > bestSubResult2.length()) { bestResult = bestSubResult1; } else { bestResult = bestSubResult2; } } } return bestResult; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; final class LongestPalindromicSubstring { private LongestPalindromicSubstring() { } public static String longestPalindrome(String string) { if (string == null || string.isEmpty()) { return \"\"; } String string2 = \"\"; for (int i = 0; i < string.length(); ++i) { for (int j = i; j < string.length(); ++j) { boolean bl; block4: { int n = j; int n2 = i; String string3 = string; int n3 = n - n2 + 1; for (int k = 0; k < n3 / 2; ++k) { if (string3.charAt(n2 + k) == string3.charAt(n - k)) continue; bl = false; break block4; } bl = true; } if (!bl || j - i + 1 <= string2.length()) continue; string2 = string.substring(i, j + 1); } } return string2; } }", "deobfuscated_code": "package com.thealgorithms.strings; final class LongestPalindromicSubstring { private LongestPalindromicSubstring() { } /** * Finds the longest palindromic substring in the given string. * * @param s the input string * @return the longest palindromic substring */ public static String longestPalindrome(String s) { if (s == null || s.isEmpty()) { return \"\"; } String maxStr = \"\"; for (int i = 0; i < s.length(); ++i) { for (int j = i; j < s.length(); ++j) { if (isValid(s, i, j) && (j - i + 1 > maxStr.length())) { maxStr = s.substring(i, j + 1); } } } return maxStr; } private static boolean isValid(String s, int lo, int hi) { int n = hi - lo + 1; for (int i = 0; i < n / 2; ++i) { if (s.charAt(lo + i) != s.charAt(hi - i)) { return false; } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.slidingwindow; public final class LongestSubarrayWithSumLessOrEqualToK { private LongestSubarrayWithSumLessOrEqualToK() { } public static int longestSubarrayWithSumLEK(int[] nArray, int n) { int n2 = 0; int n3 = 0; int n4 = 0; for (int i = 0; i < nArray.length; ++i) { n3 += nArray[i]; while (n3 > n && n4 <= i) { n3 -= nArray[n4]; ++n4; } n2 = Math.max(n2, i - n4 + 1); } return n2; } }", "deobfuscated_code": "package com.thealgorithms.slidingwindow; /** * The Longest Subarray with Sum Less Than or Equal to k algorithm finds the length * of the longest subarray whose sum is less than or equal to a given value k. * * <p> * Worst-case performance O(n) * Best-case performance O(n) * Average performance O(n) * Worst-case space complexity O(1) * * @author https://github.com/Chiefpatwal */ public final class LongestSubarrayWithSumLessOrEqualToK { // Prevent instantiation private LongestSubarrayWithSumLessOrEqualToK() { } /** * This method finds the length of the longest subarray with a sum less than or equal to k. * * @param arr is the input array * @param k is the maximum sum allowed * @return the length of the longest subarray with sum less than or equal to k */ public static int longestSubarrayWithSumLEK(int[] arr, int k) { int maxLength = 0; // To store the maximum length found int currentSum = 0; // To store the current sum of the window int left = 0; // Left index of the sliding window for (int right = 0; right < arr.length; right++) { currentSum += arr[right]; // Expand the window to the right // Shrink the window from the left if the current sum exceeds k while (currentSum > k && left <= right) { currentSum -= arr[left]; // Remove the leftmost element left++; // Move the left index to the right } // Update maxLength if the current window is valid maxLength = Math.max(maxLength, right - left + 1); } return maxLength; // Return the maximum length found } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.slidingwindow; import java.util.HashSet; public final class LongestSubstringWithoutRepeatingCharacters { private LongestSubstringWithoutRepeatingCharacters() { } public static int lengthOfLongestSubstring(String string) { int n = 0; int n2 = 0; HashSet<Character> hashSet = new HashSet<Character>(); for (int i = 0; i < string.length(); ++i) { while (hashSet.contains(Character.valueOf(string.charAt(i)))) { hashSet.remove(Character.valueOf(string.charAt(n2))); ++n2; } hashSet.add(Character.valueOf(string.charAt(i))); n = Math.max(n, i - n2 + 1); } return n; } }", "deobfuscated_code": "package com.thealgorithms.slidingwindow; import java.util.HashSet; /** * The Longest Substring Without Repeating Characters algorithm finds the length of * the longest substring without repeating characters in a given string. * * <p> * Worst-case performance O(n) * Best-case performance O(n) * Average performance O(n) * Worst-case space complexity O(min(n, m)), where n is the length of the string * and m is the size of the character set. * * @author (https://github.com/Chiefpatwal) */ public final class LongestSubstringWithoutRepeatingCharacters { // Prevent instantiation private LongestSubstringWithoutRepeatingCharacters() { } /** * This method finds the length of the longest substring without repeating characters. * * @param s is the input string * @return the length of the longest substring without repeating characters */ public static int lengthOfLongestSubstring(String s) { int maxLength = 0; int left = 0; HashSet<Character> charSet = new HashSet<>(); for (int right = 0; right < s.length(); right++) { // If the character is already in the set, remove characters from the left while (charSet.contains(s.charAt(right))) { charSet.remove(s.charAt(left)); left++; } charSet.add(s.charAt(right)); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class LongestValidParentheses { private LongestValidParentheses() { } public static int getLongestValidParentheses(String object) { if (object == null || ((String)object).length() < 2) { return 0; } char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; int[] nArray = new int[n]; int[] nArray2 = nArray; nArray[0] = 0; nArray2[1] = object[1] == 41 && object[0] == 40 ? 2 : 0; int n2 = nArray2[1]; for (int i = 2; i < n; ++i) { block5: { int n3; int n4; block7: { int n5; int[] nArray3; block6: { if (object[i] != 41) break block5; if (object[i - 1] != 40) break block6; nArray3 = nArray2; n5 = i; n4 = nArray2[i - 2]; n3 = 2; break block7; } int n6 = i - nArray2[i - 1] - 1; if (n6 < 0 || object[n6] != 40) break block5; nArray3 = nArray2; n5 = i; n4 = nArray2[i - 1] + 2; n3 = n6 - 1 >= 0 ? nArray2[n6 - 1] : 0; } nArray3[n5] = n4 + n3; } n2 = Math.max(n2, nArray2[i]); } return n2; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Given a string containing just the characters '(' and ')', find the length of * the longest valid (well-formed) parentheses substring. * * @author Libin Yang (https://github.com/yanglbme) * @since 2018/10/5 */ public final class LongestValidParentheses { private LongestValidParentheses() { } public static int getLongestValidParentheses(String s) { if (s == null || s.length() < 2) { return 0; } char[] chars = s.toCharArray(); int n = chars.length; int[] res = new int[n]; res[0] = 0; res[1] = chars[1] == ')' && chars[0] == '(' ? 2 : 0; int max = res[1]; for (int i = 2; i < n; ++i) { if (chars[i] == ')') { if (chars[i - 1] == '(') { res[i] = res[i - 2] + 2; } else { int index = i - res[i - 1] - 1; if (index >= 0 && chars[index] == '(') { // ()(()) res[i] = res[i - 1] + 2 + (index - 1 >= 0 ? res[index - 1] : 0); } } } max = Math.max(max, res[i]); } return max; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling.diskscheduling; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class LookScheduling { private final int a; private final int b; private boolean c; private int d; public LookScheduling(int n, boolean bl, int n2) { this.b = n; this.c = bl; this.a = n2; } public List execute(List object) { ArrayList arrayList = new ArrayList(); ArrayList<Integer> arrayList2 = new ArrayList<Integer>(); ArrayList<Integer> arrayList3 = new ArrayList<Integer>(); object = object.iterator(); while (object.hasNext()) { int n = (Integer)object.next(); if (n < 0 || n >= this.a) continue; if (n < this.b) { arrayList2.add(n); continue; } arrayList3.add(n); } Collections.sort(arrayList2); Collections.sort(arrayList3); if (this.c) { arrayList.addAll(arrayList3); if (!arrayList3.isEmpty()) { ArrayList<Integer> arrayList4 = arrayList3; this.d = (Integer)arrayList4.get(arrayList4.size() - 1); } this.c = false; Collections.reverse(arrayList2); arrayList.addAll(arrayList2); if (!arrayList2.isEmpty()) { this.d = Math.max(this.d, (Integer)arrayList2.get(0)); } } else { Collections.reverse(arrayList2); arrayList.addAll(arrayList2); if (!arrayList2.isEmpty()) { this.d = (Integer)arrayList2.get(0); } this.c = true; arrayList.addAll(arrayList3); if (!arrayList3.isEmpty()) { ArrayList<Integer> arrayList5 = arrayList3; this.d = Math.max(this.d, (Integer)arrayList5.get(arrayList5.size() - 1)); } } return arrayList; } public int getCurrentPosition() { return this.b; } public boolean isMovingUp() { return this.c; } public int getFarthestPosition() { return this.d; } }", "deobfuscated_code": "package com.thealgorithms.scheduling.diskscheduling; import java.util.ArrayList; import java.util.Collections; import java.util.List; /** * https://en.wikipedia.org/wiki/LOOK_algorithm * Look Scheduling algorithm implementation. * The Look algorithm moves the disk arm to the closest request in the current direction, * and once it processes all requests in that direction, it reverses the direction. */ public class LookScheduling { private final int maxTrack; private final int currentPosition; private boolean movingUp; private int farthestPosition; public LookScheduling(int startPosition, boolean initialDirection, int maxTrack) { this.currentPosition = startPosition; this.movingUp = initialDirection; this.maxTrack = maxTrack; } /** * Executes the Look Scheduling algorithm on the given list of requests. * * @param requests List of disk requests. * @return Order in which requests are processed. */ public List<Integer> execute(List<Integer> requests) { List<Integer> result = new ArrayList<>(); List<Integer> lower = new ArrayList<>(); List<Integer> upper = new ArrayList<>(); // Split requests into two lists based on their position relative to current position for (int request : requests) { if (request >= 0 && request < maxTrack) { if (request < currentPosition) { lower.add(request); } else { upper.add(request); } } } // Sort the requests Collections.sort(lower); Collections.sort(upper); // Process the requests depending on the initial moving direction if (movingUp) { // Process requests in the upward direction result.addAll(upper); if (!upper.isEmpty()) { farthestPosition = upper.get(upper.size() - 1); } // Reverse the direction and process downward movingUp = false; Collections.reverse(lower); result.addAll(lower); if (!lower.isEmpty()) { farthestPosition = Math.max(farthestPosition, lower.get(0)); } } else { // Process requests in the downward direction Collections.reverse(lower); result.addAll(lower); if (!lower.isEmpty()) { farthestPosition = lower.get(0); } // Reverse the direction and process upward movingUp = true; result.addAll(upper); if (!upper.isEmpty()) { farthestPosition = Math.max(farthestPosition, upper.get(upper.size() - 1)); } } return result; } public int getCurrentPosition() { return currentPosition; } public boolean isMovingUp() { return movingUp; } public int getFarthestPosition() { return farthestPosition; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; public class LotteryScheduling$Process { private String a; private int b; private int c; private int d; private int e; public LotteryScheduling$Process(String string, int n, int n2) { this.a = string; this.b = n; this.c = n2; } public String getProcessId() { return this.a; } public int getBurstTime() { return this.b; } public int getTickets() { return this.c; } public int getWaitingTime() { return this.d; } public void setWaitingTime(int n) { this.d = n; } public int getTurnAroundTime() { return this.e; } public void setTurnAroundTime(int n) { this.e = n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; public class LotteryScheduling$Process { private String a; private int b; private int c; private int d; private int e; public LotteryScheduling$Process(String string, int n, int n2) { this.a = string; this.b = n; this.c = n2; } public String getProcessId() { return this.a; } public int getBurstTime() { return this.b; } public int getTickets() { return this.c; } public int getWaitingTime() { return this.d; } public void setWaitingTime(int n) { this.d = n; } public int getTurnAroundTime() { return this.e; } public void setTurnAroundTime(int n) { this.e = n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.LotteryScheduling$Process; import java.util.ArrayList; import java.util.List; import java.util.Random; public final class LotteryScheduling { private List a; private Random b; private LotteryScheduling() { } public LotteryScheduling(List list) { this.a = list; this.b = new Random(); } public LotteryScheduling(List list, Random random) { this.a = list; this.b = random; } public final List scheduleProcesses() { int n = this.a.stream().mapToInt(LotteryScheduling$Process::getTickets).sum(); int n2 = 0; ArrayList<Object> arrayList = new ArrayList<Object>(); while (!this.a.isEmpty()) { Object object; Object object2; block3: { int n3 = n = this.b.nextInt(n) + 1; object2 = this; int n4 = 0; object2 = ((LotteryScheduling)object2).a.iterator(); while (object2.hasNext()) { LotteryScheduling$Process lotteryScheduling$Process = (LotteryScheduling$Process)object2.next(); if ((n4 += lotteryScheduling$Process.getTickets()) < n3) continue; object = lotteryScheduling$Process; break block3; } object = object2 = null; } if (object == null) { System.err.println(\"Error: No process selected. Recalculating total tickets.\"); n = this.a.stream().mapToInt(LotteryScheduling$Process::getTickets).sum(); continue; } ((LotteryScheduling$Process)object2).setWaitingTime(n2); n2 += ((LotteryScheduling$Process)object2).getBurstTime(); Object object3 = object2; ((LotteryScheduling$Process)object3).setTurnAroundTime(((LotteryScheduling$Process)object3).getWaitingTime() + ((LotteryScheduling$Process)object2).getBurstTime()); arrayList.add(object2); this.a.remove(object2); n = this.a.stream().mapToInt(LotteryScheduling$Process::getTickets).sum(); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.List; import java.util.Random; /** * The LotteryScheduling class implements the Lottery Scheduling algorithm, which is * a probabilistic CPU scheduling algorithm. Processes are assigned tickets, and * the CPU is allocated to a randomly selected process based on ticket count. * Processes with more tickets have a higher chance of being selected. */ public final class LotteryScheduling { private LotteryScheduling() { } private List<Process> processes; private Random random; /** * Constructs a LotteryScheduling object with the provided list of processes. * * @param processes List of processes to be scheduled using Lottery Scheduling. */ public LotteryScheduling(final List<Process> processes) { this.processes = processes; this.random = new Random(); } /** * Constructs a LotteryScheduling object with the provided list of processes and a Random object. * * @param processes List of processes to be scheduled using Lottery Scheduling. * @param random Random object used for generating random numbers. */ public LotteryScheduling(final List<Process> processes, Random random) { this.processes = processes; this.random = random; } /** * Schedules the processes using the Lottery Scheduling algorithm. * Each process is assigned a certain number of tickets, and the algorithm randomly * selects a process to execute based on ticket count. The method calculates the * waiting time and turnaround time for each process and simulates their execution. */ public List<Process> scheduleProcesses() { int totalTickets = processes.stream().mapToInt(Process::getTickets).sum(); int currentTime = 0; List<Process> executedProcesses = new ArrayList<>(); while (!processes.isEmpty()) { int winningTicket = random.nextInt(totalTickets) + 1; Process selectedProcess = selectProcessByTicket(winningTicket); if (selectedProcess == null) { // This should not happen in normal circumstances, but we'll handle it just in case System.err.println(\"Error: No process selected. Recalculating total tickets.\"); totalTickets = processes.stream().mapToInt(Process::getTickets).sum(); continue; } selectedProcess.setWaitingTime(currentTime); currentTime += selectedProcess.getBurstTime(); selectedProcess.setTurnAroundTime(selectedProcess.getWaitingTime() + selectedProcess.getBurstTime()); executedProcesses.add(selectedProcess); processes.remove(selectedProcess); totalTickets = processes.stream().mapToInt(Process::getTickets).sum(); } return executedProcesses; } /** * Selects a process based on a winning ticket. The method iterates over the * list of processes, and as the ticket sum accumulates, it checks if the * current process holds the winning ticket. * * @param winningTicket The randomly generated ticket number that determines the selected process. * @return The process associated with the winning ticket. */ private Process selectProcessByTicket(int winningTicket) { int ticketSum = 0; for (Process process : processes) { ticketSum += process.getTickets(); if (ticketSum >= winningTicket) { return process; } } return null; } /** * The Process class represents a process in the scheduling system. Each process has * an ID, burst time (CPU time required for execution), number of tickets (used in * lottery selection), waiting time, and turnaround time. */ public static class Process { private String processId; private int burstTime; private int tickets; private int waitingTime; private int turnAroundTime; public Process(String processId, int burstTime, int tickets) { this.processId = processId; this.burstTime = burstTime; this.tickets = tickets; } public String getProcessId() { return processId; } public int getBurstTime() { return burstTime; } public int getTickets() { return tickets; } public int getWaitingTime() { return waitingTime; } public void setWaitingTime(int waitingTime) { this.waitingTime = waitingTime; } public int getTurnAroundTime() { return turnAroundTime; } public void setTurnAroundTime(int turnAroundTime) { this.turnAroundTime = turnAroundTime; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class Lower { private Lower() { } public static void main(String[] stringArray) { String[] stringArray2 = new String[]{\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"}; stringArray = stringArray2; stringArray = stringArray2; int cfr_ignored_0 = stringArray2.length; for (int i = 0; i < 4; ++i) { String string = stringArray[i]; assert (Lower.toLowerCase(string).equals(string.toLowerCase())); } } public static String toLowerCase(String object) { object = ((String)object).toCharArray(); for (int i = 0; i < ((Object)object).length; ++i) { if (!Character.isLetter((char)object[i]) || !Character.isUpperCase((char)object[i])) continue; object[i] = Character.toLowerCase((char)object[i]); } return new String((char[])object); } }", "deobfuscated_code": "package com.thealgorithms.strings; public final class Lower { private Lower() { } /** * Driver Code */ public static void main(String[] args) { String[] strings = {\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"}; for (String s : strings) { assert toLowerCase(s).equals(s.toLowerCase()); } } /** * Converts all of the characters in this {@code String} to lower case * * @param s the string to convert * @return the {@code String}, converted to lowercase. */ public static String toLowerCase(String s) { char[] values = s.toCharArray(); for (int i = 0; i < values.length; ++i) { if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) { values[i] = Character.toLowerCase(values[i]); } } return new String(values); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; class LowerBound implements SearchAlgorithm { LowerBound() { } @Override public int find(Comparable[] comparableArray, Comparable comparable) { return this.a(comparableArray, comparable, 0, comparableArray.length - 1); } private int a(Comparable[] comparableArray, Comparable comparable, int n, int n2) { while (n2 > n) { int n3 = n + n2 >>> 1; int n4 = comparable.compareTo(comparableArray[n3]); if (n4 == 0) { return n3; } if (n4 < 0) { n2 = n3; continue; } n = n3 + 1; } return n; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; /** * The LowerBound method is used to return an index pointing to the first * element in the range [first, last) which has a value not less than val, i.e. * the index of the next smallest number just greater than or equal to that * number. If there are multiple values that are equal to val it returns the * index of the first such value. * * <p> * This is an extension of BinarySearch. * * <p> * Worst-case performance O(log n) Best-case performance O(1) Average * performance O(log n) Worst-case space complexity O(1) * * @author Pratik Padalia (https://github.com/15pratik) * @see SearchAlgorithm * @see BinarySearch */ class LowerBound implements SearchAlgorithm { /** * @param array is an array where the LowerBound value is to be found * @param key is an element for which the LowerBound is to be found * @param <T> is any comparable type * @return index of the LowerBound element */ @Override public <T extends Comparable<T>> int find(T[] array, T key) { return search(array, key, 0, array.length - 1); } /** * This method implements the Generic Binary Search * * @param array The array to make the binary search * @param key The number you are looking for * @param left The lower bound * @param right The upper bound * @return the location of the key */ private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) { if (right <= left) { return left; } // find median int median = (left + right) >>> 1; int comp = key.compareTo(array[median]); if (comp == 0) { return median; } else if (comp < 0) { // median position can be a possible solution return search(array, key, left, median); } else { // key we are looking is greater, so we must look on the right of median position return search(array, key, median + 1, right); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.ArrayList; import java.util.List; public final class LowestBasePalindrome { private LowestBasePalindrome() { } private static void a(int n) { if (n <= 1) { throw new IllegalArgumentException(\"Base must be greater than 1.\"); } } private static void b(int n) { if (n < 0) { throw new IllegalArgumentException(\"Number must be non-negative.\"); } } public static List computeDigitsInBase(int n, int n2) { LowestBasePalindrome.b(n); LowestBasePalindrome.a(n2); ArrayList<Integer> arrayList = new ArrayList<Integer>(); while (n > 0) { arrayList.add(n % n2); n /= n2; } return arrayList; } public static boolean isPalindromic(List list) { int n = list.size(); for (int i = 0; i < n / 2; ++i) { if (((Integer)list.get(i)).equals(list.get(n - 1 - i))) continue; return false; } return true; } public static boolean isPalindromicInBase(int n, int n2) { LowestBasePalindrome.b(n); LowestBasePalindrome.a(n2); if (n <= 1) { return true; } if (n % n2 == 0) { return false; } return LowestBasePalindrome.isPalindromic(LowestBasePalindrome.computeDigitsInBase(n, n2)); } public static int lowestBasePalindrome(int n) { LowestBasePalindrome.b(n); int n2 = 2; while (!LowestBasePalindrome.isPalindromicInBase(n, n2)) { ++n2; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.ArrayList; import java.util.List; /** * @brief Class for finding the lowest base in which a given integer is a palindrome. cf. https://oeis.org/A016026 */ public final class LowestBasePalindrome { private LowestBasePalindrome() { } /** * Validates the base, ensuring it is greater than 1. * * @param base the base to be checked * @throws IllegalArgumentException if the base is less than or equal to 1 */ private static void checkBase(int base) { if (base <= 1) { throw new IllegalArgumentException(\"Base must be greater than 1.\"); } } /** * Validates the number, ensuring it is non-negative. * * @param number the number to be checked * @throws IllegalArgumentException if the number is negative */ private static void checkNumber(int number) { if (number < 0) { throw new IllegalArgumentException(\"Number must be non-negative.\"); } } /** * Computes the digits of a given number in a specified base. * * @param number the number to be converted * @param base the base to be used for the conversion * @return a list of digits representing the number in the given base, with the most * significant digit at the end of the list * @throws IllegalArgumentException if the number is negative or the base is less than 2 */ public static List<Integer> computeDigitsInBase(int number, int base) { checkNumber(number); checkBase(base); List<Integer> digits = new ArrayList<>(); while (number > 0) { digits.add(number % base); number /= base; } return digits; } /** * Checks if a list of integers is palindromic. * * @param list the list of integers to be checked * @return {@code true} if the list is a palindrome, {@code false} otherwise */ public static boolean isPalindromic(List<Integer> list) { int size = list.size(); for (int i = 0; i < size / 2; i++) { if (!list.get(i).equals(list.get(size - 1 - i))) { return false; } } return true; } /** * Checks if the representation of a given number in a specified base is palindromic. * * @param number the number to be checked * @param base the base in which the number will be represented * @return {@code true} if the number is palindromic in the specified base, {@code false} otherwise * @throws IllegalArgumentException if the number is negative or the base is less than 2 */ public static boolean isPalindromicInBase(int number, int base) { checkNumber(number); checkBase(base); if (number <= 1) { return true; } if (number % base == 0) { // If the last digit of the number in the given base is 0, it can't be palindromic return false; } return isPalindromic(computeDigitsInBase(number, base)); } /** * Finds the smallest base in which the representation of a given number is palindromic. * * @param number the number to be checked * @return the smallest base in which the number is a palindrome * @throws IllegalArgumentException if the number is negative */ public static int lowestBasePalindrome(int number) { checkNumber(number); int base = 2; while (!isPalindromicInBase(number, base)) { base++; } return base; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class LowestSetBit { private LowestSetBit() { } public static int isolateLowestSetBit(int n) { int n2 = n; return n2 & -n2; } public static int clearLowestSetBit(int n) { int n2 = n; return n2 & n2 - 1; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * Lowest Set Bit * @author Prayas Kumar (https://github.com/prayas7102) */ public final class LowestSetBit { // Private constructor to hide the default public one private LowestSetBit() { } /** * Isolates the lowest set bit of the given number. For example, if n = 18 * (binary: 10010), the result will be 2 (binary: 00010). * * @param n the number whose lowest set bit will be isolated * @return the isolated lowest set bit of n */ public static int isolateLowestSetBit(int n) { // Isolate the lowest set bit using n & -n return n & -n; } /** * Clears the lowest set bit of the given number. * For example, if n = 18 (binary: 10010), the result will be 16 (binary: 10000). * * @param n the number whose lowest set bit will be cleared * @return the number after clearing its lowest set bit */ public static int clearLowestSetBit(int n) { // Clear the lowest set bit using n & (n - 1) return n & (n - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class LucasSeries { private LucasSeries() { } public static int lucasSeries(int n) { if (n == 1) { return 2; } if (n == 2) { return 1; } return LucasSeries.lucasSeries(n - 1) + LucasSeries.lucasSeries(n - 2); } public static int lucasSeriesIteration(int n) { int n2 = 2; int n3 = 1; for (int i = 1; i < n; ++i) { int n4 = n2 + n3; n2 = n3; n3 = n4; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * https://en.wikipedia.org/wiki/Lucas_number */ public final class LucasSeries { private LucasSeries() { } /** * Calculate nth number of Lucas Series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76, * 123, ....) using recursion * * @param n nth * @return nth number of Lucas Series */ public static int lucasSeries(int n) { return n == 1 ? 2 : n == 2 ? 1 : lucasSeries(n - 1) + lucasSeries(n - 2); } /** * Calculate nth number of Lucas Series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76, * 123, ....) using iteration * * @param n nth * @return nth number of lucas series */ public static int lucasSeriesIteration(int n) { int previous = 2; int current = 1; for (int i = 1; i < n; i++) { int next = previous + current; previous = current; current = next; } return previous; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.Luhn; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; import java.util.Objects; final class Luhn$CreditCard extends Record { private final int[] a; private Luhn$CreditCard(int[] nArray) { this.a = nArray; } public static Luhn$CreditCard fromString(String string) { Objects.requireNonNull(string); Object object = string.replaceAll(\" \", \"\"); if (((String)object).length() != 16 || !((String)object).matches(\"\\\\d+\")) { throw new IllegalArgumentException(\"{\" + string + \"} - is not a card number\"); } int[] nArray = ((String)object).chars().map(n -> Character.digit(n, 10)).toArray(); object = nArray; boolean bl = Luhn.luhnCheck(nArray); if (!bl) { throw new IllegalArgumentException(\"Credit card number {\" + string + \"} - have a typo\"); } return new Luhn$CreditCard((int[])object); } public final String number() { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < 16; ++i) { if (i % 4 == 0 && i != 0) { stringBuilder.append(\" \"); } stringBuilder.append(this.a[i]); } return stringBuilder.toString(); } @Override public final String toString() { return String.format(\"%s {%s}\", Luhn$CreditCard.class.getSimpleName(), this.number()); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{Luhn$CreditCard.class, \"digits\", \"a\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{Luhn$CreditCard.class, \"digits\", \"a\"}, this, object); } public final int[] digits() { return this.a; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.Luhn; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; import java.util.Objects; final class Luhn$CreditCard extends Record { private final int[] a; private Luhn$CreditCard(int[] nArray) { this.a = nArray; } public static Luhn$CreditCard fromString(String string) { Objects.requireNonNull(string); Object object = string.replaceAll(\" \", \"\"); if (((String)object).length() != 16 || !((String)object).matches(\"\\\\d+\")) { throw new IllegalArgumentException(\"{\" + string + \"} - is not a card number\"); } int[] nArray = ((String)object).chars().map(n -> Character.digit(n, 10)).toArray(); object = nArray; boolean bl = Luhn.luhnCheck(nArray); if (!bl) { throw new IllegalArgumentException(\"Credit card number {\" + string + \"} - have a typo\"); } return new Luhn$CreditCard((int[])object); } public final String number() { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < 16; ++i) { if (i % 4 == 0 && i != 0) { stringBuilder.append(\" \"); } stringBuilder.append(this.a[i]); } return stringBuilder.toString(); } @Override public final String toString() { return String.format(\"%s {%s}\", Luhn$CreditCard.class.getSimpleName(), this.number()); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{Luhn$CreditCard.class, \"digits\", \"a\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{Luhn$CreditCard.class, \"digits\", \"a\"}, this, object); } public final int[] digits() { return this.a; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.Luhn$CreditCard; import java.util.Arrays; public final class Luhn { private Luhn() { } public static boolean luhnCheck(int[] nArray) { nArray = Arrays.copyOf(nArray, nArray.length); int n = 0; for (int i = nArray.length - 1; i >= 0; --i) { if (i % 2 == 0) { int n2 = nArray[i] << 1; if (n2 > 9) { n2 -= 9; } nArray[i] = n2; } n += nArray[i]; } return n % 10 == 0; } public static void main(String[] object) { System.out.println(\"Luhn algorithm usage examples:\"); object = new int[]{4, 5, 6, 1, 2, 6, 1, 2, 1, 2, 3, 4, 5, 4, 6, 7}; Object object2 = new int[]{4, 5, 6, 1, 2, 6, 1, 2, 1, 2, 3, 4, 5, 4, 6, 4}; Luhn.a((int[])object); Luhn.a(object2); System.out.println(\"\\nBusiness examples:\"); object = \"5265 9251 6151 1412\"; object2 = \"4929 3231 3088 1896\"; String string = \"4F15 BC06 3A88 76D5\"; Luhn.a((String)object); Luhn.a((String)object2); Luhn.a(string); } private static void a(int[] nArray) { String string = Luhn.luhnCheck(nArray) ? \"valid\" : \"not valid\"; System.out.println(\"Input \" + Arrays.toString(nArray) + \" is \" + string); } private static void a(String object) { try { System.out.println(\"Trying to create CreditCard object from valid card number: \" + (String)object); object = Luhn$CreditCard.fromString((String)object); System.out.println(\"And business object is successfully created: \" + String.valueOf(object) + \"\\n\"); return; } catch (IllegalArgumentException illegalArgumentException) { System.out.println(\"And fail with exception message: \" + illegalArgumentException.getMessage() + \"\\n\"); return; } } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Arrays; import java.util.Objects; /** * The Luhn algorithm or Luhn formula, also known as the \"modulus 10\" or \"mod * 10\" algorithm, named after its creator, IBM scientist Hans Peter Luhn, is a * simple checksum formula used to validate a variety of identification numbers. * * <p> * The algorithm is in the public domain and is in wide use today. It is * specified in ISO/IEC 7812-1. It is not intended to be a cryptographically * secure hash function; it was designed to protect against accidental errors, * not malicious attacks. Most credit cards and many government identification * numbers use the algorithm as a simple method of distinguishing valid numbers * from mistyped or otherwise incorrect numbers.</p> * * <p> * The Luhn algorithm will detect any single-digit error, as well as almost all * transpositions of adjacent digits. It will not, however, detect transposition * of the two-digit sequence 09 to 90 (or vice versa). It will detect most of * the possible twin errors (it will not detect 22  55, 33  66 or 44  * 77).</p> * * <p> * The check digit is computed as follows:</p> * <ol> * <li>Take the original number and starting from the rightmost digit moving * left, double the value of every second digit (including the rightmost * digit).</li> * <li>Replace the resulting value at each position with the sum of the digits * of this position's value or just subtract 9 from all numbers more or equal * then 10.</li> * <li>Sum up the resulting values from all positions (s).</li> * <li>The calculated check digit is equal to {@code 10 - s % 10}.</li> * </ol> * * @see <a href=\"https://en.wikipedia.org/wiki/Luhn_algorithm\">Wiki</a> */ public final class Luhn { private Luhn() { } /** * Check input digits array by Luhn algorithm. Initial array doesn't change * while processing. * * @param digits array of digits from 0 to 9 * @return true if check was successful, false otherwise */ public static boolean luhnCheck(int[] digits) { int[] numbers = Arrays.copyOf(digits, digits.length); int sum = 0; for (int i = numbers.length - 1; i >= 0; i--) { if (i % 2 == 0) { int temp = numbers[i] * 2; if (temp > 9) { temp = temp - 9; } numbers[i] = temp; } sum += numbers[i]; } return sum % 10 == 0; } public static void main(String[] args) { System.out.println(\"Luhn algorithm usage examples:\"); int[] validInput = {4, 5, 6, 1, 2, 6, 1, 2, 1, 2, 3, 4, 5, 4, 6, 7}; int[] invalidInput = {4, 5, 6, 1, 2, 6, 1, 2, 1, 2, 3, 4, 5, 4, 6, 4}; // typo in last // symbol checkAndPrint(validInput); checkAndPrint(invalidInput); System.out.println(\"\\nBusiness examples:\"); String validCardNumber = \"5265 9251 6151 1412\"; String invalidCardNumber = \"4929 3231 3088 1896\"; String illegalCardNumber = \"4F15 BC06 3A88 76D5\"; businessExample(validCardNumber); businessExample(invalidCardNumber); businessExample(illegalCardNumber); } private static void checkAndPrint(int[] input) { String validationResult = Luhn.luhnCheck(input) ? \"valid\" : \"not valid\"; System.out.println(\"Input \" + Arrays.toString(input) + \" is \" + validationResult); } /* ======================== Business usage example ======================== */ /** * Object representation of credit card. */ private record CreditCard(int[] digits) { private static final int DIGITS_COUNT = 16; /** * @param cardNumber string representation of credit card number - 16 * digits. Can have spaces for digits separation * @return credit card object * @throws IllegalArgumentException if input string is not 16 digits or * if Luhn check was failed */ public static CreditCard fromString(String cardNumber) { Objects.requireNonNull(cardNumber); String trimmedCardNumber = cardNumber.replaceAll(\" \", \"\"); if (trimmedCardNumber.length() != DIGITS_COUNT || !trimmedCardNumber.matches(\"\\\\d+\")) { throw new IllegalArgumentException(\"{\" + cardNumber + \"} - is not a card number\"); } int[] cardNumbers = toIntArray(trimmedCardNumber); boolean isValid = luhnCheck(cardNumbers); if (!isValid) { throw new IllegalArgumentException(\"Credit card number {\" + cardNumber + \"} - have a typo\"); } return new CreditCard(cardNumbers); } /** * @return string representation separated by space every 4 digits. * Example: \"5265 9251 6151 1412\" */ public String number() { StringBuilder result = new StringBuilder(); for (int i = 0; i < DIGITS_COUNT; i++) { if (i % 4 == 0 && i != 0) { result.append(\" \"); } result.append(digits[i]); } return result.toString(); } @Override public String toString() { return String.format(\"%s {%s}\", CreditCard.class.getSimpleName(), number()); } private static int[] toIntArray(String string) { return string.chars().map(i -> Character.digit(i, 10)).toArray(); } } private static void businessExample(String cardNumber) { try { System.out.println(\"Trying to create CreditCard object from valid card number: \" + cardNumber); CreditCard creditCard = CreditCard.fromString(cardNumber); System.out.println(\"And business object is successfully created: \" + creditCard + \"\\n\"); } catch (IllegalArgumentException e) { System.out.println(\"And fail with exception message: \" + e.getMessage() + \"\\n\"); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; public final class MColoring { private MColoring() { } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.HashSet; import java.util.LinkedList; import java.util.Queue; import java.util.Set; /** * Node class represents a graph node. Each node is associated with a color * (initially 1) and contains a set of edges representing its adjacent nodes. * * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi) */ class Node { int color = 1; // Initial color for each node Set<Integer> edges = new HashSet<Integer>(); // Set of edges representing adjacent nodes } /** * MColoring class solves the M-Coloring problem where the goal is to determine * if it's possible to color a graph using at most M colors such that no two * adjacent nodes have the same color. */ public final class MColoring { private MColoring() { } // Prevent instantiation of utility class /** * Determines whether it is possible to color the graph using at most M colors. * * @param nodes List of nodes representing the graph. * @param n The total number of nodes in the graph. * @param m The maximum number of allowed colors. * @return true if the graph can be colored using M colors, false otherwise. */ static boolean isColoringPossible(ArrayList<Node> nodes, int n, int m) { // Visited array keeps track of whether each node has been processed. ArrayList<Integer> visited = new ArrayList<Integer>(); for (int i = 0; i < n + 1; i++) { visited.add(0); // Initialize all nodes as unvisited (0) } // The number of colors used so far (initially set to 1, since all nodes // start with color 1). int maxColors = 1; // Loop through all the nodes to ensure every node is visited, in case the // graph is disconnected. for (int sv = 1; sv <= n; sv++) { if (visited.get(sv) > 0) { continue; // Skip nodes that are already visited } // If the node is unvisited, mark it as visited and add it to the queue for BFS. visited.set(sv, 1); Queue<Integer> q = new LinkedList<>(); q.add(sv); // Perform BFS to process all nodes and their adjacent nodes while (q.size() != 0) { int top = q.peek(); // Get the current node from the queue q.remove(); // Check all adjacent nodes of the current node for (int it : nodes.get(top).edges) { // If the adjacent node has the same color as the current node, increment its // color to avoid conflict. if (nodes.get(top).color == nodes.get(it).color) { nodes.get(it).color += 1; } // Keep track of the maximum number of colors used so far maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color)); // If the number of colors used exceeds the allowed limit M, return false. if (maxColors > m) { return false; } // If the adjacent node hasn't been visited yet, mark it as visited and add it // to the queue for further processing. if (visited.get(it) == 0) { visited.set(it, 1); q.add(it); } } } } return true; // Possible to color the entire graph with M or fewer colors. } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.Process; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; public class MLFQScheduler { private List a; private int[] b; private int c; public MLFQScheduler(int n, int[] nArray) { this.a = new ArrayList(n); for (int i = 0; i < n; ++i) { this.a.add(new LinkedList()); } this.b = nArray; this.c = 0; } public void addProcess(Process process) { ((Queue)this.a.get(0)).add(process); } public void run() { block0: while (true) { boolean bl; block8: { MLFQScheduler mLFQScheduler = this; for (Queue queue : mLFQScheduler.a) { if (queue.isEmpty()) continue; bl = false; break block8; } bl = true; } if (bl) break; int n = 0; while (true) { Queue queue; if (n >= this.a.size()) continue block0; queue = (Queue)this.a.get(n); if (!queue.isEmpty()) { Process process = (Process)queue.poll(); int n2 = this.b[n]; n2 = Math.min(n2, process.b); process.execute(n2); this.c += n2; if (process.isFinished()) { System.out.println(\"Process \" + process.a + \" finished at time \" + this.c); } else if (n < this.a.size() - 1) { ++process.c; ((Queue)this.a.get(n + 1)).add(process); } else { queue.add(process); } } ++n; } break; } } public int getCurrentTime() { return this.c; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; /** * The Multi-Level Feedback Queue (MLFQ) Scheduler class. * This class simulates scheduling using multiple queues, where processes move * between queues depending on their CPU burst behavior. */ public class MLFQScheduler { private List<Queue<Process>> queues; // Multi-level feedback queues private int[] timeQuantum; // Time quantum for each queue level private int currentTime; // Current time in the system /** * Constructor to initialize the MLFQ scheduler with the specified number of * levels and their corresponding time quantums. * * @param levels Number of queues (priority levels) * @param timeQuantums Time quantum for each queue level */ public MLFQScheduler(int levels, int[] timeQuantums) { queues = new ArrayList<>(levels); for (int i = 0; i < levels; i++) { queues.add(new LinkedList<>()); } timeQuantum = timeQuantums; currentTime = 0; } /** * Adds a new process to the highest priority queue (queue 0). * * @param p The process to be added to the scheduler */ public void addProcess(Process p) { queues.get(0).add(p); } /** * Executes the scheduling process by running the processes in all queues, * promoting or demoting them based on their completion status and behavior. * The process continues until all queues are empty. */ public void run() { while (!allQueuesEmpty()) { for (int i = 0; i < queues.size(); i++) { Queue<Process> queue = queues.get(i); if (!queue.isEmpty()) { Process p = queue.poll(); int quantum = timeQuantum[i]; // Execute the process for the minimum of the time quantum or the remaining time int timeSlice = Math.min(quantum, p.remainingTime); p.execute(timeSlice); currentTime += timeSlice; // Update the system's current time if (p.isFinished()) { System.out.println(\"Process \" + p.pid + \" finished at time \" + currentTime); } else { if (i < queues.size() - 1) { p.priority++; // Demote the process to the next lower priority queue queues.get(i + 1).add(p); // Add to the next queue level } else { queue.add(p); // Stay in the same queue if it's the last level } } } } } } /** * Helper function to check if all the queues are empty (i.e., no process is * left to execute). * * @return true if all queues are empty, otherwise false */ private boolean allQueuesEmpty() { for (Queue<Process> queue : queues) { if (!queue.isEmpty()) { return false; } } return true; } /** * Retrieves the current time of the scheduler, which reflects the total time * elapsed during the execution of all processes. * * @return The current time in the system */ public int getCurrentTime() { return currentTime; } } /** * Represents a process in the Multi-Level Feedback Queue (MLFQ) scheduling * algorithm. */ class Process { int pid; int burstTime; int remainingTime; int arrivalTime; int priority; /** * Constructor to initialize a new process. * * @param pid Process ID * @param burstTime CPU Burst Time (time required for the process) * @param arrivalTime Arrival time of the process */ Process(int pid, int burstTime, int arrivalTime) { this.pid = pid; this.burstTime = burstTime; this.remainingTime = burstTime; this.arrivalTime = arrivalTime; this.priority = 0; } /** * Executes the process for a given time slice. * * @param timeSlice The amount of time the process is executed */ public void execute(int timeSlice) { remainingTime -= timeSlice; if (remainingTime < 0) { remainingTime = 0; } } /** * Checks if the process has finished execution. * * @return true if the process is finished, otherwise false */ public boolean isFinished() { return remainingTime == 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; final class MRUCache$Entry { private MRUCache$Entry a; private MRUCache$Entry b; private Object c; private Object d; MRUCache$Entry() { } public final MRUCache$Entry getPreEntry() { return this.a; } public final void setPreEntry(MRUCache$Entry mRUCache$Entry) { this.a = mRUCache$Entry; } public final MRUCache$Entry getNextEntry() { return this.b; } public final void setNextEntry(MRUCache$Entry mRUCache$Entry) { this.b = mRUCache$Entry; } public final Object getKey() { return this.c; } public final void setKey(Object object) { this.c = object; } public final Object getValue() { return this.d; } public final void setValue(Object object) { this.d = object; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; final class MRUCache$Entry { private MRUCache$Entry a; private MRUCache$Entry b; private Object c; private Object d; MRUCache$Entry() { } public final MRUCache$Entry getPreEntry() { return this.a; } public final void setPreEntry(MRUCache$Entry mRUCache$Entry) { this.a = mRUCache$Entry; } public final MRUCache$Entry getNextEntry() { return this.b; } public final void setNextEntry(MRUCache$Entry mRUCache$Entry) { this.b = mRUCache$Entry; } public final Object getKey() { return this.c; } public final void setKey(Object object) { this.c = object; } public final Object getValue() { return this.d; } public final void setValue(Object object) { this.d = object; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.MRUCache$Entry; import java.util.HashMap; import java.util.Map; public class MRUCache { private final Map a = new HashMap(); private MRUCache$Entry b; private MRUCache$Entry c; private int d; public MRUCache() { this.a(100); } public MRUCache(int n) { this.a(n); } private void a(int n) { MRUCache.b(n); while (this.a.size() > n) { MRUCache$Entry mRUCache$Entry = this.a(); this.a.remove(mRUCache$Entry.getKey()); } this.d = n; } private static void b(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Capacity must be greater than 0!\"); } } private MRUCache$Entry a() { if (this.b == null) { throw new RuntimeException(\"Cache cannot be empty!\"); } MRUCache$Entry mRUCache$Entry = this.c; this.c = mRUCache$Entry.getPreEntry(); if (this.c != null) { this.c.setNextEntry(null); } mRUCache$Entry.setNextEntry(null); return mRUCache$Entry; } public Object get(Object object) { if (!this.a.containsKey(object)) { return null; } object = (MRUCache$Entry)this.a.get(object); this.a((MRUCache$Entry)object); return ((MRUCache$Entry)object).getValue(); } public void put(Object object, Object object2) { MRUCache$Entry mRUCache$Entry; if (this.a.containsKey(object)) { MRUCache$Entry mRUCache$Entry2 = (MRUCache$Entry)this.a.get(object); mRUCache$Entry2.setValue(object2); this.a(mRUCache$Entry2); return; } if (this.a.size() == this.d) { mRUCache$Entry = this.a(); this.a.remove(mRUCache$Entry.getKey()); } else { mRUCache$Entry = new MRUCache$Entry(); } mRUCache$Entry.setKey(object); mRUCache$Entry.setValue(object2); MRUCache$Entry mRUCache$Entry3 = mRUCache$Entry; object2 = this; if (((MRUCache)object2).a.isEmpty()) { ((MRUCache)object2).b = mRUCache$Entry3; ((MRUCache)object2).c = mRUCache$Entry3; } else { ((MRUCache)object2).c.setNextEntry(mRUCache$Entry3); mRUCache$Entry3.setPreEntry(((MRUCache)object2).c); mRUCache$Entry3.setNextEntry(null); ((MRUCache)object2).c = mRUCache$Entry3; } this.a.put(object, mRUCache$Entry); } private void a(MRUCache$Entry mRUCache$Entry) { if (this.c == mRUCache$Entry) { return; } MRUCache$Entry mRUCache$Entry2 = mRUCache$Entry.getPreEntry(); MRUCache$Entry mRUCache$Entry3 = mRUCache$Entry.getNextEntry(); if (mRUCache$Entry2 != null) { mRUCache$Entry2.setNextEntry(mRUCache$Entry3); } if (mRUCache$Entry3 != null) { mRUCache$Entry3.setPreEntry(mRUCache$Entry2); } if (this.b == mRUCache$Entry) { this.b = mRUCache$Entry3; } this.c.setNextEntry(mRUCache$Entry); mRUCache$Entry.setPreEntry(this.c); mRUCache$Entry.setNextEntry(null); this.c = mRUCache$Entry; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.caches; import java.util.HashMap; import java.util.Map; /** * Represents a Most Recently Used (MRU) Cache. * <p> * In contrast to the Least Recently Used (LRU) strategy, the MRU caching policy * evicts the most recently accessed items first. This class provides methods to * store key-value pairs and manage cache eviction based on this policy. * * For more information, refer to: * <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#Most_recently_used_(MRU)\">MRU on Wikipedia</a>. * * @param <K> the type of keys maintained by this cache * @param <V> the type of values associated with the keys */ public class MRUCache<K, V> { private final Map<K, Entry<K, V>> data = new HashMap<>(); private Entry<K, V> head; private Entry<K, V> tail; private int cap; private static final int DEFAULT_CAP = 100; /** * Creates an MRUCache with the default capacity. */ public MRUCache() { setCapacity(DEFAULT_CAP); } /** * Creates an MRUCache with a specified capacity. * * @param cap the maximum number of items the cache can hold */ public MRUCache(int cap) { setCapacity(cap); } /** * Sets the capacity of the cache and evicts items if the new capacity * is less than the current number of items. * * @param newCapacity the new capacity to set */ private void setCapacity(int newCapacity) { checkCapacity(newCapacity); while (data.size() > newCapacity) { Entry<K, V> evicted = evict(); data.remove(evicted.getKey()); } this.cap = newCapacity; } /** * Checks if the specified capacity is valid. * * @param capacity the capacity to check * @throws IllegalArgumentException if the capacity is less than or equal to zero */ private void checkCapacity(int capacity) { if (capacity <= 0) { throw new IllegalArgumentException(\"Capacity must be greater than 0!\"); } } /** * Evicts the most recently used entry from the cache. * * @return the evicted entry * @throws RuntimeException if the cache is empty */ private Entry<K, V> evict() { if (head == null) { throw new RuntimeException(\"Cache cannot be empty!\"); } final Entry<K, V> evicted = this.tail; tail = evicted.getPreEntry(); if (tail != null) { tail.setNextEntry(null); } evicted.setNextEntry(null); return evicted; } /** * Retrieves the value associated with the specified key. * * @param key the key whose associated value is to be returned * @return the value associated with the specified key, or null if the key does not exist */ public V get(K key) { if (!data.containsKey(key)) { return null; } final Entry<K, V> entry = data.get(key); moveEntryToLast(entry); return entry.getValue(); } /** * Associates the specified value with the specified key in the cache. * If the key already exists, its value is updated and the entry is moved to the most recently used position. * If the cache is full, the most recently used entry is evicted before adding the new entry. * * @param key the key with which the specified value is to be associated * @param value the value to be associated with the specified key */ public void put(K key, V value) { if (data.containsKey(key)) { final Entry<K, V> existingEntry = data.get(key); existingEntry.setValue(value); moveEntryToLast(existingEntry); return; } Entry<K, V> newEntry; if (data.size() == cap) { newEntry = evict(); data.remove(newEntry.getKey()); } else { newEntry = new Entry<>(); } newEntry.setKey(key); newEntry.setValue(value); addNewEntry(newEntry); data.put(key, newEntry); } /** * Adds a new entry to the cache and updates the head and tail pointers accordingly. * * @param newEntry the new entry to be added */ private void addNewEntry(Entry<K, V> newEntry) { if (data.isEmpty()) { head = newEntry; tail = newEntry; return; } tail.setNextEntry(newEntry); newEntry.setPreEntry(tail); newEntry.setNextEntry(null); tail = newEntry; } /** * Moves the specified entry to the most recently used position in the cache. * * @param entry the entry to be moved */ private void moveEntryToLast(Entry<K, V> entry) { if (tail == entry) { return; } final Entry<K, V> preEntry = entry.getPreEntry(); final Entry<K, V> nextEntry = entry.getNextEntry(); if (preEntry != null) { preEntry.setNextEntry(nextEntry); } if (nextEntry != null) { nextEntry.setPreEntry(preEntry); } if (head == entry) { head = nextEntry; } tail.setNextEntry(entry); entry.setPreEntry(tail); entry.setNextEntry(null); tail = entry; } /** * A nested class representing an entry in the cache, which holds a key-value pair * and references to the previous and next entries in the linked list structure. * * @param <I> the type of the key * @param <J> the type of the value */ static final class Entry<I, J> { private Entry<I, J> preEntry; private Entry<I, J> nextEntry; private I key; private J value; Entry() { } Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) { this.preEntry = preEntry; this.nextEntry = nextEntry; this.key = key; this.value = value; } public Entry<I, J> getPreEntry() { return preEntry; } public void setPreEntry(Entry<I, J> preEntry) { this.preEntry = preEntry; } public Entry<I, J> getNextEntry() { return nextEntry; } public void setNextEntry(Entry<I, J> nextEntry) { this.nextEntry = nextEntry; } public I getKey() { return key; } public void setKey(I key) { this.key = key; } public J getValue() { return value; } public void setValue(J value) { this.value = value; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.Scanner; public final class MagicSquare { private MagicSquare() { } public static void main(String[] object) { object = new Scanner(System.in); System.out.print(\"Input a number: \"); int n = ((Scanner)object).nextInt(); if (n % 2 == 0 || n <= 0) { System.out.print(\"Input number must be odd and >0\"); System.exit(0); } int n2 = n; int[][] nArray = new int[n2][n2]; int n3 = n / 2; int n4 = n - 1; nArray[n3][n4] = 1; int n5 = 2; while (true) { int n6 = n; if (n5 > n6 * n6) break; if (nArray[(n3 - 1 + n) % n][(n4 + 1) % n] == 0) { n3 = (n3 - 1 + n) % n; n4 = (n4 + 1) % n; } else { n4 = (n4 - 1 + n) % n; } nArray[n3][n4] = n5++; } for (n5 = 0; n5 < n; ++n5) { for (n3 = 0; n3 < n; ++n3) { if (nArray[n5][n3] < 10) { System.out.print(\" \"); } if (nArray[n5][n3] < 100) { System.out.print(\" \"); } System.out.print(nArray[n5][n3] + \" \"); } System.out.println(); } ((Scanner)object).close(); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.Scanner; /*A magic square of order n is an arrangement of distinct n^2 integers,in a square, such that the n numbers in all rows, all columns, and both diagonals sum to the same constant. A magic square contains the integers from 1 to n^2.*/ public final class MagicSquare { private MagicSquare() { } public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\"Input a number: \"); int num = sc.nextInt(); if ((num % 2 == 0) || (num <= 0)) { System.out.print(\"Input number must be odd and >0\"); System.exit(0); } int[][] magicSquare = new int[num][num]; int rowNum = num / 2; int colNum = num - 1; magicSquare[rowNum][colNum] = 1; for (int i = 2; i <= num * num; i++) { if (magicSquare[(rowNum - 1 + num) % num][(colNum + 1) % num] == 0) { rowNum = (rowNum - 1 + num) % num; colNum = (colNum + 1) % num; } else { colNum = (colNum - 1 + num) % num; } magicSquare[rowNum][colNum] = i; } // print the square for (int i = 0; i < num; i++) { for (int j = 0; j < num; j++) { if (magicSquare[i][j] < 10) { System.out.print(\" \"); } if (magicSquare[i][j] < 100) { System.out.print(\" \"); } System.out.print(magicSquare[i][j] + \" \"); } System.out.println(); } sc.close(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import com.thealgorithms.datastructures.hashmap.hashing.HashMapCuckooHashing; import java.util.Scanner; public final class MainCuckooHashing { private MainCuckooHashing() { } public static void main(String[] stringArray) { int n; HashMapCuckooHashing hashMapCuckooHashing = new HashMapCuckooHashing(7); Scanner scanner = new Scanner(System.in); block9: while (true) { System.out.println(\"_________________________\"); System.out.println(\"Enter your Choice :\"); System.out.println(\"1. Add Key\"); System.out.println(\"2. Delete Key\"); System.out.println(\"3. Print Table\"); System.out.println(\"4. Exit\"); System.out.println(\"5. Search and print key index\"); System.out.println(\"6. Check load factor\"); System.out.println(\"7. Rehash Current Table\"); n = scanner.nextInt(); switch (n) { case 1: { System.out.println(\"Enter the Key: \"); n = scanner.nextInt(); hashMapCuckooHashing.insertKey2HashTable(n); continue block9; } case 2: { System.out.println(\"Enter the Key delete: \"); n = scanner.nextInt(); hashMapCuckooHashing.deleteKeyFromHashTable(n); continue block9; } case 3: { System.out.println(\"Print table:\\n\"); hashMapCuckooHashing.displayHashtable(); continue block9; } case 4: { scanner.close(); return; } case 5: { System.out.println(\"Enter the Key to find and print: \"); n = scanner.nextInt(); System.out.println(\"Key: \" + n + \" is at index: \" + hashMapCuckooHashing.findKeyInTable(n) + \"\\n\"); continue block9; } case 6: { System.out.printf(\"Load factor is: %.2f%n\", hashMapCuckooHashing.checkLoadFactor()); continue block9; } case 7: { hashMapCuckooHashing.reHashTableIncreasesTableSize(); continue block9; } } break; } throw new IllegalArgumentException(\"Unexpected value: \" + n); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.hashmap.hashing; import java.util.Scanner; public final class MainCuckooHashing { private MainCuckooHashing() { } public static void main(String[] args) { int choice; int key; HashMapCuckooHashing h = new HashMapCuckooHashing(7); Scanner scan = new Scanner(System.in); while (true) { System.out.println(\"_________________________\"); System.out.println(\"Enter your Choice :\"); System.out.println(\"1. Add Key\"); System.out.println(\"2. Delete Key\"); System.out.println(\"3. Print Table\"); System.out.println(\"4. Exit\"); System.out.println(\"5. Search and print key index\"); System.out.println(\"6. Check load factor\"); System.out.println(\"7. Rehash Current Table\"); choice = scan.nextInt(); switch (choice) { case 1: System.out.println(\"Enter the Key: \"); key = scan.nextInt(); h.insertKey2HashTable(key); break; case 2: System.out.println(\"Enter the Key delete: \"); key = scan.nextInt(); h.deleteKeyFromHashTable(key); break; case 3: System.out.println(\"Print table:\\n\"); h.displayHashtable(); break; case 4: scan.close(); return; case 5: System.out.println(\"Enter the Key to find and print: \"); key = scan.nextInt(); System.out.println(\"Key: \" + key + \" is at index: \" + h.findKeyInTable(key) + \"\\n\"); break; case 6: System.out.printf(\"Load factor is: %.2f%n\", h.checkLoadFactor()); break; case 7: h.reHashTableIncreasesTableSize(); break; default: throw new IllegalArgumentException(\"Unexpected value: \" + choice); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; public final class MajorityElement { private MajorityElement() { } public static List majority(int[] nArray) { if (nArray == null || nArray.length == 0) { return Collections.emptyList(); } HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>(); Object object = nArray; int n = nArray.length; for (int i = 0; i < n; ++i) { int n2 = object[i]; hashMap.merge(n2, 1, Integer::sum); } object = new ArrayList(); for (Map.Entry entry : hashMap.entrySet()) { if ((Integer)entry.getValue() < nArray.length / 2) continue; object.add((Integer)entry.getKey()); } return object; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.hashmap.hashing; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; /** * This class provides a method to find the majority element(s) in an array of integers. * A majority element is defined as an element that appears at least n/2 times, * where n is the length of the array. If multiple elements qualify as majority elements, * they are all returned in a list. */ public final class MajorityElement { private MajorityElement() { } /** * Returns a list of majority element(s) from the given array of integers. * * @param nums an array of integers * @return a list containing the majority element(s); returns an empty list if none exist or input is null/empty */ public static List<Integer> majority(int[] nums) { if (nums == null || nums.length == 0) { return Collections.emptyList(); } Map<Integer, Integer> numToCount = new HashMap<>(); for (final var num : nums) { numToCount.merge(num, 1, Integer::sum); } List<Integer> majorityElements = new ArrayList<>(); for (final var entry : numToCount.entrySet()) { if (entry.getValue() >= nums.length / 2) { majorityElements.add(entry.getKey()); } } return majorityElements; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class Manacher { private Manacher() { } public static String longestPalindrome(String string) { int n; Object object; int n2; int n3; Object object2; String string2; Object object3 = string; if (((String)object3).isEmpty()) { string2 = \"^$\"; } else { object2 = new StringBuilder(\"^\"); char[] cArray = ((String)object3).toCharArray(); object3 = cArray; n3 = cArray.length; for (n2 = 0; n2 < n3; ++n2) { object = object3[n2]; ((StringBuilder)object2).append('#').append((char)object); } ((StringBuilder)object2).append(\"#$\"); string2 = ((StringBuilder)object2).toString(); } object3 = string2; object2 = new int[string2.length()]; n3 = 0; n2 = 0; object = false; int n4 = 0; for (n = 1; n < ((String)object3).length() - 1; ++n) { int n5 = 2 * n3 - n; if (n < n2) { object2[n] = Math.min(n2 - n, (int)object2[n5]); } while (((String)object3).charAt(n + 1 + object2[n]) == ((String)object3).charAt(n - 1 - object2[n])) { Object object4 = object2; int n6 = n; object4[n6] = object4[n6] + true; } if (n + object2[n] > n2) { n3 = n; n2 = n + object2[n]; } if (object2[n] <= object) continue; object = object2[n]; n4 = n; } int n7 = n = (n4 - object) / 2; return string.substring(n7, n7 + object); } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * Wikipedia: https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm */ public final class Manacher { private Manacher() { } /** * Finds the longest palindromic substring using Manacher's Algorithm * * @param s The input string * @return The longest palindromic substring in {@code s} */ public static String longestPalindrome(String s) { final String processedString = preprocess(s); int[] palindromeLengths = new int[processedString.length()]; int center = 0; int rightBoundary = 0; int maxLen = 0; int centerIndex = 0; for (int i = 1; i < processedString.length() - 1; i++) { int mirror = 2 * center - i; if (i < rightBoundary) { palindromeLengths[i] = Math.min(rightBoundary - i, palindromeLengths[mirror]); } while (processedString.charAt(i + 1 + palindromeLengths[i]) == processedString.charAt(i - 1 - palindromeLengths[i])) { palindromeLengths[i]++; } if (i + palindromeLengths[i] > rightBoundary) { center = i; rightBoundary = i + palindromeLengths[i]; } if (palindromeLengths[i] > maxLen) { maxLen = palindromeLengths[i]; centerIndex = i; } } final int start = (centerIndex - maxLen) / 2; return s.substring(start, start + maxLen); } /** * Preprocesses the input string by inserting a special character ('#') between each character * and adding '^' at the start and '$' at the end to avoid boundary conditions. * * @param s The original string * @return The preprocessed string with additional characters */ private static String preprocess(String s) { if (s.isEmpty()) { return \"^$\"; } StringBuilder sb = new StringBuilder(\"^\"); for (char c : s.toCharArray()) { sb.append('#').append(c); } sb.append(\"#$\"); return sb.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.awt.Color; import java.awt.image.BufferedImage; import java.awt.image.RenderedImage; import java.io.File; import java.io.IOException; import javax.imageio.ImageIO; public final class Mandelbrot { private Mandelbrot() { } public static void main(String[] object) { object = Mandelbrot.getImage(800, 600, -0.6, 0.0, 3.2, 50, false); assert (((BufferedImage)object).getRGB(0, 0) == new Color(255, 255, 255).getRGB()); assert (((BufferedImage)object).getRGB(400, 300) == new Color(0, 0, 0).getRGB()); object = Mandelbrot.getImage(800, 600, -0.6, 0.0, 3.2, 50, true); assert (((BufferedImage)object).getRGB(0, 0) == new Color(255, 0, 0).getRGB()); assert (((BufferedImage)object).getRGB(400, 300) == new Color(0, 0, 0).getRGB()); try { ImageIO.write((RenderedImage)object, \"png\", new File(\"Mandelbrot.png\")); return; } catch (IOException iOException) { object = iOException; iOException.printStackTrace(); return; } } public static BufferedImage getImage(int n, int n2, double d, double d2, double d3, int n3, boolean bl) { if (n <= 0) { throw new IllegalArgumentException(\"imageWidth should be greater than zero\"); } if (n2 <= 0) { throw new IllegalArgumentException(\"imageHeight should be greater than zero\"); } if (n3 <= 0) { throw new IllegalArgumentException(\"maxStep should be greater than zero\"); } BufferedImage bufferedImage = new BufferedImage(n, n2, 1); double d4 = d3 / (double)n * (double)n2; for (int i = 0; i < n; ++i) { for (int j = 0; j < n2; ++j) { int n4; double d5; double d6 = d + ((double)i / (double)n - 0.5) * d3; double d7 = d2 + ((double)j / (double)n2 - 0.5) * d4; int n5 = n3; double d8 = d7; double d9 = d5 = d6; double d10 = d8; int n6 = 0; int n7 = 0; while (n7 < n5) { n6 = n7++; double d11 = d9; double d12 = d10; double d13 = d11 * d11 - d12 * d12 + d5; d10 = d9 * 2.0 * d10 + d8; d9 = d13; double d14 = d10; if (!(d9 * d9 + d14 * d14 > 4.0)) continue; } double d15 = (double)n6 / (double)(n5 - 1); if (bl) { Color color; double d16; d5 = d15; if (d16 >= 1.0) { color = new Color(0, 0, 0); } else { d8 = d5 * 360.0; int n8 = (int)Math.floor(d8 / 60.0) % 6; double d17 = d8 / 60.0 - Math.floor(d8 / 60.0); n5 = (int)(255.0 * (1.0 - d17)); int n9 = (int)(255.0 * (1.0 - (1.0 - d17))); switch (n8) { case 0: { color = new Color(255, n9, 0); break; } case 1: { color = new Color(n5, 255, 0); break; } case 2: { color = new Color(0, 255, n9); break; } case 3: { color = new Color(0, n5, 255); break; } case 4: { color = new Color(n9, 0, 255); break; } default: { color = new Color(255, 0, n5); } } } n4 = color.getRGB(); } else { double d18; d5 = d15; n4 = (d18 >= 1.0 ? new Color(0, 0, 0) : new Color(255, 255, 255)).getRGB(); } bufferedImage.setRGB(i, j, n4); } } return bufferedImage; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.awt.Color; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import javax.imageio.ImageIO; /** * The Mandelbrot set is the set of complex numbers \"c\" for which the series * \"z_(n+1) = z_n * z_n + c\" does not diverge, i.e. remains bounded. Thus, a * complex number \"c\" is a member of the Mandelbrot set if, when starting with * \"z_0 = 0\" and applying the iteration repeatedly, the absolute value of \"z_n\" * remains bounded for all \"n > 0\". Complex numbers can be written as \"a + b*i\": * \"a\" is the real component, usually drawn on the x-axis, and \"b*i\" is the * imaginary component, usually drawn on the y-axis. Most visualizations of the * Mandelbrot set use a color-coding to indicate after how many steps in the * series the numbers outside the set cross the divergence threshold. Images of * the Mandelbrot set exhibit an elaborate and infinitely complicated boundary * that reveals progressively ever-finer recursive detail at increasing * magnifications, making the boundary of the Mandelbrot set a fractal curve. * (description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set ) (see * also https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set * ) */ public final class Mandelbrot { private Mandelbrot() { } public static void main(String[] args) { // Test black and white BufferedImage blackAndWhiteImage = getImage(800, 600, -0.6, 0, 3.2, 50, false); // Pixel outside the Mandelbrot set should be white. assert blackAndWhiteImage.getRGB(0, 0) == new Color(255, 255, 255).getRGB(); // Pixel inside the Mandelbrot set should be black. assert blackAndWhiteImage.getRGB(400, 300) == new Color(0, 0, 0).getRGB(); // Test color-coding BufferedImage coloredImage = getImage(800, 600, -0.6, 0, 3.2, 50, true); // Pixel distant to the Mandelbrot set should be red. assert coloredImage.getRGB(0, 0) == new Color(255, 0, 0).getRGB(); // Pixel inside the Mandelbrot set should be black. assert coloredImage.getRGB(400, 300) == new Color(0, 0, 0).getRGB(); // Save image try { ImageIO.write(coloredImage, \"png\", new File(\"Mandelbrot.png\")); } catch (IOException e) { e.printStackTrace(); } } /** * Method to generate the image of the Mandelbrot set. Two types of * coordinates are used: image-coordinates that refer to the pixels and * figure-coordinates that refer to the complex numbers inside and outside * the Mandelbrot set. The figure-coordinates in the arguments of this * method determine which section of the Mandelbrot set is viewed. The main * area of the Mandelbrot set is roughly between \"-1.5 < x < 0.5\" and \"-1 < * y < 1\" in the figure-coordinates. * * @param imageWidth The width of the rendered image. * @param imageHeight The height of the rendered image. * @param figureCenterX The x-coordinate of the center of the figure. * @param figureCenterY The y-coordinate of the center of the figure. * @param figureWidth The width of the figure. * @param maxStep Maximum number of steps to check for divergent behavior. * @param useDistanceColorCoding Render in color or black and white. * @return The image of the rendered Mandelbrot set. */ public static BufferedImage getImage(int imageWidth, int imageHeight, double figureCenterX, double figureCenterY, double figureWidth, int maxStep, boolean useDistanceColorCoding) { if (imageWidth <= 0) { throw new IllegalArgumentException(\"imageWidth should be greater than zero\"); } if (imageHeight <= 0) { throw new IllegalArgumentException(\"imageHeight should be greater than zero\"); } if (maxStep <= 0) { throw new IllegalArgumentException(\"maxStep should be greater than zero\"); } BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); double figureHeight = figureWidth / imageWidth * imageHeight; // loop through the image-coordinates for (int imageX = 0; imageX < imageWidth; imageX++) { for (int imageY = 0; imageY < imageHeight; imageY++) { // determine the figure-coordinates based on the image-coordinates double figureX = figureCenterX + ((double) imageX / imageWidth - 0.5) * figureWidth; double figureY = figureCenterY + ((double) imageY / imageHeight - 0.5) * figureHeight; double distance = getDistance(figureX, figureY, maxStep); // color the corresponding pixel based on the selected coloring-function image.setRGB(imageX, imageY, useDistanceColorCoding ? colorCodedColorMap(distance).getRGB() : blackAndWhiteColorMap(distance).getRGB()); } } return image; } /** * Black and white color-coding that ignores the relative distance. The * Mandelbrot set is black, everything else is white. * * @param distance Distance until divergence threshold * @return The color corresponding to the distance. */ private static Color blackAndWhiteColorMap(double distance) { return distance >= 1 ? new Color(0, 0, 0) : new Color(255, 255, 255); } /** * Color-coding taking the relative distance into account. The Mandelbrot * set is black. * * @param distance Distance until divergence threshold. * @return The color corresponding to the distance. */ private static Color colorCodedColorMap(double distance) { if (distance >= 1) { return new Color(0, 0, 0); } else { // simplified transformation of HSV to RGB // distance determines hue double hue = 360 * distance; double saturation = 1; double val = 255; int hi = (int) (Math.floor(hue / 60)) % 6; double f = hue / 60 - Math.floor(hue / 60); int v = (int) val; int p = 0; int q = (int) (val * (1 - f * saturation)); int t = (int) (val * (1 - (1 - f) * saturation)); switch (hi) { case 0: return new Color(v, t, p); case 1: return new Color(q, v, p); case 2: return new Color(p, v, t); case 3: return new Color(p, q, v); case 4: return new Color(t, p, v); default: return new Color(v, p, q); } } } /** * Return the relative distance (ratio of steps taken to maxStep) after * which the complex number constituted by this x-y-pair diverges. Members * of the Mandelbrot set do not diverge so their distance is 1. * * @param figureX The x-coordinate within the figure. * @param figureX The y-coordinate within the figure. * @param maxStep Maximum number of steps to check for divergent behavior. * @return The relative distance as the ratio of steps taken to maxStep. */ private static double getDistance(double figureX, double figureY, int maxStep) { double a = figureX; double b = figureY; int currentStep = 0; for (int step = 0; step < maxStep; step++) { currentStep = step; double aNew = a * a - b * b + figureX; b = 2 * a * b + figureY; a = aNew; // divergence happens for all complex number with an absolute value // greater than 4 (= divergence threshold) if (a * a + b * b > 4) { break; } } return (double) currentStep / (maxStep - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.hashmap.hashing; public abstract class Map { abstract Object get(Object var1); public boolean contains(Object object) { return this.get(object) != null; } protected static int a(Object object, int n) { return (object.hashCode() & Integer.MAX_VALUE) % n; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.hashmap.hashing; public abstract class Map<Key, Value> { abstract boolean put(Key key, Value value); abstract Value get(Key key); abstract boolean delete(Key key); abstract Iterable<Key> keys(); abstract int size(); public boolean contains(Key key) { return get(key) != null; } protected int hash(Key key, int size) { return (key.hashCode() & Integer.MAX_VALUE) % size; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import java.util.Arrays; import java.util.LinkedHashMap; import java.util.function.Function; import java.util.stream.Collectors; public final class MapReduce { private MapReduce() { } public static String countWordFrequencies(String object) { object = Arrays.asList(((String)object).trim().split(\"\\\\s+\")); object = object.stream().collect(Collectors.groupingBy(Function.identity(), LinkedHashMap::new, Collectors.counting())); return object.entrySet().stream().map(entry -> (String)entry.getKey() + \": \" + String.valueOf(entry.getValue())).collect(Collectors.joining(\",\")); } }", "deobfuscated_code": "package com.thealgorithms.misc; import java.util.Arrays; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.function.Function; import java.util.stream.Collectors; /** * MapReduce is a programming model for processing and generating large data sets * using a parallel, distributed algorithm on a cluster. * It consists of two main phases: * - Map: the input data is split into smaller chunks and processed in parallel. * - Reduce: the results from the Map phase are aggregated to produce the final output. * * See also: https://en.wikipedia.org/wiki/MapReduce */ public final class MapReduce { private MapReduce() { } /** * Counts the frequency of each word in a given sentence using a simple MapReduce-style approach. * * @param sentence the input sentence * @return a string representing word frequencies in the format \"word: count,word: count,...\" */ public static String countWordFrequencies(String sentence) { // Map phase: split the sentence into words List<String> words = Arrays.asList(sentence.trim().split(\"\\\\s+\")); // Group and count occurrences of each word, maintain insertion order Map<String, Long> wordCounts = words.stream().collect(Collectors.groupingBy(Function.identity(), LinkedHashMap::new, Collectors.counting())); // Reduce phase: format the result return wordCounts.entrySet().stream().map(entry -> entry.getKey() + \": \" + entry.getValue()).collect(Collectors.joining(\",\")); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.MathBuilder; import java.text.DecimalFormat; import java.text.NumberFormat; import java.util.Random; import java.util.function.BiFunction; import java.util.function.Function; public class MathBuilder$Builder { private double a; private double b; private boolean c; private double d = 0.0; public MathBuilder$Builder() { this.a = 0.0; } public MathBuilder$Builder(double d) { this.a = d; } public MathBuilder$Builder add(double d) { if (this.c) { this.b += d; } else { this.a += d; } return this; } public MathBuilder$Builder addIf(double d, BiFunction biFunction) { if (!((Boolean)biFunction.apply(this.a, d)).booleanValue()) { return this; } if (this.c) { this.b += d; } else { this.a += d; } return this; } public MathBuilder$Builder minus(double d) { if (this.c) { this.b -= d; } else { this.a -= d; } return this; } public MathBuilder$Builder minusIf(double d, BiFunction biFunction) { if (!((Boolean)biFunction.apply(this.a, d)).booleanValue()) { return this; } if (this.c) { this.b -= d; } else { this.a -= d; } return this; } public MathBuilder$Builder rand(long l) { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero for random assignment!\"); } Random random = new Random(); this.a = random.nextDouble(l); return this; } public MathBuilder$Builder pi() { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero for PI assignment!\"); } this.a = Math.PI; return this; } public MathBuilder$Builder e() { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero for E assignment!\"); } this.a = Math.E; return this; } public MathBuilder$Builder randomInRange(double d, double d2) { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero for random assignment!\"); } Random random = new Random(); this.a = d + (d2 - d) * random.nextDouble(); return this; } public MathBuilder$Builder toDegrees() { if (this.c) { this.b = Math.toDegrees(this.b); } else { this.a = Math.toDegrees(this.a); } return this; } public MathBuilder$Builder max(double d) { if (this.c) { this.b = Math.max(this.b, d); } else { this.a = Math.max(this.a, d); } return this; } public MathBuilder$Builder min(double d) { if (this.c) { this.b = Math.min(this.b, d); } else { this.a = Math.min(this.a, d); } return this; } public MathBuilder$Builder multiply(double d) { if (this.c) { this.b *= d; } else { this.a *= d; } return this; } public MathBuilder$Builder multiplyIf(double d, BiFunction biFunction) { if (!((Boolean)biFunction.apply(this.a, d)).booleanValue()) { return this; } if (this.c) { this.b *= d; } else { this.a *= d; } return this; } public MathBuilder$Builder divide(double d) { if (d == 0.0) { return this; } if (this.c) { this.b /= d; } else { this.a /= d; } return this; } public MathBuilder$Builder divideIf(double d, BiFunction biFunction) { if (d == 0.0) { return this; } if (!((Boolean)biFunction.apply(this.a, d)).booleanValue()) { return this; } if (this.c) { this.b /= d; } else { this.a /= d; } return this; } public MathBuilder$Builder mod(double d) { if (this.c) { this.b %= d; } else { this.a %= d; } return this; } public MathBuilder$Builder modIf(double d, BiFunction biFunction) { if (!((Boolean)biFunction.apply(this.a, d)).booleanValue()) { return this; } if (this.c) { this.b %= d; } else { this.a %= d; } return this; } public MathBuilder$Builder pow(double d) { if (this.c) { this.b = Math.pow(this.b, d); } else { this.a = Math.pow(this.a, d); } return this; } public MathBuilder$Builder sqrt() { if (this.c) { this.b = Math.sqrt(this.b); } else { this.a = Math.sqrt(this.a); } return this; } public MathBuilder$Builder round() { if (this.c) { this.b = Math.round(this.b); } else { this.a = Math.round(this.a); } return this; } public MathBuilder$Builder floor() { if (this.c) { this.b = Math.floor(this.b); } else { this.a = Math.floor(this.a); } return this; } public MathBuilder$Builder ceil() { if (this.c) { this.b = Math.ceil(this.b); } else { this.a = Math.ceil(this.a); } return this; } public MathBuilder$Builder abs() { if (this.c) { this.b = Math.abs(this.b); } else { this.a = Math.abs(this.a); } return this; } public MathBuilder$Builder cbrt() { if (this.c) { this.b = Math.cbrt(this.b); } else { this.a = Math.cbrt(this.a); } return this; } public MathBuilder$Builder log() { if (this.c) { this.b = Math.log(this.b); } else { this.a = Math.log(this.a); } return this; } public MathBuilder$Builder log10() { if (this.c) { this.b = Math.log10(this.b); } else { this.a = Math.log10(this.a); } return this; } public MathBuilder$Builder sin() { if (this.c) { this.b = Math.sin(this.b); } else { this.a = Math.sin(this.a); } return this; } public MathBuilder$Builder cos() { if (this.c) { this.b = Math.cos(this.b); } else { this.a = Math.cos(this.a); } return this; } public MathBuilder$Builder tan() { if (this.c) { this.b = Math.tan(this.b); } else { this.a = Math.tan(this.a); } return this; } public MathBuilder$Builder sinh() { if (this.c) { this.b = Math.sinh(this.b); } else { this.a = Math.sinh(this.a); } return this; } public MathBuilder$Builder cosh() { if (this.c) { this.b = Math.cosh(this.b); } else { this.a = Math.cosh(this.a); } return this; } public MathBuilder$Builder tanh() { if (this.c) { this.b = Math.tanh(this.b); } else { this.a = Math.tanh(this.a); } return this; } public MathBuilder$Builder exp() { if (this.c) { this.b = Math.exp(this.b); } else { this.a = Math.exp(this.a); } return this; } public MathBuilder$Builder toRadians() { if (this.c) { this.b = Math.toRadians(this.b); } else { this.a = Math.toRadians(this.a); } return this; } public MathBuilder$Builder remember() { this.d = this.a; return this; } public MathBuilder$Builder recall(boolean bl) { this.a = this.d; if (bl) { this.d = 0.0; } return this; } public MathBuilder$Builder recallIf(Function function, boolean bl) { if (!((Boolean)function.apply(this.a)).booleanValue()) { return this; } this.a = this.d; if (bl) { this.d = 0.0; } return this; } public MathBuilder$Builder set(double d) { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero to set!\"); } this.a = d; return this; } public MathBuilder$Builder setIf(double d, BiFunction biFunction) { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero to set!\"); } if (((Boolean)biFunction.apply(this.a, d)).booleanValue()) { this.a = d; } return this; } public MathBuilder$Builder print() { System.out.println(\"MathBuilder Result :: \" + this.a); return this; } public MathBuilder$Builder openParenthesis(double d) { this.b = d; this.c = true; return this; } public MathBuilder$Builder closeParenthesisAndPlus() { this.a += this.b; this.c = false; this.b = 0.0; return this; } public MathBuilder$Builder closeParenthesisAndMinus() { this.a -= this.b; this.c = false; this.b = 0.0; return this; } public MathBuilder$Builder closeParenthesisAndMultiply() { this.a *= this.b; this.c = false; this.b = 0.0; return this; } public MathBuilder$Builder closeParenthesisAndDivide() { this.a /= this.b; this.c = false; this.b = 0.0; return this; } public MathBuilder$Builder format(String object) { object = new DecimalFormat((String)object); object = ((NumberFormat)object).format(this.a); this.a = Double.parseDouble((String)object); return this; } public MathBuilder$Builder format(int n) { Object object = \".\" + \"#\".repeat(n); object = new DecimalFormat((String)object); object = ((NumberFormat)object).format(this.a); this.a = Double.parseDouble((String)object); return this; } public MathBuilder build() { return new MathBuilder(this); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.MathBuilder; import java.text.DecimalFormat; import java.text.NumberFormat; import java.util.Random; import java.util.function.BiFunction; import java.util.function.Function; public class MathBuilder$Builder { private double a; private double b; private boolean c; private double d = 0.0; public MathBuilder$Builder() { this.a = 0.0; } public MathBuilder$Builder(double d) { this.a = d; } public MathBuilder$Builder add(double d) { if (this.c) { this.b += d; } else { this.a += d; } return this; } public MathBuilder$Builder addIf(double d, BiFunction biFunction) { if (!((Boolean)biFunction.apply(this.a, d)).booleanValue()) { return this; } if (this.c) { this.b += d; } else { this.a += d; } return this; } public MathBuilder$Builder minus(double d) { if (this.c) { this.b -= d; } else { this.a -= d; } return this; } public MathBuilder$Builder minusIf(double d, BiFunction biFunction) { if (!((Boolean)biFunction.apply(this.a, d)).booleanValue()) { return this; } if (this.c) { this.b -= d; } else { this.a -= d; } return this; } public MathBuilder$Builder rand(long l) { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero for random assignment!\"); } Random random = new Random(); this.a = random.nextDouble(l); return this; } public MathBuilder$Builder pi() { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero for PI assignment!\"); } this.a = Math.PI; return this; } public MathBuilder$Builder e() { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero for E assignment!\"); } this.a = Math.E; return this; } public MathBuilder$Builder randomInRange(double d, double d2) { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero for random assignment!\"); } Random random = new Random(); this.a = d + (d2 - d) * random.nextDouble(); return this; } public MathBuilder$Builder toDegrees() { if (this.c) { this.b = Math.toDegrees(this.b); } else { this.a = Math.toDegrees(this.a); } return this; } public MathBuilder$Builder max(double d) { if (this.c) { this.b = Math.max(this.b, d); } else { this.a = Math.max(this.a, d); } return this; } public MathBuilder$Builder min(double d) { if (this.c) { this.b = Math.min(this.b, d); } else { this.a = Math.min(this.a, d); } return this; } public MathBuilder$Builder multiply(double d) { if (this.c) { this.b *= d; } else { this.a *= d; } return this; } public MathBuilder$Builder multiplyIf(double d, BiFunction biFunction) { if (!((Boolean)biFunction.apply(this.a, d)).booleanValue()) { return this; } if (this.c) { this.b *= d; } else { this.a *= d; } return this; } public MathBuilder$Builder divide(double d) { if (d == 0.0) { return this; } if (this.c) { this.b /= d; } else { this.a /= d; } return this; } public MathBuilder$Builder divideIf(double d, BiFunction biFunction) { if (d == 0.0) { return this; } if (!((Boolean)biFunction.apply(this.a, d)).booleanValue()) { return this; } if (this.c) { this.b /= d; } else { this.a /= d; } return this; } public MathBuilder$Builder mod(double d) { if (this.c) { this.b %= d; } else { this.a %= d; } return this; } public MathBuilder$Builder modIf(double d, BiFunction biFunction) { if (!((Boolean)biFunction.apply(this.a, d)).booleanValue()) { return this; } if (this.c) { this.b %= d; } else { this.a %= d; } return this; } public MathBuilder$Builder pow(double d) { if (this.c) { this.b = Math.pow(this.b, d); } else { this.a = Math.pow(this.a, d); } return this; } public MathBuilder$Builder sqrt() { if (this.c) { this.b = Math.sqrt(this.b); } else { this.a = Math.sqrt(this.a); } return this; } public MathBuilder$Builder round() { if (this.c) { this.b = Math.round(this.b); } else { this.a = Math.round(this.a); } return this; } public MathBuilder$Builder floor() { if (this.c) { this.b = Math.floor(this.b); } else { this.a = Math.floor(this.a); } return this; } public MathBuilder$Builder ceil() { if (this.c) { this.b = Math.ceil(this.b); } else { this.a = Math.ceil(this.a); } return this; } public MathBuilder$Builder abs() { if (this.c) { this.b = Math.abs(this.b); } else { this.a = Math.abs(this.a); } return this; } public MathBuilder$Builder cbrt() { if (this.c) { this.b = Math.cbrt(this.b); } else { this.a = Math.cbrt(this.a); } return this; } public MathBuilder$Builder log() { if (this.c) { this.b = Math.log(this.b); } else { this.a = Math.log(this.a); } return this; } public MathBuilder$Builder log10() { if (this.c) { this.b = Math.log10(this.b); } else { this.a = Math.log10(this.a); } return this; } public MathBuilder$Builder sin() { if (this.c) { this.b = Math.sin(this.b); } else { this.a = Math.sin(this.a); } return this; } public MathBuilder$Builder cos() { if (this.c) { this.b = Math.cos(this.b); } else { this.a = Math.cos(this.a); } return this; } public MathBuilder$Builder tan() { if (this.c) { this.b = Math.tan(this.b); } else { this.a = Math.tan(this.a); } return this; } public MathBuilder$Builder sinh() { if (this.c) { this.b = Math.sinh(this.b); } else { this.a = Math.sinh(this.a); } return this; } public MathBuilder$Builder cosh() { if (this.c) { this.b = Math.cosh(this.b); } else { this.a = Math.cosh(this.a); } return this; } public MathBuilder$Builder tanh() { if (this.c) { this.b = Math.tanh(this.b); } else { this.a = Math.tanh(this.a); } return this; } public MathBuilder$Builder exp() { if (this.c) { this.b = Math.exp(this.b); } else { this.a = Math.exp(this.a); } return this; } public MathBuilder$Builder toRadians() { if (this.c) { this.b = Math.toRadians(this.b); } else { this.a = Math.toRadians(this.a); } return this; } public MathBuilder$Builder remember() { this.d = this.a; return this; } public MathBuilder$Builder recall(boolean bl) { this.a = this.d; if (bl) { this.d = 0.0; } return this; } public MathBuilder$Builder recallIf(Function function, boolean bl) { if (!((Boolean)function.apply(this.a)).booleanValue()) { return this; } this.a = this.d; if (bl) { this.d = 0.0; } return this; } public MathBuilder$Builder set(double d) { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero to set!\"); } this.a = d; return this; } public MathBuilder$Builder setIf(double d, BiFunction biFunction) { if (this.a != 0.0) { throw new RuntimeException(\"Number must be zero to set!\"); } if (((Boolean)biFunction.apply(this.a, d)).booleanValue()) { this.a = d; } return this; } public MathBuilder$Builder print() { System.out.println(\"MathBuilder Result :: \" + this.a); return this; } public MathBuilder$Builder openParenthesis(double d) { this.b = d; this.c = true; return this; } public MathBuilder$Builder closeParenthesisAndPlus() { this.a += this.b; this.c = false; this.b = 0.0; return this; } public MathBuilder$Builder closeParenthesisAndMinus() { this.a -= this.b; this.c = false; this.b = 0.0; return this; } public MathBuilder$Builder closeParenthesisAndMultiply() { this.a *= this.b; this.c = false; this.b = 0.0; return this; } public MathBuilder$Builder closeParenthesisAndDivide() { this.a /= this.b; this.c = false; this.b = 0.0; return this; } public MathBuilder$Builder format(String object) { object = new DecimalFormat((String)object); object = ((NumberFormat)object).format(this.a); this.a = Double.parseDouble((String)object); return this; } public MathBuilder$Builder format(int n) { Object object = \".\" + \"#\".repeat(n); object = new DecimalFormat((String)object); object = ((NumberFormat)object).format(this.a); this.a = Double.parseDouble((String)object); return this; } public MathBuilder build() { return new MathBuilder(this); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.MathBuilder$Builder; public final class MathBuilder { private final double a; private MathBuilder(MathBuilder$Builder mathBuilder$Builder) { this.a = mathBuilder$Builder.a; } public final double get() { return this.a; } public final long toLong() { try { if (Double.isNaN(this.a)) { throw new IllegalArgumentException(\"Cannot convert NaN to long!\"); } if (this.a == Double.POSITIVE_INFINITY) { return Long.MAX_VALUE; } if (this.a == Double.NEGATIVE_INFINITY) { return Long.MIN_VALUE; } if (this.a > 9.223372036854776E18) { return Long.MAX_VALUE; } if (this.a < -9.223372036854776E18) { return Long.MIN_VALUE; } return Math.round(this.a); } catch (Exception exception) { return 0L; } } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.text.DecimalFormat; import java.util.Random; import java.util.function.BiFunction; import java.util.function.Function; /** * Author: Sadiul Hakim : https://github.com/sadiul-hakim * Profession: Backend Engineer * Date: Oct 20, 2024 */ public final class MathBuilder { private final double result; private MathBuilder(Builder builder) { this.result = builder.number; } // Returns final result public double get() { return result; } // Return result in long public long toLong() { try { if (Double.isNaN(result)) { throw new IllegalArgumentException(\"Cannot convert NaN to long!\"); } if (result == Double.POSITIVE_INFINITY) { return Long.MAX_VALUE; } if (result == Double.NEGATIVE_INFINITY) { return Long.MIN_VALUE; } if (result > Long.MAX_VALUE) { return Long.MAX_VALUE; } if (result < Long.MIN_VALUE) { return Long.MIN_VALUE; } return Math.round(result); } catch (Exception ex) { return 0; } } public static class Builder { private double number; private double sideNumber; private boolean inParenthesis; private double memory = 0; public Builder() { number = 0; } public Builder(double num) { number = num; } public Builder add(double num) { if (inParenthesis) { sideNumber += num; } else { number += num; } return this; } // Takes a number and a condition, only does the operation if condition is true. public Builder addIf(double num, BiFunction<Double, Double, Boolean> condition) { if (!condition.apply(number, num)) { return this; } if (inParenthesis) { sideNumber += num; } else { number += num; } return this; } public Builder minus(double num) { if (inParenthesis) { sideNumber -= num; } else { number -= num; } return this; } // Takes a number and a condition, only does the operation if condition is true. public Builder minusIf(double num, BiFunction<Double, Double, Boolean> condition) { if (!condition.apply(number, num)) { return this; } if (inParenthesis) { sideNumber -= num; } else { number -= num; } return this; } // Generates a random number and sets to NUMBER public Builder rand(long seed) { if (number != 0) { throw new RuntimeException(\"Number must be zero for random assignment!\"); } Random random = new Random(); number = random.nextDouble(seed); return this; } // Takes PI value and sets to NUMBER public Builder pi() { if (number != 0) { throw new RuntimeException(\"Number must be zero for PI assignment!\"); } number = Math.PI; return this; } // Takes E value and sets to NUMBER public Builder e() { if (number != 0) { throw new RuntimeException(\"Number must be zero for E assignment!\"); } number = Math.E; return this; } public Builder randomInRange(double min, double max) { if (number != 0) { throw new RuntimeException(\"Number must be zero for random assignment!\"); } Random random = new Random(); number = min + (max - min) * random.nextDouble(); return this; } public Builder toDegrees() { if (inParenthesis) { sideNumber = Math.toDegrees(sideNumber); } else { number = Math.toDegrees(number); } return this; } public Builder max(double num) { if (inParenthesis) { sideNumber = Math.max(sideNumber, num); } else { number = Math.max(number, num); } return this; } public Builder min(double num) { if (inParenthesis) { sideNumber = Math.min(sideNumber, num); } else { number = Math.min(number, num); } return this; } public Builder multiply(double num) { if (inParenthesis) { sideNumber *= num; } else { number *= num; } return this; } // Takes a number and a condition, only does the operation if condition is true. public Builder multiplyIf(double num, BiFunction<Double, Double, Boolean> condition) { if (!condition.apply(number, num)) { return this; } if (inParenthesis) { sideNumber *= num; } else { number *= num; } return this; } public Builder divide(double num) { if (num == 0) { return this; } if (inParenthesis) { sideNumber /= num; } else { number /= num; } return this; } // Takes a number and a condition, only does the operation if condition is true. public Builder divideIf(double num, BiFunction<Double, Double, Boolean> condition) { if (num == 0) { return this; } if (!condition.apply(number, num)) { return this; } if (inParenthesis) { sideNumber /= num; } else { number /= num; } return this; } public Builder mod(double num) { if (inParenthesis) { sideNumber %= num; } else { number %= num; } return this; } // Takes a number and a condition, only does the operation if condition is true. public Builder modIf(double num, BiFunction<Double, Double, Boolean> condition) { if (!condition.apply(number, num)) { return this; } if (inParenthesis) { sideNumber %= num; } else { number %= num; } return this; } public Builder pow(double num) { if (inParenthesis) { sideNumber = Math.pow(sideNumber, num); } else { number = Math.pow(number, num); } return this; } public Builder sqrt() { if (inParenthesis) { sideNumber = Math.sqrt(sideNumber); } else { number = Math.sqrt(number); } return this; } public Builder round() { if (inParenthesis) { sideNumber = Math.round(sideNumber); } else { number = Math.round(number); } return this; } public Builder floor() { if (inParenthesis) { sideNumber = Math.floor(sideNumber); } else { number = Math.floor(number); } return this; } public Builder ceil() { if (inParenthesis) { sideNumber = Math.ceil(sideNumber); } else { number = Math.ceil(number); } return this; } public Builder abs() { if (inParenthesis) { sideNumber = Math.abs(sideNumber); } else { number = Math.abs(number); } return this; } public Builder cbrt() { if (inParenthesis) { sideNumber = Math.cbrt(sideNumber); } else { number = Math.cbrt(number); } return this; } public Builder log() { if (inParenthesis) { sideNumber = Math.log(sideNumber); } else { number = Math.log(number); } return this; } public Builder log10() { if (inParenthesis) { sideNumber = Math.log10(sideNumber); } else { number = Math.log10(number); } return this; } public Builder sin() { if (inParenthesis) { sideNumber = Math.sin(sideNumber); } else { number = Math.sin(number); } return this; } public Builder cos() { if (inParenthesis) { sideNumber = Math.cos(sideNumber); } else { number = Math.cos(number); } return this; } public Builder tan() { if (inParenthesis) { sideNumber = Math.tan(sideNumber); } else { number = Math.tan(number); } return this; } public Builder sinh() { if (inParenthesis) { sideNumber = Math.sinh(sideNumber); } else { number = Math.sinh(number); } return this; } public Builder cosh() { if (inParenthesis) { sideNumber = Math.cosh(sideNumber); } else { number = Math.cosh(number); } return this; } public Builder tanh() { if (inParenthesis) { sideNumber = Math.tanh(sideNumber); } else { number = Math.tanh(number); } return this; } public Builder exp() { if (inParenthesis) { sideNumber = Math.exp(sideNumber); } else { number = Math.exp(number); } return this; } public Builder toRadians() { if (inParenthesis) { sideNumber = Math.toRadians(sideNumber); } else { number = Math.toRadians(number); } return this; } // Remembers the NUMBER public Builder remember() { memory = number; return this; } // Recalls the NUMBER public Builder recall(boolean cleanMemory) { number = memory; if (cleanMemory) { memory = 0; } return this; } // Recalls the NUMBER on condition public Builder recallIf(Function<Double, Boolean> condition, boolean cleanMemory) { if (!condition.apply(number)) { return this; } number = memory; if (cleanMemory) { memory = 0; } return this; } // Replaces NUMBER with given number public Builder set(double num) { if (number != 0) { throw new RuntimeException(\"Number must be zero to set!\"); } number = num; return this; } // Replaces NUMBER with given number on condition public Builder setIf(double num, BiFunction<Double, Double, Boolean> condition) { if (number != 0) { throw new RuntimeException(\"Number must be zero to set!\"); } if (condition.apply(number, num)) { number = num; } return this; } // Prints current NUMBER public Builder print() { System.out.println(\"MathBuilder Result :: \" + number); return this; } public Builder openParenthesis(double num) { sideNumber = num; inParenthesis = true; return this; } public Builder closeParenthesisAndPlus() { number += sideNumber; inParenthesis = false; sideNumber = 0; return this; } public Builder closeParenthesisAndMinus() { number -= sideNumber; inParenthesis = false; sideNumber = 0; return this; } public Builder closeParenthesisAndMultiply() { number *= sideNumber; inParenthesis = false; sideNumber = 0; return this; } public Builder closeParenthesisAndDivide() { number /= sideNumber; inParenthesis = false; sideNumber = 0; return this; } public Builder format(String format) { DecimalFormat formater = new DecimalFormat(format); String num = formater.format(number); number = Double.parseDouble(num); return this; } public Builder format(int decimalPlace) { String pattern = \".\" + \"#\".repeat(decimalPlace); DecimalFormat formater = new DecimalFormat(pattern); String num = formater.format(number); number = Double.parseDouble(num); return this; } public MathBuilder build() { return new MathBuilder(this); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public class MatrixChainMultiplication$Matrix { private final int a; private final int b; private final int c; public MatrixChainMultiplication$Matrix(int n, int n2, int n3) { this.a = n; this.b = n2; this.c = n3; } public int count() { return this.a; } public int col() { return this.b; } public int row() { return this.c; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public class MatrixChainMultiplication$Matrix { private final int a; private final int b; private final int c; public MatrixChainMultiplication$Matrix(int n, int n2, int n3) { this.a = n; this.b = n2; this.c = n3; } public int count() { return this.a; } public int col() { return this.b; } public int row() { return this.c; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public class MatrixChainMultiplication$Result { private final int[][] a; private final int[][] b; public MatrixChainMultiplication$Result(int[][] nArray, int[][] nArray2) { this.a = nArray; this.b = nArray2; } public int[][] getM() { return this.a; } public int[][] getS() { return this.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public class MatrixChainMultiplication$Result { private final int[][] a; private final int[][] b; public MatrixChainMultiplication$Result(int[][] nArray, int[][] nArray2) { this.a = nArray; this.b = nArray2; } public int[][] getM() { return this.a; } public int[][] getS() { return this.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import com.thealgorithms.dynamicprogramming.MatrixChainMultiplication$Matrix; import com.thealgorithms.dynamicprogramming.MatrixChainMultiplication$Result; import java.util.ArrayList; import java.util.Arrays; public final class MatrixChainMultiplication { private static int[][] a; private static int[][] b; private static int[] c; private MatrixChainMultiplication() { } public static MatrixChainMultiplication$Result calculateMatrixChainOrder(ArrayList arrayList) { int n; int n2 = arrayList.size(); a = new int[n2 + 1][n2 + 1]; b = new int[n2 + 1][n2 + 1]; c = new int[n2 + 1]; for (n = 0; n < n2 + 1; ++n) { Arrays.fill(a[n], -1); Arrays.fill(b[n], -1); } for (n = 0; n < c.length; ++n) { int n3 = n; MatrixChainMultiplication.c[n3] = n3 == 0 ? ((MatrixChainMultiplication$Matrix)arrayList.get(n)).col() : ((MatrixChainMultiplication$Matrix)arrayList.get(n - 1)).row(); } int n4 = n2; for (n2 = 1; n2 < n4 + 1; ++n2) { MatrixChainMultiplication.a[n2][n2] = 0; } for (n2 = 2; n2 < n4 + 1; ++n2) { for (n = 1; n < n4 - n2 + 2; ++n) { int n5 = n + n2 - 1; MatrixChainMultiplication.a[n][n5] = Integer.MAX_VALUE; for (int i = n; i < n5; ++i) { int n6 = a[n][i] + a[i + 1][n5] + c[n - 1] * c[i] * c[n5]; if (n6 >= a[n][n5]) continue; MatrixChainMultiplication.a[n][n5] = n6; MatrixChainMultiplication.b[n][n5] = i; } } } return new MatrixChainMultiplication$Result(a, b); } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.ArrayList; import java.util.Arrays; /** * The MatrixChainMultiplication class provides functionality to compute the * optimal way to multiply a sequence of matrices. The optimal multiplication * order is determined using dynamic programming, which minimizes the total * number of scalar multiplications required. */ public final class MatrixChainMultiplication { private MatrixChainMultiplication() { } // Matrices to store minimum multiplication costs and split points private static int[][] m; private static int[][] s; private static int[] p; /** * Calculates the optimal order for multiplying a given list of matrices. * * @param matrices an ArrayList of Matrix objects representing the matrices * to be multiplied. * @return a Result object containing the matrices of minimum costs and * optimal splits. */ public static Result calculateMatrixChainOrder(ArrayList<Matrix> matrices) { int size = matrices.size(); m = new int[size + 1][size + 1]; s = new int[size + 1][size + 1]; p = new int[size + 1]; for (int i = 0; i < size + 1; i++) { Arrays.fill(m[i], -1); Arrays.fill(s[i], -1); } for (int i = 0; i < p.length; i++) { p[i] = i == 0 ? matrices.get(i).col() : matrices.get(i - 1).row(); } matrixChainOrder(size); return new Result(m, s); } /** * A helper method that computes the minimum cost of multiplying * the matrices using dynamic programming. * * @param size the number of matrices in the multiplication sequence. */ private static void matrixChainOrder(int size) { for (int i = 1; i < size + 1; i++) { m[i][i] = 0; } for (int l = 2; l < size + 1; l++) { for (int i = 1; i < size - l + 2; i++) { int j = i + l - 1; m[i][j] = Integer.MAX_VALUE; for (int k = i; k < j; k++) { int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; if (q < m[i][j]) { m[i][j] = q; s[i][j] = k; } } } } } /** * The Result class holds the results of the matrix chain multiplication * calculation, including the matrix of minimum costs and split points. */ public static class Result { private final int[][] m; private final int[][] s; /** * Constructs a Result object with the specified matrices of minimum * costs and split points. * * @param m the matrix of minimum multiplication costs. * @param s the matrix of optimal split points. */ public Result(int[][] m, int[][] s) { this.m = m; this.s = s; } /** * Returns the matrix of minimum multiplication costs. * * @return the matrix of minimum multiplication costs. */ public int[][] getM() { return m; } /** * Returns the matrix of optimal split points. * * @return the matrix of optimal split points. */ public int[][] getS() { return s; } } /** * The Matrix class represents a matrix with its dimensions and count. */ public static class Matrix { private final int count; private final int col; private final int row; /** * Constructs a Matrix object with the specified count, number of columns, * and number of rows. * * @param count the identifier for the matrix. * @param col the number of columns in the matrix. * @param row the number of rows in the matrix. */ public Matrix(int count, int col, int row) { this.count = count; this.col = col; this.row = row; } /** * Returns the identifier of the matrix. * * @return the identifier of the matrix. */ public int count() { return count; } /** * Returns the number of columns in the matrix. * * @return the number of columns in the matrix. */ public int col() { return col; } /** * Returns the number of rows in the matrix. * * @return the number of rows in the matrix. */ public int row() { return row; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class MatrixChainRecursiveTopDownMemoisation { private MatrixChainRecursiveTopDownMemoisation() { } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * The MatrixChainRecursiveTopDownMemoisation class implements the matrix-chain * multiplication problem using a top-down recursive approach with memoization. * * <p>Given a chain of matrices A1, A2, ..., An, where matrix Ai has dimensions * pi-1  pi, this algorithm finds the optimal way to fully parenthesize the * product A1A2...An in a way that minimizes the total number of scalar * multiplications required.</p> * * <p>This implementation uses a memoization technique to store the results of * subproblems, which significantly reduces the number of recursive calls and * improves performance compared to a naive recursive approach.</p> */ public final class MatrixChainRecursiveTopDownMemoisation { private MatrixChainRecursiveTopDownMemoisation() { } /** * Calculates the minimum number of scalar multiplications needed to multiply * a chain of matrices. * * @param p an array of integers representing the dimensions of the matrices. * The length of the array is n + 1, where n is the number of matrices. * @return the minimum number of multiplications required to multiply the chain * of matrices. */ static int memoizedMatrixChain(int[] p) { int n = p.length; int[][] m = new int[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { m[i][j] = Integer.MAX_VALUE; } } return lookupChain(m, p, 1, n - 1); } /** * A recursive helper method to lookup the minimum number of multiplications * for multiplying matrices from index i to index j. * * @param m the memoization table storing the results of subproblems. * @param p an array of integers representing the dimensions of the matrices. * @param i the starting index of the matrix chain. * @param j the ending index of the matrix chain. * @return the minimum number of multiplications needed to multiply matrices * from i to j. */ static int lookupChain(int[][] m, int[] p, int i, int j) { if (i == j) { m[i][j] = 0; return m[i][j]; } if (m[i][j] < Integer.MAX_VALUE) { return m[i][j]; } else { for (int k = i; k < j; k++) { int q = lookupChain(m, p, i, k) + lookupChain(m, p, k + 1, j) + (p[i - 1] * p[k] * p[j]); if (q < m[i][j]) { m[i][j] = q; } } } return m[i][j]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.AdjacencyMatrixGraph; public final class MatrixGraphs { private MatrixGraphs() { } public static void main(String[] object) { object = new AdjacencyMatrixGraph(10); ((AdjacencyMatrixGraph)object).addEdge(1, 2); ((AdjacencyMatrixGraph)object).addEdge(1, 5); ((AdjacencyMatrixGraph)object).addEdge(2, 5); ((AdjacencyMatrixGraph)object).addEdge(1, 2); ((AdjacencyMatrixGraph)object).addEdge(2, 3); ((AdjacencyMatrixGraph)object).addEdge(3, 4); ((AdjacencyMatrixGraph)object).addEdge(4, 1); ((AdjacencyMatrixGraph)object).addEdge(2, 3); ((AdjacencyMatrixGraph)object).addEdge(3, 9); ((AdjacencyMatrixGraph)object).addEdge(9, 1); ((AdjacencyMatrixGraph)object).addEdge(9, 8); ((AdjacencyMatrixGraph)object).addEdge(1, 8); ((AdjacencyMatrixGraph)object).addEdge(5, 6); System.out.println(\"The graph matrix:\"); System.out.println(object); System.out.println(\"Depth first order beginning at node '1':\"); System.out.println(((AdjacencyMatrixGraph)object).depthFirstOrder(1)); System.out.println(\"Breadth first order beginning at node '1':\"); System.out.println(((AdjacencyMatrixGraph)object).breadthFirstOrder(1)); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; /** * Implementation of a graph in a matrix form Also known as an adjacency matrix * representation [Adjacency matrix - * Wikipedia](https://en.wikipedia.org/wiki/Adjacency_matrix) * * @author Unknown */ public final class MatrixGraphs { private MatrixGraphs() { } public static void main(String[] args) { AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(10); graph.addEdge(1, 2); graph.addEdge(1, 5); graph.addEdge(2, 5); graph.addEdge(1, 2); graph.addEdge(2, 3); graph.addEdge(3, 4); graph.addEdge(4, 1); graph.addEdge(2, 3); graph.addEdge(3, 9); graph.addEdge(9, 1); graph.addEdge(9, 8); graph.addEdge(1, 8); graph.addEdge(5, 6); System.out.println(\"The graph matrix:\"); System.out.println(graph); System.out.println(\"Depth first order beginning at node '1':\"); System.out.println(graph.depthFirstOrder(1)); System.out.println(\"Breadth first order beginning at node '1':\"); System.out.println(graph.breadthFirstOrder(1)); } } /** * AdjacencyMatrixGraph Implementation */ class AdjacencyMatrixGraph { /** * The number of vertices in the graph */ private int vertexCount; /** * The number of edges in the graph */ private int edgeCount; /** * The adjacency matrix for the graph */ private int[][] adjMatrix; /** * Static variables to define whether or not an edge exists in the adjacency * matrix */ static final int EDGE_EXIST = 1; static final int EDGE_NONE = 0; /** * Constructor */ AdjacencyMatrixGraph(int givenNumberOfVertices) { this.setNumberOfVertices(givenNumberOfVertices); this.setNumberOfEdges(0); this.setAdjacency(new int[givenNumberOfVertices][givenNumberOfVertices]); for (int i = 0; i < givenNumberOfVertices; i++) { for (int j = 0; j < givenNumberOfVertices; j++) { this.adjacency()[i][j] = AdjacencyMatrixGraph.EDGE_NONE; } } } /** * Updates the number of vertices in the graph * * @param newNumberOfVertices the new number of vertices */ private void setNumberOfVertices(int newNumberOfVertices) { this.vertexCount = newNumberOfVertices; } /** * Getter for `this.vertexCount` * * @return the number of vertices in the graph */ public int numberOfVertices() { return this.vertexCount; } /** * Updates the number of edges in the graph * * @param newNumberOfEdges the new number of edges * */ private void setNumberOfEdges(int newNumberOfEdges) { this.edgeCount = newNumberOfEdges; } /** * Getter for `this.edgeCount` * * @return the number of edges */ public int numberOfEdges() { return this.edgeCount; } /** * Sets a new matrix as the adjacency matrix * * @param newAdjacency the new adjaceny matrix */ private void setAdjacency(int[][] newAdjacency) { this.adjMatrix = newAdjacency; } /** * Getter for the adjacency matrix * * @return the adjacency matrix */ private int[][] adjacency() { return this.adjMatrix; } /** * Checks if two vertices are connected by an edge * * @param from the parent vertex to check for adjacency * @param to the child vertex to check for adjacency * @return whether or not the vertices are adjancent */ private boolean adjacencyOfEdgeDoesExist(int from, int to) { return (this.adjacency()[from][to] != AdjacencyMatrixGraph.EDGE_NONE); } /** * Checks if a particular vertex exists in a graph * * @param aVertex the vertex to check for existence * @return whether or not the vertex exists */ public boolean vertexDoesExist(int aVertex) { return aVertex >= 0 && aVertex < this.numberOfVertices(); } /** * Checks if two vertices are connected by an edge * * @param from the parent vertex to check for adjacency * @param to the child vertex to check for adjacency * @return whether or not the vertices are adjancent */ public boolean edgeDoesExist(int from, int to) { if (this.vertexDoesExist(from) && this.vertexDoesExist(to)) { return (this.adjacencyOfEdgeDoesExist(from, to)); } return false; } /** * This method adds an edge to the graph between two specified vertices * * @param from the data of the vertex the edge is from * @param to the data of the vertex the edge is going to * @return returns true if the edge did not exist, return false if it * already did */ public boolean addEdge(int from, int to) { if (this.vertexDoesExist(from) && this.vertexDoesExist(to)) { if (!this.adjacencyOfEdgeDoesExist(from, to)) { this.adjacency()[from][to] = AdjacencyMatrixGraph.EDGE_EXIST; this.adjacency()[to][from] = AdjacencyMatrixGraph.EDGE_EXIST; this.setNumberOfEdges(this.numberOfEdges() + 1); return true; } } return false; } /** * this method removes an edge from the graph between two specified vertices * * @param from the data of the vertex the edge is from * @param to the data of the vertex the edge is going to * @return returns false if the edge doesn't exist, returns true if the edge * exists and is removed */ public boolean removeEdge(int from, int to) { if (this.vertexDoesExist(from) && this.vertexDoesExist(to)) { if (this.adjacencyOfEdgeDoesExist(from, to)) { this.adjacency()[from][to] = AdjacencyMatrixGraph.EDGE_NONE; this.adjacency()[to][from] = AdjacencyMatrixGraph.EDGE_NONE; this.setNumberOfEdges(this.numberOfEdges() - 1); return true; } } return false; } /** * This method returns a list of the vertices in a depth first order * beginning with the specified vertex * * @param startVertex the vertex to begin the traversal * @return the list of the ordered vertices */ public List<Integer> depthFirstOrder(int startVertex) { // If the startVertex is invalid, return an empty list if (startVertex >= vertexCount || startVertex < 0) { return new ArrayList<>(); } // Create an array to track the visited vertices boolean[] visited = new boolean[vertexCount]; // Create a list to keep track of the order of our traversal ArrayList<Integer> orderList = new ArrayList<>(); // Perform our DFS algorithm depthFirstOrder(startVertex, visited, orderList); return orderList; } /** * Helper method for public depthFirstOrder(int) that will perform a depth * first traversal recursively on the graph * * @param currentVertex the currently exploring vertex * @param visited the array of values denoting whether or not that vertex * has been visited * @param orderList the list to add vertices to as they are visited */ private void depthFirstOrder(int currentVertex, boolean[] visited, List<Integer> orderList) { // If this vertex has already been visited, do nothing and return if (visited[currentVertex]) { return; } // Visit the currentVertex by marking it as visited and adding it // to the orderList visited[currentVertex] = true; orderList.add(currentVertex); // Get the adjacency array for this vertex int[] adjacent = adjMatrix[currentVertex]; for (int i = 0; i < adjacent.length; i++) { // we are considering exploring, recurse on it // If an edge exists between the // currentVertex and the vertex if (adjacent[i] == AdjacencyMatrixGraph.EDGE_EXIST) { depthFirstOrder(i, visited, orderList); } } } /** * This method returns a list of the vertices in a breadth first order * beginning with the specified vertex * * @param startVertex the vertext to begin the traversal * @return the list of the ordered vertices */ public List<Integer> breadthFirstOrder(int startVertex) { // If the specified startVertex is invalid, return an empty list if (startVertex >= vertexCount || startVertex < 0) { return new ArrayList<>(); } // Create an array to keep track of the visited vertices boolean[] visited = new boolean[vertexCount]; // Create a list to keep track of the ordered vertices ArrayList<Integer> orderList = new ArrayList<>(); // Create a queue for our BFS algorithm and add the startVertex // to the queue Queue<Integer> queue = new LinkedList<>(); queue.add(startVertex); // Continue until the queue is empty while (!queue.isEmpty()) { // Remove the first vertex in the queue int currentVertex = queue.poll(); // If we've visited this vertex, skip it if (visited[currentVertex]) { continue; } // We now visit this vertex by adding it to the orderList and // marking it as visited orderList.add(currentVertex); visited[currentVertex] = true; // Get the adjacency array for the currentVertex and // check each node int[] adjacent = adjMatrix[currentVertex]; for (int vertex = 0; vertex < adjacent.length; vertex++) { // vertex we are considering exploring, we add it to the queue // If an // edge exists between the current vertex and the if (adjacent[vertex] == AdjacencyMatrixGraph.EDGE_EXIST) { queue.add(vertex); } } } return orderList; } /** * this gives a list of vertices in the graph and their adjacencies * * @return returns a string describing this graph */ public String toString() { StringBuilder s = new StringBuilder(\" \"); for (int i = 0; i < this.numberOfVertices(); i++) { s.append(i).append(\" \"); } s.append(\" \\n\"); for (int i = 0; i < this.numberOfVertices(); i++) { s.append(i).append(\" : \"); for (int j = 0; j < this.numberOfVertices(); j++) { s.append(this.adjMatrix[i][j]).append(\" \"); } s.append(\"\\n\"); } return s.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix; public final class MatrixMultiplication { private MatrixMultiplication() { } public static double[][] multiply(double[][] dArray, double[][] dArray2) { if (dArray == null || dArray2 == null) { throw new IllegalArgumentException(\"Input matrices cannot be null\"); } if (dArray.length == 0 || dArray2.length == 0 || dArray[0].length == 0 || dArray2[0].length == 0) { throw new IllegalArgumentException(\"Input matrices must not be empty\"); } if (dArray[0].length != dArray2.length) { throw new IllegalArgumentException(\"Matrices cannot be multiplied: incompatible dimensions.\"); } int n = dArray.length; int n2 = dArray[0].length; int n3 = dArray2[0].length; double[][] dArray3 = new double[n][n3]; for (int i = 0; i < n; ++i) { for (int j = 0; j < n3; ++j) { for (int k = 0; k < n2; ++k) { double[] dArray4 = dArray3[i]; int n4 = j; dArray4[n4] = dArray4[n4] + dArray[i][k] * dArray2[k][j]; } } } return dArray3; } }", "deobfuscated_code": "package com.thealgorithms.matrix; /** * This class provides a method to perform matrix multiplication. * * <p>Matrix multiplication takes two 2D arrays (matrices) as input and * produces their product, following the mathematical definition of * matrix multiplication. * * <p>For more details: * https://www.geeksforgeeks.org/java/java-program-to-multiply-two-matrices-of-any-size/ * https://en.wikipedia.org/wiki/Matrix_multiplication * * <p>Time Complexity: O(n^3)  where n is the dimension of the matrices * (assuming square matrices for simplicity). * * <p>Space Complexity: O(n^2)  for storing the result matrix. * * * @author Nishitha Wihala Pitigala * */ public final class MatrixMultiplication { private MatrixMultiplication() { } /** * Multiplies two matrices. * * @param matrixA the first matrix rowsA x colsA * @param matrixB the second matrix rowsB x colsB * @return the product of the two matrices rowsA x colsB * @throws IllegalArgumentException if the matrices cannot be multiplied */ public static double[][] multiply(double[][] matrixA, double[][] matrixB) { // Check the input matrices are not null if (matrixA == null || matrixB == null) { throw new IllegalArgumentException(\"Input matrices cannot be null\"); } // Check for empty matrices if (matrixA.length == 0 || matrixB.length == 0 || matrixA[0].length == 0 || matrixB[0].length == 0) { throw new IllegalArgumentException(\"Input matrices must not be empty\"); } // Validate the matrix dimensions if (matrixA[0].length != matrixB.length) { throw new IllegalArgumentException(\"Matrices cannot be multiplied: incompatible dimensions.\"); } int rowsA = matrixA.length; int colsA = matrixA[0].length; int colsB = matrixB[0].length; // Initialize the result matrix with zeros double[][] result = new double[rowsA][colsB]; // Perform matrix multiplication for (int i = 0; i < rowsA; i++) { for (int j = 0; j < colsB; j++) { for (int k = 0; k < colsA; k++) { result[i][j] += matrixA[i][k] * matrixB[k][j]; } } } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix; import com.thealgorithms.matrix.utils.MatrixUtil; public final class MatrixRank { private MatrixRank() { } public static int computeRank(double[][] dArray) { int n; MatrixUtil.validateInputMatrix(dArray); int n2 = dArray.length; int n3 = dArray[0].length; int n4 = 0; boolean[] blArray = new boolean[n2]; double[][] dArray2 = dArray; int n5 = dArray.length; int n6 = dArray2[0].length; double[][] dArray3 = new double[n5][n6]; for (n = 0; n < n5; ++n) { System.arraycopy(dArray2[n], 0, dArray3[n], 0, n6); } dArray = dArray3; for (int i = 0; i < n3; ++i) { int n7; int n8; int n9; block6: { n6 = i; boolean[] blArray2 = blArray; dArray2 = dArray; n9 = dArray.length; for (n = 0; n < n9; ++n) { if (blArray2[n] || MatrixRank.a(dArray2[n][n6])) continue; n8 = n; break block6; } n8 = n7 = n9; } if (n8 == n2) continue; ++n4; blArray[n7] = true; n6 = i; int n10 = n7; dArray2 = dArray; n9 = dArray[0].length; n = n6 + 1; while (n < n9) { double[] dArray4 = dArray2[n10]; int n11 = n++; dArray4[n11] = dArray4[n11] / dArray2[n10][n6]; } n6 = i; n10 = n7; dArray2 = dArray; n9 = dArray.length; n = dArray2[0].length; for (n7 = 0; n7 < n9; ++n7) { if (n7 == n10 || MatrixRank.a(dArray2[n7][n6])) continue; for (int j = n6 + 1; j < n; ++j) { double[] dArray5 = dArray2[n7]; int n12 = j; dArray5[n12] = dArray5[n12] - dArray2[n10][j] * dArray2[n7][n6]; } } } return n4; } private static boolean a(double d) { return Math.abs(d) < 1.0E-10; } }", "deobfuscated_code": "package com.thealgorithms.matrix; import static com.thealgorithms.matrix.utils.MatrixUtil.validateInputMatrix; /** * This class provides a method to compute the rank of a matrix. * In linear algebra, the rank of a matrix is the maximum number of linearly independent rows or columns in the matrix. * For example, consider the following 3x3 matrix: * 1 2 3 * 2 4 6 * 3 6 9 * Despite having 3 rows and 3 columns, this matrix only has a rank of 1 because all rows (and columns) are multiples of each other. * It's a fundamental concept that gives key insights into the structure of the matrix. * It's important to note that the rank is not only defined for square matrices but for any m x n matrix. * * @author Anup Omkar */ public final class MatrixRank { private MatrixRank() { } private static final double EPSILON = 1e-10; /** * @brief Computes the rank of the input matrix * * @param matrix The input matrix * @return The rank of the input matrix */ public static int computeRank(double[][] matrix) { validateInputMatrix(matrix); int numRows = matrix.length; int numColumns = matrix[0].length; int rank = 0; boolean[] rowMarked = new boolean[numRows]; double[][] matrixCopy = deepCopy(matrix); for (int colIndex = 0; colIndex < numColumns; ++colIndex) { int pivotRow = findPivotRow(matrixCopy, rowMarked, colIndex); if (pivotRow != numRows) { ++rank; rowMarked[pivotRow] = true; normalizePivotRow(matrixCopy, pivotRow, colIndex); eliminateRows(matrixCopy, pivotRow, colIndex); } } return rank; } private static boolean isZero(double value) { return Math.abs(value) < EPSILON; } private static double[][] deepCopy(double[][] matrix) { int numRows = matrix.length; int numColumns = matrix[0].length; double[][] matrixCopy = new double[numRows][numColumns]; for (int rowIndex = 0; rowIndex < numRows; ++rowIndex) { System.arraycopy(matrix[rowIndex], 0, matrixCopy[rowIndex], 0, numColumns); } return matrixCopy; } /** * @brief The pivot row is the row in the matrix that is used to eliminate other rows and reduce the matrix to its row echelon form. * The pivot row is selected as the first row (from top to bottom) where the value in the current column (the pivot column) is not zero. * This row is then used to \"eliminate\" other rows, by subtracting multiples of the pivot row from them, so that all other entries in the pivot column become zero. * This process is repeated for each column, each time selecting a new pivot row, until the matrix is in row echelon form. * The number of pivot rows (rows with a leading entry, or pivot) then gives the rank of the matrix. * * @param matrix The input matrix * @param rowMarked An array indicating which rows have been marked * @param colIndex The column index * @return The pivot row index, or the number of rows if no suitable pivot row was found */ private static int findPivotRow(double[][] matrix, boolean[] rowMarked, int colIndex) { int numRows = matrix.length; for (int pivotRow = 0; pivotRow < numRows; ++pivotRow) { if (!rowMarked[pivotRow] && !isZero(matrix[pivotRow][colIndex])) { return pivotRow; } } return numRows; } /** * @brief This method divides all values in the pivot row by the value in the given column. * This ensures that the pivot value itself will be 1, which simplifies further calculations. * * @param matrix The input matrix * @param pivotRow The pivot row index * @param colIndex The column index */ private static void normalizePivotRow(double[][] matrix, int pivotRow, int colIndex) { int numColumns = matrix[0].length; for (int nextCol = colIndex + 1; nextCol < numColumns; ++nextCol) { matrix[pivotRow][nextCol] /= matrix[pivotRow][colIndex]; } } /** * @brief This method subtracts multiples of the pivot row from all other rows, * so that all values in the given column of other rows will be zero. * This is a key step in reducing the matrix to row echelon form. * * @param matrix The input matrix * @param pivotRow The pivot row index * @param colIndex The column index */ private static void eliminateRows(double[][] matrix, int pivotRow, int colIndex) { int numRows = matrix.length; int numColumns = matrix[0].length; for (int otherRow = 0; otherRow < numRows; ++otherRow) { if (otherRow != pivotRow && !isZero(matrix[otherRow][colIndex])) { for (int col2 = colIndex + 1; col2 < numColumns; ++col2) { matrix[otherRow][col2] -= matrix[pivotRow][col2] * matrix[otherRow][colIndex]; } } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.devutils.searches; public interface MatrixSearchAlgorithm { public int[] find(Comparable[][] var1, Comparable var2); }", "deobfuscated_code": "package com.thealgorithms.devutils.searches; /** * The common interface of most searching algorithms that search in matrixes. * * @author Aitor Fidalgo (https://github.com/aitorfi) */ public interface MatrixSearchAlgorithm { /** * @param key is an element which should be found * @param matrix is a matrix where the element should be found * @param <T> Comparable type * @return array containing the first found coordinates of the element */ <T extends Comparable<T>> int[] find(T[][] matrix, T key); }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix; public final class MatrixTranspose { private MatrixTranspose() { } public static int[][] transpose(int[][] nArray) { if (nArray == null || nArray.length == 0) { throw new IllegalArgumentException(\"Matrix is empty\"); } int n = nArray.length; int n2 = nArray[0].length; int[][] nArray2 = new int[n2][n]; for (int i = 0; i < n2; ++i) { for (int j = 0; j < n; ++j) { nArray2[i][j] = nArray[j][i]; } } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.matrix; /** * * * <h1>Find the Transpose of Matrix!</h1> * * Simply take input from the user and print the matrix before the transpose and * after the transpose. * * <p> * <b>Note:</b> Giving proper comments in your program makes it more user * friendly and it is assumed as a high quality code. * * @author Rajat-Jain29 * @version 11.0.9 * @since 2014-03-31 */ public final class MatrixTranspose { private MatrixTranspose() { } /** * Calculate the transpose of the given matrix. * * @param matrix The matrix to be transposed * @throws IllegalArgumentException if the matrix is empty * @throws NullPointerException if the matrix is null * @return The transposed matrix */ public static int[][] transpose(int[][] matrix) { if (matrix == null || matrix.length == 0) { throw new IllegalArgumentException(\"Matrix is empty\"); } int rows = matrix.length; int cols = matrix[0].length; int[][] transposedMatrix = new int[cols][rows]; for (int i = 0; i < cols; i++) { for (int j = 0; j < rows; j++) { transposedMatrix[i][j] = matrix[j][i]; } } return transposedMatrix; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix.utils; import java.math.BigDecimal; import java.util.Optional; import java.util.function.BiFunction; import java.util.stream.IntStream; public final class MatrixUtil { private MatrixUtil() { } private static boolean a(BigDecimal[][] bigDecimalArray) { return bigDecimalArray != null && bigDecimalArray.length > 0 && bigDecimalArray[0].length > 0; } public static void validateInputMatrix(double[][] object) { boolean bl; block7: { boolean bl2; block6: { if (object == null) { throw new IllegalArgumentException(\"The input matrix cannot be null\"); } if (((double[][])object).length == 0) { throw new IllegalArgumentException(\"The input matrix cannot be empty\"); } double[][] dArray = object; for (double[] dArray2 : object) { if (dArray2 != null && dArray2.length != 0) continue; bl2 = false; break block6; } bl2 = true; } if (!bl2) { throw new IllegalArgumentException(\"The input matrix cannot have null or empty rows\"); } double[][] dArray = object; int n = object[0].length; for (double[] dArray3 : dArray) { object = dArray3; if (dArray3.length == n) continue; bl = true; break block7; } bl = false; } if (bl) { throw new IllegalArgumentException(\"The input matrix cannot be jagged\"); } } private static Optional a(BigDecimal[][] bigDecimalArray, BigDecimal[][] bigDecimalArray2, BiFunction biFunction) { BigDecimal[][] bigDecimalArray3 = bigDecimalArray2; BigDecimal[][] bigDecimalArray4 = bigDecimalArray; if (!(MatrixUtil.a(bigDecimalArray) && MatrixUtil.a(bigDecimalArray3) && bigDecimalArray4.length == bigDecimalArray3.length && bigDecimalArray4[0].length == bigDecimalArray3[0].length)) { return Optional.empty(); } int n = bigDecimalArray.length; int n2 = bigDecimalArray[0].length; BigDecimal[][] bigDecimalArray5 = new BigDecimal[n][n2]; IntStream.range(0, n).forEach(n3 -> IntStream.range(0, n2).forEach(n2 -> { bigDecimalArray = bigDecimalArray[n3][n2]; bigDecimalArray2 = bigDecimalArray2[n3][n2]; bigDecimalArray[n][n2] = (BigDecimal)biFunction.apply(bigDecimalArray, bigDecimalArray2); })); return Optional.of(bigDecimalArray5); } public static Optional add(BigDecimal[][] bigDecimalArray, BigDecimal[][] bigDecimalArray2) { return MatrixUtil.a(bigDecimalArray, bigDecimalArray2, BigDecimal::add); } public static Optional subtract(BigDecimal[][] bigDecimalArray, BigDecimal[][] bigDecimalArray2) { return MatrixUtil.a(bigDecimalArray, bigDecimalArray2, BigDecimal::subtract); } public static Optional multiply(BigDecimal[][] bigDecimalArray, BigDecimal[][] bigDecimalArray2) { BigDecimal[][] bigDecimalArray3 = bigDecimalArray2; BigDecimal[][] bigDecimalArray4 = bigDecimalArray; if (!(MatrixUtil.a(bigDecimalArray) && MatrixUtil.a(bigDecimalArray3) && bigDecimalArray4[0].length == bigDecimalArray3.length)) { return Optional.empty(); } int n = bigDecimalArray[0].length; int n2 = bigDecimalArray.length; int n4 = bigDecimalArray2[0].length; BigDecimal[][] bigDecimalArray5 = new BigDecimal[n2][n4]; IntStream.range(0, n2).forEach(n3 -> IntStream.range(0, n4).forEach(n4 -> { bigDecimalArray[n][n4] = IntStream.range(0, n).mapToObj(n3 -> { bigDecimalArray = bigDecimalArray[n3][n3]; BigDecimal bigDecimal = bigDecimalArray2[n3][n4]; return ((BigDecimal)bigDecimalArray).multiply(bigDecimal); }).reduce(BigDecimal.ZERO, BigDecimal::add); })); return Optional.of(bigDecimalArray5); } public static double[] reverseRow(double[] dArray) { double[] dArray2 = new double[dArray.length]; for (int i = 0; i < dArray.length; ++i) { dArray2[i] = dArray[dArray.length - 1 - i]; } return dArray2; } }", "deobfuscated_code": "package com.thealgorithms.matrix.utils; import java.math.BigDecimal; import java.util.Optional; import java.util.function.BiFunction; import java.util.stream.IntStream; /** * @author: caos321 * @date: 31 October 2021 (Sunday) */ public final class MatrixUtil { private MatrixUtil() { } private static boolean isValid(final BigDecimal[][] matrix) { return matrix != null && matrix.length > 0 && matrix[0].length > 0; } private static boolean hasEqualSizes(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) { return isValid(matrix1) && isValid(matrix2) && matrix1.length == matrix2.length && matrix1[0].length == matrix2[0].length; } private static boolean canMultiply(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) { return isValid(matrix1) && isValid(matrix2) && matrix1[0].length == matrix2.length; } public static void validateInputMatrix(double[][] matrix) { if (matrix == null) { throw new IllegalArgumentException(\"The input matrix cannot be null\"); } if (matrix.length == 0) { throw new IllegalArgumentException(\"The input matrix cannot be empty\"); } if (!hasValidRows(matrix)) { throw new IllegalArgumentException(\"The input matrix cannot have null or empty rows\"); } if (isJaggedMatrix(matrix)) { throw new IllegalArgumentException(\"The input matrix cannot be jagged\"); } } private static boolean hasValidRows(double[][] matrix) { for (double[] row : matrix) { if (row == null || row.length == 0) { return false; } } return true; } /** * @brief Checks if the input matrix is a jagged matrix. * Jagged matrix is a matrix where the number of columns in each row is not the same. * * @param matrix The input matrix * @return True if the input matrix is a jagged matrix, false otherwise */ private static boolean isJaggedMatrix(double[][] matrix) { int numColumns = matrix[0].length; for (double[] row : matrix) { if (row.length != numColumns) { return true; } } return false; } private static Optional<BigDecimal[][]> operate(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2, final BiFunction<BigDecimal, BigDecimal, BigDecimal> operation) { if (!hasEqualSizes(matrix1, matrix2)) { return Optional.empty(); } final int rowSize = matrix1.length; final int columnSize = matrix1[0].length; final BigDecimal[][] result = new BigDecimal[rowSize][columnSize]; IntStream.range(0, rowSize).forEach(rowIndex -> IntStream.range(0, columnSize).forEach(columnIndex -> { final BigDecimal value1 = matrix1[rowIndex][columnIndex]; final BigDecimal value2 = matrix2[rowIndex][columnIndex]; result[rowIndex][columnIndex] = operation.apply(value1, value2); })); return Optional.of(result); } public static Optional<BigDecimal[][]> add(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) { return operate(matrix1, matrix2, BigDecimal::add); } public static Optional<BigDecimal[][]> subtract(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) { return operate(matrix1, matrix2, BigDecimal::subtract); } public static Optional<BigDecimal[][]> multiply(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) { if (!canMultiply(matrix1, matrix2)) { return Optional.empty(); } final int size = matrix1[0].length; final int matrix1RowSize = matrix1.length; final int matrix2ColumnSize = matrix2[0].length; final BigDecimal[][] result = new BigDecimal[matrix1RowSize][matrix2ColumnSize]; IntStream.range(0, matrix1RowSize) .forEach(rowIndex -> IntStream.range(0, matrix2ColumnSize) .forEach(columnIndex -> result[rowIndex][columnIndex] = IntStream.range(0, size) .mapToObj(index -> { final BigDecimal value1 = matrix1[rowIndex][index]; final BigDecimal value2 = matrix2[index][columnIndex]; return value1.multiply(value2); }) .reduce(BigDecimal.ZERO, BigDecimal::add))); return Optional.of(result); } public static double[] reverseRow(final double[] inRow) { double[] res = new double[inRow.length]; for (int i = 0; i < inRow.length; ++i) { res[i] = inRow[inRow.length - 1 - i]; } return res; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import com.thealgorithms.datastructures.heaps.EmptyHeapException; import com.thealgorithms.datastructures.heaps.Heap; import com.thealgorithms.datastructures.heaps.HeapElement; import java.util.ArrayList; import java.util.List; public class MaxHeap implements Heap { private final List a; public MaxHeap(List object) { if (object == null) { throw new IllegalArgumentException(\"Input list cannot be null\"); } this.a = new ArrayList(); object = object.iterator(); while (object.hasNext()) { HeapElement heapElement = (HeapElement)object.next(); if (heapElement == null) continue; this.a.add(heapElement); } for (int i = this.a.size() / 2; i >= 0; --i) { this.a(i + 1); } } private void a(int n) { while (true) { int n2 = n - 1; int n3 = 2 * n - 1; int n4 = 2 * n; if (n3 < this.a.size() && ((HeapElement)this.a.get(n3)).getKey() > ((HeapElement)this.a.get(n2)).getKey()) { n2 = n3; } if (n4 < this.a.size() && ((HeapElement)this.a.get(n4)).getKey() > ((HeapElement)this.a.get(n2)).getKey()) { n2 = n4; } if (n2 == n - 1) break; HeapElement heapElement = (HeapElement)this.a.get(n - 1); this.a.set(n - 1, (HeapElement)this.a.get(n2)); this.a.set(n2, heapElement); n = n2 + 1; } } public HeapElement getElement(int n) { if (n <= 0 || n > this.a.size()) { throw new IndexOutOfBoundsException(\"Index \" + n + \" is out of heap range [1, \" + this.a.size() + \"]\"); } return (HeapElement)this.a.get(n - 1); } private double b(int n) { if (n <= 0 || n > this.a.size()) { throw new IndexOutOfBoundsException(\"Index \" + n + \" is out of heap range [1, \" + this.a.size() + \"]\"); } return ((HeapElement)this.a.get(n - 1)).getKey(); } private void a(int n, int n2) { HeapElement heapElement = (HeapElement)this.a.get(n - 1); this.a.set(n - 1, (HeapElement)this.a.get(n2 - 1)); this.a.set(n2 - 1, heapElement); } private void c(int n) { double d = ((HeapElement)this.a.get(n - 1)).getKey(); while (n > 1 && this.b((int)Math.floor((double)n / 2.0)) < d) { int n2 = n; this.a(n2, (int)Math.floor((double)n2 / 2.0)); n = (int)Math.floor((double)n / 2.0); } } @Override public void insertElement(HeapElement heapElement) { if (heapElement == null) { throw new IllegalArgumentException(\"Cannot insert null element\"); } this.a.add(heapElement); MaxHeap maxHeap = this; maxHeap.c(maxHeap.a.size()); } @Override public void deleteElement(int n) { if (this.a.isEmpty()) { throw new EmptyHeapException(\"Cannot delete from an empty heap\"); } if (n > this.a.size() || n <= 0) { throw new IndexOutOfBoundsException(\"Index \" + n + \" is out of heap range [1, \" + this.a.size() + \"]\"); } this.a.set(n - 1, (HeapElement)this.a.getLast()); this.a.removeLast(); if (!this.a.isEmpty() && n <= this.a.size()) { int n2; if (n > 1 && this.b(n) > this.b((int)Math.floor((double)n / 2.0))) { this.c(n); return; } int n3 = n; MaxHeap maxHeap = this; double d = ((HeapElement)maxHeap.a.get(n3 - 1)).getKey(); int n4 = n2 = 2 * n3 <= maxHeap.a.size() && d < maxHeap.b(n3 << 1) || 2 * n3 + 1 <= maxHeap.a.size() && d < maxHeap.b((n3 << 1) + 1) ? 1 : 0; while (2 * n3 <= maxHeap.a.size() && n2 != 0) { n2 = 2 * n3 + 1 <= maxHeap.a.size() && maxHeap.b((n3 << 1) + 1) > maxHeap.b(n3 << 1) ? 2 * n3 + 1 : 2 * n3; maxHeap.a(n3, n2); n3 = n2; n2 = 2 * n3 <= maxHeap.a.size() && d < maxHeap.b(n3 << 1) || 2 * n3 + 1 <= maxHeap.a.size() && d < maxHeap.b((n3 << 1) + 1) ? 1 : 0; } } } @Override public HeapElement getElement() { MaxHeap maxHeap = this; if (maxHeap.a.isEmpty()) { throw new EmptyHeapException(\"Cannot extract from an empty heap\"); } HeapElement heapElement = (HeapElement)maxHeap.a.getFirst(); maxHeap.deleteElement(1); return heapElement; } public int size() { return this.a.size(); } public boolean isEmpty() { return this.a.isEmpty(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; import java.util.ArrayList; import java.util.List; /** * A Max Heap implementation where each node's key is higher than or equal to its children's keys. * This data structure provides O(log n) time complexity for insertion and deletion operations, * and O(1) for retrieving the maximum element. * * Properties: * 1. Complete Binary Tree * 2. Parent node's key  Children nodes' keys * 3. Root contains the maximum element * * Example usage: * <pre> * List<HeapElement> elements = Arrays.asList( * new HeapElement(5, \"Five\"), * new HeapElement(2, \"Two\") * ); * MaxHeap heap = new MaxHeap(elements); * heap.insertElement(new HeapElement(7, \"Seven\")); * HeapElement max = heap.getElement(); // Returns and removes the maximum element * </pre> * * @author Nicolas Renard */ public class MaxHeap implements Heap { /** The internal list that stores heap elements */ private final List<HeapElement> maxHeap; /** * Constructs a new MaxHeap from a list of elements. * Null elements in the input list are ignored. * * @param listElements List of HeapElement objects to initialize the heap * @throws IllegalArgumentException if the input list is null */ public MaxHeap(List<HeapElement> listElements) { if (listElements == null) { throw new IllegalArgumentException(\"Input list cannot be null\"); } maxHeap = new ArrayList<>(); // Safe initialization: directly add non-null elements first for (HeapElement heapElement : listElements) { if (heapElement != null) { maxHeap.add(heapElement); } } // Heapify the array bottom-up for (int i = maxHeap.size() / 2; i >= 0; i--) { heapifyDown(i + 1); // +1 because heapifyDown expects 1-based index } } /** * Maintains heap properties by moving an element down the heap. * Similar to toggleDown but used specifically during initialization. * * @param elementIndex 1-based index of the element to heapify */ private void heapifyDown(int elementIndex) { int largest = elementIndex - 1; int leftChild = 2 * elementIndex - 1; int rightChild = 2 * elementIndex; if (leftChild < maxHeap.size() && maxHeap.get(leftChild).getKey() > maxHeap.get(largest).getKey()) { largest = leftChild; } if (rightChild < maxHeap.size() && maxHeap.get(rightChild).getKey() > maxHeap.get(largest).getKey()) { largest = rightChild; } if (largest != elementIndex - 1) { HeapElement swap = maxHeap.get(elementIndex - 1); maxHeap.set(elementIndex - 1, maxHeap.get(largest)); maxHeap.set(largest, swap); heapifyDown(largest + 1); } } /** * Retrieves the element at the specified index without removing it. * Note: The index is 1-based for consistency with heap operations. * * @param elementIndex 1-based index of the element to retrieve * @return HeapElement at the specified index * @throws IndexOutOfBoundsException if the index is invalid */ public HeapElement getElement(int elementIndex) { if ((elementIndex <= 0) || (elementIndex > maxHeap.size())) { throw new IndexOutOfBoundsException(\"Index \" + elementIndex + \" is out of heap range [1, \" + maxHeap.size() + \"]\"); } return maxHeap.get(elementIndex - 1); } /** * Retrieves the key value of an element at the specified index. * * @param elementIndex 1-based index of the element * @return double value representing the key * @throws IndexOutOfBoundsException if the index is invalid */ private double getElementKey(int elementIndex) { if ((elementIndex <= 0) || (elementIndex > maxHeap.size())) { throw new IndexOutOfBoundsException(\"Index \" + elementIndex + \" is out of heap range [1, \" + maxHeap.size() + \"]\"); } return maxHeap.get(elementIndex - 1).getKey(); } /** * Swaps two elements in the heap. * * @param index1 1-based index of first element * @param index2 1-based index of second element */ private void swap(int index1, int index2) { HeapElement temporaryElement = maxHeap.get(index1 - 1); maxHeap.set(index1 - 1, maxHeap.get(index2 - 1)); maxHeap.set(index2 - 1, temporaryElement); } /** * Moves an element up the heap until heap properties are satisfied. * This operation is called after insertion to maintain heap properties. * * @param elementIndex 1-based index of the element to move up */ private void toggleUp(int elementIndex) { double key = maxHeap.get(elementIndex - 1).getKey(); while (elementIndex > 1 && getElementKey((int) Math.floor(elementIndex / 2.0)) < key) { swap(elementIndex, (int) Math.floor(elementIndex / 2.0)); elementIndex = (int) Math.floor(elementIndex / 2.0); } } /** * Moves an element down the heap until heap properties are satisfied. * This operation is called after deletion to maintain heap properties. * * @param elementIndex 1-based index of the element to move down */ private void toggleDown(int elementIndex) { double key = maxHeap.get(elementIndex - 1).getKey(); boolean wrongOrder = (2 * elementIndex <= maxHeap.size() && key < getElementKey(elementIndex * 2)) || (2 * elementIndex + 1 <= maxHeap.size() && key < getElementKey(elementIndex * 2 + 1)); while (2 * elementIndex <= maxHeap.size() && wrongOrder) { int largerChildIndex; if (2 * elementIndex + 1 <= maxHeap.size() && getElementKey(elementIndex * 2 + 1) > getElementKey(elementIndex * 2)) { largerChildIndex = 2 * elementIndex + 1; } else { largerChildIndex = 2 * elementIndex; } swap(elementIndex, largerChildIndex); elementIndex = largerChildIndex; wrongOrder = (2 * elementIndex <= maxHeap.size() && key < getElementKey(elementIndex * 2)) || (2 * elementIndex + 1 <= maxHeap.size() && key < getElementKey(elementIndex * 2 + 1)); } } /** * Extracts and returns the maximum element from the heap. * * @return HeapElement with the highest key * @throws EmptyHeapException if the heap is empty */ private HeapElement extractMax() throws EmptyHeapException { if (maxHeap.isEmpty()) { throw new EmptyHeapException(\"Cannot extract from an empty heap\"); } HeapElement result = maxHeap.getFirst(); deleteElement(1); return result; } /** * {@inheritDoc} */ @Override public void insertElement(HeapElement element) { if (element == null) { throw new IllegalArgumentException(\"Cannot insert null element\"); } maxHeap.add(element); toggleUp(maxHeap.size()); } /** * {@inheritDoc} */ @Override public void deleteElement(int elementIndex) throws EmptyHeapException { if (maxHeap.isEmpty()) { throw new EmptyHeapException(\"Cannot delete from an empty heap\"); } if ((elementIndex > maxHeap.size()) || (elementIndex <= 0)) { throw new IndexOutOfBoundsException(\"Index \" + elementIndex + \" is out of heap range [1, \" + maxHeap.size() + \"]\"); } // Replace with last element and remove last position maxHeap.set(elementIndex - 1, maxHeap.getLast()); maxHeap.removeLast(); // No need to toggle if we just removed the last element if (!maxHeap.isEmpty() && elementIndex <= maxHeap.size()) { // Determine whether to toggle up or down if (elementIndex > 1 && getElementKey(elementIndex) > getElementKey((int) Math.floor(elementIndex / 2.0))) { toggleUp(elementIndex); } else { toggleDown(elementIndex); } } } /** * {@inheritDoc} */ @Override public HeapElement getElement() throws EmptyHeapException { return extractMax(); } /** * Returns the current size of the heap. * * @return number of elements in the heap */ public int size() { return maxHeap.size(); } /** * Checks if the heap is empty. * * @return true if the heap contains no elements */ public boolean isEmpty() { return maxHeap.isEmpty(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.slidingwindow; public final class MaxSumKSizeSubarray { private MaxSumKSizeSubarray() { } public static int maxSumKSizeSubarray(int[] nArray, int n) { int n2; if (nArray.length < n) { return -1; } int n3 = 0; for (n2 = 0; n2 < n; ++n2) { n3 += nArray[n2]; } int n4 = n3; for (n2 = n; n2 < nArray.length; ++n2) { n4 = Math.max(n4, n3 += nArray[n2] - nArray[n2 - n]); } return n4; } }", "deobfuscated_code": "package com.thealgorithms.slidingwindow; /** * The Sliding Window algorithm is used to find the maximum sum of a subarray * of a fixed size k within a given array. * * <p> * Worst-case performance O(n) * Best-case performance O(n) * Average performance O(n) * Worst-case space complexity O(1) * * @author Your Name (https://github.com/Chiefpatwal) */ public final class MaxSumKSizeSubarray { // Prevent instantiation private MaxSumKSizeSubarray() { } /** * This method finds the maximum sum of a subarray of a given size k. * * @param arr is the input array where the maximum sum needs to be found * @param k is the size of the subarray * @return the maximum sum of the subarray of size k */ public static int maxSumKSizeSubarray(int[] arr, int k) { if (arr.length < k) { return -1; // Edge case: not enough elements } int maxSum; int windowSum = 0; // Calculate the sum of the first window for (int i = 0; i < k; i++) { windowSum += arr[i]; } maxSum = windowSum; // Slide the window across the array for (int i = k; i < arr.length; i++) { windowSum += arr[i] - arr[i - k]; maxSum = Math.max(maxSum, windowSum); } return maxSum; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class MaxValue { private MaxValue() { } public static int max(int n, int n2) { if (n >= n2) { return n; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class MaxValue { private MaxValue() { } /** * Returns the greater of two {@code int} values. That is, the result is the * argument closer to the value of {@link Integer#MAX_VALUE}. If the * arguments have the same value, the result is that same value. * * @param a an argument. * @param b another argument. * @return the larger of {@code a} and {@code b}. */ public static int max(int a, int b) { return a >= b ? a : b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Arrays; import java.util.Stack; public final class MaximumMinimumWindow { private MaximumMinimumWindow() { } public static int[] calculateMaxOfMin(int[] nArray, int n) { int n2; int n3; Stack<Integer> stack = new Stack<Integer>(); int[] nArray2 = new int[n + 1]; int[] nArray3 = new int[n + 1]; for (n3 = 0; n3 < n; ++n3) { nArray2[n3] = -1; nArray3[n3] = n; } for (n3 = 0; n3 < n; ++n3) { while (!stack.empty() && nArray[(Integer)stack.peek()] >= nArray[n3]) { stack.pop(); } if (!stack.empty()) { nArray2[n3] = (Integer)stack.peek(); } stack.push(n3); } while (!stack.empty()) { stack.pop(); } for (n3 = n - 1; n3 >= 0; --n3) { while (!stack.empty() && nArray[(Integer)stack.peek()] >= nArray[n3]) { stack.pop(); } if (!stack.empty()) { nArray3[n3] = (Integer)stack.peek(); } stack.push(n3); } int[] nArray4 = new int[n + 1]; for (n2 = 0; n2 <= n; ++n2) { nArray4[n2] = 0; } for (n2 = 0; n2 < n; ++n2) { int n4 = nArray3[n2] - nArray2[n2] - 1; nArray4[n4] = Math.max(nArray4[n4], nArray[n2]); } for (n2 = n - 1; n2 > 0; --n2) { nArray4[n2] = Math.max(nArray4[n2], nArray4[n2 + 1]); } for (n2 = 1; n2 <= n; ++n2) { System.out.print(nArray4[n2] + \" \"); } return nArray4; } public static void main(String[] objectArray) { objectArray = new int[]{10, 20, 30, 50, 10, 70, 30}; int[] nArray = new int[]{70, 30, 20, 10, 10, 10, 10}; objectArray = MaximumMinimumWindow.calculateMaxOfMin((int[])objectArray, objectArray.length); assert (Arrays.equals(nArray, (int[])objectArray)); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Arrays; import java.util.Stack; /** * Given an integer array. The task is to find the maximum of the minimum of * every window size in the array. Note: Window size varies from 1 to the size * of the Array. * <p> * For example, * <p> * N = 7 * arr[] = {10,20,30,50,10,70,30} * <p> * So the answer for the above would be : 70 30 20 10 10 10 10 * <p> * We need to consider window sizes from 1 to length of array in each iteration. * So in the iteration 1 the windows would be [10], [20], [30], [50], [10], * [70], [30]. Now we need to check the minimum value in each window. Since the * window size is 1 here the minimum element would be the number itself. Now the * maximum out of these is the result in iteration 1. In the second iteration we * need to consider window size 2, so there would be [10,20], [20,30], [30,50], * [50,10], [10,70], [70,30]. Now the minimum of each window size would be * [10,20,30,10,10] and the maximum out of these is 30. Similarly we solve for * other window sizes. * * @author sahil */ public final class MaximumMinimumWindow { private MaximumMinimumWindow() { } /** * This function contains the logic of finding maximum of minimum for every * window size using Stack Data Structure. * * @param arr Array containing the numbers * @param n Length of the array * @return result array */ public static int[] calculateMaxOfMin(int[] arr, int n) { Stack<Integer> s = new Stack<>(); int[] left = new int[n + 1]; int[] right = new int[n + 1]; for (int i = 0; i < n; i++) { left[i] = -1; right[i] = n; } for (int i = 0; i < n; i++) { while (!s.empty() && arr[s.peek()] >= arr[i]) { s.pop(); } if (!s.empty()) { left[i] = s.peek(); } s.push(i); } while (!s.empty()) { s.pop(); } for (int i = n - 1; i >= 0; i--) { while (!s.empty() && arr[s.peek()] >= arr[i]) { s.pop(); } if (!s.empty()) { right[i] = s.peek(); } s.push(i); } int[] ans = new int[n + 1]; for (int i = 0; i <= n; i++) { ans[i] = 0; } for (int i = 0; i < n; i++) { int len = right[i] - left[i] - 1; ans[len] = Math.max(ans[len], arr[i]); } for (int i = n - 1; i >= 1; i--) { ans[i] = Math.max(ans[i], ans[i + 1]); } // Print the result for (int i = 1; i <= n; i++) { System.out.print(ans[i] + \" \"); } return ans; } public static void main(String[] args) { int[] arr = new int[] {10, 20, 30, 50, 10, 70, 30}; int[] target = new int[] {70, 30, 20, 10, 10, 10, 10}; int[] res = calculateMaxOfMin(arr, arr.length); assert Arrays.equals(target, res); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.ArrayDeque; public class MaximumSlidingWindow { public int[] maxSlidingWindow(int[] nArray, int n) { if (nArray == null || nArray.length == 0 || n <= 0 || n > nArray.length) { return new int[0]; } int[] nArray2 = new int[nArray.length - n + 1]; ArrayDeque<Integer> arrayDeque = new ArrayDeque<Integer>(); for (int i = 0; i < nArray.length; ++i) { if (!arrayDeque.isEmpty() && (Integer)arrayDeque.peekFirst() == i - n) { arrayDeque.pollFirst(); } while (!arrayDeque.isEmpty() && nArray[(Integer)arrayDeque.peekLast()] < nArray[i]) { arrayDeque.pollLast(); } arrayDeque.offerLast(i); if (i < n - 1) continue; nArray2[i - n + 1] = nArray[(Integer)arrayDeque.peekFirst()]; } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.ArrayDeque; import java.util.Deque; /** * Maximum Sliding Window Algorithm * * This algorithm finds the maximum element in each sliding window of size k * in a given array of integers. It uses a deque (double-ended queue) to * efficiently keep track of potential maximum values in the current window. * * Time Complexity: O(n), where n is the number of elements in the input array * Space Complexity: O(k), where k is the size of the sliding window */ public class MaximumSlidingWindow { /** * Finds the maximum values in each sliding window of size k. * * @param nums The input array of integers * @param windowSize The size of the sliding window * @return An array of integers representing the maximums in each window */ public int[] maxSlidingWindow(int[] nums, int windowSize) { if (nums == null || nums.length == 0 || windowSize <= 0 || windowSize > nums.length) { return new int[0]; // Handle edge cases } int[] result = new int[nums.length - windowSize + 1]; Deque<Integer> deque = new ArrayDeque<>(); for (int currentIndex = 0; currentIndex < nums.length; currentIndex++) { // Remove the first element if it's outside the current window if (!deque.isEmpty() && deque.peekFirst() == currentIndex - windowSize) { deque.pollFirst(); } // Remove all elements smaller than the current element from the end while (!deque.isEmpty() && nums[deque.peekLast()] < nums[currentIndex]) { deque.pollLast(); } // Add the current element's index to the deque deque.offerLast(currentIndex); // If we have processed at least k elements, add to result if (currentIndex >= windowSize - 1) { result[currentIndex - windowSize + 1] = nums[deque.peekFirst()]; } } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.HashSet; public final class MaximumSumOfDistinctSubarraysWithLengthK { private MaximumSumOfDistinctSubarraysWithLengthK() { } public static long maximumSubarraySum(int n, int ... nArray) { int n2; if (nArray.length < n) { return 0L; } long l = 0L; long l2 = 0L; HashSet<Integer> hashSet = new HashSet<Integer>(); for (n2 = 0; n2 < n; ++n2) { l2 += (long)nArray[n2]; hashSet.add(nArray[n2]); } if (hashSet.size() == n) { l = l2; } for (n2 = 1; n2 < nArray.length - n + 1; ++n2) { l2 -= (long)nArray[n2 - 1]; l2 += (long)nArray[n2 + n - 1]; boolean bl = false; for (int i = n2; i < n2 + n && hashSet.size() < n; ++i) { if (nArray[n2 - 1] != nArray[i]) continue; bl = true; break; } if (!bl) { hashSet.remove(nArray[n2 - 1]); } hashSet.add(nArray[n2 + n - 1]); if (hashSet.size() != n || l >= l2) continue; l = l2; } return l; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.HashSet; import java.util.Set; /** * References: https://en.wikipedia.org/wiki/Streaming_algorithm * * This model involves computing the maximum sum of subarrays of a fixed size \\( K \\) from a stream of integers. * As the stream progresses, elements from the end of the window are removed, and new elements from the stream are added. * * @author Swarga-codes (https://github.com/Swarga-codes) */ public final class MaximumSumOfDistinctSubarraysWithLengthK { private MaximumSumOfDistinctSubarraysWithLengthK() { } /** * Finds the maximum sum of a subarray of size K consisting of distinct elements. * * @param k The size of the subarray. * @param nums The array from which subarrays will be considered. * * @return The maximum sum of any distinct-element subarray of size K. If no such subarray exists, returns 0. */ public static long maximumSubarraySum(int k, int... nums) { if (nums.length < k) { return 0; } long masSum = 0; // Variable to store the maximum sum of distinct subarrays long currentSum = 0; // Variable to store the sum of the current subarray Set<Integer> currentSet = new HashSet<>(); // Set to track distinct elements in the current subarray // Initialize the first window for (int i = 0; i < k; i++) { currentSum += nums[i]; currentSet.add(nums[i]); } // If the first window contains distinct elements, update maxSum if (currentSet.size() == k) { masSum = currentSum; } // Slide the window across the array for (int i = 1; i < nums.length - k + 1; i++) { // Update the sum by removing the element that is sliding out and adding the new element currentSum = currentSum - nums[i - 1]; currentSum = currentSum + nums[i + k - 1]; int j = i; boolean flag = false; // flag value which says that the subarray contains distinct elements while (j < i + k && currentSet.size() < k) { if (nums[i - 1] == nums[j]) { flag = true; break; } else { j++; } } if (!flag) { currentSet.remove(nums[i - 1]); } currentSet.add(nums[i + k - 1]); // If the current window has distinct elements, compare and possibly update maxSum if (currentSet.size() == k && masSum < currentSum) { masSum = currentSum; } } return masSum; // the final maximum sum } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; final class MaximumSumOfNonAdjacentElements { private MaximumSumOfNonAdjacentElements() { } public static int getMaxSumApproach1(int[] nArray) { if (nArray.length == 0) { return 0; } int n = nArray.length; int[] nArray2 = new int[n]; int[] nArray3 = nArray2; nArray2[0] = nArray[0]; for (int i = 1; i < n; ++i) { int n2 = nArray3[i - 1]; int n3 = nArray[i]; if (i > 1) { n3 += nArray3[i - 2]; } nArray3[i] = Math.max(n3, n2); } return nArray3[n - 1]; } public static int getMaxSumApproach2(int[] nArray) { if (nArray.length == 0) { return 0; } int n = nArray.length; int n2 = nArray[0]; int n3 = 0; for (int i = 1; i < n; ++i) { int n4 = n2; int n5 = nArray[i]; if (i > 1) { n5 += n3; } n4 = Math.max(n5, n4); n3 = n2; n2 = n4; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Class to find the maximum sum of non-adjacent elements in an array. This * class contains two approaches: one with O(n) space complexity and another * with O(1) space optimization. For more information, refer to * https://takeuforward.org/data-structure/maximum-sum-of-non-adjacent-elements-dp-5/ */ final class MaximumSumOfNonAdjacentElements { private MaximumSumOfNonAdjacentElements() { } /** * Approach 1: Uses a dynamic programming array to store the maximum sum at * each index. Time Complexity: O(n) - where n is the length of the input * array. Space Complexity: O(n) - due to the additional dp array. * @param arr The input array of integers. * @return The maximum sum of non-adjacent elements. */ public static int getMaxSumApproach1(int[] arr) { if (arr.length == 0) { return 0; // Check for empty array } int n = arr.length; int[] dp = new int[n]; // Base case: Maximum sum if only one element is present. dp[0] = arr[0]; for (int ind = 1; ind < n; ind++) { // Case 1: Do not take the current element, carry forward the previous max // sum. int notTake = dp[ind - 1]; // Case 2: Take the current element, add it to the max sum up to two // indices before. int take = arr[ind]; if (ind > 1) { take += dp[ind - 2]; } // Store the maximum of both choices in the dp array. dp[ind] = Math.max(take, notTake); } return dp[n - 1]; } /** * Approach 2: Optimized space complexity approach using two variables instead * of an array. Time Complexity: O(n) - where n is the length of the input * array. Space Complexity: O(1) - as it only uses constant space for two * variables. * @param arr The input array of integers. * @return The maximum sum of non-adjacent elements. */ public static int getMaxSumApproach2(int[] arr) { if (arr.length == 0) { return 0; // Check for empty array } int n = arr.length; // Two variables to keep track of previous two results: // prev1 = max sum up to the last element (n-1) // prev2 = max sum up to the element before last (n-2) int prev1 = arr[0]; // Base case: Maximum sum for the first element. int prev2 = 0; for (int ind = 1; ind < n; ind++) { // Case 1: Do not take the current element, keep the last max sum. int notTake = prev1; // Case 2: Take the current element and add it to the result from two // steps back. int take = arr[ind]; if (ind > 1) { take += prev2; } // Calculate the current maximum sum and update previous values. int current = Math.max(take, notTake); // Shift prev1 and prev2 for the next iteration. prev2 = prev1; prev1 = current; } return prev1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; public final class MazeRecursion { private MazeRecursion() { } public static int[][] solveMazeUsingFirstStrategy(int[][] nArray) { if (MazeRecursion.a(nArray, 1, 1)) { return nArray; } return null; } public static int[][] solveMazeUsingSecondStrategy(int[][] nArray) { if (MazeRecursion.b(nArray, 1, 1)) { return nArray; } return null; } private static boolean a(int[][] nArray, int n, int n2) { if (nArray[6][5] == 2) { return true; } if (nArray[n][n2] == 0) { nArray[n][n2] = 2; if (MazeRecursion.a(nArray, n + 1, n2)) { return true; } if (MazeRecursion.a(nArray, n, n2 + 1)) { return true; } if (MazeRecursion.a(nArray, n - 1, n2)) { return true; } if (MazeRecursion.a(nArray, n, n2 - 1)) { return true; } nArray[n][n2] = 3; return false; } return false; } private static boolean b(int[][] nArray, int n, int n2) { if (nArray[6][5] == 2) { return true; } if (nArray[n][n2] == 0) { nArray[n][n2] = 2; if (MazeRecursion.b(nArray, n - 1, n2)) { return true; } if (MazeRecursion.b(nArray, n, n2 + 1)) { return true; } if (MazeRecursion.b(nArray, n + 1, n2)) { return true; } if (MazeRecursion.b(nArray, n, n2 - 1)) { return true; } nArray[n][n2] = 3; return false; } return false; } }", "deobfuscated_code": "package com.thealgorithms.backtracking; /** * This class contains methods to solve a maze using recursive backtracking. * The maze is represented as a 2D array where walls, paths, and visited/dead * ends are marked with different integers. * * The goal is to find a path from a starting position to the target position * (map[6][5]) while navigating through the maze. */ public final class MazeRecursion { private MazeRecursion() { } /** * This method solves the maze using the \"down -> right -> up -> left\" * movement strategy. * * @param map The 2D array representing the maze (walls, paths, etc.) * @return The solved maze with paths marked, or null if no solution exists. */ public static int[][] solveMazeUsingFirstStrategy(int[][] map) { if (setWay(map, 1, 1)) { return map; } return null; } /** * This method solves the maze using the \"up -> right -> down -> left\" * movement strategy. * * @param map The 2D array representing the maze (walls, paths, etc.) * @return The solved maze with paths marked, or null if no solution exists. */ public static int[][] solveMazeUsingSecondStrategy(int[][] map) { if (setWay2(map, 1, 1)) { return map; } return null; } /** * Attempts to find a path through the maze using a \"down -> right -> up -> left\" * movement strategy. The path is marked with '2' for valid paths and '3' for dead ends. * * @param map The 2D array representing the maze (walls, paths, etc.) * @param i The current x-coordinate of the ball (row index) * @param j The current y-coordinate of the ball (column index) * @return True if a path is found to (6,5), otherwise false */ private static boolean setWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } // If the current position is unvisited (0), explore it if (map[i][j] == 0) { // Mark the current position as '2' map[i][j] = 2; // Move down if (setWay(map, i + 1, j)) { return true; } // Move right else if (setWay(map, i, j + 1)) { return true; } // Move up else if (setWay(map, i - 1, j)) { return true; } // Move left else if (setWay(map, i, j - 1)) { return true; } map[i][j] = 3; // Mark as dead end (3) if no direction worked return false; } return false; } /** * Attempts to find a path through the maze using an alternative movement * strategy \"up -> right -> down -> left\". * * @param map The 2D array representing the maze (walls, paths, etc.) * @param i The current x-coordinate of the ball (row index) * @param j The current y-coordinate of the ball (column index) * @return True if a path is found to (6,5), otherwise false */ private static boolean setWay2(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } if (map[i][j] == 0) { map[i][j] = 2; // Move up if (setWay2(map, i - 1, j)) { return true; } // Move right else if (setWay2(map, i, j + 1)) { return true; } // Move down else if (setWay2(map, i + 1, j)) { return true; } // Move left else if (setWay2(map, i, j - 1)) { return true; } map[i][j] = 3; // Mark as dead end (3) if no direction worked return false; } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. * * Could not load the following classes: * org.apache.commons.collections4.IterableUtils */ package com.thealgorithms.maths; import java.util.stream.StreamSupport; import org.apache.commons.collections4.IterableUtils; public final class Means { private Means() { } public static Double arithmetic(Iterable iterable) { Means.a(iterable); return (Double)StreamSupport.stream(iterable.spliterator(), false).reduce((d, d2) -> d + d2).get() / (double)IterableUtils.size((Iterable)iterable); } public static Double geometric(Iterable iterable) { Means.a(iterable); return Math.pow((Double)StreamSupport.stream(iterable.spliterator(), false).reduce((d, d2) -> d * d2).get(), 1.0 / (double)IterableUtils.size((Iterable)iterable)); } public static Double harmonic(Iterable iterable) { Means.a(iterable); return (double)IterableUtils.size((Iterable)iterable) / StreamSupport.stream(iterable.spliterator(), false).reduce(0.0, (d, d2) -> d + 1.0 / d2); } private static void a(Iterable iterable) { if (!iterable.iterator().hasNext()) { throw new IllegalArgumentException(\"Emtpy list given for Mean computation.\"); } } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.stream.StreamSupport; import org.apache.commons.collections4.IterableUtils; /** * https://en.wikipedia.org/wiki/Mean * <p> * by: Punit Patel */ public final class Means { private Means() { } /** * @brief computes the [Arithmetic Mean](https://en.wikipedia.org/wiki/Arithmetic_mean) of the input * @param numbers the input numbers * @throws IllegalArgumentException empty input * @return the arithmetic mean of the input numbers */ public static Double arithmetic(final Iterable<Double> numbers) { checkIfNotEmpty(numbers); return StreamSupport.stream(numbers.spliterator(), false).reduce((x, y) -> x + y).get() / IterableUtils.size(numbers); } /** * @brief computes the [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) of the input * @param numbers the input numbers * @throws IllegalArgumentException empty input * @return the geometric mean of the input numbers */ public static Double geometric(final Iterable<Double> numbers) { checkIfNotEmpty(numbers); return Math.pow(StreamSupport.stream(numbers.spliterator(), false).reduce((x, y) -> x * y).get(), 1d / IterableUtils.size(numbers)); } /** * @brief computes the [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) of the input * @param numbers the input numbers * @throws IllegalArgumentException empty input * @return the harmonic mean of the input numbers */ public static Double harmonic(final Iterable<Double> numbers) { checkIfNotEmpty(numbers); return IterableUtils.size(numbers) / StreamSupport.stream(numbers.spliterator(), false).reduce(0d, (x, y) -> x + 1d / y); } private static void checkIfNotEmpty(final Iterable<Double> numbers) { if (!numbers.iterator().hasNext()) { throw new IllegalArgumentException(\"Emtpy list given for Mean computation.\"); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.Arrays; public final class Median { private Median() { } public static double median(int[] nArray) { if (nArray == null || nArray.length == 0) { throw new IllegalArgumentException(\"Values array cannot be empty or null\"); } Arrays.sort(nArray); int n = nArray.length; if (n % 2 == 0) { return (double)(nArray[n / 2] + nArray[n / 2 - 1]) / 2.0; } return nArray[n / 2]; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.Arrays; /** * Wikipedia: https://en.wikipedia.org/wiki/Median */ public final class Median { private Median() { } /** * Calculate average median * @param values sorted numbers to find median of * @return median of given {@code values} * @throws IllegalArgumentException If the input array is empty or null. */ public static double median(int[] values) { if (values == null || values.length == 0) { throw new IllegalArgumentException(\"Values array cannot be empty or null\"); } Arrays.sort(values); int length = values.length; return length % 2 == 0 ? (values[length / 2] + values[length / 2 - 1]) / 2.0 : values[length / 2]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import java.util.PriorityQueue; public final class MedianFinder { private PriorityQueue a = new PriorityQueue(); private PriorityQueue b = new PriorityQueue((n, n2) -> n2 - n); MedianFinder() { } public final void addNum(int n) { if (this.b.isEmpty() || n <= (Integer)this.b.peek()) { this.b.offer(n); } else { this.a.offer(n); } if (this.b.size() > this.a.size() + 1) { this.a.offer((Integer)this.b.poll()); return; } if (this.a.size() > this.b.size()) { this.b.offer((Integer)this.a.poll()); } } public final double findMedian() { if (this.b.size() == this.a.size()) { return (double)((Integer)this.b.peek() + (Integer)this.a.peek()) / 2.0; } return ((Integer)this.b.peek()).intValue(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; import java.util.PriorityQueue; /** * This class maintains the median of a dynamically changing data stream using * two heaps: a max-heap and a min-heap. The max-heap stores the smaller half * of the numbers, and the min-heap stores the larger half. * This data structure ensures that retrieving the median is efficient. * * Time Complexity: * - Adding a number: O(log n) due to heap insertion. * - Finding the median: O(1). * * Space Complexity: O(n), where n is the total number of elements added. * * @author Hardvan */ public final class MedianFinder { MedianFinder() { } private PriorityQueue<Integer> minHeap = new PriorityQueue<>(); private PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); /** * Adds a new number to the data stream. The number is placed in the appropriate * heap to maintain the balance between the two heaps. * * @param num the number to be added to the data stream */ public void addNum(int num) { if (maxHeap.isEmpty() || num <= maxHeap.peek()) { maxHeap.offer(num); } else { minHeap.offer(num); } if (maxHeap.size() > minHeap.size() + 1) { minHeap.offer(maxHeap.poll()); } else if (minHeap.size() > maxHeap.size()) { maxHeap.offer(minHeap.poll()); } } /** * Finds the median of the numbers added so far. If the total number of elements * is even, the median is the average of the two middle elements. If odd, the * median is the middle element from the max-heap. * * @return the median of the numbers in the data stream */ public double findMedian() { if (maxHeap.size() == minHeap.size()) { return (maxHeap.peek() + minHeap.peek()) / 2.0; } return maxHeap.peek(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix; import java.util.ArrayList; import java.util.Collections; import java.util.List; public final class MedianOfMatrix { private MedianOfMatrix() { } public static int median(Iterable object) { ArrayList arrayList = new ArrayList(); object = object.iterator(); while (object.hasNext()) { List list = (List)object.next(); if (list == null) continue; arrayList.addAll(list); } if (arrayList.isEmpty()) { throw new IllegalArgumentException(\"Matrix must contain at least one element.\"); } Collections.sort(arrayList); ArrayList arrayList2 = arrayList; return (Integer)arrayList2.get((arrayList2.size() - 1) / 2); } }", "deobfuscated_code": "package com.thealgorithms.matrix; import java.util.ArrayList; import java.util.Collections; import java.util.List; /** * Median of Matrix (https://medium.com/@vaibhav.yadav8101/median-in-a-row-wise-sorted-matrix-901737f3e116) * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi) */ public final class MedianOfMatrix { private MedianOfMatrix() { } public static int median(Iterable<List<Integer>> matrix) { List<Integer> flattened = new ArrayList<>(); for (List<Integer> row : matrix) { if (row != null) { flattened.addAll(row); } } if (flattened.isEmpty()) { throw new IllegalArgumentException(\"Matrix must contain at least one element.\"); } Collections.sort(flattened); return flattened.get((flattened.size() - 1) / 2); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import java.util.Collections; import java.util.PriorityQueue; public abstract class MedianOfRunningArray { private final PriorityQueue a = new PriorityQueue(Collections.reverseOrder()); private final PriorityQueue b = new PriorityQueue(); public final void insert(Number number) { if (!this.b.isEmpty() && ((Comparable)((Object)number)).compareTo((Number)this.b.peek()) < 0) { this.a.offer(number); this.a(); return; } this.b.offer(number); this.a(); } public final Number getMedian() { if (this.a.isEmpty() && this.b.isEmpty()) { throw new IllegalArgumentException(\"Median is undefined for an empty data set.\"); } if (this.a.size() == this.b.size()) { MedianOfRunningArray medianOfRunningArray = this; return medianOfRunningArray.calculateAverage((Number)medianOfRunningArray.a.peek(), (Number)this.b.peek()); } if (this.a.size() > this.b.size()) { return (Number)this.a.peek(); } return (Number)this.b.peek(); } protected abstract Number calculateAverage(Number var1, Number var2); private void a() { if (this.a.size() > this.b.size() + 1) { this.b.offer((Number)this.a.poll()); return; } if (this.b.size() > this.a.size() + 1) { this.a.offer((Number)this.b.poll()); } } }", "deobfuscated_code": "package com.thealgorithms.misc; import java.util.Collections; import java.util.PriorityQueue; /** * A generic abstract class to compute the median of a dynamically growing stream of numbers. * * @param <T> the number type, must extend Number and be Comparable * * Usage: * Extend this class and implement {@code calculateAverage(T a, T b)} to define how averaging is done. */ public abstract class MedianOfRunningArray<T extends Number & Comparable<T>> { private final PriorityQueue<T> maxHeap; // Lower half (max-heap) private final PriorityQueue<T> minHeap; // Upper half (min-heap) public MedianOfRunningArray() { this.maxHeap = new PriorityQueue<>(Collections.reverseOrder()); this.minHeap = new PriorityQueue<>(); } /** * Inserts a new number into the data structure. * * @param element the number to insert */ public final void insert(final T element) { if (!minHeap.isEmpty() && element.compareTo(minHeap.peek()) < 0) { maxHeap.offer(element); balanceHeapsIfNeeded(); } else { minHeap.offer(element); balanceHeapsIfNeeded(); } } /** * Returns the median of the current elements. * * @return the median value * @throws IllegalArgumentException if no elements have been inserted */ public final T getMedian() { if (maxHeap.isEmpty() && minHeap.isEmpty()) { throw new IllegalArgumentException(\"Median is undefined for an empty data set.\"); } if (maxHeap.size() == minHeap.size()) { return calculateAverage(maxHeap.peek(), minHeap.peek()); } return (maxHeap.size() > minHeap.size()) ? maxHeap.peek() : minHeap.peek(); } /** * Calculates the average between two values. * Concrete subclasses must define how averaging works (e.g., for Integer, Double, etc.). * * @param a first number * @param b second number * @return the average of a and b */ protected abstract T calculateAverage(T a, T b); /** * Balances the two heaps so that their sizes differ by at most 1. */ private void balanceHeapsIfNeeded() { if (maxHeap.size() > minHeap.size() + 1) { minHeap.offer(maxHeap.poll()); } else if (minHeap.size() > maxHeap.size() + 1) { maxHeap.offer(minHeap.poll()); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import com.thealgorithms.misc.MedianOfRunningArray; public final class MedianOfRunningArrayByte extends MedianOfRunningArray { public final Byte calculateAverage(Byte by, Byte by2) { return (byte)((by + by2) / 2); } }", "deobfuscated_code": "package com.thealgorithms.misc; public final class MedianOfRunningArrayByte extends MedianOfRunningArray<Byte> { @Override public Byte calculateAverage(final Byte a, final Byte b) { return (byte) ((a + b) / 2); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import com.thealgorithms.misc.MedianOfRunningArray; public final class MedianOfRunningArrayDouble extends MedianOfRunningArray { public final Double calculateAverage(Double d, Double d2) { return (d + d2) / 2.0; } }", "deobfuscated_code": "package com.thealgorithms.misc; public final class MedianOfRunningArrayDouble extends MedianOfRunningArray<Double> { @Override public Double calculateAverage(final Double a, final Double b) { return (a + b) / 2.0d; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import com.thealgorithms.misc.MedianOfRunningArray; public final class MedianOfRunningArrayFloat extends MedianOfRunningArray { public final Float calculateAverage(Float f, Float f2) { return Float.valueOf((f.floatValue() + f2.floatValue()) / 2.0f); } }", "deobfuscated_code": "package com.thealgorithms.misc; public final class MedianOfRunningArrayFloat extends MedianOfRunningArray<Float> { @Override public Float calculateAverage(final Float a, final Float b) { return (a + b) / 2.0f; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import com.thealgorithms.misc.MedianOfRunningArray; public final class MedianOfRunningArrayInteger extends MedianOfRunningArray { public final Integer calculateAverage(Integer n, Integer n2) { return (n + n2) / 2; } }", "deobfuscated_code": "package com.thealgorithms.misc; public final class MedianOfRunningArrayInteger extends MedianOfRunningArray<Integer> { @Override public Integer calculateAverage(final Integer a, final Integer b) { return (a + b) / 2; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import com.thealgorithms.misc.MedianOfRunningArray; public final class MedianOfRunningArrayLong extends MedianOfRunningArray { public final Long calculateAverage(Long l, Long l2) { return (l + l2) / 2L; } }", "deobfuscated_code": "package com.thealgorithms.misc; public final class MedianOfRunningArrayLong extends MedianOfRunningArray<Long> { @Override public Long calculateAverage(final Long a, final Long b) { return (a + b) / 2L; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; public final class MedianOfTwoSortedArrays { private MedianOfTwoSortedArrays() { } public static double findMedianSortedArrays(int[] nArray, int[] nArray2) { while (nArray.length > nArray2.length) { int[] nArray3 = nArray2; nArray2 = nArray; nArray = nArray3; } int n = nArray.length; int n2 = nArray2.length; int n3 = 0; int n4 = n; while (n3 <= n4) { int n5 = (n3 + n4) / 2; int n6 = (n + n2 + 1) / 2 - n5; int n7 = n5 == 0 ? Integer.MIN_VALUE : nArray[n5 - 1]; int n8 = n5 == n ? Integer.MAX_VALUE : nArray[n5]; int n9 = n6 == 0 ? Integer.MIN_VALUE : nArray2[n6 - 1]; int n10 = n6 = n6 == n2 ? Integer.MAX_VALUE : nArray2[n6]; if (n7 <= n6 && n9 <= n8) { if ((n + n2 & 1) == 1) { return Math.max(n7, n9); } return (double)(Math.max(n7, n9) + Math.min(n8, n6)) / 2.0; } if (n7 > n6) { n4 = n5 - 1; continue; } n3 = n5 + 1; } throw new IllegalArgumentException(\"Input arrays are not sorted\"); } }", "deobfuscated_code": "package com.thealgorithms.divideandconquer; public final class MedianOfTwoSortedArrays { private MedianOfTwoSortedArrays() { } /** * Finds the median of two sorted arrays in logarithmic time. * * @param nums1 the first sorted array * @param nums2 the second sorted array * @return the median of the combined sorted array * @throws IllegalArgumentException if the input arrays are not sorted */ public static double findMedianSortedArrays(int[] nums1, int[] nums2) { if (nums1.length > nums2.length) { return findMedianSortedArrays(nums2, nums1); // Ensure nums1 is the smaller array } int m = nums1.length; int n = nums2.length; int low = 0; int high = m; while (low <= high) { int partition1 = (low + high) / 2; // Partition in the first array int partition2 = (m + n + 1) / 2 - partition1; // Partition in the second array int maxLeft1 = (partition1 == 0) ? Integer.MIN_VALUE : nums1[partition1 - 1]; int minRight1 = (partition1 == m) ? Integer.MAX_VALUE : nums1[partition1]; int maxLeft2 = (partition2 == 0) ? Integer.MIN_VALUE : nums2[partition2 - 1]; int minRight2 = (partition2 == n) ? Integer.MAX_VALUE : nums2[partition2]; // Check if partition is valid if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) { // If combined array length is odd if (((m + n) & 1) == 1) { return Math.max(maxLeft1, maxLeft2); } // If combined array length is even else { return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0; } } else if (maxLeft1 > minRight2) { high = partition1 - 1; } else { low = partition1 + 1; } } throw new IllegalArgumentException(\"Input arrays are not sorted\"); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.ArrayList; public abstract class MemoryManagementAlgorithms { public abstract ArrayList fitProcess(int[] var1, int[] var2); }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.ArrayList; /** * @author Alexandros Lemonaris */ public abstract class MemoryManagementAlgorithms { /** * Method to allocate memory to blocks according to CPU algorithms. * Use of inheritance to avoid repeated code. * Abstract method since it is implemented different for each algorithm. * It should return an ArrayList of Integers, where the index is the process * ID (zero-indexed) and the value is the block number (also zero-indexed). * @param sizeOfBlocks an int array that contains the sizes of the memory * blocks available. * @param sizeOfProcesses: an int array that contains the sizes of the * processes we need memory blocks for. * @return the ArrayList filled with Integers repressenting the memory * allocation that took place. */ public abstract ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses); /** * A constant value used to indicate that an allocation has not been made. * This value is used as a sentinel value to represent that no allocation has been made * when allocating space in an array or other data structure. * The value is -255 and is marked as protected and final to ensure that it cannot be modified * from outside the class and that its value remains consistent throughout the program * execution. * * @author: Ishan Makadia (github.com/intrepid-ishan) * @version: April 06, 2023 */ protected static final int NO_ALLOCATION = -255; } /** * @author Dekas Dimitrios */ class BestFitCPU extends MemoryManagementAlgorithms { /** * Method to find the maximum valued element of an array filled with * positive integers. * * @param array: an array filled with positive integers. * @return the maximum valued element of the array. */ private static int findMaxElement(int[] array) { int max = -1; for (int value : array) { if (value > max) { max = value; } } return max; } /** * Method to find the index of the memory block that is going to fit the * given process based on the best fit algorithm. * * @param blocks: the array with the available memory blocks. * @param process: the size of the process. * @return the index of the block that fits, or -255 if no such block * exists. */ private static int findBestFit(int[] blockSizes, int processSize) { // Initialize minDiff with an unreachable value by a difference between a blockSize and the // processSize. int minDiff = findMaxElement(blockSizes); int index = NO_ALLOCATION; // If there is no block that can fit the process, return // NO_ALLOCATION as the // result. for (int i = 0; i < blockSizes.length; i++) { // Find the most fitting memory block for the given process. if (blockSizes[i] - processSize < minDiff && blockSizes[i] - processSize >= 0) { minDiff = blockSizes[i] - processSize; index = i; } } return index; } /** * Method to allocate memory to blocks according to the best fit algorithm. * It should return an ArrayList of Integers, where the index is the process * ID (zero-indexed) and the value is the block number (also zero-indexed). * * @param sizeOfBlocks: an int array that contains the sizes of the memory * blocks available. * @param sizeOfProcesses: an int array that contains the sizes of the * processes we need memory blocks for. * @return the ArrayList filled with Integers repressenting the memory * allocation that took place. */ public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) { // The array list responsible for saving the memory allocations done by the best-fit // algorithm ArrayList<Integer> memAlloc = new ArrayList<>(); // Do this for every process for (int processSize : sizeOfProcesses) { int chosenBlockIdx = findBestFit(sizeOfBlocks, processSize); // Find the index of the memory block going to be used memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list if (chosenBlockIdx != NO_ALLOCATION) { // Only if a block was chosen to store the process in it, sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size } } return memAlloc; } } /** * @author Dekas Dimitrios */ class WorstFitCPU extends MemoryManagementAlgorithms { /** * Method to find the index of the memory block that is going to fit the * given process based on the worst fit algorithm. * * @param blocks: the array with the available memory blocks. * @param process: the size of the process. * @return the index of the block that fits, or -255 if no such block * exists. */ private static int findWorstFit(int[] blockSizes, int processSize) { int max = -1; int index = -1; for (int i = 0; i < blockSizes.length; i++) { // Find the index of the biggest memory block available. if (blockSizes[i] > max) { max = blockSizes[i]; index = i; } } // If the biggest memory block cannot fit the process, return -255 as the result if (processSize > blockSizes[index]) { return NO_ALLOCATION; } return index; } /** * Method to allocate memory to blocks according to the worst fit algorithm. * It should return an ArrayList of Integers, where the index is the process * ID (zero-indexed) and the value is the block number (also zero-indexed). * * @param sizeOfBlocks: an int array that contains the sizes of the memory * blocks available. * @param sizeOfProcesses: an int array that contains the sizes of the * processes we need memory blocks for. * @return the ArrayList filled with Integers repressenting the memory * allocation that took place. */ public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) { // The array list responsible for saving the memory allocations done by the worst-fit // algorithm ArrayList<Integer> memAlloc = new ArrayList<>(); // Do this for every process for (int processSize : sizeOfProcesses) { int chosenBlockIdx = findWorstFit(sizeOfBlocks, processSize); // Find the index of the memory block going to be used memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list if (chosenBlockIdx != NO_ALLOCATION) { // Only if a block was chosen to store the process in it, sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size } } return memAlloc; } } /** * @author Dekas Dimitrios */ class FirstFitCPU extends MemoryManagementAlgorithms { /** * Method to find the index of the memory block that is going to fit the * given process based on the first fit algorithm. * * @param blocks: the array with the available memory blocks. * @param process: the size of the process. * @return the index of the block that fits, or -255 if no such block * exists. */ private static int findFirstFit(int[] blockSizes, int processSize) { for (int i = 0; i < blockSizes.length; i++) { if (blockSizes[i] >= processSize) { return i; } } // If there is not a block that can fit the process, return -255 as the result return NO_ALLOCATION; } /** * Method to allocate memory to blocks according to the first fit algorithm. * It should return an ArrayList of Integers, where the index is the process * ID (zero-indexed) and the value is the block number (also zero-indexed). * * @param sizeOfBlocks: an int array that contains the sizes of the memory * blocks available. * @param sizeOfProcesses: an int array that contains the sizes of the * processes we need memory blocks for. * @return the ArrayList filled with Integers repressenting the memory * allocation that took place. */ public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) { // The array list responsible for saving the memory allocations done by the first-fit // algorithm ArrayList<Integer> memAlloc = new ArrayList<>(); // Do this for every process for (int processSize : sizeOfProcesses) { int chosenBlockIdx = findFirstFit(sizeOfBlocks, processSize); // Find the index of the memory block going to be used memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list if (chosenBlockIdx != NO_ALLOCATION) { // Only if a block was chosen to store the process in it, sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size } } return memAlloc; } } /** * @author Alexandros Lemonaris */ class NextFit extends MemoryManagementAlgorithms { private int counter = 0; // variable that keeps the position of the last registration into the memory /** * Method to find the index of the memory block that is going to fit the * given process based on the next fit algorithm. In the case of next fit, * if the search is interrupted in between, the new search is carried out from the last * location. * * @param blocks: the array with the available memory blocks. * @param process: the size of the process. * @return the index of the block that fits, or -255 if no such block * exists. */ private int findNextFit(int[] blockSizes, int processSize) { for (int i = 0; i < blockSizes.length; i++) { if (counter + i >= blockSizes.length) { counter = -i; // starts from the start of the array } if (blockSizes[i + counter] >= processSize) { counter += i; return counter; } } // If there is not a block that can fit the process, return -255 as the result counter += blockSizes.length; // counter keeps its last value return NO_ALLOCATION; } /** * Method to allocate memory to blocks according to the first fit algorithm. * It should return an ArrayList of Integers, where the index is the process * ID (zero-indexed) and the value is the block number (also zero-indexed). * * @param sizeOfBlocks: an int array that contains the sizes of the memory * blocks available. * @param sizeOfProcesses: an int array that contains the sizes of the * processes we need memory blocks for. * @return the ArrayList filled with Integers repressenting the memory * allocation that took place. */ public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) { // The array list responsible for saving the memory allocations done by the first-fit // algorithm ArrayList<Integer> memAlloc = new ArrayList<>(); // Do this for every process for (int processSize : sizeOfProcesses) { int chosenBlockIdx = findNextFit(sizeOfBlocks, processSize); // Find the index of the memory block going to be used memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list if (chosenBlockIdx != NO_ALLOCATION) { // Only if a block was chosen to store the process in it, sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size } } return memAlloc; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.ArrayList; import java.util.Arrays; public final class MergeIntervals { private MergeIntervals() { } public static int[][] merge(int[][] nArray3) { Arrays.sort(nArray3, (nArray, nArray2) -> Integer.compare(nArray[0], nArray2[0])); ArrayList<int[]> arrayList = new ArrayList<int[]>(); for (int[] nArray4 : nArray3) { block4: { block3: { if (arrayList.isEmpty()) break block3; ArrayList<int[]> arrayList2 = arrayList; if (nArray4[0] <= ((int[])arrayList2.get(arrayList2.size() - 1))[1]) break block4; } arrayList.add(nArray4); continue; } ArrayList<int[]> arrayList3 = arrayList; ArrayList<int[]> arrayList4 = arrayList; ((int[])arrayList3.get((int)(arrayList3.size() - 1)))[1] = Math.max(((int[])arrayList4.get(arrayList4.size() - 1))[1], nArray4[1]); } ArrayList<int[]> arrayList5 = arrayList; return (int[][])arrayList5.toArray((T[])new int[arrayList5.size()][]); } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.ArrayList; import java.util.Arrays; import java.util.List; /** * Problem Statement: * Given an array of intervals where intervals[i] = [starti, endi]. * * Merge all overlapping intervals and return an array of the non-overlapping * intervals * that cover all the intervals in the input. */ public final class MergeIntervals { /** * Private constructor to prevent instantiation of this utility class. */ private MergeIntervals() { } /** * Merges overlapping intervals from the given array of intervals. * * The method sorts the intervals by their start time, then iterates through the * sorted intervals * and merges overlapping intervals. If an interval overlaps with the last * merged interval, * it updates the end time of the last merged interval. Otherwise, it adds the * interval as a new entry. * * @param intervals A 2D array representing intervals where each element is an * interval [starti, endi]. * @return A 2D array of merged intervals where no intervals overlap. * * Example: * Input: {{1, 3}, {2, 6}, {8, 10}, {15, 18}} * Output: {{1, 6}, {8, 10}, {15, 18}} */ public static int[][] merge(int[][] intervals) { // Sort the intervals by their start time (ascending order) Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0])); // List to store merged intervals List<int[]> merged = new ArrayList<>(); for (int[] interval : intervals) { // Each interval // If the merged list is empty or the current interval does not overlap with // the last merged interval, add it to the merged list. if (merged.isEmpty() || interval[0] > merged.get(merged.size() - 1)[1]) { merged.add(interval); } else { // If there is an overlap, merge the intervals by updating the end time // of the last merged interval to the maximum end time between the two // intervals. merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], interval[1]); } } // Convert the list of merged intervals back to a 2D array and return it return merged.toArray(new int[merged.size()][]); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import java.util.Comparator; import java.util.PriorityQueue; public final class MergeKSortedArrays { private MergeKSortedArrays() { } public static int[] mergeKArrays(int[][] nArray2) { PriorityQueue<int[]> priorityQueue = new PriorityQueue<int[]>(Comparator.comparingInt(nArray -> nArray[0])); int n = 0; for (int i = 0; i < nArray2.length; ++i) { if (nArray2[i].length <= 0) continue; priorityQueue.offer(new int[]{nArray2[i][0], i, 0}); n += nArray2[i].length; } int[] nArray3 = new int[n]; n = 0; while (!priorityQueue.isEmpty()) { int[] nArray4 = priorityQueue.poll(); nArray3[n++] = nArray4[0]; if (nArray4[2] + 1 >= nArray2[nArray4[1]].length) continue; priorityQueue.offer(new int[]{nArray2[nArray4[1]][nArray4[2] + 1], nArray4[1], nArray4[2] + 1}); } return nArray3; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; import java.util.Comparator; import java.util.PriorityQueue; /** * This class provides a method to merge multiple sorted arrays into a single sorted array. * It utilizes a min-heap to efficiently retrieve the smallest elements from each array. * * Time Complexity: O(n * log k), where n is the total number of elements across all arrays * and k is the number of arrays. * * Space Complexity: O(k) for the heap, where k is the number of arrays. * * @author Hardvan */ public final class MergeKSortedArrays { private MergeKSortedArrays() { } /** * Merges k sorted arrays into one sorted array using a min-heap. * Steps: * 1. Create a min-heap to store elements in the format: {value, array index, element index} * 2. Add the first element from each array to the heap * 3. While the heap is not empty, remove the smallest element from the heap * and add it to the result array. If there are more elements in the same array, * add the next element to the heap. * Continue until all elements have been processed. * The result array will contain all elements in sorted order. * 4. Return the result array. * * @param arrays a 2D array, where each subarray is sorted in non-decreasing order * @return a single sorted array containing all elements from the input arrays */ public static int[] mergeKArrays(int[][] arrays) { PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0])); int totalLength = 0; for (int i = 0; i < arrays.length; i++) { if (arrays[i].length > 0) { minHeap.offer(new int[] {arrays[i][0], i, 0}); totalLength += arrays[i].length; } } int[] result = new int[totalLength]; int index = 0; while (!minHeap.isEmpty()) { int[] top = minHeap.poll(); result[index++] = top[0]; if (top[2] + 1 < arrays[top[1]].length) { minHeap.offer(new int[] {arrays[top[1]][top[2] + 1], top[1], top[2] + 1}); } } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; class MergeKSortedLinkedList$Node { }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; class MergeKSortedLinkedList$Node { }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; public class MergeKSortedLinkedList { }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; import java.util.Comparator; import java.util.PriorityQueue; /** * The MergeKSortedLinkedList class provides a method to merge multiple sorted linked lists * into a single sorted linked list. * This implementation uses a min-heap (priority queue) to efficiently * find the smallest node across all lists, thus optimizing the merge process. * * <p>Example usage: * <pre> * Node list1 = new Node(1, new Node(4, new Node(5))); * Node list2 = new Node(1, new Node(3, new Node(4))); * Node list3 = new Node(2, new Node(6)); * Node[] lists = { list1, list2, list3 }; * * MergeKSortedLinkedList merger = new MergeKSortedLinkedList(); * Node mergedHead = merger.mergeKList(lists, lists.length); * </pre> * </p> * * <p>This class is designed to handle nodes of integer linked lists and can be expanded for additional data types if needed.</p> * * @author Arun Pandey (https://github.com/pandeyarun709) */ public class MergeKSortedLinkedList { /** * Merges K sorted linked lists into a single sorted linked list. * * <p>This method uses a priority queue (min-heap) to repeatedly extract the smallest node from the heads of all the lists, * then inserts the next node from that list into the heap. The process continues until all nodes have been processed, * resulting in a fully merged and sorted linked list.</p> * * @param a Array of linked list heads to be merged. * @param n Number of linked lists. * @return Head of the merged sorted linked list. */ Node mergeKList(Node[] a, int n) { if (a == null || n == 0) { return null; } // Min Heap to store nodes based on their values for efficient retrieval of the smallest element. PriorityQueue<Node> minHeap = new PriorityQueue<>(Comparator.comparingInt(x -> x.data)); // Initialize the min-heap with the head of each non-null linked list for (Node node : a) { if (node != null) { minHeap.add(node); } } // Start merging process Node head = minHeap.poll(); // Smallest head is the initial head of the merged list if (head != null && head.next != null) { minHeap.add(head.next); } Node curr = head; while (!minHeap.isEmpty()) { Node temp = minHeap.poll(); curr.next = temp; curr = temp; // Add the next node in the current list to the heap if it exists if (temp.next != null) { minHeap.add(temp.next); } } return head; } /** * Represents a node in the linked list. */ static class Node { int data; Node next; Node(int data) { this.data = data; this.next = null; } Node(int data, Node next) { this.data = data; this.next = next; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; class MergeSort implements SortAlgorithm { private Comparable[] a; MergeSort() { } @Override public Comparable[] sort(Comparable[] comparableArray) { this.a = new Comparable[comparableArray.length]; this.a(comparableArray, 0, comparableArray.length - 1); return comparableArray; } private void a(Comparable[] comparableArray, int n, int n2) { if (n < n2) { int n3 = n + n2 >>> 1; this.a(comparableArray, n, n3); this.a(comparableArray, n3 + 1, n2); this.a(comparableArray, n, n3, n2); } } /* * Unable to fully structure code */ private void a(Comparable[] var1_1, int var2_2, int var3_3, int var4_4) { var5_5 = var2_2; var6_6 = var3_3 + 1; System.arraycopy(var1_1, var2_2, this.a, var2_2, var4_4 + 1 - var2_2); while (var2_2 <= var4_4) { if (var6_6 > var4_4) ** GOTO lbl-1000 if (var5_5 > var3_3) { var1_1[var2_2] = this.a[var6_6++]; } else if (SortUtils.less(this.a[var6_6], this.a[var5_5])) { var1_1[var2_2] = this.a[var6_6++]; } else lbl-1000: // 2 sources { var1_1[var2_2] = this.a[var5_5++]; } ++var2_2; } } }", "deobfuscated_code": "package com.thealgorithms.sorts; import static com.thealgorithms.sorts.SortUtils.less; /** * Generic merge sort algorithm. * * @see SortAlgorithm */ @SuppressWarnings(\"rawtypes\") class MergeSort implements SortAlgorithm { private Comparable[] aux; /** * Generic merge sort algorithm implements. * * @param unsorted the array which should be sorted. * @param <T> Comparable class. * @return sorted array. */ @Override public <T extends Comparable<T>> T[] sort(T[] unsorted) { aux = new Comparable[unsorted.length]; doSort(unsorted, 0, unsorted.length - 1); return unsorted; } /** * @param arr the array to be sorted. * @param left the first index of the array. * @param right the last index of the array. */ private <T extends Comparable<T>> void doSort(T[] arr, int left, int right) { if (left < right) { int mid = (left + right) >>> 1; doSort(arr, left, mid); doSort(arr, mid + 1, right); merge(arr, left, mid, right); } } /** * Merges two parts of an array. * * @param arr the array to be merged. * @param left the first index of the array. * @param mid the middle index of the array. * @param right the last index of the array merges two parts of an array in * increasing order. */ @SuppressWarnings(\"unchecked\") private <T extends Comparable<T>> void merge(T[] arr, int left, int mid, int right) { int i = left; int j = mid + 1; System.arraycopy(arr, left, aux, left, right + 1 - left); for (int k = left; k <= right; k++) { if (j > right) { arr[k] = (T) aux[i++]; } else if (i > mid) { arr[k] = (T) aux[j++]; } else if (less(aux[j], aux[i])) { arr[k] = (T) aux[j++]; } else { arr[k] = (T) aux[i++]; } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.Arrays; public final class MergeSortNoExtraSpace { private MergeSortNoExtraSpace() { } public static int[] sort(int[] nArray) { if (nArray.length == 0) { return nArray; } if (Arrays.stream(nArray).anyMatch(n -> n < 0)) { throw new IllegalArgumentException(\"Implementation cannot sort negative numbers.\"); } int n2 = Arrays.stream(nArray).max().getAsInt() + 1; MergeSortNoExtraSpace.mergeSort(nArray, 0, nArray.length - 1, n2); return nArray; } public static void mergeSort(int[] nArray, int n, int n2, int n3) { if (n < n2) { int n4 = n + n2 >>> 1; MergeSortNoExtraSpace.mergeSort(nArray, n, n4, n3); MergeSortNoExtraSpace.mergeSort(nArray, n4 + 1, n2, n3); int n5 = n4; n4 = n3; n3 = n2; n2 = n5; int n6 = n; int n7 = n2 + 1; int n8 = n; while (n6 <= n2 && n7 <= n3) { if (nArray[n6] % n4 <= nArray[n7] % n4) { nArray[n8] = nArray[n8] + nArray[n6] % n4 * n4; ++n8; ++n6; continue; } nArray[n8] = nArray[n8] + nArray[n7] % n4 * n4; ++n8; ++n7; } while (n6 <= n2) { nArray[n8] = nArray[n8] + nArray[n6] % n4 * n4; ++n8; ++n6; } while (n7 <= n3) { nArray[n8] = nArray[n8] + nArray[n7] % n4 * n4; ++n8; ++n7; } for (n6 = n; n6 <= n3; ++n6) { nArray[n6] = nArray[n6] / n4; } } } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.Arrays; /** * Implementation of Merge Sort without using extra space for merging. * This implementation performs in-place merging to sort the array of integers. */ public final class MergeSortNoExtraSpace { private MergeSortNoExtraSpace() { } /** * Sorts the array using in-place merge sort algorithm. * * @param array the array to be sorted * @return the sorted array * @throws IllegalArgumentException If the array contains negative numbers. */ public static int[] sort(int[] array) { if (array.length == 0) { return array; } if (Arrays.stream(array).anyMatch(s -> s < 0)) { throw new IllegalArgumentException(\"Implementation cannot sort negative numbers.\"); } final int maxElement = Arrays.stream(array).max().getAsInt() + 1; mergeSort(array, 0, array.length - 1, maxElement); return array; } /** * Recursively divides the array into two halves, sorts and merges them. * * @param array the array to be sorted * @param start the starting index of the array * @param end the ending index of the array * @param maxElement the value greater than any element in the array, used for encoding */ public static void mergeSort(int[] array, int start, int end, int maxElement) { if (start < end) { final int middle = (start + end) >>> 1; mergeSort(array, start, middle, maxElement); mergeSort(array, middle + 1, end, maxElement); merge(array, start, middle, end, maxElement); } } /** * Merges two sorted subarrays [start...middle] and [middle+1...end] in place. * * @param array the array containing the subarrays to be merged * @param start the starting index of the first subarray * @param middle the ending index of the first subarray and starting index of the second subarray * @param end the ending index of the second subarray * @param maxElement the value greater than any element in the array, used for encoding */ private static void merge(int[] array, int start, int middle, int end, int maxElement) { int i = start; int j = middle + 1; int k = start; while (i <= middle && j <= end) { if (array[i] % maxElement <= array[j] % maxElement) { array[k] = array[k] + (array[i] % maxElement) * maxElement; k++; i++; } else { array[k] = array[k] + (array[j] % maxElement) * maxElement; k++; j++; } } while (i <= middle) { array[k] = array[k] + (array[i] % maxElement) * maxElement; k++; i++; } while (j <= end) { array[k] = array[k] + (array[j] % maxElement) * maxElement; k++; j++; } for (i = start; i <= end; i++) { array[i] = array[i] / maxElement; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.List; class MergeSortRecursive$1 extends ArrayList { private /* synthetic */ List a; MergeSortRecursive$1(List list) { this.a = list; MergeSortRecursive$1 mergeSortRecursive$1 = this; mergeSortRecursive$1.add((Integer)mergeSortRecursive$1.a.get(0)); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.List; class MergeSortRecursive$1 extends ArrayList { private /* synthetic */ List a; MergeSortRecursive$1(List list) { this.a = list; MergeSortRecursive$1 mergeSortRecursive$1 = this; mergeSortRecursive$1.add((Integer)mergeSortRecursive$1.a.get(0)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.List; class MergeSortRecursive$2 extends ArrayList { private /* synthetic */ List a; MergeSortRecursive$2(List list) { this.a = list; MergeSortRecursive$2 mergeSortRecursive$2 = this; mergeSortRecursive$2.add((Integer)mergeSortRecursive$2.a.get(0)); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.List; class MergeSortRecursive$2 extends ArrayList { private /* synthetic */ List a; MergeSortRecursive$2(List list) { this.a = list; MergeSortRecursive$2 mergeSortRecursive$2 = this; mergeSortRecursive$2.add((Integer)mergeSortRecursive$2.a.get(0)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.MergeSortRecursive$1; import com.thealgorithms.sorts.MergeSortRecursive$2; import java.util.ArrayList; import java.util.List; public class MergeSortRecursive { private List a; public MergeSortRecursive(List list) { this.a = list; } public List mergeSort() { return MergeSortRecursive.a(this.a); } private static List a(List list) { if (list.size() <= 1) { return list; } int n = list.size(); List list2 = list.subList(0, n /= 2); list = list.subList(n, list.size()); list2 = MergeSortRecursive.a(list2); list = MergeSortRecursive.a(list); return MergeSortRecursive.a(list2, list); } private static List a(List list, List list2) { if (list.isEmpty() && list2.isEmpty()) { return new ArrayList(); } if (list.isEmpty()) { return list2; } if (list2.isEmpty()) { return list; } if ((Integer)list.get(0) <= (Integer)list2.get(0)) { MergeSortRecursive$1 mergeSortRecursive$1 = new MergeSortRecursive$1(list); mergeSortRecursive$1.addAll(MergeSortRecursive.a(list.subList(1, list.size()), list2)); return mergeSortRecursive$1; } MergeSortRecursive$2 mergeSortRecursive$2 = new MergeSortRecursive$2(list2); mergeSortRecursive$2.addAll(MergeSortRecursive.a(list, list2.subList(1, list2.size()))); return mergeSortRecursive$2; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.List; public class MergeSortRecursive { List<Integer> arr; public MergeSortRecursive(List<Integer> arr) { this.arr = arr; } public List<Integer> mergeSort() { return merge(arr); } private static List<Integer> merge(List<Integer> arr) { // base condition if (arr.size() <= 1) { return arr; } int arrLength = arr.size(); int half = arrLength / 2; List<Integer> arrA = arr.subList(0, half); List<Integer> arrB = arr.subList(half, arr.size()); // recursion arrA = merge(arrA); arrB = merge(arrB); return sort(arrA, arrB); } private static List<Integer> sort(List<Integer> unsortedA, List<Integer> unsortedB) { if (unsortedA.isEmpty() && unsortedB.isEmpty()) { return new ArrayList<>(); } if (unsortedA.isEmpty()) { return unsortedB; } if (unsortedB.isEmpty()) { return unsortedA; } if (unsortedA.get(0) <= unsortedB.get(0)) { List<Integer> newAl = new ArrayList<Integer>() { { add(unsortedA.get(0)); } }; newAl.addAll(sort(unsortedA.subList(1, unsortedA.size()), unsortedB)); return newAl; } else { List<Integer> newAl = new ArrayList<Integer>() { { add(unsortedB.get(0)); } }; newAl.addAll(sort(unsortedA, unsortedB.subList(1, unsortedB.size()))); return newAl; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import java.util.Collection; import java.util.List; public final class MergeSortedArrayList { private MergeSortedArrayList() { } public static void merge(List list, List list2, Collection collection) { if (list == null || list2 == null || collection == null) { throw new NullPointerException(\"Input lists and result collection must not be null.\"); } int n = 0; int n2 = 0; while (n < list.size() && n2 < list2.size()) { if ((Integer)list.get(n) <= (Integer)list2.get(n2)) { collection.add((Integer)list.get(n++)); continue; } collection.add((Integer)list2.get(n2++)); } while (n < list.size()) { collection.add((Integer)list.get(n++)); } while (n2 < list2.size()) { collection.add((Integer)list2.get(n2++)); } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; import java.util.Collection; import java.util.List; /** * Utility class for merging two sorted ArrayLists of integers into a single sorted collection. * * <p>This class provides a static `merge` method to combine two pre-sorted lists of integers into a * single sorted list. It does so without modifying the input lists by adding elements from both lists in sorted order * into the result list.</p> * * <p>Example usage:</p> * <pre> * List<Integer> listA = Arrays.asList(1, 3, 5, 7, 9); * List<Integer> listB = Arrays.asList(2, 4, 6, 8, 10); * List<Integer> result = new ArrayList<>(); * MergeSortedArrayList.merge(listA, listB, result); * </pre> * * <p>The resulting `result` list will be [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].</p> * * <p>Note: This class cannot be instantiated as it is designed to be used only with its static `merge` method.</p> * * <p>This implementation assumes the input lists are already sorted in ascending order.</p> * * @author https://github.com/shellhub * @see List */ public final class MergeSortedArrayList { private MergeSortedArrayList() { } /** * Merges two sorted lists of integers into a single sorted collection. * * <p>This method does not alter the original lists (`listA` and `listB`). Instead, it inserts elements from both * lists into `listC` in a way that maintains ascending order.</p> * * @param listA The first sorted list of integers. * @param listB The second sorted list of integers. * @param listC The collection to hold the merged result, maintaining sorted order. * @throws NullPointerException if any of the input lists or result collection is null. */ public static void merge(List<Integer> listA, List<Integer> listB, Collection<Integer> listC) { if (listA == null || listB == null || listC == null) { throw new NullPointerException(\"Input lists and result collection must not be null.\"); } int pa = 0; int pb = 0; while (pa < listA.size() && pb < listB.size()) { if (listA.get(pa) <= listB.get(pb)) { listC.add(listA.get(pa++)); } else { listC.add(listB.get(pb++)); } } // Add remaining elements from listA, if any while (pa < listA.size()) { listC.add(listA.get(pa++)); } // Add remaining elements from listB, if any while (pb < listB.size()) { listC.add(listB.get(pb++)); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SinglyLinkedList; import com.thealgorithms.datastructures.lists.SinglyLinkedListNode; public class MergeSortedSinglyLinkedList extends SinglyLinkedList { public static SinglyLinkedList merge(SinglyLinkedList singlyLinkedList, SinglyLinkedList object) { if (singlyLinkedList == null || object == null) { throw new NullPointerException(\"Input lists must not be null.\"); } SinglyLinkedListNode singlyLinkedListNode = singlyLinkedList.getHead(); SinglyLinkedListNode singlyLinkedListNode2 = ((SinglyLinkedList)object).getHead(); int n = singlyLinkedList.size() + ((SinglyLinkedList)object).size(); object = new SinglyLinkedListNode(); SinglyLinkedListNode singlyLinkedListNode3 = object; while (singlyLinkedListNode != null && singlyLinkedListNode2 != null) { if (singlyLinkedListNode.a <= singlyLinkedListNode2.a) { singlyLinkedListNode3.b = singlyLinkedListNode; singlyLinkedListNode = singlyLinkedListNode.b; } else { singlyLinkedListNode3.b = singlyLinkedListNode2; singlyLinkedListNode2 = singlyLinkedListNode2.b; } singlyLinkedListNode3 = singlyLinkedListNode3.b; } singlyLinkedListNode3.b = singlyLinkedListNode == null ? singlyLinkedListNode2 : singlyLinkedListNode; return new SinglyLinkedList(((SinglyLinkedListNode)object).b, n); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; /** * Utility class for merging two sorted singly linked lists. * * <p>This class extends the {@link SinglyLinkedList} class to support the merging of two sorted linked lists. * It provides a static method, `merge`, that takes two sorted singly linked lists, merges them into a single sorted linked list, * and returns the result.</p> * * <p>Example usage:</p> * <pre> * SinglyLinkedList listA = new SinglyLinkedList(); * SinglyLinkedList listB = new SinglyLinkedList(); * for (int i = 2; i <= 10; i += 2) { * listA.insert(i); // listA: 2->4->6->8->10 * listB.insert(i - 1); // listB: 1->3->5->7->9 * } * SinglyLinkedList mergedList = MergeSortedSinglyLinkedList.merge(listA, listB); * System.out.println(mergedList); // Output: 1->2->3->4->5->6->7->8->9->10 * </pre> * * <p>The `merge` method assumes that both input lists are already sorted in ascending order. * It returns a new singly linked list that contains all elements from both lists in sorted order.</p> * * @see SinglyLinkedList */ public class MergeSortedSinglyLinkedList extends SinglyLinkedList { /** * Merges two sorted singly linked lists into a single sorted singly linked list. * * <p>This method does not modify the input lists; instead, it creates a new merged linked list * containing all elements from both lists in sorted order.</p> * * @param listA The first sorted singly linked list. * @param listB The second sorted singly linked list. * @return A new singly linked list containing all elements from both lists in sorted order. * @throws NullPointerException if either input list is null. */ public static SinglyLinkedList merge(SinglyLinkedList listA, SinglyLinkedList listB) { if (listA == null || listB == null) { throw new NullPointerException(\"Input lists must not be null.\"); } SinglyLinkedListNode headA = listA.getHead(); SinglyLinkedListNode headB = listB.getHead(); int size = listA.size() + listB.size(); SinglyLinkedListNode head = new SinglyLinkedListNode(); SinglyLinkedListNode tail = head; while (headA != null && headB != null) { if (headA.value <= headB.value) { tail.next = headA; headA = headA.next; } else { tail.next = headB; headB = headB.next; } tail = tail.next; } // Attach remaining nodes tail.next = (headA == null) ? headB : headA; return new SinglyLinkedList(head.next, size); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.geometry; import java.util.ArrayList; import java.util.Collection; import java.util.List; public final class MidpointCircle { private MidpointCircle() { } public static List generateCirclePoints(int n, int n2, int n3) { ArrayList<int[]> arrayList = new ArrayList<int[]>(); if (n3 == 0) { arrayList.add(new int[]{n, n2}); return arrayList; } int n4 = n3; int n5 = 0; n3 = 1 - n3; MidpointCircle.a(arrayList, n, n2, n4, 0); while (n4 > n5) { n3 = n3 <= 0 ? n3 + 2 * n5 + 1 : n3 + 2 * ++n5 - 2 * --n4 + 1; MidpointCircle.a(arrayList, n, n2, n4, n5); } return arrayList; } private static void a(Collection collection, int n, int n2, int n3, int n4) { collection.add(new int[]{n + n3, n2 + n4}); collection.add(new int[]{n - n3, n2 + n4}); collection.add(new int[]{n + n3, n2 - n4}); collection.add(new int[]{n - n3, n2 - n4}); collection.add(new int[]{n + n4, n2 + n3}); collection.add(new int[]{n - n4, n2 + n3}); collection.add(new int[]{n + n4, n2 - n3}); collection.add(new int[]{n - n4, n2 - n3}); } }", "deobfuscated_code": "package com.thealgorithms.geometry; import java.util.ArrayList; import java.util.Collection; import java.util.List; /** * Class to represent the Midpoint Circle Algorithm. * This algorithm calculates points on the circumference of a circle * using integer arithmetic for efficient computation. */ public final class MidpointCircle { private MidpointCircle() { // Private Constructor to prevent instantiation. } /** * Generates points on the circumference of a circle using the midpoint circle algorithm. * * @param centerX The x-coordinate of the circle's center. * @param centerY The y-coordinate of the circle's center. * @param radius The radius of the circle. * @return A list of points on the circle, each represented as an int[] with 2 elements [x, y]. */ public static List<int[]> generateCirclePoints(int centerX, int centerY, int radius) { List<int[]> points = new ArrayList<>(); // Special case for radius 0, only the center point should be added. if (radius == 0) { points.add(new int[] {centerX, centerY}); return points; } // Start at (radius, 0) int x = radius; int y = 0; // Decision parameter int p = 1 - radius; // Add the initial points in all octants addSymmetricPoints(points, centerX, centerY, x, y); // Iterate while x > y while (x > y) { y++; if (p <= 0) { // Midpoint is inside or on the circle p = p + 2 * y + 1; } else { // Midpoint is outside the circle x--; p = p + 2 * y - 2 * x + 1; } // Add points for this (x, y) addSymmetricPoints(points, centerX, centerY, x, y); } return points; } /** * Adds the symmetric points in all octants of the circle based on the current x and y values. * * @param points The list to which symmetric points will be added. * @param centerX The x-coordinate of the circle's center. * @param centerY The y-coordinate of the circle's center. * @param x The current x-coordinate on the circumference. * @param y The current y-coordinate on the circumference. */ private static void addSymmetricPoints(Collection<int[]> points, int centerX, int centerY, int x, int y) { // Octant symmetry points points.add(new int[] {centerX + x, centerY + y}); points.add(new int[] {centerX - x, centerY + y}); points.add(new int[] {centerX + x, centerY - y}); points.add(new int[] {centerX - x, centerY - y}); points.add(new int[] {centerX + y, centerY + x}); points.add(new int[] {centerX - y, centerY + x}); points.add(new int[] {centerX + y, centerY - x}); points.add(new int[] {centerX - y, centerY - x}); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.geometry; import java.util.ArrayList; import java.util.Collection; import java.util.List; public final class MidpointEllipse { private MidpointEllipse() { } public static List drawEllipse(int n, int n2, int n3, int n4) { ArrayList<int[]> arrayList = new ArrayList<int[]>(); if (n3 == 0 && n4 == 0) { arrayList.add(new int[]{n, n2}); return arrayList; } if (n3 == 0) { int n5 = n2 - n4; while (n5 <= n2 + n4) { arrayList.add(new int[]{n, n5++}); } return arrayList; } if (n4 == 0) { int n6 = n - n3; while (n6 <= n + n3) { arrayList.add(new int[]{n6++, n2}); } return arrayList; } int n7 = n4; n4 = n3; n3 = n2; n2 = n; ArrayList<int[]> arrayList2 = arrayList; int n8 = 0; int n9 = n7; int n10 = n7; int n11 = n4; double d = (double)(n10 * n10 - n11 * n11 * n7) + 0.25 * (double)n4 * (double)n4; double d2 = 2.0 * (double)n7 * (double)n7 * 0.0; double d3 = 2.0 * (double)n4 * (double)n4 * (double)n9; while (d2 < d3) { MidpointEllipse.a(arrayList2, n2, n3, n8, n9); if (d < 0.0) { ++n8; int n12 = n7; d += (d2 += (double)(2 * n7 * n7)) + (double)(n12 * n12); continue; } ++n8; --n9; int n13 = n7; d += (d2 += (double)(2 * n7 * n7)) - (d3 -= (double)(2 * n4 * n4)) + (double)(n13 * n13); } int n14 = n7; int n15 = n4; int n16 = n4; double d4 = (double)(n14 * n14) * ((double)n8 + 0.5) * ((double)n8 + 0.5) + (double)(n15 * n15 * (n9 - 1) * (n9 - 1)) - (double)(n16 * n16 * n7 * n7); while (n9 >= 0) { MidpointEllipse.a(arrayList2, n2, n3, n8, n9); if (d4 > 0.0) { --n9; int n17 = n4; d4 += (double)(n17 * n17) - (d3 -= (double)(2 * n4 * n4)); continue; } --n9; ++n8; int n18 = n4; d4 += (d2 += (double)(2 * n7 * n7)) - (d3 -= (double)(2 * n4 * n4)) + (double)(n18 * n18); } return arrayList; } private static void a(Collection collection, int n, int n2, int n3, int n4) { collection.add(new int[]{n + n3, n2 + n4}); collection.add(new int[]{n - n3, n2 + n4}); collection.add(new int[]{n + n3, n2 - n4}); collection.add(new int[]{n - n3, n2 - n4}); } }", "deobfuscated_code": "package com.thealgorithms.geometry; import java.util.ArrayList; import java.util.Collection; import java.util.List; /** * The MidpointEllipse class implements the Midpoint Ellipse Drawing Algorithm. * This algorithm efficiently computes the points on an ellipse by dividing it into two regions * and using decision parameters to determine the next point to plot. */ public final class MidpointEllipse { private MidpointEllipse() { // Private constructor to prevent instantiation } /** * Draws an ellipse using the Midpoint Ellipse Algorithm. * * @param centerX the x-coordinate of the center of the ellipse * @param centerY the y-coordinate of the center of the ellipse * @param a the length of the semi-major axis (horizontal radius) * @param b the length of the semi-minor axis (vertical radius) * @return a list of points (represented as int arrays) that form the ellipse */ public static List<int[]> drawEllipse(int centerX, int centerY, int a, int b) { List<int[]> points = new ArrayList<>(); // Handle degenerate cases with early returns if (a == 0 && b == 0) { points.add(new int[] {centerX, centerY}); // Only the center point return points; } if (a == 0) { // Semi-major axis is zero, create a vertical line for (int y = centerY - b; y <= centerY + b; y++) { points.add(new int[] {centerX, y}); } return points; // Early return } if (b == 0) { // Semi-minor axis is zero, create a horizontal line for (int x = centerX - a; x <= centerX + a; x++) { points.add(new int[] {x, centerY}); } return points; // Early return } // Normal case: Non-degenerate ellipse computeEllipsePoints(points, centerX, centerY, a, b); return points; // Return all calculated points of the ellipse } /** * Computes points of a non-degenerate ellipse using the Midpoint Ellipse Algorithm. * * @param points the list to which points will be added * @param centerX the x-coordinate of the center of the ellipse * @param centerY the y-coordinate of the center of the ellipse * @param a the length of the semi-major axis (horizontal radius) * @param b the length of the semi-minor axis (vertical radius) */ private static void computeEllipsePoints(Collection<int[]> points, int centerX, int centerY, int a, int b) { int x = 0; // Initial x-coordinate int y = b; // Initial y-coordinate // Region 1: Initial decision parameter double d1 = (b * b) - (a * a * b) + (0.25 * a * a); // Decision variable for region 1 double dx = 2.0 * b * b * x; // Change in x double dy = 2.0 * a * a * y; // Change in y // Region 1: When the slope is less than 1 while (dx < dy) { addEllipsePoints(points, centerX, centerY, x, y); // Update decision parameter and variables if (d1 < 0) { x++; dx += (2 * b * b); // Update x change d1 += dx + (b * b); // Update decision parameter } else { x++; y--; dx += (2 * b * b); // Update x change dy -= (2 * a * a); // Update y change d1 += dx - dy + (b * b); // Update decision parameter } } // Region 2: Initial decision parameter for the second region double d2 = b * b * (x + 0.5) * (x + 0.5) + a * a * (y - 1) * (y - 1) - a * a * b * b; // Region 2: When the slope is greater than or equal to 1 while (y >= 0) { addEllipsePoints(points, centerX, centerY, x, y); // Update decision parameter and variables if (d2 > 0) { y--; dy -= (2 * a * a); // Update y change d2 += (a * a) - dy; // Update decision parameter } else { y--; x++; dx += (2 * b * b); // Update x change dy -= (2 * a * a); // Update y change d2 += dx - dy + (a * a); // Update decision parameter } } } /** * Adds points for all four quadrants of the ellipse based on symmetry. * * @param points the list to which points will be added * @param centerX the x-coordinate of the center of the ellipse * @param centerY the y-coordinate of the center of the ellipse * @param x the x-coordinate relative to the center * @param y the y-coordinate relative to the center */ private static void addEllipsePoints(Collection<int[]> points, int centerX, int centerY, int x, int y) { points.add(new int[] {centerX + x, centerY + y}); points.add(new int[] {centerX - x, centerY + y}); points.add(new int[] {centerX + x, centerY - y}); points.add(new int[] {centerX - x, centerY - y}); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths.Prime; import java.util.Random; public final class MillerRabinPrimalityCheck { private MillerRabinPrimalityCheck() { } public static boolean millerRabin(long l, int n) { if (l < 4L) { return l == 2L || l == 3L; } int n2 = 0; long l2 = l - 1L; while ((l2 & 1L) == 0L) { l2 >>= 1; ++n2; } Random random = new Random(); for (int i = 0; i < n; ++i) { long l3 = 2L + random.nextLong(l) % (l - 3L); if (!MillerRabinPrimalityCheck.a(l, l3, l2, n2)) continue; return false; } return true; } public static boolean deterministicMillerRabin(long l) { if (l < 2L) { return false; } int n = 0; long l2 = l - 1L; while ((l2 & 1L) == 0L) { l2 >>= 1; ++n; } int[] nArray = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}; int cfr_ignored_0 = nArray.length; for (int i = 0; i < 12; ++i) { int n2 = nArray[i]; if (l == (long)n2) { return true; } if (!MillerRabinPrimalityCheck.a(l, n2, l2, n)) continue; return false; } return true; } private static boolean a(long l, long l2, long l3, int n) { long l4 = MillerRabinPrimalityCheck.a(l2, l3, l); if (l4 == 1L || l4 == l - 1L) { return false; } for (int i = 1; i < n; ++i) { if ((l4 = MillerRabinPrimalityCheck.a(l4, 2L, l)) != l - 1L) continue; return false; } return true; } private static long a(long l, long l2, long l3) { long l4 = 1L; if ((l %= l3) == 0L) { return 0L; } while (l2 > 0L) { if ((l2 & 1L) == 1L) { l4 = MillerRabinPrimalityCheck.b(l4, l, l3); } l2 >>= 1; long l5 = l; l = MillerRabinPrimalityCheck.b(l5, l5, l3); } return l4; } private static long b(long l, long l2, long l3) { long l4 = l >> 24; long l5 = l & 0xFFFFFFL; long l6 = l2 >> 24; long l7 = l2 & 0xFFFFFFL; long l8 = ((l4 * l6 << 16) % l3 << 16) % l3 << 16; return (l8 += (l5 * l6 + l4 * l7 << 24) + l5 * l7) % l3; } }", "deobfuscated_code": "package com.thealgorithms.maths.Prime; import java.util.Random; public final class MillerRabinPrimalityCheck { private MillerRabinPrimalityCheck() { } /** * Check whether the given number is prime or not * MillerRabin algorithm is probabilistic. There is also an altered version which is deterministic. * https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test * https://cp-algorithms.com/algebra/primality_tests.html * * @param n Whole number which is tested on primality * @param k Number of iterations * If n is composite then running k iterations of the MillerRabin * test will declare n probably prime with a probability at most 4^(k) * @return true or false whether the given number is probably prime or not */ public static boolean millerRabin(long n, int k) { // returns true if n is probably prime, else returns false. if (n < 4) { return n == 2 || n == 3; } int s = 0; long d = n - 1; while ((d & 1) == 0) { d >>= 1; s++; } Random rnd = new Random(); for (int i = 0; i < k; i++) { long a = 2 + rnd.nextLong(n) % (n - 3); if (checkComposite(n, a, d, s)) { return false; } } return true; } public static boolean deterministicMillerRabin(long n) { // returns true if n is prime, else returns false. if (n < 2) { return false; } int r = 0; long d = n - 1; while ((d & 1) == 0) { d >>= 1; r++; } for (int a : new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) { if (n == a) { return true; } if (checkComposite(n, a, d, r)) { return false; } } return true; } /** * Check if number n is composite (probabilistic) * * @param n Whole number which is tested for compositeness * @param a Random number (prime base) to check if it holds certain equality * @param d Number which holds this equation: 'n - 1 = 2^s * d' * @param s Number of twos in (n - 1) factorization * * @return true or false whether the numbers hold the equation or not * the equations are described on the websites mentioned at the beginning of the class */ private static boolean checkComposite(long n, long a, long d, int s) { long x = powerModP(a, d, n); if (x == 1 || x == n - 1) { return false; } for (int r = 1; r < s; r++) { x = powerModP(x, 2, n); if (x == n - 1) { return false; } } return true; } private static long powerModP(long x, long y, long p) { long res = 1; // Initialize result x = x % p; // Update x if it is more than or equal to p if (x == 0) { return 0; // In case x is divisible by p; } while (y > 0) { // If y is odd, multiply x with result if ((y & 1) == 1) { res = multiplyModP(res, x, p); } // y must be even now y = y >> 1; // y = y/2 x = multiplyModP(x, x, p); } return res; } private static long multiplyModP(long a, long b, long p) { long aHi = a >> 24; long aLo = a & ((1 << 24) - 1); long bHi = b >> 24; long bLo = b & ((1 << 24) - 1); long result = ((((aHi * bHi << 16) % p) << 16) % p) << 16; result += ((aLo * bHi + aHi * bLo) << 24) + aLo * bLo; return result % p; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; import com.thealgorithms.datastructures.heaps.EmptyHeapException; import com.thealgorithms.datastructures.heaps.Heap; import com.thealgorithms.datastructures.heaps.HeapElement; import java.util.ArrayList; import java.util.List; public class MinHeap implements Heap { private final List a; public MinHeap(List object) { if (object == null) { throw new IllegalArgumentException(\"Input list cannot be null\"); } this.a = new ArrayList(); object = object.iterator(); while (object.hasNext()) { HeapElement heapElement = (HeapElement)object.next(); if (heapElement != null) { this.a.add(heapElement); continue; } System.out.println(\"Null element. Not added to heap\"); } for (int i = this.a.size() / 2; i >= 0; --i) { this.b(i + 1); } if (this.a.isEmpty()) { System.out.println(\"No element has been added, empty heap.\"); } } public HeapElement getElement(int n) { if (n <= 0 || n > this.a.size()) { throw new IndexOutOfBoundsException(\"Index \" + n + \" is out of heap range [1, \" + this.a.size() + \"]\"); } return (HeapElement)this.a.get(n - 1); } private double a(int n) { if (n <= 0 || n > this.a.size()) { throw new IndexOutOfBoundsException(\"Index \" + n + \" is out of heap range [1, \" + this.a.size() + \"]\"); } return ((HeapElement)this.a.get(n - 1)).getKey(); } private void a(int n, int n2) { HeapElement heapElement = (HeapElement)this.a.get(n - 1); this.a.set(n - 1, (HeapElement)this.a.get(n2 - 1)); this.a.set(n2 - 1, heapElement); } private void b(int n) { while (true) { int n2 = n - 1; int n3 = 2 * n - 1; int n4 = 2 * n; if (n3 < this.a.size() && ((HeapElement)this.a.get(n3)).getKey() < ((HeapElement)this.a.get(n2)).getKey()) { n2 = n3; } if (n4 < this.a.size() && ((HeapElement)this.a.get(n4)).getKey() < ((HeapElement)this.a.get(n2)).getKey()) { n2 = n4; } if (n2 == n - 1) break; HeapElement heapElement = (HeapElement)this.a.get(n - 1); this.a.set(n - 1, (HeapElement)this.a.get(n2)); this.a.set(n2, heapElement); n = n2 + 1; } } private void c(int n) { if (n <= 1) { return; } double d = ((HeapElement)this.a.get(n - 1)).getKey(); int n2 = (int)Math.floor((double)n / 2.0); while (n > 1 && this.a(n2) > d) { this.a(n, n2); n = n2; n2 = (int)Math.floor((double)n / 2.0); } } @Override public void insertElement(HeapElement heapElement) { if (heapElement == null) { throw new IllegalArgumentException(\"Cannot insert null element\"); } this.a.add(heapElement); MinHeap minHeap = this; minHeap.c(minHeap.a.size()); } @Override public void deleteElement(int n) { if (this.a.isEmpty()) { throw new EmptyHeapException(\"Cannot delete from empty heap\"); } if (n > this.a.size() || n <= 0) { throw new IndexOutOfBoundsException(\"Index \" + n + \" is out of heap range [1, \" + this.a.size() + \"]\"); } this.a.set(n - 1, (HeapElement)this.a.getLast()); this.a.removeLast(); if (!this.a.isEmpty() && n <= this.a.size()) { if (n > 1 && this.a(n) < this.a((int)Math.floor((double)n / 2.0))) { this.c(n); return; } int n2 = n; MinHeap minHeap = this; double d = ((HeapElement)minHeap.a.get(n2 - 1)).getKey(); int n3 = minHeap.a.size(); while (true) { int n4 = n2; int n5 = 2 * n2; int n6 = 2 * n2 + 1; if (n5 <= n3 && minHeap.a(n5) < d) { n4 = n5; } if (n6 <= n3 && minHeap.a(n6) < minHeap.a(n4)) { n4 = n6; } if (n4 == n2) break; minHeap.a(n2, n4); n2 = n4; } } } @Override public HeapElement getElement() { MinHeap minHeap = this; if (minHeap.a.isEmpty()) { throw new EmptyHeapException(\"Cannot extract from empty heap\"); } HeapElement heapElement = (HeapElement)minHeap.a.getFirst(); minHeap.deleteElement(1); return heapElement; } public int size() { return this.a.size(); } public boolean isEmpty() { return this.a.isEmpty(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; import java.util.ArrayList; import java.util.List; /** * A Min Heap implementation where each node's key is lower than or equal to its children's keys. * This data structure provides O(log n) time complexity for insertion and deletion operations, * and O(1) for retrieving the minimum element. * * Properties: * 1. Complete Binary Tree * 2. Parent node's key  Children nodes' keys * 3. Root contains the minimum element * * Example usage: * ```java * List<HeapElement> elements = Arrays.asList( * new HeapElement(5, \"Five\"), * new HeapElement(2, \"Two\") * ); * MinHeap heap = new MinHeap(elements); * heap.insertElement(new HeapElement(1, \"One\")); * HeapElement min = heap.getElement(); // Returns and removes the minimum element * ``` * * @author Nicolas Renard */ public class MinHeap implements Heap { private final List<HeapElement> minHeap; /** * Constructs a new MinHeap from a list of elements. * Null elements in the input list are ignored with a warning message. * * @param listElements List of HeapElement objects to initialize the heap * @throws IllegalArgumentException if the input list is null */ public MinHeap(List<HeapElement> listElements) { if (listElements == null) { throw new IllegalArgumentException(\"Input list cannot be null\"); } minHeap = new ArrayList<>(); // Safe initialization: directly add elements first for (HeapElement heapElement : listElements) { if (heapElement != null) { minHeap.add(heapElement); } else { System.out.println(\"Null element. Not added to heap\"); } } // Heapify the array bottom-up for (int i = minHeap.size() / 2; i >= 0; i--) { heapifyDown(i + 1); } if (minHeap.isEmpty()) { System.out.println(\"No element has been added, empty heap.\"); } } /** * Retrieves the element at the specified index without removing it. * Note: The index is 1-based for consistency with heap operations. * * @param elementIndex 1-based index of the element to retrieve * @return HeapElement at the specified index * @throws IndexOutOfBoundsException if the index is invalid */ public HeapElement getElement(int elementIndex) { if ((elementIndex <= 0) || (elementIndex > minHeap.size())) { throw new IndexOutOfBoundsException(\"Index \" + elementIndex + \" is out of heap range [1, \" + minHeap.size() + \"]\"); } return minHeap.get(elementIndex - 1); } /** * Retrieves the key value of an element at the specified index. * * @param elementIndex 1-based index of the element * @return double value representing the key * @throws IndexOutOfBoundsException if the index is invalid */ private double getElementKey(int elementIndex) { if ((elementIndex <= 0) || (elementIndex > minHeap.size())) { throw new IndexOutOfBoundsException(\"Index \" + elementIndex + \" is out of heap range [1, \" + minHeap.size() + \"]\"); } return minHeap.get(elementIndex - 1).getKey(); } /** * Swaps two elements in the heap. * * @param index1 1-based index of first element * @param index2 1-based index of second element */ private void swap(int index1, int index2) { HeapElement temporaryElement = minHeap.get(index1 - 1); minHeap.set(index1 - 1, minHeap.get(index2 - 1)); minHeap.set(index2 - 1, temporaryElement); } /** * Maintains heap properties by moving an element down the heap. * Used specifically during initialization. * * @param elementIndex 1-based index of the element to heapify */ private void heapifyDown(int elementIndex) { int smallest = elementIndex - 1; // Convert to 0-based index int leftChild = 2 * elementIndex - 1; int rightChild = 2 * elementIndex; // Check if left child is smaller than root if (leftChild < minHeap.size() && minHeap.get(leftChild).getKey() < minHeap.get(smallest).getKey()) { smallest = leftChild; } // Check if right child is smaller than smallest so far if (rightChild < minHeap.size() && minHeap.get(rightChild).getKey() < minHeap.get(smallest).getKey()) { smallest = rightChild; } // If smallest is not root if (smallest != elementIndex - 1) { HeapElement swap = minHeap.get(elementIndex - 1); minHeap.set(elementIndex - 1, minHeap.get(smallest)); minHeap.set(smallest, swap); // Recursively heapify the affected sub-tree heapifyDown(smallest + 1); // Convert back to 1-based index } } /** * Moves an element up the heap until heap properties are satisfied. * This operation is called after insertion to maintain heap properties. * * @param elementIndex 1-based index of the element to move up */ private void toggleUp(int elementIndex) { if (elementIndex <= 1) { return; } double key = minHeap.get(elementIndex - 1).getKey(); int parentIndex = (int) Math.floor(elementIndex / 2.0); while (elementIndex > 1 && getElementKey(parentIndex) > key) { swap(elementIndex, parentIndex); elementIndex = parentIndex; parentIndex = (int) Math.floor(elementIndex / 2.0); } } /** * Moves an element down the heap until heap properties are satisfied. * This operation is called after deletion to maintain heap properties. * * @param elementIndex 1-based index of the element to move down */ private void toggleDown(int elementIndex) { double key = minHeap.get(elementIndex - 1).getKey(); int size = minHeap.size(); while (true) { int smallest = elementIndex; int leftChild = 2 * elementIndex; int rightChild = 2 * elementIndex + 1; if (leftChild <= size && getElementKey(leftChild) < key) { smallest = leftChild; } if (rightChild <= size && getElementKey(rightChild) < getElementKey(smallest)) { smallest = rightChild; } if (smallest == elementIndex) { break; } swap(elementIndex, smallest); elementIndex = smallest; } } /** * Extracts and returns the minimum element from the heap. * * @return HeapElement with the lowest key * @throws EmptyHeapException if the heap is empty */ private HeapElement extractMin() throws EmptyHeapException { if (minHeap.isEmpty()) { throw new EmptyHeapException(\"Cannot extract from empty heap\"); } HeapElement result = minHeap.getFirst(); deleteElement(1); return result; } /** * {@inheritDoc} */ @Override public void insertElement(HeapElement element) { if (element == null) { throw new IllegalArgumentException(\"Cannot insert null element\"); } minHeap.add(element); toggleUp(minHeap.size()); } /** * {@inheritDoc} */ @Override public void deleteElement(int elementIndex) throws EmptyHeapException { if (minHeap.isEmpty()) { throw new EmptyHeapException(\"Cannot delete from empty heap\"); } if ((elementIndex > minHeap.size()) || (elementIndex <= 0)) { throw new IndexOutOfBoundsException(\"Index \" + elementIndex + \" is out of heap range [1, \" + minHeap.size() + \"]\"); } // Replace with last element and remove last position minHeap.set(elementIndex - 1, minHeap.getLast()); minHeap.removeLast(); // No need to toggle if we just removed the last element if (!minHeap.isEmpty() && elementIndex <= minHeap.size()) { // Determine whether to toggle up or down if (elementIndex > 1 && getElementKey(elementIndex) < getElementKey((int) Math.floor(elementIndex / 2.0))) { toggleUp(elementIndex); } else { toggleDown(elementIndex); } } } /** * {@inheritDoc} */ @Override public HeapElement getElement() throws EmptyHeapException { return extractMin(); } /** * Returns the current size of the heap. * * @return number of elements in the heap */ public int size() { return minHeap.size(); } /** * Checks if the heap is empty. * * @return true if the heap contains no elements */ public boolean isEmpty() { return minHeap.isEmpty(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.heaps; public class MinPriorityQueue { private final int[] a; private final int b; private int c; public MinPriorityQueue(int n) { this.b = n; this.c = 0; this.a = new int[n + 1]; } public void insert(int n) { if (this.isFull()) { throw new IllegalStateException(\"MinPriorityQueue is full. Cannot insert new element.\"); } this.a[this.c + 1] = n; for (n = this.c + 1; n > 1; n /= 2) { if (this.a[n] >= this.a[n / 2]) continue; int n2 = this.a[n]; this.a[n] = this.a[n / 2]; this.a[n / 2] = n2; } ++this.c; } public int peek() { if (this.isEmpty()) { throw new IllegalStateException(\"MinPriorityQueue is empty. Cannot peek.\"); } return this.a[1]; } public boolean isEmpty() { return this.c == 0; } public boolean isFull() { return this.c == this.b; } public void print() { for (int i = 1; i <= this.c; ++i) { System.out.print(this.a[i] + \" \"); } System.out.println(); } public void heapSort() { for (int i = 1; i <= this.c; ++i) { this.delete(); } } public int delete() { if (this.isEmpty()) { throw new IllegalStateException(\"MinPriorityQueue is empty. Cannot delete.\"); } int n = this.a[1]; this.a[1] = this.a[this.c]; --this.c; MinPriorityQueue minPriorityQueue = this; int n2 = 1; while (2 * n2 <= minPriorityQueue.c) { int n3 = n2; if (2 * n2 <= minPriorityQueue.c && minPriorityQueue.a[2 * n2] < minPriorityQueue.a[n3]) { n3 = 2 * n2; } if (2 * n2 + 1 <= minPriorityQueue.c && minPriorityQueue.a[2 * n2 + 1] < minPriorityQueue.a[n3]) { n3 = 2 * n2 + 1; } if (n3 == n2) break; int n4 = minPriorityQueue.a[n2]; minPriorityQueue.a[n2] = minPriorityQueue.a[n3]; minPriorityQueue.a[n3] = n4; n2 = n3; } return n; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.heaps; /** * A MinPriorityQueue is a specialized data structure that maintains the * min-heap property, where the smallest element has the highest priority. * * <p>In a min-priority queue, every parent node is less than or equal * to its child nodes, which ensures that the smallest element can * always be efficiently retrieved.</p> * * <p>Functions:</p> * <ul> * <li><b>insert(int key)</b>: Inserts a new key into the queue.</li> * <li><b>delete()</b>: Removes and returns the highest priority value (the minimum).</li> * <li><b>peek()</b>: Returns the highest priority value without removing it.</li> * <li><b>isEmpty()</b>: Checks if the queue is empty.</li> * <li><b>isFull()</b>: Checks if the queue is full.</li> * <li><b>heapSort()</b>: Sorts the elements in ascending order.</li> * <li><b>print()</b>: Prints the current elements in the queue.</li> * </ul> */ public class MinPriorityQueue { private final int[] heap; private final int capacity; private int size; /** * Initializes a new MinPriorityQueue with a specified capacity. * * @param c the maximum number of elements the queue can hold */ public MinPriorityQueue(int c) { this.capacity = c; this.size = 0; this.heap = new int[c + 1]; } /** * Inserts a new key into the min-priority queue. * * @param key the value to be inserted */ public void insert(int key) { if (this.isFull()) { throw new IllegalStateException(\"MinPriorityQueue is full. Cannot insert new element.\"); } this.heap[this.size + 1] = key; int k = this.size + 1; while (k > 1) { if (this.heap[k] < this.heap[k / 2]) { int temp = this.heap[k]; this.heap[k] = this.heap[k / 2]; this.heap[k / 2] = temp; } k = k / 2; } this.size++; } /** * Retrieves the highest priority value (the minimum) without removing it. * * @return the minimum value in the queue * @throws IllegalStateException if the queue is empty */ public int peek() { if (isEmpty()) { throw new IllegalStateException(\"MinPriorityQueue is empty. Cannot peek.\"); } return this.heap[1]; } /** * Checks whether the queue is empty. * * @return true if the queue is empty, false otherwise */ public boolean isEmpty() { return size == 0; } /** * Checks whether the queue is full. * * @return true if the queue is full, false otherwise */ public boolean isFull() { return size == capacity; } /** * Prints the elements of the queue. */ public void print() { for (int i = 1; i <= this.size; i++) { System.out.print(this.heap[i] + \" \"); } System.out.println(); } /** * Sorts the elements in the queue using heap sort. */ public void heapSort() { for (int i = 1; i <= this.size; i++) { this.delete(); } } /** * Reorders the heap after a deletion to maintain the heap property. */ private void sink() { int k = 1; while (2 * k <= this.size) { int minIndex = k; // Assume current index is the minimum if (2 * k <= this.size && this.heap[2 * k] < this.heap[minIndex]) { minIndex = 2 * k; // Left child is smaller } if (2 * k + 1 <= this.size && this.heap[2 * k + 1] < this.heap[minIndex]) { minIndex = 2 * k + 1; // Right child is smaller } if (minIndex == k) { break; // No swap needed, heap property is satisfied } // Swap with the smallest child int temp = this.heap[k]; this.heap[k] = this.heap[minIndex]; this.heap[minIndex] = temp; k = minIndex; // Move down to the smallest child } } /** * Deletes and returns the highest priority value (the minimum) from the queue. * * @return the minimum value from the queue * @throws IllegalStateException if the queue is empty */ public int delete() { if (isEmpty()) { throw new IllegalStateException(\"MinPriorityQueue is empty. Cannot delete.\"); } int min = this.heap[1]; this.heap[1] = this.heap[this.size]; // Move last element to the root this.size--; this.sink(); return min; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.EmptyStackException; import java.util.Stack; public class MinStackUsingSingleStack { private final Stack a = new Stack(); public void push(int n) { if (this.a.isEmpty()) { this.a.push(new long[]{n, n}); return; } long l = Math.min((long)n, ((long[])this.a.peek())[1]); this.a.push(new long[]{n, l}); } public void pop() { if (!this.a.isEmpty()) { this.a.pop(); } } public int top() { if (!this.a.isEmpty()) { return (int)((long[])this.a.peek())[0]; } throw new EmptyStackException(); } public int getMin() { if (!this.a.isEmpty()) { return (int)((long[])this.a.peek())[1]; } throw new EmptyStackException(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.EmptyStackException; import java.util.Stack; /** * Min-Stack implementation using a single stack. * * This stack supports push, pop, and retrieving the minimum element * in constant time (O(1)) using a modified approach where the stack * stores both the element and the minimum value so far. * * @author Hardvan */ public class MinStackUsingSingleStack { private final Stack<long[]> stack = new Stack<>(); /** * Pushes a new value onto the stack. * Each entry stores both the value and the minimum value so far. * * @param value The value to be pushed onto the stack. */ public void push(int value) { if (stack.isEmpty()) { stack.push(new long[] {value, value}); } else { long minSoFar = Math.min(value, stack.peek()[1]); stack.push(new long[] {value, minSoFar}); } } /** * Removes the top element from the stack. */ public void pop() { if (!stack.isEmpty()) { stack.pop(); } } /** * Retrieves the top element from the stack. * * @return The top element of the stack. */ public int top() { if (!stack.isEmpty()) { return (int) stack.peek()[0]; } throw new EmptyStackException(); } /** * Retrieves the minimum element in the stack. * * @return The minimum element so far. */ public int getMin() { if (!stack.isEmpty()) { return (int) stack.peek()[1]; } throw new EmptyStackException(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Stack; public final class MinStackUsingTwoStacks { private final Stack a = new Stack(); private final Stack b = new Stack(); MinStackUsingTwoStacks() { } public final void push(int n) { this.a.push(n); if (this.b.isEmpty() || n <= (Integer)this.b.peek()) { this.b.push(n); } } public final void pop() { if (((Integer)this.a.pop()).equals(this.b.peek())) { this.b.pop(); } } public final int top() { return (Integer)this.a.peek(); } public final int getMin() { return (Integer)this.b.peek(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; /** * Min-Stack implementation that supports push, pop, and retrieving the minimum element in constant time. * * @author Hardvan */ public final class MinStackUsingTwoStacks { MinStackUsingTwoStacks() { } private final Stack<Integer> stack = new Stack<>(); private final Stack<Integer> minStack = new Stack<>(); /** * Pushes a new element onto the {@code stack}. * If the value is less than or equal to the current minimum, it is also pushed onto the {@code minStack}. * * @param value The value to be pushed. */ public void push(int value) { stack.push(value); if (minStack.isEmpty() || value <= minStack.peek()) { minStack.push(value); } } /** * Removes the top element from the stack. * If the element is the minimum element, it is also removed from the {@code minStack}. */ public void pop() { if (stack.pop().equals(minStack.peek())) { minStack.pop(); } } /** * Retrieves the top element of the stack. * * @return The top element. */ public int top() { return stack.peek(); } /** * Retrieves the minimum element in the stack. * * @return The minimum element. */ public int getMin() { return minStack.peek(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.slidingwindow; public final class MinSumKSizeSubarray { private MinSumKSizeSubarray() { } public static int minSumKSizeSubarray(int[] nArray, int n) { int n2; if (nArray.length < n) { return -1; } int n3 = 0; for (n2 = 0; n2 < n; ++n2) { n3 += nArray[n2]; } int n4 = n3; for (n2 = n; n2 < nArray.length; ++n2) { n4 = Math.min(n4, n3 += nArray[n2] - nArray[n2 - n]); } return n4; } }", "deobfuscated_code": "package com.thealgorithms.slidingwindow; /** * The Sliding Window algorithm is used to find the minimum sum of a subarray * of a fixed size k within a given array. * * <p> * Worst-case performance O(n) * Best-case performance O(n) * Average performance O(n) * Worst-case space complexity O(1) * * This class provides a static method to find the minimum sum of a subarray * with a specified length k. * * @author Rashi Dashore (https://github.com/rashi07dashore) */ public final class MinSumKSizeSubarray { // Prevent instantiation private MinSumKSizeSubarray() { } /** * This method finds the minimum sum of a subarray of a given size k. * * @param arr is the input array where the minimum sum needs to be found * @param k is the size of the subarray * @return the minimum sum of the subarray of size k */ public static int minSumKSizeSubarray(int[] arr, int k) { if (arr.length < k) { return -1; // Edge case: not enough elements } int minSum; int windowSum = 0; // Calculate the sum of the first window for (int i = 0; i < k; i++) { windowSum += arr[i]; } minSum = windowSum; // Slide the window across the array for (int i = k; i < arr.length; i++) { windowSum += arr[i] - arr[i - k]; minSum = Math.min(minSum, windowSum); } return minSum; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class MinValue { private MinValue() { } public static int min(int n, int n2) { if (n <= n2) { return n; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class MinValue { private MinValue() { } /** * Returns the smaller of two {@code int} values. That is, the result the * argument closer to the value of {@link Integer#MIN_VALUE}. If the * arguments have the same value, the result is that same value. * * @param a an argument. * @param b another argument. * @return the smaller of {@code a} and {@code b}. */ public static int min(int a, int b) { return a <= b ? a : b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Arrays; import java.util.Random; public class MiniMaxAlgorithm { private int[] a = MiniMaxAlgorithm.getRandomScores(3, 99); private int b = this.a(this.a.length); public static void main(String[] object) { object = new MiniMaxAlgorithm(); int n = ((MiniMaxAlgorithm)object).miniMax(0, true, 0, true); System.out.println(); System.out.println(Arrays.toString(((MiniMaxAlgorithm)object).getScores())); System.out.println(\"The best score for \" + \"Maximizer\" + \" is \" + n); } public int miniMax(int n, boolean bl, int n2, boolean bl2) { if (n == this.b) { return this.a[n2]; } int n3 = this.miniMax(n + 1, !bl, n2 << 1, bl2); n2 = this.miniMax(n + 1, !bl, (n2 << 1) + 1, bl2); n = bl ? Math.max(n3, n2) : Math.min(n3, n2); if (bl2) { System.out.printf(\"From %02d and %02d, %s chooses %02d%n\", n3, n2, bl ? \"Maximizer\" : \"Minimizer\", n); } return n; } public static int[] getRandomScores(int n, int n2) { int[] nArray = new int[(int)Math.pow(2.0, n)]; Random random = new Random(); for (int i = 0; i < nArray.length; ++i) { nArray[i] = random.nextInt(n2) + 1; } return nArray; } private int a(int n) { if (n == 1) { return 0; } return this.a(n / 2) + 1; } public void setScores(int[] nArray) { int cfr_ignored_0 = nArray.length; if (!false) { this.a = nArray; this.b = this.a(this.a.length); return; } System.out.println(\"The number of scores must be a power of 2.\"); } public int[] getScores() { return this.a; } public int getHeight() { return this.b; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Arrays; import java.util.Random; /** * MiniMax is an algorithm used int artificial intelligence and game theory for * minimizing the possible loss for the worst case scenario. * * See more (https://en.wikipedia.org/wiki/Minimax, * https://www.geeksforgeeks.org/minimax-algorithm-in-game-theory-set-1-introduction/). * * @author aitofi (https://github.com/aitorfi) */ public class MiniMaxAlgorithm { /** * Game tree represented as an int array containing scores. Each array * element is a leaf node. */ private int[] scores; private int height; /** * Initializes the scores with 8 random leaf nodes */ public MiniMaxAlgorithm() { scores = getRandomScores(3, 99); height = log2(scores.length); } public static void main(String[] args) { MiniMaxAlgorithm miniMaxAlgorith = new MiniMaxAlgorithm(); boolean isMaximizer = true; // Specifies the player that goes first. boolean verbose = true; // True to show each players choices. int bestScore; bestScore = miniMaxAlgorith.miniMax(0, isMaximizer, 0, verbose); if (verbose) { System.out.println(); } System.out.println(Arrays.toString(miniMaxAlgorith.getScores())); System.out.println(\"The best score for \" + (isMaximizer ? \"Maximizer\" : \"Minimizer\") + \" is \" + bestScore); } /** * Returns the optimal score assuming that both players play their best. * * @param depth Indicates how deep we are into the game tree. * @param isMaximizer True if it is maximizers turn; otherwise false. * @param index Index of the leaf node that is being evaluated. * @param verbose True to show each players choices. * @return The optimal score for the player that made the first move. */ public int miniMax(int depth, boolean isMaximizer, int index, boolean verbose) { int bestScore; int score1; int score2; if (depth == height) { // Leaf node reached. return scores[index]; } score1 = miniMax(depth + 1, !isMaximizer, index * 2, verbose); score2 = miniMax(depth + 1, !isMaximizer, (index * 2) + 1, verbose); if (isMaximizer) { // Maximizer player wants to get the maximum possible score. bestScore = Math.max(score1, score2); } else { // Minimizer player wants to get the minimum possible score. bestScore = Math.min(score1, score2); } // Leaf nodes can be sequentially inspected by // recurssively multiplying (0 * 2) and ((0 * 2) + 1): // (0 x 2) = 0; ((0 x 2) + 1) = 1 // (1 x 2) = 2; ((1 x 2) + 1) = 3 // (2 x 2) = 4; ((2 x 2) + 1) = 5 ... if (verbose) { System.out.printf(\"From %02d and %02d, %s chooses %02d%n\", score1, score2, (isMaximizer ? \"Maximizer\" : \"Minimizer\"), bestScore); } return bestScore; } /** * Returns an array of random numbers which lenght is a power of 2. * * @param size The power of 2 that will determine the lenght of the array. * @param maxScore The maximum possible score. * @return An array of random numbers. */ public static int[] getRandomScores(int size, int maxScore) { int[] randomScores = new int[(int) Math.pow(2, size)]; Random rand = new Random(); for (int i = 0; i < randomScores.length; i++) { randomScores[i] = rand.nextInt(maxScore) + 1; } return randomScores; } // A utility function to find Log n in base 2 private int log2(int n) { return (n == 1) ? 0 : log2(n / 2) + 1; } public void setScores(int[] scores) { if (scores.length % 1 == 0) { this.scores = scores; height = log2(this.scores.length); } else { System.out.println(\"The number of scores must be a power of 2.\"); } } public int[] getScores() { return scores; } public int getHeight() { return height; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; public class MinimizingLateness$Job { private String a; private int b = 0; private int c = 0; private int d; private int e; public MinimizingLateness$Job(String string, int n, int n2) { this.a = string; this.d = n; this.e = n2; } public static MinimizingLateness$Job of(String string, int n, int n2) { return new MinimizingLateness$Job(string, n, n2); } public String toString() { return String.format(\"%s, startTime: %d, endTime: %d, lateness: %d\", this.a, this.b, this.d + this.b, this.c); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; public class MinimizingLateness$Job { private String a; private int b = 0; private int c = 0; private int d; private int e; public MinimizingLateness$Job(String string, int n, int n2) { this.a = string; this.d = n; this.e = n2; } public static MinimizingLateness$Job of(String string, int n, int n2) { return new MinimizingLateness$Job(string, n, n2); } public String toString() { return String.format(\"%s, startTime: %d, endTime: %d, lateness: %d\", this.a, this.b, this.d + this.b, this.c); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; public final class MinimizingLateness { private MinimizingLateness() { } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.Arrays; public final class MinimizingLateness { private MinimizingLateness() { } public static class Job { String jobName; int startTime = 0; int lateness = 0; int processingTime; int deadline; public Job(String jobName, int processingTime, int deadline) { this.jobName = jobName; this.processingTime = processingTime; this.deadline = deadline; } public static Job of(String jobName, int processingTime, int deadline) { return new Job(jobName, processingTime, deadline); } @Override public String toString() { return String.format(\"%s, startTime: %d, endTime: %d, lateness: %d\", jobName, startTime, processingTime + startTime, lateness); } } static void calculateLateness(Job... jobs) { // sort the jobs based on their deadline Arrays.sort(jobs, (a, b) -> a.deadline - b.deadline); int startTime = 0; for (Job job : jobs) { job.startTime = startTime; startTime += job.processingTime; job.lateness = Math.max(0, startTime - job.deadline); // if the job finishes before deadline the lateness is 0 } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class MinimumPathSum { private MinimumPathSum() { } public static int minimumPathSum(int[][] nArray) { int n; int n2 = nArray.length; int n3 = nArray[0].length; if (n3 == 0) { return 0; } int[] nArray2 = new int[n3]; int[] nArray3 = nArray2; nArray2[0] = nArray[0][0]; for (n = 1; n < n3; ++n) { nArray3[n] = nArray3[n - 1] + nArray[0][n]; } for (n = 1; n < n2; ++n) { nArray3[0] = nArray3[0] + nArray[n][0]; for (int i = 1; i < n3; ++i) { nArray3[i] = Math.min(nArray3[i - 1], nArray3[i]) + nArray[n][i]; } } return nArray3[n3 - 1]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /* Given the following grid with length m and width n: \\---\\---\\---\\ (n) \\ 1 \\ 3 \\ 1 \\ \\---\\---\\---\\ \\ 1 \\ 5 \\ 1 \\ \\---\\---\\---\\ \\ 4 \\ 2 \\ 1 \\ \\---\\---\\---\\ (m) Find the path where its sum is the smallest. The Time Complexity of your algorithm should be smaller than or equal to O(mn). The Space Complexity of your algorithm should be smaller than or equal to O(n). You can only move from the top left corner to the down right corner. You can only move one step down or right. EXAMPLE: INPUT: grid = [[1,3,1],[1,5,1],[4,2,1]] OUTPUT: 7 EXPLANATIONS: 1 + 3 + 1 + 1 + 1 = 7 For more information see https://www.geeksforgeeks.org/maximum-path-sum-matrix/ */ public final class MinimumPathSum { private MinimumPathSum() { } public static int minimumPathSum(final int[][] grid) { int numRows = grid.length; int numCols = grid[0].length; if (numCols == 0) { return 0; } int[] dp = new int[numCols]; // Initialize the first element of the dp array dp[0] = grid[0][0]; // Calculate the minimum path sums for the first row for (int col = 1; col < numCols; col++) { dp[col] = dp[col - 1] + grid[0][col]; } // Calculate the minimum path sums for the remaining rows for (int row = 1; row < numRows; row++) { // Update the minimum path sum for the first column dp[0] += grid[row][0]; for (int col = 1; col < numCols; col++) { // Choose the minimum path sum from the left or above dp[col] = Math.min(dp[col - 1], dp[col]) + grid[row][col]; } } // Return the minimum path sum for the last cell in the grid return dp[numCols - 1]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import java.util.Arrays; public final class MinimumSumPartition { private MinimumSumPartition() { } public static int minimumSumPartition(int[] nArray) { int[] nArray2 = nArray; if (Arrays.stream(nArray).anyMatch(n -> n < 0)) { throw new IllegalArgumentException(\"Input array should not contain negative number(s).\"); } int n2 = Arrays.stream(nArray).sum(); boolean[] blArray = new boolean[n2 / 2 + 1]; boolean[] blArray2 = blArray; blArray[0] = true; int n3 = 0; for (int i = 0; i < nArray.length; ++i) { for (int j = n2 / 2; j > 0; --j) { if (nArray[i] <= j) { boolean bl = blArray2[j] = blArray2[j] || blArray2[j - nArray[i]]; } if (!blArray2[j]) continue; n3 = Math.max(n3, j); } } return n2 - 2 * n3; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.Arrays; /* Given an array of non-negative integers , partition the array in two subset that difference in sum of elements for both subset minimum. Return the minimum difference in sum of these subsets you can achieve. Input: array[] = {1, 6, 11, 4} Output: 0 Explanation: Subset1 = {1, 4, 6}, sum of Subset1 = 11 Subset2 = {11}, sum of Subset2 = 11 Input: array[] = {36, 7, 46, 40} Output: 23 Explanation: Subset1 = {7, 46} ; sum of Subset1 = 53 Subset2 = {36, 40} ; sum of Subset2 = 76 */ public final class MinimumSumPartition { private MinimumSumPartition() { } private static void throwIfInvalidInput(final int[] array) { if (Arrays.stream(array).anyMatch(a -> a < 0)) { throw new IllegalArgumentException(\"Input array should not contain negative number(s).\"); } } public static int minimumSumPartition(final int[] array) { throwIfInvalidInput(array); int sum = Arrays.stream(array).sum(); boolean[] dp = new boolean[sum / 2 + 1]; dp[0] = true; // Base case , don't select any element from array // Find the closest sum of subset array that we can achieve which is closest to half of sum of full array int closestPartitionSum = 0; for (int i = 0; i < array.length; i++) { for (int j = sum / 2; j > 0; j--) { if (array[i] <= j) { dp[j] = dp[j] || dp[j - array[i]]; } if (dp[j]) { closestPartitionSum = Math.max(closestPartitionSum, j); } } } /* Difference in sum = Big partition sum - Small partition sum = ( Total sum - Small partition sum) - Small partition sum */ return sum - (2 * closestPartitionSum); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.Arrays; public final class MinimumWaitingTime { private MinimumWaitingTime() { } public static int minimumWaitingTime(int[] nArray) { int n = nArray.length; if (n <= 1) { return 0; } Arrays.sort(nArray); int n2 = 0; for (int i = 0; i < n; ++i) { n2 += nArray[i] * (n - i - 1); } return n2; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.Arrays; /** * The MinimumWaitingTime class provides a method to calculate the minimum * waiting time for a list of queries using a greedy algorithm. * * @author Hardvan */ public final class MinimumWaitingTime { private MinimumWaitingTime() { } /** * Calculates the minimum waiting time for a list of queries. * The function sorts the queries in non-decreasing order and then calculates * the waiting time for each query based on its position in the sorted list. * * @param queries an array of integers representing the query times in picoseconds * @return the minimum waiting time in picoseconds */ public static int minimumWaitingTime(int[] queries) { int n = queries.length; if (n <= 1) { return 0; } Arrays.sort(queries); int totalWaitingTime = 0; for (int i = 0; i < n; i++) { totalWaitingTime += queries[i] * (n - i - 1); } return totalWaitingTime; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix; import com.thealgorithms.matrix.utils.MatrixUtil; public final class MirrorOfMatrix { private MirrorOfMatrix() { } public static double[][] mirrorMatrix(double[][] dArray) { MatrixUtil.validateInputMatrix(dArray); int n = dArray.length; int n2 = dArray[0].length; double[][] dArray2 = new double[n][n2]; for (int i = 0; i < n; ++i) { dArray2[i] = MatrixUtil.reverseRow(dArray[i]); } return dArray2; } }", "deobfuscated_code": "package com.thealgorithms.matrix; // Problem Statement import com.thealgorithms.matrix.utils.MatrixUtil; /* We have given an array of m x n (where m is the number of rows and n is the number of columns). Print the new matrix in such a way that the new matrix is the mirror image of the original matrix. The Original matrix is: | The Mirror matrix is: 1 2 3 | 3 2 1 4 5 6 | 6 5 4 7 8 9 | 9 8 7 @author - Aman (https://github.com/Aman28801) */ public final class MirrorOfMatrix { private MirrorOfMatrix() { } public static double[][] mirrorMatrix(final double[][] originalMatrix) { MatrixUtil.validateInputMatrix(originalMatrix); int numRows = originalMatrix.length; int numCols = originalMatrix[0].length; double[][] mirroredMatrix = new double[numRows][numCols]; for (int i = 0; i < numRows; i++) { mirroredMatrix[i] = MatrixUtil.reverseRow(originalMatrix[i]); } return mirroredMatrix; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths.Prime; import com.thealgorithms.maths.Prime.PrimeCheck; public final class MobiusFunction { private MobiusFunction() { } public static int mobius(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Number must be greater than zero.\"); } if (n == 1) { return 1; } int n2 = 0; for (int i = 1; i <= n; ++i) { if (n % i != 0 || !PrimeCheck.isPrime(i)) continue; int n3 = i; if (n % (n3 * n3) == 0) { return 0; } ++n2; } if (n2 % 2 == 0) { return 1; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.maths.Prime; /* * Java program for mobius function * For any positive integer n, define (n) as the sum of the primitive nth roots of unity. * It has values in {1, 0, 1} depending on the factorization of n into prime factors: * (n) = +1 if n is a square-free positive integer with an even number of prime factors. * (n) = 1 if n is a square-free positive integer with an odd number of prime factors. * (n) = 0 if n has a squared prime factor. * Wikipedia: https://en.wikipedia.org/wiki/M%C3%B6bius_function * * Author: Akshay Dubey (https://github.com/itsAkshayDubey) * * */ public final class MobiusFunction { private MobiusFunction() { } /** * This method returns (n) of given number n * * @param number Integer value which (n) is to be calculated * @return 1 when number is less than or equals 1 * or number has even number of prime factors * 0 when number has repeated prime factor * -1 when number has odd number of prime factors */ public static int mobius(int number) { if (number <= 0) { // throw exception when number is less than or is zero throw new IllegalArgumentException(\"Number must be greater than zero.\"); } if (number == 1) { // return 1 if number passed is less or is 1 return 1; } int primeFactorCount = 0; for (int i = 1; i <= number; i++) { // find prime factors of number if (number % i == 0 && PrimeCheck.isPrime(i)) { // check if number is divisible by square of prime factor if (number % (i * i) == 0) { // if number is divisible by square of prime factor return 0; } /*increment primeFactorCount by 1 if number is not divisible by square of found prime factor*/ primeFactorCount++; } } return (primeFactorCount % 2 == 0) ? 1 : -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.Map; public final class Mode { private Mode() { } public static int[] mode(int[] nArray) { if (nArray.length == 0) { return null; } HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>(); for (int n : nArray) { hashMap.put(n, hashMap.getOrDefault(n, 0) + 1); } int n = (Integer)Collections.max(hashMap.values()); ArrayList<Integer> arrayList = new ArrayList<Integer>(); for (Map.Entry entry : hashMap.entrySet()) { if ((Integer)entry.getValue() != n) continue; arrayList.add((Integer)entry.getKey()); } return arrayList.stream().mapToInt(Integer::intValue).toArray(); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; /** * Utility class to calculate the mode(s) of an array of integers. * <p> * The mode of an array is the integer value(s) that occur most frequently. * If multiple values have the same highest frequency, all such values are returned. * </p> */ public final class Mode { private Mode() { } /** * Computes the mode(s) of the specified array of integers. * <p> * If the input array is empty, this method returns {@code null}. * If multiple numbers share the highest frequency, all are returned in the result array. * </p> * * @param numbers an array of integers to analyze * @return an array containing the mode(s) of the input array, or {@code null} if the input is empty */ public static int[] mode(final int[] numbers) { if (numbers.length == 0) { return null; } Map<Integer, Integer> count = new HashMap<>(); for (int num : numbers) { count.put(num, count.getOrDefault(num, 0) + 1); } int max = Collections.max(count.values()); List<Integer> modes = new ArrayList<>(); for (final var entry : count.entrySet()) { if (entry.getValue() == max) { modes.add(entry.getKey()); } } return modes.stream().mapToInt(Integer::intValue).toArray(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class ModuloPowerOfTwo { private ModuloPowerOfTwo() { } public static int moduloPowerOfTwo(int n, int n2) { if (n2 <= 0) { throw new IllegalArgumentException(\"The exponent must be positive\"); } return n & (1 << n2) - 1; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class provides a method to compute the remainder * of a number when divided by a power of two (2^n) * without using division or modulo operations. * * @author Hardvan */ public final class ModuloPowerOfTwo { private ModuloPowerOfTwo() { } /** * Computes the remainder of a given integer when divided by 2^n. * * @param x the input number * @param n the exponent (power of two) * @return the remainder of x divided by 2^n */ public static int moduloPowerOfTwo(int x, int n) { if (n <= 0) { throw new IllegalArgumentException(\"The exponent must be positive\"); } return x & ((1 << n) - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; public final class MonoAlphabetic { private MonoAlphabetic() { throw new UnsupportedOperationException(\"Utility class\"); } public static String encrypt(String object, String string) { if (!((String)object).matches(\"[A-Z]+\")) { throw new IllegalArgumentException(\"Input data contains invalid characters. Only uppercase A-Z are allowed.\"); } StringBuilder stringBuilder = new StringBuilder(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { reference v1 = object[i]; reference var5_5 = v1; var5_5 = v1; var5_5 = v1 - 65; stringBuilder.append(string.charAt((int)var5_5)); } return stringBuilder.toString(); } public static String decrypt(String object, String string) { StringBuilder stringBuilder = new StringBuilder(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object2 = object[i]; int n2 = string.indexOf((int)object2); object2 = n2; if (n2 == -1) { throw new IllegalArgumentException(\"Input data contains invalid characters.\"); } stringBuilder.append((char)(object2 + 65)); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; public final class MonoAlphabetic { private MonoAlphabetic() { throw new UnsupportedOperationException(\"Utility class\"); } // Encryption method public static String encrypt(String data, String key) { if (!data.matches(\"[A-Z]+\")) { throw new IllegalArgumentException(\"Input data contains invalid characters. Only uppercase A-Z are allowed.\"); } StringBuilder sb = new StringBuilder(); // Encrypt each character for (char c : data.toCharArray()) { int idx = charToPos(c); // Get the index of the character sb.append(key.charAt(idx)); // Map to the corresponding character in the key } return sb.toString(); } // Decryption method public static String decrypt(String data, String key) { StringBuilder sb = new StringBuilder(); // Decrypt each character for (char c : data.toCharArray()) { int idx = key.indexOf(c); // Find the index of the character in the key if (idx == -1) { throw new IllegalArgumentException(\"Input data contains invalid characters.\"); } sb.append(posToChar(idx)); // Convert the index back to the original character } return sb.toString(); } // Helper method: Convert a character to its position in the alphabet private static int charToPos(char c) { return c - 'A'; // Subtract 'A' to get position (0 for A, 1 for B, etc.) } // Helper method: Convert a position in the alphabet to a character private static char posToChar(int pos) { return (char) (pos + 'A'); // Add 'A' to convert position back to character } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import java.util.Random; import java.util.function.Function; public final class MonteCarloIntegration { private MonteCarloIntegration() { } public static double approximate(Function function, double d, double d2, int n, long l) { return MonteCarloIntegration.a(function, d, d2, n, new Random(l)); } public static double approximate(Function function, double d, double d2, int n) { return MonteCarloIntegration.a(function, d, d2, n, new Random(System.currentTimeMillis())); } private static double a(Function function, double d, double d2, int n, Random random) { if (!MonteCarloIntegration.a(function, d, d2, n)) { throw new IllegalArgumentException(\"Invalid input parameters\"); } double d3 = 0.0; double d4 = d2 - d; for (int i = 0; i < n; ++i) { double d5 = d + random.nextDouble() * d4; d3 += ((Double)function.apply(d5)).doubleValue(); } return d4 * d3 / (double)n; } private static boolean a(Function function, double d, double d2, int n) { boolean bl; boolean bl2 = function != null; boolean bl3 = d < d2; boolean bl4 = bl = n > 0; return bl2 && bl3 && bl; } }", "deobfuscated_code": "package com.thealgorithms.randomized; import java.util.Random; import java.util.function.Function; /** * A demonstration of the Monte Carlo integration algorithm in Java. * * <p>This class estimates the value of definite integrals using randomized sampling, * also known as the Monte Carlo method. It is particularly effective for: * <ul> * <li>Functions that are difficult or impossible to integrate analytically</li> * <li>High-dimensional integrals where traditional methods are inefficient</li> * <li>Simulation and probabilistic analysis tasks</li> * </ul> * * <p>The core idea is to sample random points uniformly from the integration domain, * evaluate the function at those points, and compute the scaled average to estimate the integral. * * <p>For a one-dimensional integral over [a, b], the approximation is the function range (b-a), * multiplied by the function average result for a random sample. * See more: <a href=\"https://en.wikipedia.org/wiki/Monte_Carlo_integration\">Monte Carlo Integration</a> * * @author: MuhammadEzzatHBK */ public final class MonteCarloIntegration { private MonteCarloIntegration() { } /** * Approximates the definite integral of a given function over a specified * interval using the Monte Carlo method with a fixed random seed for * reproducibility. * * @param fx the function to integrate * @param a the lower bound of the interval * @param b the upper bound of the interval * @param n the number of random samples to use * @param seed the seed for the random number generator * @return the approximate value of the integral */ public static double approximate(Function<Double, Double> fx, double a, double b, int n, long seed) { return doApproximate(fx, a, b, n, new Random(seed)); } /** * Approximates the definite integral of a given function over a specified * interval using the Monte Carlo method with a random seed based on the * current system time for more randomness. * * @param fx the function to integrate * @param a the lower bound of the interval * @param b the upper bound of the interval * @param n the number of random samples to use * @return the approximate value of the integral */ public static double approximate(Function<Double, Double> fx, double a, double b, int n) { return doApproximate(fx, a, b, n, new Random(System.currentTimeMillis())); } private static double doApproximate(Function<Double, Double> fx, double a, double b, int n, Random generator) { if (!validate(fx, a, b, n)) { throw new IllegalArgumentException(\"Invalid input parameters\"); } double totalArea = 0.0; double interval = b - a; for (int i = 0; i < n; i++) { double x = a + generator.nextDouble() * interval; totalArea += fx.apply(x); } return interval * totalArea / n; } private static boolean validate(Function<Double, Double> fx, double a, double b, int n) { boolean isFunctionValid = fx != null; boolean isIntervalValid = a < b; boolean isSampleSizeValid = n > 0; return isFunctionValid && isIntervalValid && isSampleSizeValid; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.searches.MonteCarloTreeSearch; import java.util.ArrayList; public class MonteCarloTreeSearch$Node { MonteCarloTreeSearch$Node a; ArrayList b; boolean c; boolean d; int e; int f; public MonteCarloTreeSearch$Node(MonteCarloTreeSearch monteCarloTreeSearch) { } public MonteCarloTreeSearch$Node(MonteCarloTreeSearch monteCarloTreeSearch, MonteCarloTreeSearch$Node monteCarloTreeSearch$Node, boolean bl) { this.a = monteCarloTreeSearch$Node; this.b = new ArrayList(); this.c = bl; this.d = false; this.e = 0; this.f = 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.searches.MonteCarloTreeSearch; import java.util.ArrayList; public class MonteCarloTreeSearch$Node { MonteCarloTreeSearch$Node a; ArrayList b; boolean c; boolean d; int e; int f; public MonteCarloTreeSearch$Node(MonteCarloTreeSearch monteCarloTreeSearch) { } public MonteCarloTreeSearch$Node(MonteCarloTreeSearch monteCarloTreeSearch, MonteCarloTreeSearch$Node monteCarloTreeSearch$Node, boolean bl) { this.a = monteCarloTreeSearch$Node; this.b = new ArrayList(); this.c = bl; this.d = false; this.e = 0; this.f = 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.searches.MonteCarloTreeSearch$Node; import java.util.Collections; import java.util.Comparator; import java.util.Random; public class MonteCarloTreeSearch { public MonteCarloTreeSearch$Node monteCarloTreeSearch(MonteCarloTreeSearch$Node monteCarloTreeSearch$Node) { MonteCarloTreeSearch$Node monteCarloTreeSearch$Node2; this.addChildNodes(monteCarloTreeSearch$Node, 10); double d = System.currentTimeMillis() + 500L; while ((double)System.currentTimeMillis() < d) { monteCarloTreeSearch$Node2 = this.getPromisingNode(monteCarloTreeSearch$Node); if (monteCarloTreeSearch$Node2.b.size() == 0) { this.addChildNodes(monteCarloTreeSearch$Node2, 10); } this.simulateRandomPlay(monteCarloTreeSearch$Node2); } monteCarloTreeSearch$Node2 = this.getWinnerNode(monteCarloTreeSearch$Node); this.printScores(monteCarloTreeSearch$Node); System.out.format(\"%nThe optimal node is: %02d%n\", monteCarloTreeSearch$Node.b.indexOf(monteCarloTreeSearch$Node2) + 1); return monteCarloTreeSearch$Node2; } public void addChildNodes(MonteCarloTreeSearch$Node monteCarloTreeSearch$Node, int n) { for (int i = 0; i < n; ++i) { MonteCarloTreeSearch$Node monteCarloTreeSearch$Node2 = monteCarloTreeSearch$Node; monteCarloTreeSearch$Node.b.add(new MonteCarloTreeSearch$Node(this, monteCarloTreeSearch$Node2, !monteCarloTreeSearch$Node2.c)); } } public MonteCarloTreeSearch$Node getPromisingNode(MonteCarloTreeSearch$Node monteCarloTreeSearch$Node) { while (monteCarloTreeSearch$Node.b.size() != 0) { double d = Double.MIN_VALUE; int n = 0; for (int i = 0; i < monteCarloTreeSearch$Node.b.size(); ++i) { double d2; MonteCarloTreeSearch$Node monteCarloTreeSearch$Node2 = (MonteCarloTreeSearch$Node)monteCarloTreeSearch$Node.b.get(i); if (monteCarloTreeSearch$Node2.f == 0) { n = i; break; } double d3 = (double)monteCarloTreeSearch$Node2.e / (double)monteCarloTreeSearch$Node2.f + 1.41 * Math.sqrt(Math.log(monteCarloTreeSearch$Node.f) / (double)monteCarloTreeSearch$Node2.f); if (!(d2 > d)) continue; d = d3; n = i; } monteCarloTreeSearch$Node = (MonteCarloTreeSearch$Node)monteCarloTreeSearch$Node.b.get(n); } return monteCarloTreeSearch$Node; } public void simulateRandomPlay(MonteCarloTreeSearch$Node monteCarloTreeSearch$Node) { Random random = new Random(); MonteCarloTreeSearch$Node monteCarloTreeSearch$Node2 = monteCarloTreeSearch$Node; boolean bl = monteCarloTreeSearch$Node.d = random.nextInt(6) == 0; while (monteCarloTreeSearch$Node2 != null) { ++monteCarloTreeSearch$Node2.f; if (monteCarloTreeSearch$Node2.c && bl || !monteCarloTreeSearch$Node2.c && !bl) { monteCarloTreeSearch$Node2.e += 10; } monteCarloTreeSearch$Node2 = monteCarloTreeSearch$Node2.a; } } public MonteCarloTreeSearch$Node getWinnerNode(MonteCarloTreeSearch$Node monteCarloTreeSearch$Node2) { return Collections.max(monteCarloTreeSearch$Node2.b, Comparator.comparing(monteCarloTreeSearch$Node -> monteCarloTreeSearch$Node.e)); } public void printScores(MonteCarloTreeSearch$Node monteCarloTreeSearch$Node) { System.out.println(\"N.\\tScore\\t\\tVisits\"); for (int i = 0; i < monteCarloTreeSearch$Node.b.size(); ++i) { System.out.printf(\"%02d\\t%d\\t\\t%d%n\", i + 1, ((MonteCarloTreeSearch$Node)monteCarloTreeSearch$Node.b.get((int)i)).e, ((MonteCarloTreeSearch$Node)monteCarloTreeSearch$Node.b.get((int)i)).f); } } }", "deobfuscated_code": "package com.thealgorithms.searches; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.Random; /** * Monte Carlo Tree Search (MCTS) is a heuristic search algorithm used in * decition taking problems especially games. * * See more: https://en.wikipedia.org/wiki/Monte_Carlo_tree_search, * https://www.baeldung.com/java-monte-carlo-tree-search */ public class MonteCarloTreeSearch { public class Node { Node parent; ArrayList<Node> childNodes; boolean isPlayersTurn; // True if it is the player's turn. boolean playerWon; // True if the player won; false if the opponent won. int score; int visitCount; public Node() { } public Node(Node parent, boolean isPlayersTurn) { this.parent = parent; childNodes = new ArrayList<>(); this.isPlayersTurn = isPlayersTurn; playerWon = false; score = 0; visitCount = 0; } } static final int WIN_SCORE = 10; static final int TIME_LIMIT = 500; // Time the algorithm will be running for (in milliseconds). /** * Explores a game tree using Monte Carlo Tree Search (MCTS) and returns the * most promising node. * * @param rootNode Root node of the game tree. * @return The most promising child of the root node. */ public Node monteCarloTreeSearch(Node rootNode) { Node winnerNode; double timeLimit; // Expand the root node. addChildNodes(rootNode, 10); timeLimit = System.currentTimeMillis() + TIME_LIMIT; // Explore the tree until the time limit is reached. while (System.currentTimeMillis() < timeLimit) { Node promisingNode; // Get a promising node using UCT. promisingNode = getPromisingNode(rootNode); // Expand the promising node. if (promisingNode.childNodes.size() == 0) { addChildNodes(promisingNode, 10); } simulateRandomPlay(promisingNode); } winnerNode = getWinnerNode(rootNode); printScores(rootNode); System.out.format(\"%nThe optimal node is: %02d%n\", rootNode.childNodes.indexOf(winnerNode) + 1); return winnerNode; } public void addChildNodes(Node node, int childCount) { for (int i = 0; i < childCount; i++) { node.childNodes.add(new Node(node, !node.isPlayersTurn)); } } /** * Uses UCT to find a promising child node to be explored. * * UCT: Upper Confidence bounds applied to Trees. * * @param rootNode Root node of the tree. * @return The most promising node according to UCT. */ public Node getPromisingNode(Node rootNode) { Node promisingNode = rootNode; // Iterate until a node that hasn't been expanded is found. while (promisingNode.childNodes.size() != 0) { double uctIndex = Double.MIN_VALUE; int nodeIndex = 0; // Iterate through child nodes and pick the most promising one // using UCT (Upper Confidence bounds applied to Trees). for (int i = 0; i < promisingNode.childNodes.size(); i++) { Node childNode = promisingNode.childNodes.get(i); double uctTemp; // If child node has never been visited // it will have the highest uct value. if (childNode.visitCount == 0) { nodeIndex = i; break; } uctTemp = ((double) childNode.score / childNode.visitCount) + 1.41 * Math.sqrt(Math.log(promisingNode.visitCount) / (double) childNode.visitCount); if (uctTemp > uctIndex) { uctIndex = uctTemp; nodeIndex = i; } } promisingNode = promisingNode.childNodes.get(nodeIndex); } return promisingNode; } /** * Simulates a random play from a nodes current state and back propagates * the result. * * @param promisingNode Node that will be simulated. */ public void simulateRandomPlay(Node promisingNode) { Random rand = new Random(); Node tempNode = promisingNode; boolean isPlayerWinner; // The following line randomly determines whether the simulated play is a win or loss. // To use the MCTS algorithm correctly this should be a simulation of the nodes' current // state of the game until it finishes (if possible) and use an evaluation function to // determine how good or bad the play was. // e.g. Play tic tac toe choosing random squares until the game ends. promisingNode.playerWon = (rand.nextInt(6) == 0); isPlayerWinner = promisingNode.playerWon; // Back propagation of the random play. while (tempNode != null) { tempNode.visitCount++; // Add wining scores to bouth player and opponent depending on the turn. if ((tempNode.isPlayersTurn && isPlayerWinner) || (!tempNode.isPlayersTurn && !isPlayerWinner)) { tempNode.score += WIN_SCORE; } tempNode = tempNode.parent; } } public Node getWinnerNode(Node rootNode) { return Collections.max(rootNode.childNodes, Comparator.comparing(c -> c.score)); } public void printScores(Node rootNode) { System.out.println(\"N.\\tScore\\t\\tVisits\"); for (int i = 0; i < rootNode.childNodes.size(); i++) { System.out.printf(\"%02d\\t%d\\t\\t%d%n\", i + 1, rootNode.childNodes.get(i).score, rootNode.childNodes.get(i).visitCount); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.util.HashMap; import java.util.Map; public final class MorseCodeConverter { private static final Map a = new HashMap(); private static final Map b = new HashMap(); private MorseCodeConverter() { } public static String textToMorse(String stringArray) { StringBuilder stringBuilder = new StringBuilder(); stringArray = stringArray.toUpperCase().split(\" \"); for (int i = 0; i < stringArray.length; ++i) { for (char c : stringArray[i].toCharArray()) { stringBuilder.append(a.getOrDefault(Character.valueOf(c), \"\")).append(\" \"); } if (i >= stringArray.length - 1) continue; stringBuilder.append(\"| \"); } return stringBuilder.toString().trim(); } public static String morseToText(String stringArray) { StringBuilder stringBuilder = new StringBuilder(); stringArray = stringArray.split(\" \\\\| \"); for (int i = 0; i < stringArray.length; ++i) { for (String string : stringArray[i].split(\" \")) { stringBuilder.append(b.getOrDefault(string, Character.valueOf('?'))); } if (i >= stringArray.length - 1) continue; stringBuilder.append(\" \"); } return stringBuilder.toString(); } static { a.put(Character.valueOf('A'), \".-\"); a.put(Character.valueOf('B'), \"-...\"); a.put(Character.valueOf('C'), \"-.-.\"); a.put(Character.valueOf('D'), \"-..\"); a.put(Character.valueOf('E'), \".\"); a.put(Character.valueOf('F'), \"..-.\"); a.put(Character.valueOf('G'), \"--.\"); a.put(Character.valueOf('H'), \"....\"); a.put(Character.valueOf('I'), \"..\"); a.put(Character.valueOf('J'), \".---\"); a.put(Character.valueOf('K'), \"-.-\"); a.put(Character.valueOf('L'), \".-..\"); a.put(Character.valueOf('M'), \"--\"); a.put(Character.valueOf('N'), \"-.\"); a.put(Character.valueOf('O'), \"---\"); a.put(Character.valueOf('P'), \".--.\"); a.put(Character.valueOf('Q'), \"--.-\"); a.put(Character.valueOf('R'), \".-.\"); a.put(Character.valueOf('S'), \"...\"); a.put(Character.valueOf('T'), \"-\"); a.put(Character.valueOf('U'), \"..-\"); a.put(Character.valueOf('V'), \"...-\"); a.put(Character.valueOf('W'), \".--\"); a.put(Character.valueOf('X'), \"-..-\"); a.put(Character.valueOf('Y'), \"-.--\"); a.put(Character.valueOf('Z'), \"--..\"); a.forEach((c, string) -> b.put(string, c)); } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.util.HashMap; import java.util.Map; /** * Converts text to Morse code and vice-versa. * Text to Morse code: Each letter is separated by a space and each word is separated by a pipe (|). * Example: \"HELLO WORLD\" -> \".... . .-.. .-.. --- | .-- --- .-. .-.. -..\" * * Morse code to text: Each letter is separated by a space and each word is separated by a pipe (|). * Example: \".... . .-.. .-.. --- | .-- --- .-. .-.. -..\" -> \"HELLO WORLD\" * * Applications: Used in radio communications and algorithmic challenges. * * @author Hardvan */ public final class MorseCodeConverter { private MorseCodeConverter() { } private static final Map<Character, String> MORSE_MAP = new HashMap<>(); private static final Map<String, Character> REVERSE_MAP = new HashMap<>(); static { MORSE_MAP.put('A', \".-\"); MORSE_MAP.put('B', \"-...\"); MORSE_MAP.put('C', \"-.-.\"); MORSE_MAP.put('D', \"-..\"); MORSE_MAP.put('E', \".\"); MORSE_MAP.put('F', \"..-.\"); MORSE_MAP.put('G', \"--.\"); MORSE_MAP.put('H', \"....\"); MORSE_MAP.put('I', \"..\"); MORSE_MAP.put('J', \".---\"); MORSE_MAP.put('K', \"-.-\"); MORSE_MAP.put('L', \".-..\"); MORSE_MAP.put('M', \"--\"); MORSE_MAP.put('N', \"-.\"); MORSE_MAP.put('O', \"---\"); MORSE_MAP.put('P', \".--.\"); MORSE_MAP.put('Q', \"--.-\"); MORSE_MAP.put('R', \".-.\"); MORSE_MAP.put('S', \"...\"); MORSE_MAP.put('T', \"-\"); MORSE_MAP.put('U', \"..-\"); MORSE_MAP.put('V', \"...-\"); MORSE_MAP.put('W', \".--\"); MORSE_MAP.put('X', \"-..-\"); MORSE_MAP.put('Y', \"-.--\"); MORSE_MAP.put('Z', \"--..\"); // Build reverse map for decoding MORSE_MAP.forEach((k, v) -> REVERSE_MAP.put(v, k)); } /** * Converts text to Morse code. * Each letter is separated by a space and each word is separated by a pipe (|). * * @param text The text to convert to Morse code. * @return The Morse code representation of the text. */ public static String textToMorse(String text) { StringBuilder morse = new StringBuilder(); String[] words = text.toUpperCase().split(\" \"); for (int i = 0; i < words.length; i++) { for (char c : words[i].toCharArray()) { morse.append(MORSE_MAP.getOrDefault(c, \"\")).append(\" \"); } if (i < words.length - 1) { morse.append(\"| \"); } } return morse.toString().trim(); } /** * Converts Morse code to text. * Each letter is separated by a space and each word is separated by a pipe (|). * * @param morse The Morse code to convert to text. * @return The text representation of the Morse code. */ public static String morseToText(String morse) { StringBuilder text = new StringBuilder(); String[] words = morse.split(\" \\\\| \"); for (int i = 0; i < words.length; i++) { for (String code : words[i].split(\" \")) { text.append(REVERSE_MAP.getOrDefault(code, '?')); } if (i < words.length - 1) { text.append(\" \"); } } return text.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; class Movie { private int a; private String b; private double c; private int d; private String e; Movie(int n, String string, double d, int n2, String string2) { this.a = n; this.b = string; this.c = d; this.d = n2; this.e = string2; } public String[] getWords() { return (this.b + \" \" + this.e).toLowerCase().split(\"\\\\W+\"); } public String toString() { return \"Movie{docId=\" + this.a + \", name='\" + this.b + \"', imdbRating=\" + this.c + \", releaseYear=\" + this.d + \"}\"; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; class Movie { private int a; private String b; private double c; private int d; private String e; Movie(int n, String string, double d, int n2, String string2) { this.a = n; this.b = string; this.c = d; this.d = n2; this.e = string2; } public String[] getWords() { return (this.b + \" \" + this.e).toLowerCase().split(\"\\\\W+\"); } public String toString() { return \"Movie{docId=\" + this.a + \", name='\" + this.b + \"', imdbRating=\" + this.c + \", releaseYear=\" + this.d + \"}\"; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.List; class MultiAgentScheduling$Agent { String a; List b; MultiAgentScheduling$Agent(String string) { this.a = string; this.b = new ArrayList(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.List; class MultiAgentScheduling$Agent { String a; List b; MultiAgentScheduling$Agent(String string) { this.a = string; this.b = new ArrayList(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.MultiAgentScheduling$Agent; import java.util.HashMap; import java.util.List; import java.util.Map; public class MultiAgentScheduling { private final Map a = new HashMap(); public void addAgent(String string) { this.a.putIfAbsent(string, new MultiAgentScheduling$Agent(string)); } public void assignTask(String object, String string) { if ((object = (MultiAgentScheduling$Agent)this.a.get(object)) != null) { ((MultiAgentScheduling$Agent)object).b.add(string); } } public Map getScheduledTasks() { HashMap<String, List> hashMap = new HashMap<String, List>(); for (MultiAgentScheduling$Agent multiAgentScheduling$Agent : this.a.values()) { hashMap.put(multiAgentScheduling$Agent.a, multiAgentScheduling$Agent.b); } return hashMap; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * MultiAgentScheduling assigns tasks to different autonomous agents * who independently decide the execution order of their assigned tasks. * The focus is on collaboration between agents to optimize the overall schedule. * * Use Case: Distributed scheduling in decentralized systems like IoT networks. * * @author Hardvan */ public class MultiAgentScheduling { static class Agent { String name; List<String> tasks; Agent(String name) { this.name = name; this.tasks = new ArrayList<>(); } void addTask(String task) { tasks.add(task); } List<String> getTasks() { return tasks; } } private final Map<String, Agent> agents; public MultiAgentScheduling() { agents = new HashMap<>(); } public void addAgent(String agentName) { agents.putIfAbsent(agentName, new Agent(agentName)); } /** * Assign a task to a specific agent. * * @param agentName the name of the agent * @param task the task to be assigned */ public void assignTask(String agentName, String task) { Agent agent = agents.get(agentName); if (agent != null) { agent.addTask(task); } } /** * Get the scheduled tasks for each agent. * * @return a map of agent names to their scheduled tasks */ public Map<String, List<String>> getScheduledTasks() { Map<String, List<String>> schedule = new HashMap<>(); for (Agent agent : agents.values()) { schedule.put(agent.name, agent.getTasks()); } return schedule; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class MyAtoi { private MyAtoi() { } public static int myAtoi(String string) { int n; if (string == null || string.isEmpty()) { return 0; } int n2 = (string = string.trim()).length(); if (n2 == 0) { return 0; } int n3 = 0; boolean bl = false; if (string.charAt(0) == '-' || string.charAt(0) == '+') { bl = string.charAt(0) == '-'; ++n3; } int n4 = 0; while (n3 < n2 && Character.isDigit((char)(n = string.charAt(n3)))) { if (n4 > (Integer.MAX_VALUE - (n -= 48)) / 10) { if (bl) { return Integer.MIN_VALUE; } return Integer.MAX_VALUE; } n4 = n4 * 10 + n; ++n3; } if (bl) { return -n4; } return n4; } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * A utility class that provides a method to convert a string to a 32-bit signed integer (similar to C/C++'s atoi function). */ public final class MyAtoi { private MyAtoi() { } /** * Converts the given string to a 32-bit signed integer. * The conversion discards any leading whitespace characters until the first non-whitespace character is found. * Then, it takes an optional initial plus or minus sign followed by as many numerical digits as possible and interprets them as a numerical value. * The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. * * If the number is out of the range of a 32-bit signed integer: * - Returns {@code Integer.MAX_VALUE} if the value exceeds {@code Integer.MAX_VALUE}. * - Returns {@code Integer.MIN_VALUE} if the value is less than {@code Integer.MIN_VALUE}. * * If no valid conversion could be performed, a zero is returned. * * @param s the string to convert * @return the converted integer, or 0 if the string cannot be converted to a valid integer */ public static int myAtoi(String s) { if (s == null || s.isEmpty()) { return 0; } s = s.trim(); int length = s.length(); if (length == 0) { return 0; } int index = 0; boolean negative = false; // Check for the sign if (s.charAt(index) == '-' || s.charAt(index) == '+') { negative = s.charAt(index) == '-'; index++; } int number = 0; while (index < length) { char ch = s.charAt(index); if (!Character.isDigit(ch)) { break; } int digit = ch - '0'; // Check for overflow if (number > (Integer.MAX_VALUE - digit) / 10) { return negative ? Integer.MIN_VALUE : Integer.MAX_VALUE; } number = number * 10 + digit; index++; } return negative ? -number : number; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.HuffmanNode; import java.util.Comparator; class MyComparator implements Comparator { MyComparator() { } public int compare(HuffmanNode huffmanNode, HuffmanNode huffmanNode2) { return huffmanNode.a - huffmanNode2.a; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.HuffmanNode; import java.util.Comparator; class MyComparator implements Comparator { MyComparator() { } public int compare(HuffmanNode huffmanNode, HuffmanNode huffmanNode2) { return huffmanNode.a - huffmanNode2.a; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.List; public final class NQueens { private NQueens() { } public static List getNQueensArrangements(int n) { ArrayList arrayList = new ArrayList(); NQueens.a(n, arrayList, new int[n], 0); return arrayList; } public static void placeQueens(int n) { List list2 = new ArrayList(); NQueens.a(n, list2, new int[n], 0); if (list2.isEmpty()) { int n2 = n; System.out.println(\"There is no way to place \" + n2 + \" queens on board of size \" + n2 + \"x\" + n); } else { System.out.println(\"Arrangement for placing \" + n + \" queens\"); } for (List list2 : list2) { list2.forEach(System.out::println); System.out.println(); } } private static void a(int n, List list, int[] nArray, int n2) { if (n2 == n) { ArrayList<String> arrayList = new ArrayList<String>(); for (n2 = 0; n2 < n; ++n2) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < n; ++i) { stringBuilder.append(i == nArray[n2] ? \"Q\" : \".\"); } arrayList.add(stringBuilder.toString()); } list.add(arrayList); return; } for (int i = 0; i < n; ++i) { nArray[n2] = i; if (!NQueens.a(nArray, i, n2)) continue; NQueens.a(n, list, nArray, n2 + 1); } } private static boolean a(int[] nArray, int n, int n2) { for (int i = 0; i < n2; ++i) { int n3 = Math.abs(nArray[i] - n); if (n3 != 0 && n2 - i != n3) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.List; /** * Problem statement: Given a N x N chess board. Return all arrangements in * which N queens can be placed on the board such no two queens attack each * other. Ex. N = 6 Solution= There are 4 possible ways Arrangement: 1 \".Q....\", * \"...Q..\", \".....Q\", \"Q.....\", \"..Q...\", \"....Q.\" * * Arrangement: 2 \"..Q...\", \".....Q\", \".Q....\", \"....Q.\", \"Q.....\", \"...Q..\" * * Arrangement: 3 \"...Q..\", \"Q.....\", \"....Q.\", \".Q....\", \".....Q\", \"..Q...\" * * Arrangement: 4 \"....Q.\", \"..Q...\", \"Q.....\", \".....Q\", \"...Q..\", \".Q....\" * * Solution: Brute Force approach: * * Generate all possible arrangement to place N queens on N*N board. Check each * board if queens are placed safely. If it is safe, include arrangement in * solution set. Otherwise, ignore it * * Optimized solution: This can be solved using backtracking in below steps * * Start with first column and place queen on first row Try placing queen in a * row on second column If placing second queen in second column attacks any of * the previous queens, change the row in second column otherwise move to next * column and try to place next queen In case if there is no rows where a queen * can be placed such that it doesn't attack previous queens, then go back to * previous column and change row of previous queen. Keep doing this until last * queen is not placed safely. If there is no such way then return an empty list * as solution */ public final class NQueens { private NQueens() { } public static List<List<String>> getNQueensArrangements(int queens) { List<List<String>> arrangements = new ArrayList<>(); getSolution(queens, arrangements, new int[queens], 0); return arrangements; } public static void placeQueens(final int queens) { List<List<String>> arrangements = new ArrayList<List<String>>(); getSolution(queens, arrangements, new int[queens], 0); if (arrangements.isEmpty()) { System.out.println(\"There is no way to place \" + queens + \" queens on board of size \" + queens + \"x\" + queens); } else { System.out.println(\"Arrangement for placing \" + queens + \" queens\"); } for (List<String> arrangement : arrangements) { arrangement.forEach(System.out::println); System.out.println(); } } /** * This is backtracking function which tries to place queen recursively * * @param boardSize: size of chess board * @param solutions: this holds all possible arrangements * @param columns: columns[i] = rowId where queen is placed in ith column. * @param columnIndex: This is the column in which queen is being placed */ private static void getSolution(int boardSize, List<List<String>> solutions, int[] columns, int columnIndex) { if (columnIndex == boardSize) { // this means that all queens have been placed List<String> sol = new ArrayList<String>(); for (int i = 0; i < boardSize; i++) { StringBuilder sb = new StringBuilder(); for (int j = 0; j < boardSize; j++) { sb.append(j == columns[i] ? \"Q\" : \".\"); } sol.add(sb.toString()); } solutions.add(sol); return; } // This loop tries to place queen in a row one by one for (int rowIndex = 0; rowIndex < boardSize; rowIndex++) { columns[columnIndex] = rowIndex; if (isPlacedCorrectly(columns, rowIndex, columnIndex)) { // If queen is placed successfully at rowIndex in column=columnIndex then try // placing queen in next column getSolution(boardSize, solutions, columns, columnIndex + 1); } } } /** * This function checks if queen can be placed at row = rowIndex in column = * columnIndex safely * * @param columns: columns[i] = rowId where queen is placed in ith column. * @param rowIndex: row in which queen has to be placed * @param columnIndex: column in which queen is being placed * @return true: if queen can be placed safely false: otherwise */ private static boolean isPlacedCorrectly(int[] columns, int rowIndex, int columnIndex) { for (int i = 0; i < columnIndex; i++) { int diff = Math.abs(columns[i] - rowIndex); if (diff == 0 || columnIndex - i == diff) { return false; } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class NRKTree { public NRKTree left = null; public NRKTree right = null; public int data; private NRKTree(int n) { this.data = n; } NRKTree(NRKTree nRKTree, NRKTree nRKTree2, int n) { this.data = n; } public NRKTree insertKey(NRKTree nRKTree, int n) { if (nRKTree == null) { return new NRKTree(n); } if (n < nRKTree.data) { nRKTree.left = this.insertKey(nRKTree.left, n); } else if (n > nRKTree.data) { nRKTree.right = this.insertKey(nRKTree.right, n); } return nRKTree; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class NRKTree { public NRKTree left = null; public NRKTree right = null; public int data; private NRKTree(int n) { this.data = n; } NRKTree(NRKTree nRKTree, NRKTree nRKTree2, int n) { this.data = n; } public NRKTree insertKey(NRKTree nRKTree, int n) { if (nRKTree == null) { return new NRKTree(n); } if (n < nRKTree.data) { nRKTree.left = this.insertKey(nRKTree.left, n); } else if (n > nRKTree.data) { nRKTree.right = this.insertKey(nRKTree.right, n); } return nRKTree; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class NewManShanksPrime { private NewManShanksPrime() { } public static boolean nthManShanksPrime(int n, int n2) { int[] nArray = new int[n + 1]; int[] nArray2 = nArray; nArray[0] = 1; nArray2[1] = 1; for (int i = 2; i <= n; ++i) { nArray2[i] = 2 * nArray2[i - 1] + nArray2[i - 2]; } return nArray2[n] == n2; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * The NewManShanksPrime class provides a method to determine whether the nth * New Man Shanks prime matches an expected answer. * * <p>This is based on the New Man Shanks prime sequence defined by the recurrence * relation:</p> * * <pre> * a(n) = 2 * a(n-1) + a(n-2) for n >= 2 * a(0) = 1 * a(1) = 1 * </pre> * * <p>For more information on New Man Shanks primes, please refer to the * <a href=\"https://en.wikipedia.org/wiki/Newman%E2%80%93Shanks%E2%80%93Williams_prime\"> * Wikipedia article</a>.</p> * * <p>Note: The class is designed to be non-instantiable.</p> * * @author <a href=\"https://github.com/siddhant2002\">Siddhant Swarup Mallick</a> */ public final class NewManShanksPrime { private NewManShanksPrime() { } /** * Calculates the nth New Man Shanks prime and checks if it equals the * expected answer. * * @param n the index of the New Man Shanks prime to calculate (0-based). * @param expectedAnswer the expected value of the nth New Man Shanks prime. * @return true if the calculated nth New Man Shanks prime matches the * expected answer; false otherwise. */ public static boolean nthManShanksPrime(int n, int expectedAnswer) { int[] a = new int[n + 1]; a[0] = 1; a[1] = 1; for (int i = 2; i <= n; i++) { a[i] = 2 * a[i - 1] + a[i - 2]; } return a[n] == expectedAnswer; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.MemoryManagementAlgorithms; import java.util.ArrayList; class NextFit extends MemoryManagementAlgorithms { private int a = 0; NextFit() { } @Override public ArrayList fitProcess(int[] nArray, int[] nArray2) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); int n = nArray2.length; for (int i = 0; i < n; ++i) { int n2; int n3; block3: { int n4 = n3 = nArray2[i]; int[] nArray3 = nArray; NextFit nextFit = this; for (int j = 0; j < nArray3.length; ++j) { if (nextFit.a + j >= nArray3.length) { nextFit.a = -j; } if (nArray3[j + nextFit.a] < n4) continue; nextFit.a += j; n2 = nextFit.a; break block3; } nextFit.a += nArray3.length; n2 = -255; } int n5 = n2; arrayList.add(n5); if (n5 == -255) continue; int n6 = n5; nArray[n6] = nArray[n6] - n3; } return arrayList; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.MemoryManagementAlgorithms; import java.util.ArrayList; class NextFit extends MemoryManagementAlgorithms { private int a = 0; NextFit() { } @Override public ArrayList fitProcess(int[] nArray, int[] nArray2) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); int n = nArray2.length; for (int i = 0; i < n; ++i) { int n2; int n3; block3: { int n4 = n3 = nArray2[i]; int[] nArray3 = nArray; NextFit nextFit = this; for (int j = 0; j < nArray3.length; ++j) { if (nextFit.a + j >= nArray3.length) { nextFit.a = -j; } if (nArray3[j + nextFit.a] < n4) continue; nextFit.a += j; n2 = nextFit.a; break block3; } nextFit.a += nArray3.length; n2 = -255; } int n5 = n2; arrayList.add(n5); if (n5 == -255) continue; int n6 = n5; nArray[n6] = nArray[n6] - n3; } return arrayList; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Stack; public final class NextGreaterElement { private NextGreaterElement() { } public static int[] findNextGreaterElements(int[] nArray) { if (nArray == null) { throw new IllegalArgumentException(\"Input array cannot be null\"); } int[] nArray2 = new int[nArray.length]; Stack<Integer> stack = new Stack<Integer>(); for (int i = 0; i < nArray.length; ++i) { while (!stack.isEmpty() && nArray[(Integer)stack.peek()] < nArray[i]) { nArray2[((Integer)stack.pop()).intValue()] = nArray[i]; } stack.push(i); } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; /** * Utility class to find the next greater element for each element in a given integer array. * * <p>The next greater element for an element x is the first greater element on the right side of x in the array. * If no such element exists, the result will contain 0 for that position.</p> * * <p>Example:</p> * <pre> * Input: {2, 7, 3, 5, 4, 6, 8} * Output: {7, 0, 5, 6, 6, 8, 0} * </pre> */ public final class NextGreaterElement { private NextGreaterElement() { } /** * Finds the next greater element for each element in the given array. * * @param array the input array of integers * @return an array where each element is replaced by the next greater element on the right side in the input array, * or 0 if there is no greater element. * @throws IllegalArgumentException if the input array is null */ public static int[] findNextGreaterElements(int[] array) { if (array == null) { throw new IllegalArgumentException(\"Input array cannot be null\"); } int[] result = new int[array.length]; Stack<Integer> stack = new Stack<>(); for (int i = 0; i < array.length; i++) { while (!stack.isEmpty() && array[stack.peek()] < array[i]) { result[stack.pop()] = array[i]; } stack.push(i); } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class NextHigherSameBitCount { private NextHigherSameBitCount() { } public static int nextHigherSameBitCount(int n) { int n2 = n; int n3 = n2 & -n2; int n4 = n + n3; return ((n4 ^ n) >> 2) / n3 | n4; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class provides a method to find the next higher number * with the same number of set bits as the given number. * * @author Hardvan */ public final class NextHigherSameBitCount { private NextHigherSameBitCount() { } /** * Finds the next higher integer with the same number of set bits. * Steps: * 1. Find {@code c}, the rightmost set bit of {@code n}. * 2. Find {@code r}, the rightmost set bit of {@code n + c}. * 3. Swap the bits of {@code r} and {@code n} to the right of {@code c}. * 4. Shift the bits of {@code r} and {@code n} to the right of {@code c} to the rightmost. * 5. Combine the results of steps 3 and 4. * * @param n the input number * @return the next higher integer with the same set bit count */ public static int nextHigherSameBitCount(int n) { int c = n & -n; int r = n + c; return (((r ^ n) >> 2) / c) | r; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Arrays; import java.util.Stack; public final class NextSmallerElement { private NextSmallerElement() { } public static int[] findNextSmallerElements(int[] nArray) { if (nArray == null) { throw new IllegalArgumentException(\"Input array cannot be null\"); } int[] nArray2 = new int[nArray.length]; Stack<Integer> stack = new Stack<Integer>(); Arrays.fill(nArray2, -1); for (int i = 0; i < nArray.length; ++i) { while (!stack.isEmpty() && (Integer)stack.peek() >= nArray[i]) { stack.pop(); } if (!stack.isEmpty()) { nArray2[i] = (Integer)stack.peek(); } stack.push(nArray[i]); } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Arrays; import java.util.Stack; /** * Utility class to find the next smaller element for each element in a given integer array. * * <p>The next smaller element for an element x is the first smaller element on the left side of x in the array. * If no such element exists, the result will contain -1 for that position.</p> * * <p>Example:</p> * <pre> * Input: {2, 7, 3, 5, 4, 6, 8} * Output: [-1, 2, 2, 3, 3, 4, 6] * </pre> */ public final class NextSmallerElement { private NextSmallerElement() { } /** * Finds the next smaller element for each element in the given array. * * @param array the input array of integers * @return an array where each element is replaced by the next smaller element on the left side in the input array, * or -1 if there is no smaller element. * @throws IllegalArgumentException if the input array is null */ public static int[] findNextSmallerElements(int[] array) { if (array == null) { throw new IllegalArgumentException(\"Input array cannot be null\"); } int[] result = new int[array.length]; Stack<Integer> stack = new Stack<>(); // Initialize all elements to -1 (in case there is no smaller element) Arrays.fill(result, -1); // Traverse the array from left to right for (int i = 0; i < array.length; i++) { // Maintain the stack such that the top of the stack is the next smaller element while (!stack.isEmpty() && stack.peek() >= array[i]) { stack.pop(); } // If stack is not empty, then the top is the next smaller element if (!stack.isEmpty()) { result[i] = stack.peek(); } // Push the current element onto the stack stack.push(array[i]); } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; class Node { int a; Node b; Node() { } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; class Node { int a; Node b; Node() { } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.stacks; class NodeStack$Node { Object a; NodeStack$Node b; NodeStack$Node(Object object) { this.a = object; this.b = null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.stacks; class NodeStack$Node { Object a; NodeStack$Node b; NodeStack$Node(Object object) { this.a = object; this.b = null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.stacks; import com.thealgorithms.datastructures.stacks.NodeStack$Node; public class NodeStack { private NodeStack$Node a = null; private int b = 0; public void push(Object object) { object = new NodeStack$Node(object); v0.b = this.a; this.a = object; ++this.b; } public Object pop() { if (this.isEmpty()) { throw new IllegalStateException(\"Cannot pop from an empty stack.\"); } Object object = this.a.a; this.a = this.a.b; --this.b; return object; } public Object peek() { if (this.isEmpty()) { throw new IllegalStateException(\"Cannot peek from an empty stack.\"); } return this.a.a; } public boolean isEmpty() { return this.a == null; } public int size() { return this.b; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.stacks; /** * A stack implementation using linked nodes, supporting unlimited size without an ArrayList. * * <p>Each node in the stack contains data of generic type {@code Item}, along with references * to the next and previous nodes, supporting typical stack operations. * * <p>The stack follows a Last-In-First-Out (LIFO) order where elements added last are * removed first. Supported operations include push, pop, and peek. * * @param <Item> the type of elements held in this stack */ public class NodeStack<Item> { /** * Node class representing each element in the stack. */ private class Node { Item data; Node previous; Node(Item data) { this.data = data; this.previous = null; } } private Node head; // Top node in the stack private int size; // Number of elements in the stack /** * Constructs an empty NodeStack. */ public NodeStack() { head = null; size = 0; } /** * Pushes an item onto the stack. * * @param item the item to be pushed onto the stack */ public void push(Item item) { Node newNode = new Node(item); newNode.previous = head; head = newNode; size++; } /** * Removes and returns the item at the top of the stack. * * @return the item at the top of the stack, or {@code null} if the stack is empty * @throws IllegalStateException if the stack is empty */ public Item pop() { if (isEmpty()) { throw new IllegalStateException(\"Cannot pop from an empty stack.\"); } Item data = head.data; head = head.previous; size--; return data; } /** * Returns the item at the top of the stack without removing it. * * @return the item at the top of the stack, or {@code null} if the stack is empty * @throws IllegalStateException if the stack is empty */ public Item peek() { if (isEmpty()) { throw new IllegalStateException(\"Cannot peek from an empty stack.\"); } return head.data; } /** * Checks whether the stack is empty. * * @return {@code true} if the stack has no elements, {@code false} otherwise */ public boolean isEmpty() { return head == null; } /** * Returns the number of elements currently in the stack. * * @return the size of the stack */ public int size() { return size; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class NonPreemptivePriorityScheduling$Process implements Comparable { int a; int b; int c; private int d; public int compareTo(NonPreemptivePriorityScheduling$Process nonPreemptivePriorityScheduling$Process) { int cfr_ignored_0 = nonPreemptivePriorityScheduling$Process.d; return Integer.compare(this.a, nonPreemptivePriorityScheduling$Process.a); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class NonPreemptivePriorityScheduling$Process implements Comparable { int a; int b; int c; private int d; public int compareTo(NonPreemptivePriorityScheduling$Process nonPreemptivePriorityScheduling$Process) { int cfr_ignored_0 = nonPreemptivePriorityScheduling$Process.d; return Integer.compare(this.a, nonPreemptivePriorityScheduling$Process.a); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.NonPreemptivePriorityScheduling$Process; import java.util.Collections; import java.util.LinkedList; import java.util.PriorityQueue; public final class NonPreemptivePriorityScheduling { private NonPreemptivePriorityScheduling() { } public static NonPreemptivePriorityScheduling$Process[] scheduleProcesses(NonPreemptivePriorityScheduling$Process[] object) { PriorityQueue<NonPreemptivePriorityScheduling$Process> priorityQueue = new PriorityQueue<NonPreemptivePriorityScheduling$Process>(); LinkedList linkedList = new LinkedList(); int n = 0; NonPreemptivePriorityScheduling$Process[] nonPreemptivePriorityScheduling$ProcessArray = new NonPreemptivePriorityScheduling$Process[((NonPreemptivePriorityScheduling$Process[])object).length]; Collections.addAll(linkedList, object); while (!linkedList.isEmpty() || !priorityQueue.isEmpty()) { while (!linkedList.isEmpty()) { int cfr_ignored_0 = ((NonPreemptivePriorityScheduling$Process)linkedList.peek()).a; priorityQueue.add((NonPreemptivePriorityScheduling$Process)linkedList.poll()); } if (!priorityQueue.isEmpty()) { object = (NonPreemptivePriorityScheduling$Process)priorityQueue.poll(); ((NonPreemptivePriorityScheduling$Process)priorityQueue.poll()).b = 0; nonPreemptivePriorityScheduling$ProcessArray[n++] = object; int cfr_ignored_1 = object.c; continue; } int cfr_ignored_2 = ((NonPreemptivePriorityScheduling$Process)linkedList.peek()).a; } return nonPreemptivePriorityScheduling$ProcessArray; } public static double calculateAverageWaitingTime(NonPreemptivePriorityScheduling$Process[] nonPreemptivePriorityScheduling$ProcessArray, NonPreemptivePriorityScheduling$Process[] nonPreemptivePriorityScheduling$ProcessArray2) { int n = 0; for (NonPreemptivePriorityScheduling$Process nonPreemptivePriorityScheduling$Process : nonPreemptivePriorityScheduling$ProcessArray2) { int n2 = nonPreemptivePriorityScheduling$Process.b - nonPreemptivePriorityScheduling$Process.a; n += n2; } return (double)n / (double)nonPreemptivePriorityScheduling$ProcessArray.length; } public static double calculateAverageTurnaroundTime(NonPreemptivePriorityScheduling$Process[] nonPreemptivePriorityScheduling$ProcessArray, NonPreemptivePriorityScheduling$Process[] nonPreemptivePriorityScheduling$ProcessArray2) { int n = 0; for (NonPreemptivePriorityScheduling$Process nonPreemptivePriorityScheduling$Process : nonPreemptivePriorityScheduling$ProcessArray2) { int n2 = nonPreemptivePriorityScheduling$Process.b + nonPreemptivePriorityScheduling$Process.c - nonPreemptivePriorityScheduling$Process.a; n += n2; } return (double)n / (double)nonPreemptivePriorityScheduling$ProcessArray.length; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.Collections; import java.util.LinkedList; import java.util.PriorityQueue; import java.util.Queue; /** * This class implements the Non-Preemptive Priority Scheduling algorithm. * Processes are executed in order of their priority. The process with the * highest priority (lower priority number) is executed first, * and once a process starts executing, it cannot be preempted. */ public final class NonPreemptivePriorityScheduling { private NonPreemptivePriorityScheduling() { } /** * Represents a process with an ID, burst time, priority, arrival time, and start time. */ static class Process implements Comparable<Process> { int id; int arrivalTime; int startTime; int burstTime; int priority; /** * Constructs a Process instance with the specified parameters. * * @param id Unique identifier for the process * @param arrivalTime Time when the process arrives in the system * @param burstTime Time required for the process execution * @param priority Priority of the process */ Process(int id, int arrivalTime, int burstTime, int priority) { this.id = id; this.arrivalTime = arrivalTime; this.startTime = -1; this.burstTime = burstTime; this.priority = priority; } /** * Compare based on priority for scheduling. The process with the lowest * priority is selected first. * If two processes have the same priority, the one that arrives earlier is selected. * * @param other The other process to compare against * @return A negative integer, zero, or a positive integer as this process * is less than, equal to, or greater than the specified process. */ @Override public int compareTo(Process other) { if (this.priority == other.priority) { return Integer.compare(this.arrivalTime, other.arrivalTime); } return Integer.compare(this.priority, other.priority); } } /** * Schedules processes based on their priority in a non-preemptive manner, considering their arrival times. * * @param processes Array of processes to be scheduled. * @return Array of processes in the order they are executed. */ public static Process[] scheduleProcesses(Process[] processes) { PriorityQueue<Process> pq = new PriorityQueue<>(); Queue<Process> waitingQueue = new LinkedList<>(); int currentTime = 0; int index = 0; Process[] executionOrder = new Process[processes.length]; Collections.addAll(waitingQueue, processes); while (!waitingQueue.isEmpty() || !pq.isEmpty()) { // Add processes that have arrived to the priority queue while (!waitingQueue.isEmpty() && waitingQueue.peek().arrivalTime <= currentTime) { pq.add(waitingQueue.poll()); } if (!pq.isEmpty()) { Process currentProcess = pq.poll(); currentProcess.startTime = currentTime; executionOrder[index++] = currentProcess; currentTime += currentProcess.burstTime; } else { // If no process is ready, move to the next arrival time currentTime = waitingQueue.peek().arrivalTime; } } return executionOrder; } /** * Calculates the average waiting time of the processes. * * @param processes Array of processes. * @param executionOrder Array of processes in execution order. * @return Average waiting time. */ public static double calculateAverageWaitingTime(Process[] processes, Process[] executionOrder) { int totalWaitingTime = 0; for (Process process : executionOrder) { int waitingTime = process.startTime - process.arrivalTime; totalWaitingTime += waitingTime; } return (double) totalWaitingTime / processes.length; } /** * Calculates the average turn-around time of the processes. * * @param processes Array of processes. * @param executionOrder Array of processes in execution order. * @return Average turn-around time. */ public static double calculateAverageTurnaroundTime(Process[] processes, Process[] executionOrder) { int totalTurnaroundTime = 0; for (Process process : executionOrder) { int turnaroundTime = process.startTime + process.burstTime - process.arrivalTime; totalTurnaroundTime += turnaroundTime; } return (double) totalTurnaroundTime / processes.length; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class NonRepeatingElement { private NonRepeatingElement() { } public static int[] findNonRepeatingElements(int[] nArray) { int n; if (nArray.length % 2 != 0) { throw new IllegalArgumentException(\"Array should contain an even number of elements\"); } int n2 = 0; int[] nArray2 = nArray; int n3 = nArray.length; for (n = 0; n < n3; ++n) { int n4 = nArray2[n]; n2 ^= n4; } int n5 = n2; int n6 = n5 & -n5; n3 = 0; n = 0; int[] nArray3 = nArray; int n7 = nArray.length; for (n2 = 0; n2 < n7; ++n2) { int n8 = nArray3[n2]; if ((n8 & n6) != 0) { n3 ^= n8; continue; } n ^= n8; } return new int[]{n3, n}; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Find the 2 elements which are non-repeating in an array * Reason to use bitwise operator: It makes our program faster as we are operating on bits and not * on actual numbers. * * Explanation of the code: * Let us assume we have an array [1, 2, 1, 2, 3, 4] * Property of XOR: num ^ num = 0. * If we XOR all the elements of the array, we will be left with 3 ^ 4 as 1 ^ 1 * and 2 ^ 2 would give 0. Our task is to find num1 and num2 from the result of 3 ^ 4 = 7. * We need to find the two's complement of 7 and find the rightmost set bit, i.e., (num & (-num)). * Two's complement of 7 is 001, and hence res = 1. There can be 2 options when we Bitwise AND this res * with all the elements in our array: * 1. The result will be a non-zero number. * 2. The result will be 0. * In the first case, we will XOR our element with the first number (which is initially 0). * In the second case, we will XOR our element with the second number (which is initially 0). * This is how we will get non-repeating elements with the help of bitwise operators. */ public final class NonRepeatingElement { private NonRepeatingElement() { } /** * Finds the two non-repeating elements in the array. * * @param arr The input array containing exactly two non-repeating elements and all other elements repeating. * @return An array containing the two non-repeating elements. * @throws IllegalArgumentException if the input array length is odd. */ public static int[] findNonRepeatingElements(int[] arr) { if (arr.length % 2 != 0) { throw new IllegalArgumentException(\"Array should contain an even number of elements\"); } int xorResult = 0; // Find XOR of all elements for (int num : arr) { xorResult ^= num; } // Find the rightmost set bit int rightmostSetBit = xorResult & (-xorResult); int num1 = 0; int num2 = 0; // Divide the elements into two groups and XOR them for (int num : arr) { if ((num & rightmostSetBit) != 0) { num1 ^= num; } else { num2 ^= num; } } return new int[] {num1, num2}; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class NonRepeatingNumberFinder { private NonRepeatingNumberFinder() { } public static int findNonRepeatingNumber(int[] nArray) { int n = 0; for (int n2 : nArray) { n ^= n2; } return n; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * A utility class to find the non-repeating number in an array where every other number repeats. * This class contains a method to identify the single unique number using bit manipulation. * * The solution leverages the properties of the XOR operation, which states that: * - x ^ x = 0 for any integer x (a number XORed with itself is zero) * - x ^ 0 = x for any integer x (a number XORed with zero is the number itself) * * Using these properties, we can find the non-repeating number in linear time with constant space. * * Example: * Given the input array [2, 3, 5, 2, 3], the output will be 5 since it does not repeat. * * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi) */ public final class NonRepeatingNumberFinder { private NonRepeatingNumberFinder() { } /** * Finds the non-repeating number in the given array. * * @param arr an array of integers where every number except one appears twice * @return the integer that appears only once in the array or 0 if the array is empty */ public static int findNonRepeatingNumber(int[] arr) { int result = 0; for (int num : arr) { result ^= num; } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.ArrayList; public class NthUglyNumber { private ArrayList a; public Long get(int n) { if (n < 0) { throw new IllegalArgumentException(\"n must be non-negative.\"); } throw new NullPointerException(); } }", "deobfuscated_code": "package com.thealgorithms.maths; import static java.util.Collections.singletonList; import java.util.ArrayList; import java.util.Map; import org.apache.commons.lang3.tuple.MutablePair; /** * @brief class computing the n-th ugly number (when they are sorted) * @details the ugly numbers with base [2, 3, 5] are all numbers of the form 2^a*3^b^5^c, * where the exponents a, b, c are non-negative integers. * Some properties of ugly numbers: * - base [2, 3, 5] ugly numbers are the 5-smooth numbers, cf. https://oeis.org/A051037 * - base [2, 3, 5, 7] ugly numbers are 7-smooth numbers, cf. https://oeis.org/A002473 * - base [2] ugly numbers are the non-negative powers of 2, * - the base [2, 3, 5] ugly numbers are the same as base [5, 6, 2, 3, 5] ugly numbers */ public class NthUglyNumber { private ArrayList<Long> uglyNumbers = new ArrayList<>(singletonList(1L)); private ArrayList<MutablePair<Integer, Integer>> positions = new ArrayList<>(); /** * @brief initialized the object allowing to compute ugly numbers with given base * @param baseNumbers the given base of ugly numbers * @exception IllegalArgumentException baseNumber is empty */ NthUglyNumber(final int[] baseNumbers) { if (baseNumbers.length == 0) { throw new IllegalArgumentException(\"baseNumbers must be non-empty.\"); } for (final var baseNumber : baseNumbers) { this.positions.add(MutablePair.of(baseNumber, 0)); } } /** * @param n the zero-based-index of the queried ugly number * @exception IllegalArgumentException n is negative * @return the n-th ugly number (starting from index 0) */ public Long get(final int n) { if (n < 0) { throw new IllegalArgumentException(\"n must be non-negative.\"); } while (uglyNumbers.size() <= n) { addUglyNumber(); } return uglyNumbers.get(n); } private void addUglyNumber() { uglyNumbers.add(computeMinimalCandidate()); updatePositions(); } private void updatePositions() { final var lastUglyNumber = uglyNumbers.get(uglyNumbers.size() - 1); for (var entry : positions) { if (computeCandidate(entry) == lastUglyNumber) { entry.setValue(entry.getValue() + 1); } } } private long computeCandidate(final Map.Entry<Integer, Integer> entry) { return entry.getKey() * uglyNumbers.get(entry.getValue()); } private long computeMinimalCandidate() { long res = Long.MAX_VALUE; for (final var entry : positions) { res = Math.min(res, computeCandidate(entry)); } return res; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class NumberAppearingOddTimes { private NumberAppearingOddTimes() { } public static int findOddOccurrence(int[] nArray) { int n = 0; for (int n2 : nArray) { n ^= n2; } return n; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class provides a method to find the element that appears an * odd number of times in an array. All other elements in the array * must appear an even number of times for the logic to work. * * The solution uses the XOR operation, which has the following properties: * - a ^ a = 0 (XOR-ing the same numbers cancels them out) * - a ^ 0 = a * - XOR is commutative and associative. * * Time Complexity: O(n), where n is the size of the array. * Space Complexity: O(1), as no extra space is used. * * Usage Example: * int result = NumberAppearingOddTimes.findOddOccurrence(new int[]{1, 2, 1, 2, 3}); * // result will be 3 * * @author Lakshyajeet Singh Goyal (https://github.com/DarkMatter-999) */ public final class NumberAppearingOddTimes { private NumberAppearingOddTimes() { } /** * Finds the element in the array that appears an odd number of times. * * @param arr the input array containing integers, where all elements * except one appear an even number of times. * @return the integer that appears an odd number of times. */ public static int findOddOccurrence(int[] arr) { int result = 0; for (int num : arr) { result ^= num; } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class NumberOfDigits { private NumberOfDigits() { } public static int numberOfDigits(int n) { int n2 = 0; do { ++n2; } while ((n /= 10) != 0); return n2; } public static int numberOfDigitsFast(int n) { if (n == 0) { return 1; } return (int)Math.floor(Math.log10(Math.abs(n)) + 1.0); } public static int numberOfDigitsFaster(int n) { if (n < 0) { return (\"\" + -n).length(); } return (\"\" + n).length(); } public static int numberOfDigitsRecursion(int n) { if (n / 10 == 0) { return 1; } return 1 + NumberOfDigits.numberOfDigitsRecursion(n / 10); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Find the number of digits in a number. */ public final class NumberOfDigits { private NumberOfDigits() { } /** * Find the number of digits in a number. * * @param number number to find * @return number of digits of given number */ public static int numberOfDigits(int number) { int digits = 0; do { digits++; number /= 10; } while (number != 0); return digits; } /** * Find the number of digits in a number fast version. * * @param number number to find * @return number of digits of given number */ public static int numberOfDigitsFast(int number) { return number == 0 ? 1 : (int) Math.floor(Math.log10(Math.abs(number)) + 1); } /** * Find the number of digits in a number faster version. * * @param number number to find * @return number of digits of given number */ public static int numberOfDigitsFaster(int number) { return number < 0 ? (-number + \"\").length() : (number + \"\").length(); } /** * Find the number of digits in a number using recursion. * * @param number number to find * @return number of digits of given number */ public static int numberOfDigitsRecursion(int number) { return number / 10 == 0 ? 1 : 1 + numberOfDigitsRecursion(number / 10); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.math.BigDecimal; public final class NumberToWords { private static final String[] a = new String[]{\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"}; private static final String[] b = new String[]{\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"}; private static final String[] c = new String[]{\"\", \"Thousand\", \"Million\", \"Billion\", \"Trillion\"}; private NumberToWords() { } public static String convert(BigDecimal object) { Object object2; String string; if (object == null) { return \"Invalid Input\"; } boolean bl = object.signum() < 0; object = object.abs().divideAndRemainder(BigDecimal.ONE); Comparable<BigDecimal> comparable = object[0]; object = object[1].compareTo(BigDecimal.ZERO) > 0 ? object[1].toPlainString().substring(2) : \"\"; StringBuilder stringBuilder = new StringBuilder(); if (bl) { stringBuilder.append(\"Negative \"); } Object object3 = comparable; if (((BigDecimal)comparable).compareTo(BigDecimal.ZERO) == 0) { string = \"Zero\"; } else { comparable = new StringBuilder(); object2 = 0; while (object3.compareTo(BigDecimal.ZERO) > 0) { int n = (object3 = object3.divideAndRemainder(BigDecimal.valueOf(1000L)))[1].intValue(); if (n > 0) { String string2 = NumberToWords.a(n); if (object2 > 0) { ((StringBuilder)comparable).insert(0, c[object2] + \" \"); } ((StringBuilder)comparable).insert(0, string2 + \" \"); } object3 = object3[0]; ++object2; } string = ((StringBuilder)comparable).toString().trim(); } stringBuilder.append(string); if (!object.isEmpty()) { stringBuilder.append(\" Point\"); char[] cArray = object.toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { object2 = object[i]; object2 = Character.getNumericValue((char)object2); stringBuilder.append(\" \").append(object2 == 0 ? \"Zero\" : a[object2]); } } return stringBuilder.toString().trim(); } private static String a(int n) { Object object = n < 20 ? a[n] : (n < 100 ? b[n / 10] + (String)(n % 10 > 0 ? \" \" + a[n % 10] : \"\") : a[n / 100] + \" Hundred\" + (String)(n % 100 > 0 ? \" \" + NumberToWords.a(n % 100) : \"\")); return object; } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.math.BigDecimal; /** A Java-based utility for converting numeric values into their English word representations. Whether you need to convert a small number, a large number with millions and billions, or even a number with decimal places, this utility has you covered. * */ public final class NumberToWords { private NumberToWords() { } private static final String[] UNITS = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"}; private static final String[] TENS = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"}; private static final String[] POWERS = {\"\", \"Thousand\", \"Million\", \"Billion\", \"Trillion\"}; private static final String ZERO = \"Zero\"; private static final String POINT = \" Point\"; private static final String NEGATIVE = \"Negative \"; public static String convert(BigDecimal number) { if (number == null) { return \"Invalid Input\"; } // Check for negative sign boolean isNegative = number.signum() < 0; // Split the number into whole and fractional parts BigDecimal[] parts = number.abs().divideAndRemainder(BigDecimal.ONE); BigDecimal wholePart = parts[0]; // Keep whole part as BigDecimal String fractionalPartStr = parts[1].compareTo(BigDecimal.ZERO) > 0 ? parts[1].toPlainString().substring(2) : \"\"; // Get fractional part only if it exists // Convert whole part to words StringBuilder result = new StringBuilder(); if (isNegative) { result.append(NEGATIVE); } result.append(convertWholeNumberToWords(wholePart)); // Convert fractional part to words if (!fractionalPartStr.isEmpty()) { result.append(POINT); for (char digit : fractionalPartStr.toCharArray()) { int digitValue = Character.getNumericValue(digit); result.append(\" \").append(digitValue == 0 ? ZERO : UNITS[digitValue]); } } return result.toString().trim(); } private static String convertWholeNumberToWords(BigDecimal number) { if (number.compareTo(BigDecimal.ZERO) == 0) { return ZERO; } StringBuilder words = new StringBuilder(); int power = 0; while (number.compareTo(BigDecimal.ZERO) > 0) { // Get the last three digits BigDecimal[] divisionResult = number.divideAndRemainder(BigDecimal.valueOf(1000)); int chunk = divisionResult[1].intValue(); if (chunk > 0) { String chunkWords = convertChunk(chunk); if (power > 0) { words.insert(0, POWERS[power] + \" \"); } words.insert(0, chunkWords + \" \"); } number = divisionResult[0]; // Continue with the remaining part power++; } return words.toString().trim(); } private static String convertChunk(int number) { String chunkWords; if (number < 20) { chunkWords = UNITS[number]; } else if (number < 100) { chunkWords = TENS[number / 10] + (number % 10 > 0 ? \" \" + UNITS[number % 10] : \"\"); } else { chunkWords = UNITS[number / 100] + \" Hundred\" + (number % 100 > 0 ? \" \" + convertChunk(number % 100) : \"\"); } return chunkWords; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class NumbersDifferentSigns { private NumbersDifferentSigns() { } public static boolean differentSigns(int n, int n2) { return (n ^ n2) < 0; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class provides a method to determine whether two integers have * different signs. It utilizes the XOR operation on the two numbers: * * - If two numbers have different signs, their most significant bits * (sign bits) will differ, resulting in a negative XOR result. * - If two numbers have the same sign, the XOR result will be non-negative. * * Time Complexity: O(1) - Constant time operation. * Space Complexity: O(1) - No extra space used. * * @author Bama Charan Chhandogi */ public final class NumbersDifferentSigns { private NumbersDifferentSigns() { } /** * Determines if two integers have different signs using bitwise XOR. * * @param num1 the first integer * @param num2 the second integer * @return true if the two numbers have different signs, false otherwise */ public static boolean differentSigns(int num1, int num2) { return (num1 ^ num2) < 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.crdt; public class ORSet$Pair { private final Object a; private final String b; public ORSet$Pair(Object object, String string) { this.a = object; this.b = string; } public Object getElement() { return this.a; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.crdt; public class ORSet$Pair { private final Object a; private final String b; public ORSet$Pair(Object object, String string) { this.a = object; this.b = string; } public Object getElement() { return this.a; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.crdt; import com.thealgorithms.datastructures.crdt.ORSet$Pair; import java.util.Collection; import java.util.HashSet; import java.util.Set; import java.util.UUID; public class ORSet { private final Set a = new HashSet(); private final Set b = new HashSet(); public boolean contains(Object object) { return this.a.stream().anyMatch(oRSet$Pair -> oRSet$Pair.getElement().equals(object)); } public Set elements() { HashSet hashSet = new HashSet(); this.a.forEach(oRSet$Pair -> hashSet.add(oRSet$Pair.getElement())); return hashSet; } public void add(Object object) { Object object2 = this; Object object3 = object2 = UUID.randomUUID().toString(); object2 = this; object = new ORSet$Pair(object, (String)object3); ((ORSet)object2).a.add(object); ((ORSet)object2).a.removeAll(((ORSet)object2).b); } public void remove(Object object) { Object object2 = object; object = this; HashSet<ORSet$Pair> hashSet = new HashSet<ORSet$Pair>(); object = ((ORSet)object).a.iterator(); while (object.hasNext()) { ORSet$Pair oRSet$Pair = (ORSet$Pair)object.next(); if (!oRSet$Pair.getElement().equals(object2)) continue; hashSet.add(oRSet$Pair); } object2 = object = hashSet; object = this; ((ORSet)object).a.removeAll((Collection<?>)object2); ((ORSet)object).b.addAll(object2); } public boolean compare(ORSet oRSet) { HashSet hashSet = new HashSet(this.a); hashSet.addAll(this.b); HashSet hashSet2 = new HashSet(oRSet.a); hashSet2.addAll(oRSet.b); return hashSet2.containsAll(hashSet) && oRSet.b.containsAll(this.b); } public void merge(ORSet oRSet) { this.a.removeAll(oRSet.b); oRSet.a.removeAll(this.b); this.a.addAll(oRSet.a); this.b.addAll(oRSet.b); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.crdt; import java.util.HashSet; import java.util.Set; import java.util.UUID; /** * ORSet (Observed-Removed Set) is a state-based CRDT (Conflict-free Replicated Data Type) * that supports both addition and removal of elements. This particular implementation follows * the Add-Wins strategy, meaning that in case of conflicting add and remove operations, * the add operation takes precedence. The merge operation of two OR-Sets ensures that * elements added at any replica are eventually observed at all replicas. Removed elements, * once observed, are never reintroduced. * This OR-Set implementation provides methods for adding elements, removing elements, * checking for element existence, retrieving the set of elements, comparing with other OR-Sets, * and merging with another OR-Set to create a new OR-Set containing all unique elements * from both sets. * * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah) * @see <a href=\"https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type\">Conflict-free_replicated_data_type</a> * @see <a href=\"https://github.com/itakurah\">itakurah (Niklas Hoefflin)</a> */ public class ORSet<T> { private final Set<Pair<T>> elements; private final Set<Pair<T>> tombstones; /** * Constructs an empty OR-Set. */ public ORSet() { this.elements = new HashSet<>(); this.tombstones = new HashSet<>(); } /** * Checks if the set contains the specified element. * * @param element the element to check for * @return true if the set contains the element, false otherwise */ public boolean contains(T element) { return elements.stream().anyMatch(pair -> pair.getElement().equals(element)); } /** * Retrieves the elements in the set. * * @return a set containing the elements */ public Set<T> elements() { Set<T> result = new HashSet<>(); elements.forEach(pair -> result.add(pair.getElement())); return result; } /** * Adds the specified element to the set. * * @param element the element to add */ public void add(T element) { String n = prepare(); effect(element, n); } /** * Removes the specified element from the set. * * @param element the element to remove */ public void remove(T element) { Set<Pair<T>> pairsToRemove = prepare(element); effect(pairsToRemove); } /** * Collect all pairs with the specified element. * * @param element the element to collect pairs for * @return a set of pairs with the specified element to be removed */ private Set<Pair<T>> prepare(T element) { Set<Pair<T>> pairsToRemove = new HashSet<>(); for (Pair<T> pair : elements) { if (pair.getElement().equals(element)) { pairsToRemove.add(pair); } } return pairsToRemove; } /** * Generates a unique tag for the element. * * @return the unique tag */ private String prepare() { return generateUniqueTag(); } /** * Adds the element with the specified unique tag to the set. * * @param element the element to add * @param n the unique tag associated with the element */ private void effect(T element, String n) { Pair<T> pair = new Pair<>(element, n); elements.add(pair); elements.removeAll(tombstones); } /** * Removes the specified pairs from the set. * * @param pairsToRemove the pairs to remove */ private void effect(Set<Pair<T>> pairsToRemove) { elements.removeAll(pairsToRemove); tombstones.addAll(pairsToRemove); } /** * Generates a unique tag. * * @return the unique tag */ private String generateUniqueTag() { return UUID.randomUUID().toString(); } /** * Compares this Add-Wins OR-Set with another OR-Set to check if elements and tombstones are a subset. * * @param other the other OR-Set to compare * @return true if the sets are subset, false otherwise */ public boolean compare(ORSet<T> other) { Set<Pair<T>> union = new HashSet<>(elements); union.addAll(tombstones); Set<Pair<T>> otherUnion = new HashSet<>(other.elements); otherUnion.addAll(other.tombstones); return otherUnion.containsAll(union) && other.tombstones.containsAll(tombstones); } /** * Merges this Add-Wins OR-Set with another OR-Set. * * @param other the other OR-Set to merge */ public void merge(ORSet<T> other) { elements.removeAll(other.tombstones); other.elements.removeAll(tombstones); elements.addAll(other.elements); tombstones.addAll(other.tombstones); } /** * Represents a pair containing an element and a unique tag. * * @param <T> the type of the element in the pair */ public static class Pair<T> { private final T element; private final String uniqueTag; /** * Constructs a pair with the specified element and unique tag. * * @param element the element in the pair * @param uniqueTag the unique tag associated with the element */ public Pair(T element, String uniqueTag) { this.element = element; this.uniqueTag = uniqueTag; } /** * Gets the element from the pair. * * @return the element */ public T getElement() { return element; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class OctalToBinary { private OctalToBinary() { } public static long convertOctalToBinary(int n) { long l = 0L; int n2 = 1; while (n != 0) { int n3 = n % 10; long l2 = OctalToBinary.convertOctalDigitToBinary(n3); l += l2 * (long)n2; n /= 10; n2 *= 1000; } return l; } public static long convertOctalDigitToBinary(int n) { long l = 0L; int n2 = 1; while (n != 0) { int n3 = n % 2; l += (long)(n3 * n2); n /= 2; n2 *= 10; } return l; } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * A utility class to convert an octal (base-8) number into its binary (base-2) representation. * * <p>This class provides methods to: * <ul> * <li>Convert an octal number to its binary equivalent</li> * <li>Convert individual octal digits to binary</li> * </ul> * * <h2>Octal to Binary Conversion:</h2> * <p>An octal number is converted to binary by converting each octal digit to its 3-bit binary equivalent. * The result is a long representing the full binary equivalent of the octal number.</p> * * <h2>Example Usage</h2> * <pre> * long binary = OctalToBinary.convertOctalToBinary(52); // Output: 101010 (52 in octal is 101010 in binary) * </pre> * * @author Bama Charan Chhandogi * @see <a href=\"https://en.wikipedia.org/wiki/Octal\">Octal Number System</a> * @see <a href=\"https://en.wikipedia.org/wiki/Binary_number\">Binary Number System</a> */ public final class OctalToBinary { private OctalToBinary() { } /** * Converts an octal number to its binary representation. * * <p>Each octal digit is individually converted to its 3-bit binary equivalent, and the binary * digits are concatenated to form the final binary number.</p> * * @param octalNumber the octal number to convert (non-negative integer) * @return the binary equivalent as a long */ public static long convertOctalToBinary(int octalNumber) { long binaryNumber = 0; int digitPosition = 1; while (octalNumber != 0) { int octalDigit = octalNumber % 10; long binaryDigit = convertOctalDigitToBinary(octalDigit); binaryNumber += binaryDigit * digitPosition; octalNumber /= 10; digitPosition *= 1000; } return binaryNumber; } /** * Converts a single octal digit (0-7) to its binary equivalent. * * <p>For example: * <ul> * <li>Octal digit 7 is converted to binary 111</li> * <li>Octal digit 3 is converted to binary 011</li> * </ul> * </p> * * @param octalDigit a single octal digit (0-7) * @return the binary equivalent as a long */ public static long convertOctalDigitToBinary(int octalDigit) { long binaryDigit = 0; int binaryMultiplier = 1; while (octalDigit != 0) { int octalDigitRemainder = octalDigit % 2; binaryDigit += octalDigitRemainder * binaryMultiplier; octalDigit /= 2; binaryMultiplier *= 10; } return binaryDigit; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class OctalToDecimal { private OctalToDecimal() { } public static int convertOctalToDecimal(String string) { if (string == null || string.isEmpty()) { throw new IllegalArgumentException(\"Input cannot be null or empty\"); } int n = 0; for (int i = 0; i < string.length(); ++i) { int n2 = string.charAt(i); if (n2 < 48 || n2 > 55) { throw new IllegalArgumentException(\"Incorrect input: Expecting an octal number (digits 0-7)\"); } n = (n << 3) + (n2 -= 48); } return n; } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * Class for converting an octal number to a decimal number. Octal numbers are based on 8, using digits from 0 to 7. * */ public final class OctalToDecimal { private static final int OCTAL_BASE = 8; private OctalToDecimal() { } /** * Converts a given octal number (as a string) to its decimal representation. * If the input is not a valid octal number (i.e., contains characters other than 0-7), * the method throws an IllegalArgumentException. * * @param inputOctal The octal number as a string * @return The decimal equivalent of the octal number * @throws IllegalArgumentException if the input is not a valid octal number */ public static int convertOctalToDecimal(String inputOctal) { if (inputOctal == null || inputOctal.isEmpty()) { throw new IllegalArgumentException(\"Input cannot be null or empty\"); } int decimalValue = 0; for (int i = 0; i < inputOctal.length(); i++) { char currentChar = inputOctal.charAt(i); if (currentChar < '0' || currentChar > '7') { throw new IllegalArgumentException(\"Incorrect input: Expecting an octal number (digits 0-7)\"); } int currentDigit = currentChar - '0'; decimalValue = decimalValue * OCTAL_BASE + currentDigit; } return decimalValue; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class OctalToHexadecimal { private OctalToHexadecimal() { } public static int octalToDecimal(String string) { if (string == null || string.isEmpty()) { throw new IllegalArgumentException(\"Input cannot be null or empty\"); } int n = 0; for (int i = 0; i < string.length(); ++i) { int n2 = string.charAt(i); if (n2 < 48 || n2 > 55) { throw new IllegalArgumentException(\"Incorrect octal digit: \" + (char)n2); } n = (n << 3) + (n2 -= 48); } return n; } public static String decimalToHexadecimal(int n) { if (n == 0) { return \"0\"; } StringBuilder stringBuilder = new StringBuilder(); while (n > 0) { int n2 = n % 16; stringBuilder.insert(0, \"0123456789ABCDEF\".charAt(n2)); n /= 16; } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * Class for converting an Octal number to its Hexadecimal equivalent. * * @author Tanmay Joshi */ public final class OctalToHexadecimal { private static final int OCTAL_BASE = 8; private static final int HEX_BASE = 16; private static final String HEX_DIGITS = \"0123456789ABCDEF\"; private OctalToHexadecimal() { } /** * Converts an Octal number (as a string) to its Decimal equivalent. * * @param octalNumber The Octal number as a string * @return The Decimal equivalent of the Octal number * @throws IllegalArgumentException if the input contains invalid octal digits */ public static int octalToDecimal(String octalNumber) { if (octalNumber == null || octalNumber.isEmpty()) { throw new IllegalArgumentException(\"Input cannot be null or empty\"); } int decimalValue = 0; for (int i = 0; i < octalNumber.length(); i++) { char currentChar = octalNumber.charAt(i); if (currentChar < '0' || currentChar > '7') { throw new IllegalArgumentException(\"Incorrect octal digit: \" + currentChar); } int currentDigit = currentChar - '0'; decimalValue = decimalValue * OCTAL_BASE + currentDigit; } return decimalValue; } /** * Converts a Decimal number to its Hexadecimal equivalent. * * @param decimalNumber The Decimal number * @return The Hexadecimal equivalent of the Decimal number */ public static String decimalToHexadecimal(int decimalNumber) { if (decimalNumber == 0) { return \"0\"; } StringBuilder hexValue = new StringBuilder(); while (decimalNumber > 0) { int digit = decimalNumber % HEX_BASE; hexValue.insert(0, HEX_DIGITS.charAt(digit)); decimalNumber /= HEX_BASE; } return hexValue.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public final class OddEvenSort implements SortAlgorithm { @Override public final Comparable[] sort(Comparable[] comparableArray) { boolean bl = false; while (!bl) { int n; Object[] objectArray = comparableArray; boolean bl2 = true; for (n = 1; n < objectArray.length - 1; n += 2) { if (!SortUtils.greater(objectArray[n], objectArray[n + 1])) continue; int n2 = n; SortUtils.swap(objectArray, n2, n2 + 1); bl2 = false; } bl = bl2; objectArray = comparableArray; bl2 = true; for (n = 0; n < objectArray.length - 1; n += 2) { if (!SortUtils.greater((Comparable)objectArray[n], (Comparable)objectArray[n + 1])) continue; int n3 = n; SortUtils.swap(objectArray, n3, n3 + 1); bl2 = false; } bl = bl2 && bl; } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * OddEvenSort class implements the SortAlgorithm interface using the odd-even sort technique. * Odd-even sort is a comparison sort related to bubble sort. * It operates by comparing all (odd, even)-indexed pairs of adjacent elements in the list and, if a pair is in the wrong order, swapping them. * The next step repeats this process for (even, odd)-indexed pairs. This process continues until the list is sorted. * */ public final class OddEvenSort implements SortAlgorithm { /** * Sorts the given array using the Odd-Even Sort algorithm. * * @param <T> the type of elements in the array, which must implement the Comparable interface * @param array the array to be sorted * @return the sorted array */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { boolean sorted = false; while (!sorted) { sorted = performOddSort(array); sorted = performEvenSort(array) && sorted; } return array; } private <T extends Comparable<T>> boolean performOddSort(T[] array) { boolean sorted = true; for (int i = 1; i < array.length - 1; i += 2) { if (SortUtils.greater(array[i], array[i + 1])) { SortUtils.swap(array, i, i + 1); sorted = false; } } return sorted; } private <T extends Comparable<T>> boolean performEvenSort(T[] array) { boolean sorted = true; for (int i = 0; i < array.length - 1; i += 2) { if (SortUtils.greater(array[i], array[i + 1])) { SortUtils.swap(array, i, i + 1); sorted = false; } } return sorted; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class OneBitDifference { private OneBitDifference() { } public static boolean differByOneBit(int n, int n2) { if (n == n2) { return false; } return ((n ^= n2) & n - 1) == 0; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class provides a method to detect if two integers * differ by exactly one bit flip. * * Example: * 1 (0001) and 2 (0010) differ by exactly one bit flip. * 7 (0111) and 3 (0011) differ by exactly one bit flip. * * @author Hardvan */ public final class OneBitDifference { private OneBitDifference() { } /** * Checks if two integers differ by exactly one bit. * * @param x the first integer * @param y the second integer * @return true if x and y differ by exactly one bit, false otherwise */ public static boolean differByOneBit(int x, int y) { if (x == y) { return false; } int xor = x ^ y; return (xor & (xor - 1)) == 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class OnesComplement { private OnesComplement() { } public static String onesComplement(String object) { if (object == null || ((String)object).isEmpty()) { throw new IllegalArgumentException(\"Input must be a non-empty binary string.\"); } StringBuilder stringBuilder = new StringBuilder(((String)object).length()); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; block4: for (int i = 0; i < n; ++i) { Object object2 = object[i]; switch (object2) { case 48: { stringBuilder.append('1'); continue block4; } case 49: { stringBuilder.append('0'); continue block4; } default: { throw new IllegalArgumentException(\"Input must contain only '0' and '1'. Found: \" + (char)object2); } } } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * @author - https://github.com/Monk-AbhinayVerma * @Wikipedia - https://en.wikipedia.org/wiki/Ones%27_complement * The class OnesComplement computes the complement of binary number * and returns * the complemented binary string. * @return the complimented binary string */ public final class OnesComplement { private OnesComplement() { } /** * Returns the 1's complement of a binary string. * * @param binary A string representing a binary number (e.g., \"1010\"). * @return A string representing the 1's complement. * @throws IllegalArgumentException if the input is null or contains characters other than '0' or '1'. */ public static String onesComplement(String binary) { if (binary == null || binary.isEmpty()) { throw new IllegalArgumentException(\"Input must be a non-empty binary string.\"); } StringBuilder complement = new StringBuilder(binary.length()); for (char bit : binary.toCharArray()) { switch (bit) { case '0' -> complement.append('1'); case '1' -> complement.append('0'); default -> throw new IllegalArgumentException(\"Input must contain only '0' and '1'. Found: \" + bit); } } return complement.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; import java.util.PriorityQueue; public final class OptimalFileMerging { private OptimalFileMerging() { } public static int minMergeCost(int[] nArray) { PriorityQueue<Integer> priorityQueue = new PriorityQueue<Integer>(); for (int n2 : nArray) { priorityQueue.add(n2); } int n = 0; while (priorityQueue.size() > 1) { int n2; int n3 = (Integer)priorityQueue.poll(); int n4 = (Integer)priorityQueue.poll(); n2 = n3 + n4; n += n2; priorityQueue.add(n2); } return n; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; import java.util.PriorityQueue; /** * Class to solve the Optimal File Merging Problem. * The goal is to minimize the cost of merging files, where the cost of merging two files is the sum of their sizes. * The cost of merging all files is the sum of the costs of merging each pair of files. * Example: * files = [4, 3, 2, 6] * The minimum cost to merge all files is 29. * Steps: * 1. Merge files 2 and 3 (cost = 2 + 3 = 5). New files = [4, 5, 6] * 2. Merge files 4 and 5 (cost = 4 + 5 = 9). New files = [6, 9] * 3. Merge files 6 and 9 (cost = 6 + 9 = 15). New files = [15] * Total cost = 5 + 9 + 15 = 29 * * @author Hardvan */ public final class OptimalFileMerging { private OptimalFileMerging() { } /** * Calculates the minimum cost to merge all files. * Steps: * 1. Add all files to a min heap. * 2. Remove the two smallest files from the heap, merge them, and add the result back to the heap. * 3. Repeat step 2 until there is only one file left in the heap. * 4. The total cost is the sum of all the costs of merging the files. * * @param files array of file sizes * @return the minimum cost to merge the files */ public static int minMergeCost(int[] files) { PriorityQueue<Integer> minHeap = new PriorityQueue<>(); for (int file : files) { minHeap.add(file); } int totalCost = 0; while (minHeap.size() > 1) { int first = minHeap.poll(); int second = minHeap.poll(); int cost = first + second; totalCost += cost; minHeap.add(cost); } return totalCost; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public class OptimalJobScheduling { private final int a; private final int b; private final int[][] c; private final int[][] d; private final int[][] e; public OptimalJobScheduling(int n, int n2, int[][] nArray, int[][] nArray2) { this.a = n; this.b = n2; this.c = nArray; this.d = nArray2; this.e = new int[n][n2]; } public void execute() { int n; int n2; OptimalJobScheduling optimalJobScheduling = this; for (n2 = 0; n2 < optimalJobScheduling.a; ++n2) { for (n = 0; n < optimalJobScheduling.b; ++n) { Object object; int[] nArray = optimalJobScheduling.e[n2]; int n3 = n; int n4 = n2; Object object2 = optimalJobScheduling; if (n4 == 0) { object = ((OptimalJobScheduling)object2).c[n4][n3]; } else { int[] nArray2 = new int[((OptimalJobScheduling)object2).b]; for (int i = 0; i < ((OptimalJobScheduling)object2).b; ++i) { nArray2[i] = ((OptimalJobScheduling)object2).e[n4 - 1][i] + ((OptimalJobScheduling)object2).d[i][n3] + ((OptimalJobScheduling)object2).c[n4][n3]; } object2 = nArray2; n4 = 0; for (n3 = 1; n3 < ((Object)object2).length; ++n3) { if (object2[n3] >= object2[n4]) continue; n4 = n3; } object = object2[n4]; } nArray[n] = object; } } optimalJobScheduling = this; for (n2 = 0; n2 < optimalJobScheduling.a; ++n2) { for (n = 0; n < optimalJobScheduling.b; ++n) { System.out.print(optimalJobScheduling.e[n2][n]); System.out.print(\" \"); } System.out.println(); } System.out.println(); } public int getCost(int n, int n2) { return this.e[n][n2]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * This class refers to the Optimal Job Scheduling problem with the following constrains: * - precedence relation between the processes * - machine pair dependent transportation delays * * https://en.wikipedia.org/wiki/Optimal_job_scheduling * * @author georgioct@csd.auth.gr */ public class OptimalJobScheduling { private final int numberProcesses; private final int numberMachines; private final int[][] run; private final int[][] transfer; private final int[][] cost; /** * Constructor of the class. * @param numberProcesses ,refers to the number of precedent processes(N) * @param numberMachines ,refers to the number of different machines in our disposal(M) * @param run , N*M matrix refers to the cost of running each process to each machine * @param transfer ,M*M symmetric matrix refers to the transportation delay for each pair of * machines */ public OptimalJobScheduling(int numberProcesses, int numberMachines, int[][] run, int[][] transfer) { this.numberProcesses = numberProcesses; this.numberMachines = numberMachines; this.run = run; this.transfer = transfer; this.cost = new int[numberProcesses][numberMachines]; } /** * Function which computes the cost of process scheduling to a number of VMs. */ public void execute() { this.calculateCost(); this.showResults(); } /** * Function which computes the cost of running each Process to each and every Machine */ private void calculateCost() { for (int i = 0; i < numberProcesses; i++) { // for each Process for (int j = 0; j < numberMachines; j++) { // for each Machine cost[i][j] = runningCost(i, j); } } } /** * Function which returns the minimum cost of running a certain Process to a certain Machine.In * order for the Machine to execute the Process ,he requires the output of the previously * executed Process, which may have been executed to the same Machine or some other.If the * previous Process has been executed to another Machine,we have to transfer her result, which * means extra cost for transferring the data from one Machine to another(if the previous * Process has been executed to the same Machine, there is no transport cost). * * @param process ,refers to the Process * @param machine ,refers to the Machine * @return the minimum cost of executing the process to the certain machine. */ private int runningCost(int process, int machine) { if (process == 0) { // refers to the first process,which does not require for a previous one // to have been executed return run[process][machine]; } else { int[] runningCosts = new int[numberMachines]; // stores the costs of executing our Process depending on // the Machine the previous one was executed for (int k = 0; k < numberMachines; k++) { // computes the cost of executing the previous // process to each and every Machine runningCosts[k] = cost[process - 1][k] + transfer[k][machine] + run[process][machine]; // transferring the result to our Machine and executing // the Process to our Machine } return findMin(runningCosts); // returns the minimum running cost } } /** * Function used in order to return the minimum Cost. * @param costArr ,an Array of size M which refers to the costs of executing a Process to each * Machine * @return the minimum cost */ private int findMin(int[] costArr) { int min = 0; for (int i = 1; i < costArr.length; i++) { if (costArr[i] < costArr[min]) { min = i; } } return costArr[min]; } /** * Method used in order to present the overall costs. */ private void showResults() { for (int i = 0; i < numberProcesses; i++) { for (int j = 0; j < numberMachines; j++) { System.out.print(cost[i][j]); System.out.print(\" \"); } System.out.println(); } System.out.println(); } /** * Getter for the running Cost of i process on j machine. */ public int getCost(int process, int machine) { return cost[process][machine]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; public final class OrderAgnosticBinarySearch { private OrderAgnosticBinarySearch() { } }", "deobfuscated_code": "package com.thealgorithms.searches; // URL: https://www.geeksforgeeks.org/order-agnostic-binary-search/ /* Order Agnostic Binary Search is an algorithm where we do not know whether the given sorted array is ascending or descending order. We declare a boolean variable to find whether the array is ascending order. In the while loop, we use the two pointer method (start and end) to get the middle element. if the middle element is equal to our target element, then that is the answer. If not, then we check if the array is ascending or descending order. Depending upon the condition, respective statements will be executed and we will get our answer. */ public final class OrderAgnosticBinarySearch { private OrderAgnosticBinarySearch() { } static int binSearchAlgo(int[] arr, int start, int end, int target) { // Checking whether the given array is ascending order boolean ascOrd = arr[start] < arr[end]; while (start <= end) { int middle = start + (end - start) / 2; // Check if the desired element is present at the middle position if (arr[middle] == target) { return middle; // returns the index of the middle element } if (ascOrd) { // Ascending order if (arr[middle] < target) { start = middle + 1; } else { end = middle - 1; } } else { // Descending order if (arr[middle] > target) { start = middle + 1; } else { end = middle - 1; } } } // Element is not present return -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.crdt; import java.util.Map; class PNCounter { private final Map a; private final Map b; private final int c; private final int d; public void increment() { Integer.valueOf(this.c); Integer.valueOf(this.c); throw new NullPointerException(); } public void decrement() { Integer.valueOf(this.c); Integer.valueOf(this.c); throw new NullPointerException(); } public int value() { throw new NullPointerException(); } public boolean compare(PNCounter pNCounter) { int cfr_ignored_0 = pNCounter.d; return true; } public void merge(PNCounter pNCounter) { int cfr_ignored_0 = pNCounter.d; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.crdt; import java.util.HashMap; import java.util.Map; /** * PN-Counter (Positive-Negative Counter) is a state-based CRDT (Conflict-free Replicated Data Type) * designed for tracking counts with both increments and decrements in a distributed and concurrent environment. * It combines two G-Counters, one for increments (P) and one for decrements (N). * The total count is obtained by subtracting the value of the decrement counter from the increment counter. * This implementation supports incrementing, decrementing, querying the total count, * comparing with other PN-Counters, and merging with another PN-Counter * to compute the element-wise maximum for both increment and decrement counters. * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) * * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah) */ class PNCounter { private final Map<Integer, Integer> pCounter; private final Map<Integer, Integer> nCounter; private final int myId; private final int n; /** * Constructs a PN-Counter for a cluster of n nodes. * * @param myId The identifier of the current node. * @param n The number of nodes in the cluster. */ PNCounter(int myId, int n) { this.myId = myId; this.n = n; this.pCounter = new HashMap<>(); this.nCounter = new HashMap<>(); for (int i = 0; i < n; i++) { pCounter.put(i, 0); nCounter.put(i, 0); } } /** * Increments the increment counter for the current node. */ public void increment() { pCounter.put(myId, pCounter.get(myId) + 1); } /** * Increments the decrement counter for the current node. */ public void decrement() { nCounter.put(myId, nCounter.get(myId) + 1); } /** * Gets the total value of the counter by subtracting the decrement counter from the increment counter. * * @return The total value of the counter. */ public int value() { int sumP = pCounter.values().stream().mapToInt(Integer::intValue).sum(); int sumN = nCounter.values().stream().mapToInt(Integer::intValue).sum(); return sumP - sumN; } /** * Compares the state of this PN-Counter with another PN-Counter. * * @param other The other PN-Counter to compare with. * @return True if the state of this PN-Counter is less than or equal to the state of the other PN-Counter. */ public boolean compare(PNCounter other) { if (this.n != other.n) { throw new IllegalArgumentException(\"Cannot compare PN-Counters with different number of nodes\"); } for (int i = 0; i < n; i++) { if (this.pCounter.get(i) > other.pCounter.get(i) && this.nCounter.get(i) > other.nCounter.get(i)) { return false; } } return true; } /** * Merges the state of this PN-Counter with another PN-Counter. * * @param other The other PN-Counter to merge with. */ public void merge(PNCounter other) { if (this.n != other.n) { throw new IllegalArgumentException(\"Cannot merge PN-Counters with different number of nodes\"); } for (int i = 0; i < n; i++) { this.pCounter.put(i, Math.max(this.pCounter.get(i), other.pCounter.get(i))); this.nCounter.put(i, Math.max(this.nCounter.get(i), other.nCounter.get(i))); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Scanner; class PageRank { public int[][] path = new int[10][10]; public double[] pagerank = new double[10]; PageRank() { } public static void main(String[] stringArray) { Scanner scanner = new Scanner(System.in); System.out.print(\"Enter the Number of WebPages: \"); int n = scanner.nextInt(); PageRank pageRank = new PageRank(); System.out.println(\"Enter the Adjacency Matrix with 1->PATH & 0->NO PATH Between two WebPages: \"); for (int i = 1; i <= n; ++i) { for (int j = 1; j <= n; ++j) { pageRank.path[i][j] = scanner.nextInt(); if (j != i) continue; pageRank.path[i][j] = 0; } } pageRank.calc(n); } public void calc(double d) { double[] dArray = new double[10]; int n = 1; double d2 = 1.0 / d; System.out.printf(\" Total Number of Nodes :\" + d + \"\\t Initial PageRank of All Nodes :\" + d2 + \"\\n\", new Object[0]); int n2 = 1; while ((double)n2 <= d) { this.pagerank[n2] = d2; ++n2; } System.out.print(\"\\n Initial PageRank Values , 0th Step \\n\"); n2 = 1; while ((double)n2 <= d) { System.out.printf(\" Page Rank of \" + n2 + \" is :\\t\" + this.pagerank[n2] + \"\\n\", new Object[0]); ++n2; } while (n <= 2) { n2 = 1; while ((double)n2 <= d) { dArray[n2] = this.pagerank[n2]; this.pagerank[n2] = 0.0; ++n2; } int n3 = 1; while ((double)n3 <= d) { int n4 = 1; while ((double)n4 <= d) { if (this.path[n4][n3] == 1) { n2 = 1; double d3 = 0.0; while ((double)n2 <= d) { if (this.path[n4][n2] == 1) { d3 += 1.0; } ++n2; } int n5 = n3; this.pagerank[n5] = this.pagerank[n5] + dArray[n4] * (1.0 / d3); } ++n4; } System.out.printf(\"\\n After \" + n + \"th Step \\n\", new Object[0]); n2 = 1; while ((double)n2 <= d) { System.out.printf(\" Page Rank of \" + n2 + \" is :\\t\" + this.pagerank[n2] + \"\\n\", new Object[0]); ++n2; } ++n; ++n3; } n2 = 1; while ((double)n2 <= d) { this.pagerank[n2] = 0.15000000000000002 + 0.85 * this.pagerank[n2]; ++n2; } System.out.print(\"\\n Final Page Rank : \\n\"); n2 = 1; while ((double)n2 <= d) { System.out.printf(\" Page Rank of \" + n2 + \" is :\\t\" + this.pagerank[n2] + \"\\n\", new Object[0]); ++n2; } } } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Scanner; class PageRank { public static void main(String[] args) { int nodes; int i; int j; Scanner in = new Scanner(System.in); System.out.print(\"Enter the Number of WebPages: \"); nodes = in.nextInt(); PageRank p = new PageRank(); System.out.println(\"Enter the Adjacency Matrix with 1->PATH & 0->NO PATH Between two WebPages: \"); for (i = 1; i <= nodes; i++) { for (j = 1; j <= nodes; j++) { p.path[i][j] = in.nextInt(); if (j == i) { p.path[i][j] = 0; } } } p.calc(nodes); } public int[][] path = new int[10][10]; public double[] pagerank = new double[10]; public void calc(double totalNodes) { double initialPageRank; double outgoingLinks = 0; double dampingFactor = 0.85; double[] tempPageRank = new double[10]; int externalNodeNumber; int internalNodeNumber; int k = 1; // For Traversing int iterationStep = 1; initialPageRank = 1 / totalNodes; System.out.printf(\" Total Number of Nodes :\" + totalNodes + \"\\t Initial PageRank of All Nodes :\" + initialPageRank + \"\\n\"); // 0th ITERATION _ OR _ INITIALIZATION PHASE // for (k = 1; k <= totalNodes; k++) { this.pagerank[k] = initialPageRank; } System.out.print(\"\\n Initial PageRank Values , 0th Step \\n\"); for (k = 1; k <= totalNodes; k++) { System.out.printf(\" Page Rank of \" + k + \" is :\\t\" + this.pagerank[k] + \"\\n\"); } while (iterationStep <= 2) { // Iterations // Store the PageRank for All Nodes in Temporary Array for (k = 1; k <= totalNodes; k++) { tempPageRank[k] = this.pagerank[k]; this.pagerank[k] = 0; } for (internalNodeNumber = 1; internalNodeNumber <= totalNodes; internalNodeNumber++) { for (externalNodeNumber = 1; externalNodeNumber <= totalNodes; externalNodeNumber++) { if (this.path[externalNodeNumber][internalNodeNumber] == 1) { k = 1; outgoingLinks = 0; // Count the Number of Outgoing Links for each externalNodeNumber while (k <= totalNodes) { if (this.path[externalNodeNumber][k] == 1) { outgoingLinks = outgoingLinks + 1; // Counter for Outgoing Links } k = k + 1; } // Calculate PageRank this.pagerank[internalNodeNumber] += tempPageRank[externalNodeNumber] * (1 / outgoingLinks); } } System.out.printf(\"\\n After \" + iterationStep + \"th Step \\n\"); for (k = 1; k <= totalNodes; k++) { System.out.printf(\" Page Rank of \" + k + \" is :\\t\" + this.pagerank[k] + \"\\n\"); } iterationStep = iterationStep + 1; } // Add the Damping Factor to PageRank for (k = 1; k <= totalNodes; k++) { this.pagerank[k] = (1 - dampingFactor) + dampingFactor * this.pagerank[k]; } // Display PageRank System.out.print(\"\\n Final Page Rank : \\n\"); for (k = 1; k <= totalNodes; k++) { System.out.printf(\" Page Rank of \" + k + \" is :\\t\" + this.pagerank[k] + \"\\n\"); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; final class Palindrome { private Palindrome() { } public static boolean isPalindrome(String string) { return string == null || string.length() <= 1 || string.equals(new StringBuilder(string).reverse().toString()); } public static boolean isPalindromeRecursion(String string) { while (string != null && string.length() > 1) { String string2 = string; if (string.charAt(0) != string2.charAt(string2.length() - 1)) { return false; } string = string.substring(1, string.length() - 1); } return true; } public static boolean isPalindromeTwoPointer(String string) { if (string == null || string.length() <= 1) { return true; } int n = 0; for (int i = string.length() - 1; n < i; ++n, --i) { if (string.charAt(n) == string.charAt(i)) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * Wikipedia: https://en.wikipedia.org/wiki/Palindrome */ final class Palindrome { private Palindrome() { } /** * Check if a string is palindrome string or not using String Builder * * @param s a string to check * @return {@code true} if given string is palindrome, otherwise * {@code false} */ public static boolean isPalindrome(String s) { return ((s == null || s.length() <= 1) || s.equals(new StringBuilder(s).reverse().toString())); } /** * Check if a string is palindrome string or not using recursion * * @param s a string to check * @return {@code true} if given string is palindrome, otherwise * {@code false} */ public static boolean isPalindromeRecursion(String s) { if (s == null || s.length() <= 1) { return true; } if (s.charAt(0) != s.charAt(s.length() - 1)) { return false; } return isPalindromeRecursion(s.substring(1, s.length() - 1)); } /** * Check if a string is palindrome string or not using two pointer technique * * @param s a string to check * @return {@code true} if given string is palindrome, otherwise * {@code false} */ public static boolean isPalindromeTwoPointer(String s) { if (s == null || s.length() <= 1) { return true; } for (int i = 0, j = s.length() - 1; i < j; ++i, --j) { if (s.charAt(i) != s.charAt(j)) { return false; } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class PalindromeNumber { private PalindromeNumber() { } public static boolean isPalindrome(int n) { if (n < 0) { throw new IllegalArgumentException(\"Input parameter must not be negative!\"); } int n2 = 0; for (int i = n; i != 0; i /= 10) { int n3 = i % 10; n2 = n2 * 10 + n3; } return n == n2; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class PalindromeNumber { private PalindromeNumber() { } /** * Check if {@code n} is palindrome number or not * * @param number the number * @return {@code true} if {@code n} is palindrome number, otherwise * {@code false} */ public static boolean isPalindrome(int number) { if (number < 0) { throw new IllegalArgumentException(\"Input parameter must not be negative!\"); } int numberCopy = number; int reverseNumber = 0; while (numberCopy != 0) { int remainder = numberCopy % 10; reverseNumber = reverseNumber * 10 + remainder; numberCopy /= 10; } return number == reverseNumber; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import java.util.ArrayList; import java.util.List; public final class PalindromePrime { private PalindromePrime() { } public static boolean prime(int n) { if (n < 2) { return false; } if (n == 2) { return true; } if (n % 2 == 0) { return false; } int n2 = 3; while ((double)n2 <= Math.sqrt(n)) { if (n % n2 == 0) { return false; } n2 += 2; } return true; } public static int reverse(int n) { int n2 = 0; while (n != 0) { n2 = n2 * 10 + n % 10; n /= 10; } return n2; } public static List generatePalindromePrimes(int n) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); if (n <= 0) { return arrayList; } arrayList.add(2); int n2 = 1; int n3 = 3; while (n2 < n) { int n4 = n3; if (n4 == PalindromePrime.reverse(n4) && PalindromePrime.prime(n3)) { arrayList.add(n3); ++n2; } n3 += 2; } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.misc; import java.util.ArrayList; import java.util.List; public final class PalindromePrime { private PalindromePrime() { } public static boolean prime(int num) { if (num < 2) { return false; // Handle edge case for numbers < 2 } if (num == 2) { return true; // 2 is prime } if (num % 2 == 0) { return false; // Even numbers > 2 are not prime } for (int divisor = 3; divisor <= Math.sqrt(num); divisor += 2) { if (num % divisor == 0) { return false; } } return true; } public static int reverse(int n) { int reverse = 0; while (n != 0) { reverse = reverse * 10 + (n % 10); n /= 10; } return reverse; } public static List<Integer> generatePalindromePrimes(int n) { List<Integer> palindromicPrimes = new ArrayList<>(); if (n <= 0) { return palindromicPrimes; // Handle case for 0 or negative input } palindromicPrimes.add(2); // 2 is the first palindromic prime int count = 1; int num = 3; while (count < n) { if (num == reverse(num) && prime(num)) { palindromicPrimes.add(num); count++; } num += 2; // Skip even numbers } return palindromicPrimes; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; class PalindromeSinglyLinkedList$Node { int a; PalindromeSinglyLinkedList$Node b; }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; class PalindromeSinglyLinkedList$Node { int a; PalindromeSinglyLinkedList$Node b; }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import com.thealgorithms.misc.PalindromeSinglyLinkedList$Node; import java.util.Stack; public final class PalindromeSinglyLinkedList { private PalindromeSinglyLinkedList() { } public static boolean isPalindrome(Iterable iterable) { Stack stack = new Stack(); for (Object t : iterable) { stack.push(t); } for (Object t : iterable) { if (t == stack.pop()) continue; return false; } return true; } public static boolean isPalindromeOptimised(PalindromeSinglyLinkedList$Node palindromeSinglyLinkedList$Node) { if (palindromeSinglyLinkedList$Node == null || palindromeSinglyLinkedList$Node.b == null) { return true; } PalindromeSinglyLinkedList$Node palindromeSinglyLinkedList$Node2 = palindromeSinglyLinkedList$Node; PalindromeSinglyLinkedList$Node palindromeSinglyLinkedList$Node3 = palindromeSinglyLinkedList$Node; while (palindromeSinglyLinkedList$Node3 != null && palindromeSinglyLinkedList$Node3.b != null) { palindromeSinglyLinkedList$Node2 = palindromeSinglyLinkedList$Node2.b; palindromeSinglyLinkedList$Node3 = palindromeSinglyLinkedList$Node3.b.b; } palindromeSinglyLinkedList$Node3 = null; while (palindromeSinglyLinkedList$Node2 != null) { PalindromeSinglyLinkedList$Node palindromeSinglyLinkedList$Node4 = palindromeSinglyLinkedList$Node2.b; palindromeSinglyLinkedList$Node2.b = palindromeSinglyLinkedList$Node3; palindromeSinglyLinkedList$Node3 = palindromeSinglyLinkedList$Node2; palindromeSinglyLinkedList$Node2 = palindromeSinglyLinkedList$Node4; } palindromeSinglyLinkedList$Node2 = palindromeSinglyLinkedList$Node3; while (palindromeSinglyLinkedList$Node != null && palindromeSinglyLinkedList$Node2 != null) { int cfr_ignored_0 = palindromeSinglyLinkedList$Node.a; int cfr_ignored_1 = palindromeSinglyLinkedList$Node2.a; palindromeSinglyLinkedList$Node2 = palindromeSinglyLinkedList$Node2.b; palindromeSinglyLinkedList$Node = palindromeSinglyLinkedList$Node.b; } return true; } }", "deobfuscated_code": "package com.thealgorithms.misc; import java.util.Stack; /** * A simple way of knowing if a singly linked list is palindrome is to push all * the values into a Stack and then compare the list to popped vales from the * Stack. * * See more: * https://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/ */ @SuppressWarnings(\"rawtypes\") public final class PalindromeSinglyLinkedList { private PalindromeSinglyLinkedList() { } public static boolean isPalindrome(final Iterable linkedList) { var linkedListValues = new Stack<>(); for (final var x : linkedList) { linkedListValues.push(x); } for (final var x : linkedList) { if (x != linkedListValues.pop()) { return false; } } return true; } // Optimised approach with O(n) time complexity and O(1) space complexity public static boolean isPalindromeOptimised(Node head) { if (head == null || head.next == null) { return true; } Node slow = head; Node fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; } Node midNode = slow; Node prevNode = null; Node currNode = midNode; Node nextNode; while (currNode != null) { nextNode = currNode.next; currNode.next = prevNode; prevNode = currNode; currNode = nextNode; } Node left = head; Node right = prevNode; while (left != null && right != null) { if (left.val != right.val) { return false; } right = right.next; left = left.next; } return true; } static class Node { int val; Node next; Node(int val) { this.val = val; this.next = null; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.LinkedList; public class PalindromeWithStack { private LinkedList a = new LinkedList(); public boolean checkPalindrome(String string) { StringBuilder stringBuilder = new StringBuilder(string.length()); string = string.toLowerCase(); for (int i = 0; i < string.length(); ++i) { char c = string.charAt(i); stringBuilder.append(c); this.a.push(Character.valueOf(c)); } StringBuilder stringBuilder2 = new StringBuilder(this.a.size()); while (!this.a.isEmpty()) { stringBuilder2.append(this.a.pop()); } return stringBuilder2.toString().equals(stringBuilder.toString()); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.LinkedList; /** * A class that implements a palindrome checker using a stack. * The stack is used to store the characters of the string, * which we will pop one-by-one to create the string in reverse. * * Reference: https://www.geeksforgeeks.org/check-whether-the-given-string-is-palindrome-using-stack/ */ public class PalindromeWithStack { private LinkedList<Character> stack; /** * Constructs an empty stack that stores characters. */ public PalindromeWithStack() { stack = new LinkedList<Character>(); } /** * Check if the string is a palindrome or not. * Convert all characters to lowercase and push them into a stack. * At the same time, build a string * Next, pop from the stack and build the reverse string * Finally, compare these two strings * * @param string The string to check if it is palindrome or not. */ public boolean checkPalindrome(String string) { // Create a StringBuilder to build the string from left to right StringBuilder stringBuilder = new StringBuilder(string.length()); // Convert all characters to lowercase String lowercase = string.toLowerCase(); // Iterate through the string for (int i = 0; i < lowercase.length(); ++i) { char c = lowercase.charAt(i); // Build the string from L->R stringBuilder.append(c); // Push to the stack stack.push(c); } // The stack contains the reverse order of the string StringBuilder reverseString = new StringBuilder(stack.size()); // Until the stack is not empty while (!stack.isEmpty()) { // Build the string from R->L reverseString.append(stack.pop()); } // Finally, compare the L->R string with the R->L string return reverseString.toString().equals(stringBuilder.toString()); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class PalindromicPartitioning { private PalindromicPartitioning() { } public static int minimalPartitions(String string) { int n; int n2; int n3 = string.length(); int[] nArray = new int[n3]; int n4 = n3; boolean[][] blArray = new boolean[n4][n4]; for (n2 = 0; n2 < n3; ++n2) { blArray[n2][n2] = true; } for (int i = 2; i <= n3; ++i) { for (n2 = 0; n2 < n3 - i + 1; ++n2) { n = n2 + i - 1; blArray[n2][n] = i == 2 ? string.charAt(n2) == string.charAt(n) : string.charAt(n2) == string.charAt(n) && blArray[n2 + 1][n - 1]; } } for (n2 = 0; n2 < n3; ++n2) { if (blArray[0][n2]) { nArray[n2] = 0; continue; } nArray[n2] = Integer.MAX_VALUE; for (n = 0; n < n2; ++n) { if (!blArray[n + 1][n2] || 1 + nArray[n] >= nArray[n2]) continue; nArray[n2] = 1 + nArray[n]; } } return nArray[n3 - 1]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Provides functionality to solve the Palindrome Partitioning II problem, which involves finding * the minimum number of partitions needed to divide a given string into palindromic substrings. * * <p> * The problem is solved using dynamic programming. The approach involves checking all possible * substrings and determining whether they are palindromes. The minimum number of cuts required * for palindrome partitioning is computed in a bottom-up manner. * </p> * * <p> * Example: * <ul> * <li>Input: \"nitik\" => Output: 2 (Partitioning: \"n | iti | k\")</li> * <li>Input: \"ababbbabbababa\" => Output: 3 (Partitioning: \"aba | b | bbabb | ababa\")</li> * </ul> * </p> * * @see <a href=\"https://leetcode.com/problems/palindrome-partitioning-ii/\">Palindrome Partitioning II</a> * @see <a href=\"https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/\">Palindrome Partitioning (GeeksforGeeks)</a> */ public final class PalindromicPartitioning { private PalindromicPartitioning() { } public static int minimalPartitions(String word) { int len = word.length(); /* We Make two arrays to create a bottom-up solution. minCuts[i] = Minimum number of cuts needed for palindrome partitioning of substring word[0..i] isPalindrome[i][j] = true if substring str[i..j] is palindrome Base Condition: C[i] is 0 if P[0][i]= true */ int[] minCuts = new int[len]; boolean[][] isPalindrome = new boolean[len][len]; int i; int j; int subLen; // different looping variables // Every substring of length 1 is a palindrome for (i = 0; i < len; i++) { isPalindrome[i][i] = true; } /* subLen is substring length. Build the solution in bottom up manner by considering all * substrings of length starting from 2 to n. */ for (subLen = 2; subLen <= len; subLen++) { // For substring of length subLen, set different possible starting indexes for (i = 0; i < len - subLen + 1; i++) { j = i + subLen - 1; // Ending index // If subLen is 2, then we just need to // compare two characters. Else need to // check two corner characters and value // of P[i+1][j-1] if (subLen == 2) { isPalindrome[i][j] = (word.charAt(i) == word.charAt(j)); } else { isPalindrome[i][j] = (word.charAt(i) == word.charAt(j)) && isPalindrome[i + 1][j - 1]; } } } // We find the minimum for each index for (i = 0; i < len; i++) { if (isPalindrome[0][i]) { minCuts[i] = 0; } else { minCuts[i] = Integer.MAX_VALUE; for (j = 0; j < i; j++) { if (isPalindrome[j + 1][i] && 1 + minCuts[j] < minCuts[i]) { minCuts[i] = 1 + minCuts[j]; } } } } // Return the min cut value for complete // string. i.e., str[0..n-1] return minCuts[len - 1]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class PancakeSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length < 2) { return comparableArray; } for (int i = 0; i < comparableArray.length; ++i) { int n = i; Comparable[] comparableArray2 = comparableArray; Comparable comparable = comparableArray[0]; int n2 = 0; for (int j = 0; j < comparableArray2.length - n; ++j) { if (!SortUtils.less(comparable, comparableArray2[j])) continue; comparable = comparableArray2[j]; n2 = j; } int n3 = n2; SortUtils.flip(comparableArray, n3, comparableArray.length - 1 - i); } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * Implementation of pancake sort * * @author Podshivalov Nikita (https://github.com/nikitap492) * @since 2018-04-10 */ public class PancakeSort implements SortAlgorithm { @Override public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length < 2) { return array; } for (int currentSize = 0; currentSize < array.length; currentSize++) { int maxIndex = findMaxIndex(array, currentSize); SortUtils.flip(array, maxIndex, array.length - 1 - currentSize); } return array; } /** * Finds the index of the maximum element in the array up to the given size. * * @param array the array to be searched * @param currentSize the current size of the unsorted portion of the array * @param <T> the type of elements in the array * @return the index of the maximum element */ private <T extends Comparable<T>> int findMaxIndex(T[] array, int currentSize) { T max = array[0]; int maxIndex = 0; for (int i = 0; i < array.length - currentSize; i++) { if (SortUtils.less(max, array[i])) { max = array[i]; maxIndex = i; } } return maxIndex; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.HashSet; public final class Pangram { private Pangram() { } public static void main(String[] stringArray) { assert (Pangram.isPangram(\"The quick brown fox jumps over the lazy dog\")); assert (!Pangram.isPangram(\"The quick brown fox jumps over the azy dog\")); assert (!Pangram.isPangram(\"+-1234 This string is not alphabetical\")); assert (!Pangram.isPangram(\"\\u0000/\\\\\")); } public static boolean isPangramUsingSet(String string) { HashSet<Character> hashSet = new HashSet<Character>(); string = string.trim().toLowerCase(); for (int i = 0; i < string.length(); ++i) { if (string.charAt(i) == ' ') continue; hashSet.add(Character.valueOf(string.charAt(i))); } return hashSet.size() == 26; } public static boolean isPangram(String object) { Object object2; int n; boolean[] blArray = new boolean[26]; char[] cArray = ((String)object).toCharArray(); object = cArray; int n2 = cArray.length; for (n = 0; n < n2; ++n) { if ((object2 -= Character.isUpperCase((char)(object2 = object[n])) ? 65 : 97) < 0 || object2 >= blArray.length) continue; blArray[object2] = true; } object = blArray; int cfr_ignored_0 = blArray.length; for (n = 0; n < 26; ++n) { object2 = object[n]; if (object2 != false) continue; return false; } return true; } public static boolean isPangram2(String string) { if (string.length() < 26) { return false; } string = string.toLowerCase(); for (int n = 97; n <= 122; n = (int)((char)(n + 1))) { if (string.indexOf(n) != -1) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.HashSet; /** * Wikipedia: https://en.wikipedia.org/wiki/Pangram */ public final class Pangram { private Pangram() { } /** * Test code */ public static void main(String[] args) { assert isPangram(\"The quick brown fox jumps over the lazy dog\"); assert !isPangram(\"The quick brown fox jumps over the azy dog\"); // L is missing assert !isPangram(\"+-1234 This string is not alphabetical\"); assert !isPangram(\"\\u0000/\\\\\"); } /** * Checks if a String is considered a Pangram * * @param s The String to check * @return {@code true} if s is a Pangram, otherwise {@code false} */ // alternative approach using Java Collection Framework public static boolean isPangramUsingSet(String s) { HashSet<Character> alpha = new HashSet<>(); s = s.trim().toLowerCase(); for (int i = 0; i < s.length(); i++) { if (s.charAt(i) != ' ') { alpha.add(s.charAt(i)); } } return alpha.size() == 26; } /** * Checks if a String is considered a Pangram * * @param s The String to check * @return {@code true} if s is a Pangram, otherwise {@code false} */ public static boolean isPangram(String s) { boolean[] lettersExisting = new boolean[26]; for (char c : s.toCharArray()) { int letterIndex = c - (Character.isUpperCase(c) ? 'A' : 'a'); if (letterIndex >= 0 && letterIndex < lettersExisting.length) { lettersExisting[letterIndex] = true; } } for (boolean letterFlag : lettersExisting) { if (!letterFlag) { return false; } } return true; } /** * Checks if a String is Pangram or not by checking if each alhpabet is present or not * * @param s The String to check * @return {@code true} if s is a Pangram, otherwise {@code false} */ public static boolean isPangram2(String s) { if (s.length() < 26) { return false; } s = s.toLowerCase(); // Converting s to Lower-Case for (char i = 'a'; i <= 'z'; i++) { if (s.indexOf(i) == -1) { return false; // if any alphabet is not present, return false } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.List; public final class ParenthesesGenerator { private ParenthesesGenerator() { } public static List generateParentheses(int n) { if (n < 0) { throw new IllegalArgumentException(\"The number of pairs of parentheses cannot be negative\"); } ArrayList arrayList = new ArrayList(); ParenthesesGenerator.a(arrayList, \"\", 0, 0, n); return arrayList; } private static void a(List list, String object, int n, int n2, int n3) { while (true) { if (((String)object).length() == n3 << 1) { list.add(object); return; } if (n < n3) { ParenthesesGenerator.a(list, (String)object + \"(\", n + 1, n2, n3); } if (n2 >= n) break; ++n2; object = (String)object + \")\"; } } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.List; /** * This class generates all valid combinations of parentheses for a given number of pairs using backtracking. */ public final class ParenthesesGenerator { private ParenthesesGenerator() { } /** * Generates all valid combinations of parentheses for a given number of pairs. * * @param n The number of pairs of parentheses. * @return A list of strings representing valid combinations of parentheses. * @throws IllegalArgumentException if n is less than 0. */ public static List<String> generateParentheses(final int n) { if (n < 0) { throw new IllegalArgumentException(\"The number of pairs of parentheses cannot be negative\"); } List<String> result = new ArrayList<>(); generateParenthesesHelper(result, \"\", 0, 0, n); return result; } /** * Helper function for generating all valid combinations of parentheses recursively. * * @param result The list to store valid combinations. * @param current The current combination being formed. * @param open The number of open parentheses. * @param close The number of closed parentheses. * @param n The total number of pairs of parentheses. */ private static void generateParenthesesHelper(List<String> result, final String current, final int open, final int close, final int n) { if (current.length() == n * 2) { result.add(current); return; } if (open < n) { generateParenthesesHelper(result, current + \"(\", open + 1, close, n); } if (close < open) { generateParenthesesHelper(result, current + \")\", open, close + 1, n); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class ParityCheck { private ParityCheck() { } public static boolean checkParity(int n) { int n2 = 0; while (n > 0) { n2 += n & 1; n >>= 1; } return n2 % 2 == 0; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * The ParityCheck class provides a method to check the parity of a given number. * <p> * Parity is a mathematical term that describes the property of an integer's binary representation. * The parity of a binary number is the number of 1s in its binary representation. * If the number of 1s is even, the parity is even; otherwise, it is odd. * <p> * For example, the binary representation of 5 is 101, which has two 1s, so the parity of 5 is even. * The binary representation of 6 is 110, which has two 1s, so the parity of 6 is even. * The binary representation of 7 is 111, which has three 1s, so the parity of 7 is odd. * * @author Hardvan */ public final class ParityCheck { private ParityCheck() { } /** * This method checks the parity of the given number. * * @param n the number to check the parity of * @return true if the number has even parity, false otherwise */ public static boolean checkParity(int n) { int count = 0; while (n > 0) { count += n & 1; n >>= 1; } return count % 2 == 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class ParseInteger { private ParseInteger() { } public static int parseInt(String string) { String string2 = string; if (string2 == null) { throw new NumberFormatException(\"Input parameter must not be null!\"); } if (string2.isEmpty()) { throw new NumberFormatException(\"Input parameter must not be empty!\"); } boolean bl = string.charAt(0) == '-'; int n = string.charAt(0) == '+' ? 1 : 0; int n2 = 0; int n3 = string.length(); for (n = bl || n != 0 ? 1 : 0; n < n3; ++n) { string2 = string; int n4 = n; if (!Character.isDigit(string2.charAt(n4))) { throw new NumberFormatException(\"Input parameter of incorrect format: \" + string2); } char c = string.charAt(n); n2 = n2 * 10 + (c - 48); } if (bl) { return -n2; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class ParseInteger { private ParseInteger() { } private static void checkInput(final String s) { if (s == null) { throw new NumberFormatException(\"Input parameter must not be null!\"); } if (s.isEmpty()) { throw new NumberFormatException(\"Input parameter must not be empty!\"); } } private static void checkDigitAt(final String s, final int pos) { if (!Character.isDigit(s.charAt(pos))) { throw new NumberFormatException(\"Input parameter of incorrect format: \" + s); } } private static int digitToInt(final char digit) { return digit - '0'; } /** * Parse a string to integer * * @param s the string * @return the integer value represented by the argument in decimal. * @throws NumberFormatException if the {@code string} does not contain a * parsable integer. */ public static int parseInt(final String s) { checkInput(s); final boolean isNegative = s.charAt(0) == '-'; final boolean isPositive = s.charAt(0) == '+'; int number = 0; for (int i = isNegative || isPositive ? 1 : 0, length = s.length(); i < length; ++i) { checkDigitAt(s, i); number = number * 10 + digitToInt(s.charAt(i)); } return isNegative ? -number : number; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import com.thealgorithms.dynamicprogramming.SubsetSum; import java.util.Arrays; public final class PartitionProblem { private PartitionProblem() { } public static boolean partition(int[] nArray) { int n = Arrays.stream(nArray).sum(); return (n & 1) == 0 && SubsetSum.subsetSum(nArray, n / 2); } }", "deobfuscated_code": "/** * @author Md Asif Joardar * * Description: The partition problem is a classic problem in computer science * that asks whether a given set can be partitioned into two subsets such that * the sum of elements in each subset is the same. * * Example: * Consider nums = {1, 2, 3} * We can split the array \"nums\" into two partitions, where each having a sum of 3. * nums1 = {1, 2} * nums2 = {3} * * The time complexity of the solution is O(n  sum) and requires O(n  sum) space */ package com.thealgorithms.dynamicprogramming; import java.util.Arrays; public final class PartitionProblem { private PartitionProblem() { } /** * Test if a set of integers can be partitioned into two subsets such that the sum of elements * in each subset is the same. * * @param nums the array contains integers. * @return {@code true} if two subset exists, otherwise {@code false}. */ public static boolean partition(int[] nums) { // calculate the sum of all the elements in the array int sum = Arrays.stream(nums).sum(); // it will return true if the sum is even and the array can be divided into two // subarrays/subset with equal sum. and here i reuse the SubsetSum class from dynamic // programming section to check if there is exists a subsetsum into nums[] array same as the // given sum return (sum & 1) == 0 && SubsetSum.subsetSum(nums, sum / 2); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class PascalTriangle { private PascalTriangle() { } public static int[][] pascal(int n) { int n2 = n; int[][] nArray = new int[n2][n2]; for (int i = 0; i < n; ++i) { for (int j = 0; j <= i; ++j) { nArray[i][j] = i == j || j == 0 ? 1 : nArray[i - 1][j - 1] + nArray[i - 1][j]; } } return nArray; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class PascalTriangle { private PascalTriangle() { } /** *In mathematics, Pascal's triangle is a triangular array of the binomial coefficients that *arises in probability theory, combinatorics, and algebra. In much of the Western world, it is *named after the French mathematician Blaise Pascal, although other mathematicians studied it *centuries before him in India, Persia, China, Germany, and Italy. * * The rows of Pascal's triangle are conventionally enumerated starting with row n=0 at the top *(the 0th row). The entries in each row are numbered from the left beginning with k=0 and are *usually staggered relative to the numbers in the adjacent rows. The triangle may be *constructed in the following manner: In row 0 (the topmost row), there is a unique nonzero *entry 1. Each entry of each subsequent row is constructed by adding the number above and to *the left with the number above and to the right, treating blank entries as 0. For example, the *initial number in the first (or any other) row is 1 (the sum of 0 and 1), whereas the numbers *1 and 3 in the third row are added to produce the number 4 in the fourth row. * * *<p> * link:-https://en.wikipedia.org/wiki/Pascal%27s_triangle * * <p> * Example:- * 1 * 1 1 * 1 2 1 * 1 3 3 1 * 1 4 6 4 1 * 1 5 10 10 5 1 * 1 6 15 20 15 6 1 * 1 7 21 35 35 21 7 1 * 1 8 28 56 70 56 28 8 1 * */ public static int[][] pascal(int n) { /* * @param arr An auxiliary array to store generated pascal triangle values * @return */ int[][] arr = new int[n][n]; /* * @param line Iterate through every line and print integer(s) in it * @param i Represents the column number of the element we are currently on */ for (int line = 0; line < n; line++) { /* * @Every line has number of integers equal to line number */ for (int i = 0; i <= line; i++) { // First and last values in every row are 1 if (line == i || i == 0) { arr[line][i] = 1; } else { arr[line][i] = arr[line - 1][i - 1] + arr[line - 1][i]; } } } return arr; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.ArrayList; import java.util.Collections; import java.util.Random; final class PasswordGen { private PasswordGen() { } public static String generatePassword(int n, int n2) { if (n > n2 || n <= 0 || n2 <= 0) { throw new IllegalArgumentException(\"Incorrect length parameters: minLength must be <= maxLength and both must be > 0\"); } Random random = new Random(); ArrayList<Character> arrayList = new ArrayList<Character>(); for (char c : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(){}?\".toCharArray()) { arrayList.add(Character.valueOf(c)); } Collections.shuffle(arrayList); Object object = new StringBuilder(); for (int i = random.nextInt(n2 - n) + n; i > 0; --i) { ((StringBuilder)object).append(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(){}?\".charAt(random.nextInt(75))); } return ((StringBuilder)object).toString(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Random; /** * Creates a random password from ASCII letters Given password length bounds * * @author AKS1996 * @date 2017.10.25 */ final class PasswordGen { private static final String UPPERCASE_LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; private static final String LOWERCASE_LETTERS = \"abcdefghijklmnopqrstuvwxyz\"; private static final String DIGITS = \"0123456789\"; private static final String SPECIAL_CHARACTERS = \"!@#$%^&*(){}?\"; private static final String ALL_CHARACTERS = UPPERCASE_LETTERS + LOWERCASE_LETTERS + DIGITS + SPECIAL_CHARACTERS; private PasswordGen() { } /** * Generates a random password with a length between minLength and maxLength. * * @param minLength The minimum length of the password. * @param maxLength The maximum length of the password. * @return A randomly generated password. * @throws IllegalArgumentException if minLength is greater than maxLength or if either is non-positive. */ public static String generatePassword(int minLength, int maxLength) { if (minLength > maxLength || minLength <= 0 || maxLength <= 0) { throw new IllegalArgumentException(\"Incorrect length parameters: minLength must be <= maxLength and both must be > 0\"); } Random random = new Random(); List<Character> letters = new ArrayList<>(); for (char c : ALL_CHARACTERS.toCharArray()) { letters.add(c); } // Inbuilt method to randomly shuffle a elements of a list Collections.shuffle(letters); StringBuilder password = new StringBuilder(); // Note that size of the password is also random for (int i = random.nextInt(maxLength - minLength) + minLength; i > 0; --i) { password.append(ALL_CHARACTERS.charAt(random.nextInt(ALL_CHARACTERS.length()))); } return password.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; import java.util.List; final class PatienceSort$PileNode extends Record implements Comparable { private final Comparable a; private final List b; private PatienceSort$PileNode(Comparable comparable, List list) { this.a = comparable; this.b = list; } public final int compareTo(PatienceSort$PileNode patienceSort$PileNode) { return this.a.compareTo(patienceSort$PileNode.a); } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{PatienceSort$PileNode.class, \"value;pile\", \"a\", \"b\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{PatienceSort$PileNode.class, \"value;pile\", \"a\", \"b\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{PatienceSort$PileNode.class, \"value;pile\", \"a\", \"b\"}, this, object); } public final Comparable value() { return this.a; } public final List pile() { return this.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.lang.invoke.MethodHandle; import java.lang.runtime.ObjectMethods; import java.util.List; final class PatienceSort$PileNode extends Record implements Comparable { private final Comparable a; private final List b; private PatienceSort$PileNode(Comparable comparable, List list) { this.a = comparable; this.b = list; } public final int compareTo(PatienceSort$PileNode patienceSort$PileNode) { return this.a.compareTo(patienceSort$PileNode.a); } @Override public final String toString() { return ObjectMethods.bootstrap(\"toString\", new MethodHandle[]{PatienceSort$PileNode.class, \"value;pile\", \"a\", \"b\"}, this); } @Override public final int hashCode() { return (int)ObjectMethods.bootstrap(\"hashCode\", new MethodHandle[]{PatienceSort$PileNode.class, \"value;pile\", \"a\", \"b\"}, this); } @Override public final boolean equals(Object object) { return (boolean)ObjectMethods.bootstrap(\"equals\", new MethodHandle[]{PatienceSort$PileNode.class, \"value;pile\", \"a\", \"b\"}, this, object); } public final Comparable value() { return this.a; } public final List pile() { return this.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.PatienceSort$PileNode; import com.thealgorithms.sorts.SortAlgorithm; import java.util.AbstractCollection; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.PriorityQueue; public class PatienceSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length == 0) { return comparableArray; } Comparable[] comparableArray2 = comparableArray; AbstractCollection abstractCollection = new ArrayList(); ArrayList arrayList = new ArrayList(); Comparable[] object2 = comparableArray2; int n = comparableArray2.length; for (int i = 0; i < n; ++i) { Comparable comparable = object2[i]; int n2 = Collections.binarySearch(arrayList, comparable); if (n2 < 0) { n2 = -n2 - 1; } if (n2 < abstractCollection.size()) { ((List)abstractCollection.get(n2)).add(comparable); arrayList.set(n2, comparable); continue; } ArrayList<Comparable> arrayList2 = new ArrayList<Comparable>(); arrayList2.add(comparable); abstractCollection.add(arrayList2); arrayList.add(comparable); } Comparable[] comparableArray3 = abstractCollection; abstractCollection = new PriorityQueue(); for (List list : comparableArray3) { ((PriorityQueue)abstractCollection).add(new PatienceSort$PileNode((Comparable)list.removeLast(), list)); } comparableArray3 = abstractCollection; abstractCollection = comparableArray3; comparableArray3 = comparableArray; int n3 = 0; while (!abstractCollection.isEmpty()) { PatienceSort$PileNode patienceSort$PileNode = (PatienceSort$PileNode)((PriorityQueue)abstractCollection).poll(); comparableArray3[n3++] = patienceSort$PileNode.a; if (patienceSort$PileNode.b.isEmpty()) continue; ((PriorityQueue)abstractCollection).add(new PatienceSort$PileNode((Comparable)patienceSort$PileNode.b.removeLast(), patienceSort$PileNode.b)); } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.PriorityQueue; /** * This class implements the Patience Sort algorithm. Patience Sort is a sorting algorithm that * is particularly good for sorting sequences that are already partially sorted. */ public class PatienceSort implements SortAlgorithm { /** * Sorts an array of comparable elements using the Patience Sort algorithm. * * @param array the array to be sorted * @param <T> the type of elements in the array, must be comparable * @return the sorted array */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length == 0) { return array; } final List<List<T>> piles = formPiles(array); final PriorityQueue<PileNode<T>> pq = mergePiles(piles); extractPiles(array, pq); return array; } /** * Forms piles from the given array. Each pile is a list of elements where * each element is smaller than the one before it. Binary search is used * to find the appropriate pile for each element. * * @param array the array of elements to be organized into piles * @param <T> the type of elements in the array, must be comparable * @return a list of piles */ private static <T extends Comparable<T>> List<List<T>> formPiles(final T[] array) { final List<List<T>> piles = new ArrayList<>(); final List<T> lastElements = new ArrayList<>(); for (T x : array) { int pos = Collections.binarySearch(lastElements, x); if (pos < 0) { pos = -pos - 1; } if (pos < piles.size()) { piles.get(pos).add(x); lastElements.set(pos, x); } else { List<T> newPile = new ArrayList<>(); newPile.add(x); piles.add(newPile); lastElements.add(x); } } return piles; } /** * Merges the piles into a priority queue where the smallest elements are * prioritized. * * @param piles the list of piles to be merged * @param <T> the type of elements in the piles, must be comparable * @return a priority queue containing the top element of each pile */ private static <T extends Comparable<T>> PriorityQueue<PileNode<T>> mergePiles(final Iterable<List<T>> piles) { PriorityQueue<PileNode<T>> pq = new PriorityQueue<>(); for (List<T> pile : piles) { pq.add(new PileNode<>(pile.removeLast(), pile)); } return pq; } /** * Extracts elements from the priority queue to form the sorted array. * * @param array the array to be filled with sorted elements * @param pq the priority queue containing the elements to be extracted * @param <T> the type of elements in the array, must be comparable */ private static <T extends Comparable<T>> void extractPiles(final T[] array, final PriorityQueue<PileNode<T>> pq) { int index = 0; while (!pq.isEmpty()) { PileNode<T> node = pq.poll(); array[index++] = node.value; if (!node.pile.isEmpty()) { pq.add(new PileNode<>(node.pile.removeLast(), node.pile)); } } } /** * A helper record representing a node in the priority queue. * * @param <T> the type of elements in the node, must be comparable */ private record PileNode<T extends Comparable<T>>(T value, List<T> pile) implements Comparable<PileNode<T>> { @Override public int compareTo(PileNode<T> other) { return this.value.compareTo(other.value); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; public class PerfectBinarySearch implements SearchAlgorithm { @Override public int find(Comparable[] comparableArray, Comparable comparable) { int n = comparableArray.length - 1; int n2 = 0; while (n2 <= n) { int n3 = n2 + n >>> 1; int n4 = comparable.compareTo(comparableArray[n3]); if (n4 == 0) { return n3; } if (n4 < 0) { n = n3 - 1; continue; } n2 = n3 + 1; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; /** * Binary search is one of the most popular algorithms The algorithm finds the * position of a target value within a sorted array * * <p> * Worst-case performance O(log n) Best-case performance O(1) Average * performance O(log n) Worst-case space complexity O(1) * * @author D Sunil (https://github.com/sunilnitdgp) * @see SearchAlgorithm */ public class PerfectBinarySearch<T> implements SearchAlgorithm { /** * @param array is an array where the element should be found * @param key is an element which should be found * @param <T> is any comparable type * @return index of the element */ @Override public <T extends Comparable<T>> int find(T[] array, T key) { return search(array, key, 0, array.length - 1); } /** * This method implements the Generic Binary Search iteratively. * * @param array The array to make the binary search * @param key The number you are looking for * @return the location of the key, or -1 if not found */ private static <T extends Comparable<T>> int search(T[] array, T key, int left, int right) { while (left <= right) { int median = (left + right) >>> 1; int comp = key.compareTo(array[median]); if (comp == 0) { return median; // Key found } if (comp < 0) { right = median - 1; // Adjust the right bound } else { left = median + 1; // Adjust the left bound } } return -1; // Key not found } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class PerfectCube { private PerfectCube() { } public static boolean isPerfectCube(int n) { int n2 = (int)Math.pow(n = Math.abs(n), 0.3333333333333333); return n2 * n2 * n2 == n; } public static boolean isPerfectCubeMathCbrt(int n) { double d = Math.cbrt(n); return d == (double)((int)d); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * https://en.wikipedia.org/wiki/Cube_(algebra) */ public final class PerfectCube { private PerfectCube() { } /** * Check if a number is perfect cube or not * * @param number number to check * @return {@code true} if {@code number} is perfect cube, otherwise * {@code false} */ public static boolean isPerfectCube(int number) { number = Math.abs(number); // converting negative number to positive number int a = (int) Math.pow(number, 1.0 / 3); return a * a * a == number; } /** * Check if a number is perfect cube or not by using Math.cbrt function * * @param number number to check * @return {@code true} if {@code number} is perfect cube, otherwise * {@code false} */ public static boolean isPerfectCubeMathCbrt(int number) { double cubeRoot = Math.cbrt(number); return cubeRoot == (int) cubeRoot; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class PerfectNumber { private PerfectNumber() { } public static boolean isPerfectNumber(int n) { if (n <= 0) { return false; } int n2 = 0; for (int i = 1; i < n; ++i) { if (n % i != 0) continue; n2 += i; } return n2 == n; } public static boolean isPerfectNumber2(int n) { if (n <= 0) { return false; } int n2 = 1; double d = Math.sqrt(n); int n3 = 2; while ((double)n3 <= d) { if (n % n3 == 0) { n2 += n3 + n / n3; } ++n3; } double d2 = d; if (d2 == (double)((int)d2)) { n2 -= (int)d; } return n2 == n; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * In number theory, a perfect number is a positive integer that is equal to the * sum of its positive divisors, excluding the number itself. For instance, 6 * has divisors 1, 2 and 3 (excluding itself), and 1 + 2 + 3 = 6, so 6 is a * perfect number. * * link:https://en.wikipedia.org/wiki/Perfect_number */ public final class PerfectNumber { private PerfectNumber() { } /** * Check if {@code number} is perfect number or not * * @param number the number * @return {@code true} if {@code number} is perfect number, otherwise false */ public static boolean isPerfectNumber(int number) { if (number <= 0) { return false; } int sum = 0; /* sum of its positive divisors */ for (int i = 1; i < number; ++i) { if (number % i == 0) { sum += i; } } return sum == number; } /** * Check if {@code n} is perfect number or not * * @param n the number * @return {@code true} if {@code number} is perfect number, otherwise false */ public static boolean isPerfectNumber2(int n) { if (n <= 0) { return false; } int sum = 1; double root = Math.sqrt(n); /* * We can get the factors after the root by dividing number by its factors * before the root. * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100. * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5. * Now by dividing 100 by each factor before 10 we get: * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20 * So we get 100, 50, 25 and 20 which are factors of 100 after 10 */ for (int i = 2; i <= root; i++) { if (n % i == 0) { sum += i + n / i; } } // if n is a perfect square then its root was added twice in above loop, so subtracting root // from sum if (root == (int) root) { sum -= (int) root; } return sum == n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class PerfectSquare { private PerfectSquare() { } public static boolean isPerfectSquare(int n) { int n2 = (int)Math.sqrt(n); return n2 * n2 == n; } public static boolean isPerfectSquareUsingPow(long l) { long l2 = (long)Math.pow(l, 0.5); return l2 * l2 == l; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * https://en.wikipedia.org/wiki/Perfect_square */ public final class PerfectSquare { private PerfectSquare() { } /** * Check if a number is perfect square number * * @param number the number to be checked * @return <tt>true</tt> if {@code number} is perfect square, otherwise * <tt>false</tt> */ public static boolean isPerfectSquare(final int number) { final int sqrt = (int) Math.sqrt(number); return sqrt * sqrt == number; } /** * Check if a number is perfect square or not * * @param number number to be checked * @return {@code true} if {@code number} is perfect square, otherwise * {@code false} */ public static boolean isPerfectSquareUsingPow(long number) { long a = (long) Math.pow(number, 1.0 / 2); return a * a == number; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class Perimeter { private Perimeter() { } public static float perimeterRegularPolygon(int n, float f) { return (float)n * f; } public static float perimeterIrregularPolygon(float f, float f2, float f3, float ... fArray) { f = f + f2 + f3; float[] fArray2 = fArray; int n = fArray.length; for (int i = 0; i < n; ++i) { float f4 = fArray2[i]; f += f4; } return f; } public static float perimeterRectangle(float f, float f2) { return 2.0f * (f + f2); } public static double perimeterCircle(float f) { return Math.PI * 2 * (double)f; } }", "deobfuscated_code": "package com.thealgorithms.maths; // Perimeter of different 2D geometrical shapes public final class Perimeter { private Perimeter() { } /** * Calculate the Perimeter of regular polygon (equals sides) * Examples of regular polygon are Equilateral Triangle, Square, Regular Pentagon, Regular * Hexagon. * * @param n for number of sides. * @param side for length of each side. * @return Perimeter of given polygon */ public static float perimeterRegularPolygon(int n, float side) { return n * side; } /** * Calculate the Perimeter of irregular polygon (unequals sides) * Examples of irregular polygon are scalent triangle, irregular quadrilateral, irregular * Pentagon, irregular Hexagon. * * @param side1 for length of side 1 * @param side2 for length of side 2 * @param side3 for length of side 3 * @param sides for length of remaining sides * @return Perimeter of given trapezoid. */ public static float perimeterIrregularPolygon(float side1, float side2, float side3, float... sides) { float perimeter = side1 + side2 + side3; for (float side : sides) { perimeter += side; } return perimeter; } /** * Calculate the Perimeter of rectangle * * @param length for length of rectangle * @param breadth for breadth of rectangle * @return Perimeter of given rectangle */ public static float perimeterRectangle(float length, float breadth) { return 2 * (length + breadth); } /** * Calculate the Perimeter or Circumference of circle. * * @param r for radius of circle. * @return circumference of given circle. */ public static double perimeterCircle(float r) { return 2 * Math.PI * r; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Random; import java.util.Scanner; public final class PerlinNoise { private PerlinNoise() { } private static float a(float f, float f2, float f3) { return f * (1.0f - f3) + f3 * f2; } public static void main(String[] object) { int n; int n2; object = new Scanner(System.in); System.out.println(\"Width (int): \"); int n3 = ((Scanner)object).nextInt(); System.out.println(\"Height (int): \"); int n4 = ((Scanner)object).nextInt(); System.out.println(\"Octave count (int): \"); int n5 = ((Scanner)object).nextInt(); System.out.println(\"Persistence (float): \"); float f = ((Scanner)object).nextFloat(); System.out.println(\"Seed (long): \"); long l = ((Scanner)object).nextLong(); System.out.println(\"Charset (String): \"); String string = ((Scanner)object).next(); long l2 = l; float f2 = f; int n6 = n5; int n7 = n4; n5 = n3; float[][] fArray = new float[n5][n7]; float[][] fArray2 = new float[n5][n7]; Object object2 = new float[n6][][]; Object object3 = new Random(l2); for (n2 = 0; n2 < n5; ++n2) { for (n = 0; n < n7; ++n) { fArray[n2][n] = ((Random)object3).nextFloat(); } } for (n2 = 0; n2 < n6; ++n2) { int n8 = n2; int n9 = n7; n = n5; object3 = fArray; float[][] fArray3 = new float[n][n9]; n8 = 1 << n8; float f3 = 1.0f / (float)n8; for (int i = 0; i < n; ++i) { int n10 = i / n8 * n8; int n11 = (n10 + n8) % n; float f4 = (float)(i - n10) * f3; for (int j = 0; j < n9; ++j) { int n12 = j / n8 * n8; int n13 = (n12 + n8) % n9; float f5 = (float)(j - n12) * f3; float f6 = PerlinNoise.a((float)object3[n10][n12], (float)object3[n11][n12], f4); float f7 = PerlinNoise.a((float)object3[n10][n13], (float)object3[n11][n13], f4); fArray3[i][j] = PerlinNoise.a(f6, f7, f5); } } object2[n2] = fArray3; } float f8 = 1.0f; float f9 = 0.0f; --n6; while (n6 >= 0) { f9 += (f8 *= f2); for (int i = 0; i < n5; ++i) { for (int j = 0; j < n7; ++j) { float[] fArray4 = fArray2[i]; int n14 = j; fArray4[n14] = fArray4[n14] + object2[n6][i][j] * f8; } } --n6; } for (n6 = 0; n6 < n5; ++n6) { int n15 = 0; while (n15 < n7) { float[] fArray5 = fArray2[n6]; int n16 = n15++; fArray5[n16] = fArray5[n16] / f9; } } float[][] fArray6 = fArray2; char[] cArray = string.toCharArray(); int n17 = cArray.length; float f10 = 1.0f / (float)n17; for (n6 = 0; n6 < n3; ++n6) { block11: for (int i = 0; i < n4; ++i) { float f11 = f10; float f12 = fArray6[n6][i]; object2 = cArray; int n18 = cArray.length; for (int j = 0; j < n18; ++j) { float[][] fArray7 = object2[j]; if (f12 <= f11) { System.out.print((char)fArray7); continue block11; } f11 += f10; } } System.out.println(); } ((Scanner)object).close(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Random; import java.util.Scanner; /** * For detailed info and implementation see: <a * href=\"http://devmag.org.za/2009/04/25/perlin-noise/\">Perlin-Noise</a> */ public final class PerlinNoise { private PerlinNoise() { } /** * @param width width of noise array * @param height height of noise array * @param octaveCount numbers of layers used for blending noise * @param persistence value of impact each layer get while blending * @param seed used for randomizer * @return float array containing calculated \"Perlin-Noise\" values */ static float[][] generatePerlinNoise(int width, int height, int octaveCount, float persistence, long seed) { final float[][] base = new float[width][height]; final float[][] perlinNoise = new float[width][height]; final float[][][] noiseLayers = new float[octaveCount][][]; Random random = new Random(seed); // fill base array with random values as base for noise for (int x = 0; x < width; x++) { for (int y = 0; y < height; y++) { base[x][y] = random.nextFloat(); } } // calculate octaves with different roughness for (int octave = 0; octave < octaveCount; octave++) { noiseLayers[octave] = generatePerlinNoiseLayer(base, width, height, octave); } float amplitude = 1f; float totalAmplitude = 0f; // calculate perlin noise by blending each layer together with specific persistence for (int octave = octaveCount - 1; octave >= 0; octave--) { amplitude *= persistence; totalAmplitude += amplitude; for (int x = 0; x < width; x++) { for (int y = 0; y < height; y++) { // adding each value of the noise layer to the noise // by increasing amplitude the rougher noises will have more impact perlinNoise[x][y] += noiseLayers[octave][x][y] * amplitude; } } } // normalize values so that they stay between 0..1 for (int x = 0; x < width; x++) { for (int y = 0; y < height; y++) { perlinNoise[x][y] /= totalAmplitude; } } return perlinNoise; } /** * @param base base random float array * @param width width of noise array * @param height height of noise array * @param octave current layer * @return float array containing calculated \"Perlin-Noise-Layer\" values */ static float[][] generatePerlinNoiseLayer(float[][] base, int width, int height, int octave) { float[][] perlinNoiseLayer = new float[width][height]; // calculate period (wavelength) for different shapes int period = 1 << octave; // 2^k float frequency = 1f / period; // 1/2^k for (int x = 0; x < width; x++) { // calculates the horizontal sampling indices int x0 = (x / period) * period; int x1 = (x0 + period) % width; float horizintalBlend = (x - x0) * frequency; for (int y = 0; y < height; y++) { // calculates the vertical sampling indices int y0 = (y / period) * period; int y1 = (y0 + period) % height; float verticalBlend = (y - y0) * frequency; // blend top corners float top = interpolate(base[x0][y0], base[x1][y0], horizintalBlend); // blend bottom corners float bottom = interpolate(base[x0][y1], base[x1][y1], horizintalBlend); // blend top and bottom interpolation to get the final blend value for this cell perlinNoiseLayer[x][y] = interpolate(top, bottom, verticalBlend); } } return perlinNoiseLayer; } /** * @param a value of point a * @param b value of point b * @param alpha determine which value has more impact (closer to 0 -> a, * closer to 1 -> b) * @return interpolated value */ static float interpolate(float a, float b, float alpha) { return a * (1 - alpha) + alpha * b; } public static void main(String[] args) { Scanner in = new Scanner(System.in); final int width; final int height; final int octaveCount; final float persistence; final long seed; final String charset; final float[][] perlinNoise; System.out.println(\"Width (int): \"); width = in.nextInt(); System.out.println(\"Height (int): \"); height = in.nextInt(); System.out.println(\"Octave count (int): \"); octaveCount = in.nextInt(); System.out.println(\"Persistence (float): \"); persistence = in.nextFloat(); System.out.println(\"Seed (long): \"); seed = in.nextLong(); System.out.println(\"Charset (String): \"); charset = in.next(); perlinNoise = generatePerlinNoise(width, height, octaveCount, persistence, seed); final char[] chars = charset.toCharArray(); final int length = chars.length; final float step = 1f / length; // output based on charset for (int x = 0; x < width; x++) { for (int y = 0; y < height; y++) { float value = step; float noiseValue = perlinNoise[x][y]; for (char c : chars) { if (noiseValue <= value) { System.out.print(c); break; } value += step; } } System.out.println(); } in.close(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; import java.util.LinkedList; import java.util.List; public final class Permutation { private Permutation() { } public static List permutation(Object[] objectArray) { objectArray = (Object[])objectArray.clone(); LinkedList linkedList = new LinkedList(); Permutation.a(objectArray, 0, linkedList); return linkedList; } private static void a(Object[] objectArray, int n, List list) { if (n == objectArray.length) { list.add((Object[])objectArray.clone()); } for (int i = n; i < objectArray.length; ++i) { Permutation.a(n, i, objectArray); Permutation.a(objectArray, n + 1, list); Permutation.a(n, i, objectArray); } } private static void a(int n, int n2, Object[] objectArray) { Object object = objectArray[n]; objectArray[n] = objectArray[n2]; objectArray[n2] = object; } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.LinkedList; import java.util.List; /** * Finds all permutations of given array * @author Alan Piao (<a href=\"https://github.com/cpiao3\">Git-Alan Piao</a>) */ public final class Permutation { private Permutation() { } /** * Find all permutations of given array using backtracking * @param arr the array. * @param <T> the type of elements in the array. * @return a list of all permutations. */ public static <T> List<T[]> permutation(T[] arr) { T[] array = arr.clone(); List<T[]> result = new LinkedList<>(); backtracking(array, 0, result); return result; } /** * Backtrack all possible orders of a given array * @param arr the array. * @param index the starting index. * @param result the list contains all permutations. * @param <T> the type of elements in the array. */ private static <T> void backtracking(T[] arr, int index, List<T[]> result) { if (index == arr.length) { result.add(arr.clone()); } for (int i = index; i < arr.length; i++) { swap(index, i, arr); backtracking(arr, index + 1, result); swap(index, i, arr); } } /** * Swap two element for a given array * @param a first index * @param b second index * @param arr the array. * @param <T> the type of elements in the array. */ private static <T> void swap(int a, int b, T[] arr) { T temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.HashSet; import java.util.Set; public final class PermuteString { private PermuteString() { } public static Set getPermutations(String string) { HashSet hashSet = new HashSet(); PermuteString.a(string, 0, string.length(), hashSet); return hashSet; } private static void a(String string, int n, int n2, Set set) { if (n == n2 - 1) { set.add(string); return; } for (int i = n; i < n2; ++i) { string = PermuteString.a(string, n, i); PermuteString.a(string, n + 1, n2, set); string = PermuteString.a(string, n, i); } } private static String a(String object, int n, int n2) { char[] cArray = ((String)object).toCharArray(); object = cArray; char c = cArray[n]; object[n] = object[n2]; object[n2] = c; return new String((char[])object); } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.HashSet; import java.util.Set; /** * This class provides methods for generating all permutations of a given string using a backtracking algorithm. * <p> * The algorithm works as follows: * <ol> * <li>Fix a character in the current position and swap it with each of the remaining characters. * For example, for the string \"ABC\": * <ul> * <li>Fix 'A' at the first position: permutations are \"ABC\", \"BAC\", \"CBA\" (obtained by swapping 'A' with 'B' and 'C' respectively).</li> * </ul> * </li> * <li>Repeat the process for the next character. * For instance, after fixing 'B' in the second position: * <ul> * <li>For \"BAC\", the permutations include \"BAC\" and \"BCA\" (after swapping 'A' and 'C').</li> * </ul> * </li> * <li>After generating permutations for the current position, backtrack by swapping the characters back to their original positions to restore the state. * For example, after generating permutations for \"ABC\", swap back to restore \"BAC\" and continue with further permutations.</li> * <li>Repeat the process for all characters to get all possible permutations.</li> * </ol> * </p> */ public final class PermuteString { private PermuteString() { } /** * Generates all possible permutations of the given string. * * <p>This method returns a set containing all unique permutations of the input string. It leverages * a recursive helper method to generate these permutations. * * @param str The input string for which permutations are to be generated. * If the string is null or empty, the result will be an empty set. * @return A {@link Set} of strings containing all unique permutations of the input string. * If the input string has duplicate characters, the set will ensure that only unique permutations * are returned. */ public static Set<String> getPermutations(String str) { Set<String> permutations = new HashSet<>(); generatePermutations(str, 0, str.length(), permutations); return permutations; } /** * Generates all permutations of the given string and collects them into a set. * * @param str the string to permute * @param start the starting index for the current permutation * @param end the end index (length of the string) * @param permutations the set to collect all unique permutations */ private static void generatePermutations(String str, int start, int end, Set<String> permutations) { if (start == end - 1) { permutations.add(str); } else { for (int currentIndex = start; currentIndex < end; currentIndex++) { // Swap the current character with the character at the start index str = swapCharacters(str, start, currentIndex); // Recursively generate permutations for the remaining characters generatePermutations(str, start + 1, end, permutations); // Backtrack: swap the characters back to their original positions str = swapCharacters(str, start, currentIndex); } } } /** * Swaps the characters at the specified positions in the given string. * * @param str the string in which characters will be swapped * @param i the position of the first character to swap * @param j the position of the second character to swap * @return a new string with the characters at positions i and j swapped */ private static String swapCharacters(String str, int i, int j) { char[] chars = str.toCharArray(); char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; return new String(chars); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.util.HashMap; import java.util.Map; public final class PhoneticAlphabetConverter { private static final Map a = new HashMap<Character, String>(); private PhoneticAlphabetConverter() { } public static String textToPhonetic(String object) { StringBuilder stringBuilder = new StringBuilder(); char[] cArray = ((String)object).toUpperCase().toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object2 = object[i]; if (Character.isWhitespace((char)object2)) continue; stringBuilder.append(a.getOrDefault(Character.valueOf((char)object2), String.valueOf((char)object2))).append(\" \"); } return stringBuilder.toString().trim(); } static { a.put(Character.valueOf('A'), \"Alpha\"); a.put(Character.valueOf('B'), \"Bravo\"); a.put(Character.valueOf('C'), \"Charlie\"); a.put(Character.valueOf('D'), \"Delta\"); a.put(Character.valueOf('E'), \"Echo\"); a.put(Character.valueOf('F'), \"Foxtrot\"); a.put(Character.valueOf('G'), \"Golf\"); a.put(Character.valueOf('H'), \"Hotel\"); a.put(Character.valueOf('I'), \"India\"); a.put(Character.valueOf('J'), \"Juliett\"); a.put(Character.valueOf('K'), \"Kilo\"); a.put(Character.valueOf('L'), \"Lima\"); a.put(Character.valueOf('M'), \"Mike\"); a.put(Character.valueOf('N'), \"November\"); a.put(Character.valueOf('O'), \"Oscar\"); a.put(Character.valueOf('P'), \"Papa\"); a.put(Character.valueOf('Q'), \"Quebec\"); a.put(Character.valueOf('R'), \"Romeo\"); a.put(Character.valueOf('S'), \"Sierra\"); a.put(Character.valueOf('T'), \"Tango\"); a.put(Character.valueOf('U'), \"Uniform\"); a.put(Character.valueOf('V'), \"Victor\"); a.put(Character.valueOf('W'), \"Whiskey\"); a.put(Character.valueOf('X'), \"X-ray\"); a.put(Character.valueOf('Y'), \"Yankee\"); a.put(Character.valueOf('Z'), \"Zulu\"); a.put(Character.valueOf('0'), \"Zero\"); a.put(Character.valueOf('1'), \"One\"); a.put(Character.valueOf('2'), \"Two\"); a.put(Character.valueOf('3'), \"Three\"); a.put(Character.valueOf('4'), \"Four\"); a.put(Character.valueOf('5'), \"Five\"); a.put(Character.valueOf('6'), \"Six\"); a.put(Character.valueOf('7'), \"Seven\"); a.put(Character.valueOf('8'), \"Eight\"); a.put(Character.valueOf('9'), \"Nine\"); } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.util.HashMap; import java.util.Map; /** * Converts text to the NATO phonetic alphabet. * Examples: * \"ABC\" -> \"Alpha Bravo Charlie\" * \"Hello\" -> \"Hotel Echo Lima Lima Oscar\" * \"123\" -> \"One Two Three\" * \"A1B2C3\" -> \"Alpha One Bravo Two Charlie Three\" * * @author Hardvan */ public final class PhoneticAlphabetConverter { private PhoneticAlphabetConverter() { } private static final Map<Character, String> PHONETIC_MAP = new HashMap<>(); static { PHONETIC_MAP.put('A', \"Alpha\"); PHONETIC_MAP.put('B', \"Bravo\"); PHONETIC_MAP.put('C', \"Charlie\"); PHONETIC_MAP.put('D', \"Delta\"); PHONETIC_MAP.put('E', \"Echo\"); PHONETIC_MAP.put('F', \"Foxtrot\"); PHONETIC_MAP.put('G', \"Golf\"); PHONETIC_MAP.put('H', \"Hotel\"); PHONETIC_MAP.put('I', \"India\"); PHONETIC_MAP.put('J', \"Juliett\"); PHONETIC_MAP.put('K', \"Kilo\"); PHONETIC_MAP.put('L', \"Lima\"); PHONETIC_MAP.put('M', \"Mike\"); PHONETIC_MAP.put('N', \"November\"); PHONETIC_MAP.put('O', \"Oscar\"); PHONETIC_MAP.put('P', \"Papa\"); PHONETIC_MAP.put('Q', \"Quebec\"); PHONETIC_MAP.put('R', \"Romeo\"); PHONETIC_MAP.put('S', \"Sierra\"); PHONETIC_MAP.put('T', \"Tango\"); PHONETIC_MAP.put('U', \"Uniform\"); PHONETIC_MAP.put('V', \"Victor\"); PHONETIC_MAP.put('W', \"Whiskey\"); PHONETIC_MAP.put('X', \"X-ray\"); PHONETIC_MAP.put('Y', \"Yankee\"); PHONETIC_MAP.put('Z', \"Zulu\"); PHONETIC_MAP.put('0', \"Zero\"); PHONETIC_MAP.put('1', \"One\"); PHONETIC_MAP.put('2', \"Two\"); PHONETIC_MAP.put('3', \"Three\"); PHONETIC_MAP.put('4', \"Four\"); PHONETIC_MAP.put('5', \"Five\"); PHONETIC_MAP.put('6', \"Six\"); PHONETIC_MAP.put('7', \"Seven\"); PHONETIC_MAP.put('8', \"Eight\"); PHONETIC_MAP.put('9', \"Nine\"); } /** * Converts text to the NATO phonetic alphabet. * Steps: * 1. Convert the text to uppercase. * 2. Iterate over each character in the text. * 3. Get the phonetic equivalent of the character from the map. * 4. Append the phonetic equivalent to the result. * 5. Append a space to separate the phonetic equivalents. * 6. Return the result. * * @param text the text to convert * @return the NATO phonetic alphabet */ public static String textToPhonetic(String text) { StringBuilder phonetic = new StringBuilder(); for (char c : text.toUpperCase().toCharArray()) { if (Character.isWhitespace(c)) { continue; } phonetic.append(PHONETIC_MAP.getOrDefault(c, String.valueOf(c))).append(\" \"); } return phonetic.toString().trim(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class PiNilakantha { private PiNilakantha() { } public static void main(String[] stringArray) { assert (PiNilakantha.calculatePi(0) == 3.0); assert (PiNilakantha.calculatePi(10) > 3.0); assert (PiNilakantha.calculatePi(100) < 4.0); System.out.println(PiNilakantha.calculatePi(500)); } public static double calculatePi(int n) { if (n < 0 || n > 500) { throw new IllegalArgumentException(\"Please input Integer Number between 0 and 500\"); } double d = 3.0; int n2 = 2; for (int i = 0; i < n; ++i) { if (i % 2 == 0) { int n3 = n2; d += 4.0 / (double)(n3 * (n3 + 1) * (n2 + 2)); } else { int n4 = n2; d -= 4.0 / (double)(n4 * (n4 + 1) * (n2 + 2)); } n2 += 2; } return d; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class PiNilakantha { private PiNilakantha() { } // Calculates Pi using Nilakantha's infinite series // Method 2 in the following link explains the algorithm // https://en.scratch-wiki.info/wiki/Calculating_Pi public static void main(String[] args) { assert calculatePi(0) == 3.0; assert calculatePi(10) > 3.0; assert calculatePi(100) < 4.0; System.out.println(calculatePi(500)); } /** * @param iterations number of times the infinite series gets repeated Pi * get more accurate the higher the value of iterations is Values from 0 up * to 500 are allowed since double precision is not sufficient for more than * about 500 repetitions of this algorithm * @return the pi value of the calculation with a precision of x iteration */ public static double calculatePi(int iterations) { if (iterations < 0 || iterations > 500) { throw new IllegalArgumentException(\"Please input Integer Number between 0 and 500\"); } double pi = 3; int divCounter = 2; for (int i = 0; i < iterations; i++) { if (i % 2 == 0) { pi = pi + 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2)); } else { pi = pi - 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2)); } divCounter += 2; } return pi; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.List; public final class PigeonholeSort { private PigeonholeSort() { } public static int[] sort(int[] nArray) { Object object; int n; int[] nArray2 = nArray; for (int n2 : nArray) { if (n2 >= 0) continue; throw new IllegalArgumentException(\"Array contains negative integers.\"); } if (nArray.length == 0) { return nArray; } int n3 = n = Arrays.stream(nArray).max().orElseThrow(); Object object2 = new ArrayList(n3 + 1); for (int i = 0; i <= n3; ++i) { object2.add(new ArrayList()); } object2 = object = object2; int[] nArray3 = nArray; for (int n4 : nArray) { ((List)object2.get(n4)).add(n4); } object2 = object; nArray3 = nArray; int n5 = 0; Iterator iterator = object2.iterator(); while (iterator.hasNext()) { List list = (List)iterator.next(); Iterator iterator2 = list.iterator(); while (iterator2.hasNext()) { int n6 = (Integer)iterator2.next(); nArray3[n5++] = n6; } } return nArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public final class PigeonholeSort { private PigeonholeSort() { } /** * Sorts the given array using the pigeonhole sort algorithm. * * @param array the array to be sorted * @throws IllegalArgumentException if any negative integers are found * @return the sorted array */ public static int[] sort(int[] array) { checkForNegativeInput(array); if (array.length == 0) { return array; } final int maxElement = Arrays.stream(array).max().orElseThrow(); final List<List<Integer>> pigeonHoles = createPigeonHoles(maxElement); populatePigeonHoles(array, pigeonHoles); collectFromPigeonHoles(array, pigeonHoles); return array; } /** * Checks if the array contains any negative integers. * * @param array the array to be checked * @throws IllegalArgumentException if any negative integers are found */ private static void checkForNegativeInput(int[] array) { for (final int number : array) { if (number < 0) { throw new IllegalArgumentException(\"Array contains negative integers.\"); } } } /** * Creates pigeonholes for sorting using an ArrayList of ArrayLists. * * @param maxElement the maximum element in the array * @return an ArrayList of ArrayLists */ private static List<List<Integer>> createPigeonHoles(int maxElement) { List<List<Integer>> pigeonHoles = new ArrayList<>(maxElement + 1); for (int i = 0; i <= maxElement; i++) { pigeonHoles.add(new ArrayList<>()); } return pigeonHoles; } /** * Populates the pigeonholes with elements from the array. * * @param array the array to be sorted * @param pigeonHoles the pigeonholes to be populated */ private static void populatePigeonHoles(int[] array, List<List<Integer>> pigeonHoles) { for (int element : array) { pigeonHoles.get(element).add(element); } } /** * Collects sorted elements from the pigeonholes back into the array. * * @param array the array to be sorted * @param pigeonHoles the populated pigeonholes */ private static void collectFromPigeonHoles(int[] array, Iterable<List<Integer>> pigeonHoles) { int index = 0; for (final var pigeonHole : pigeonHoles) { for (final int element : pigeonHole) { array[index++] = element; } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; public class PlayfairCipher { private char[][] a; private String b; public PlayfairCipher(String object) { int n; this.b = object; object = this; Object object2 = ((PlayfairCipher)object).b + \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"; StringBuilder stringBuilder = new StringBuilder(); for (n = 0; n < ((String)object2).length(); ++n) { if (stringBuilder.indexOf(String.valueOf(((String)object2).charAt(n))) != -1) continue; stringBuilder.append(((String)object2).charAt(n)); } object2 = stringBuilder.toString(); ((PlayfairCipher)object).a = new char[5][5]; int n2 = 0; for (n = 0; n < 5; ++n) { for (int i = 0; i < 5; ++i) { ((PlayfairCipher)object).a[n][i] = ((String)object2).charAt(n2); ++n2; } } } /* * WARNING - void declaration */ public String encrypt(String object) { void var3_6; Object object2; int n; object = ((String)object).replace(\"J\", \"I\"); object = ((String)object).toUpperCase().replaceAll(\"[^A-Z]\", \"\"); StringBuilder stringBuilder = new StringBuilder(); boolean n2 = false; char[] cArray = ((String)object).toCharArray(); object = cArray; int n3 = cArray.length; for (n = 0; n < n3; ++n) { Object object3; object2 = object[n]; if (object2 != object3) { stringBuilder.append((char)object2); object3 = object2; continue; } stringBuilder.append('X').append((char)object2); object3 = false; } if (stringBuilder.length() % 2 != 0) { stringBuilder.append('X'); } object = stringBuilder.toString(); stringBuilder = new StringBuilder(); boolean bl = false; while (var3_6 < ((String)object).length()) { n3 = ((String)object).charAt((int)var3_6); n = ((String)object).charAt((int)(var3_6 + true)); int[] nArray = this.a((char)n3); int[] nArray2 = this.a((char)n); object2 = nArray[0]; n3 = nArray[1]; int n4 = nArray2[0]; n = nArray2[1]; if (object2 == n4) { stringBuilder.append(this.a[object2][(n3 + 1) % 5]); stringBuilder.append(this.a[n4][(n + 1) % 5]); } else if (n3 == n) { stringBuilder.append(this.a[(object2 + true) % 5][n3]); stringBuilder.append(this.a[(n4 + 1) % 5][n]); } else { stringBuilder.append(this.a[object2][n]); stringBuilder.append(this.a[n4][n3]); } var3_6 += 2; } return stringBuilder.toString(); } public String decrypt(String string) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < string.length(); i += 2) { int n = string.charAt(i); int n2 = string.charAt(i + 1); int[] nArray = this.a((char)n); int[] nArray2 = this.a((char)n2); int n3 = nArray[0]; n = nArray[1]; int n4 = nArray2[0]; n2 = nArray2[1]; if (n3 == n4) { stringBuilder.append(this.a[n3][(n + 4) % 5]); stringBuilder.append(this.a[n4][(n2 + 4) % 5]); continue; } if (n == n2) { stringBuilder.append(this.a[(n3 + 4) % 5][n]); stringBuilder.append(this.a[(n4 + 4) % 5][n2]); continue; } stringBuilder.append(this.a[n3][n2]); stringBuilder.append(this.a[n4][n]); } return stringBuilder.toString(); } private int[] a(char c) { int[] nArray = new int[2]; for (int i = 0; i < 5; ++i) { for (int j = 0; j < 5; ++j) { if (this.a[i][j] != c) continue; nArray[0] = i; nArray[1] = j; return nArray; } } return nArray; } public void printMatrix() { System.out.println(\"\\nPlayfair Cipher Matrix:\"); for (int i = 0; i < 5; ++i) { for (int j = 0; j < 5; ++j) { System.out.print(this.a[i][j] + \" \"); } System.out.println(); } } }", "deobfuscated_code": "package com.thealgorithms.ciphers; public class PlayfairCipher { private char[][] matrix; private String key; public PlayfairCipher(String key) { this.key = key; generateMatrix(); } public String encrypt(String plaintext) { plaintext = prepareText(plaintext.replace(\"J\", \"I\")); StringBuilder ciphertext = new StringBuilder(); for (int i = 0; i < plaintext.length(); i += 2) { char char1 = plaintext.charAt(i); char char2 = plaintext.charAt(i + 1); int[] pos1 = findPosition(char1); int[] pos2 = findPosition(char2); int row1 = pos1[0]; int col1 = pos1[1]; int row2 = pos2[0]; int col2 = pos2[1]; if (row1 == row2) { ciphertext.append(matrix[row1][(col1 + 1) % 5]); ciphertext.append(matrix[row2][(col2 + 1) % 5]); } else if (col1 == col2) { ciphertext.append(matrix[(row1 + 1) % 5][col1]); ciphertext.append(matrix[(row2 + 1) % 5][col2]); } else { ciphertext.append(matrix[row1][col2]); ciphertext.append(matrix[row2][col1]); } } return ciphertext.toString(); } public String decrypt(String ciphertext) { StringBuilder plaintext = new StringBuilder(); for (int i = 0; i < ciphertext.length(); i += 2) { char char1 = ciphertext.charAt(i); char char2 = ciphertext.charAt(i + 1); int[] pos1 = findPosition(char1); int[] pos2 = findPosition(char2); int row1 = pos1[0]; int col1 = pos1[1]; int row2 = pos2[0]; int col2 = pos2[1]; if (row1 == row2) { plaintext.append(matrix[row1][(col1 + 4) % 5]); plaintext.append(matrix[row2][(col2 + 4) % 5]); } else if (col1 == col2) { plaintext.append(matrix[(row1 + 4) % 5][col1]); plaintext.append(matrix[(row2 + 4) % 5][col2]); } else { plaintext.append(matrix[row1][col2]); plaintext.append(matrix[row2][col1]); } } return plaintext.toString(); } private void generateMatrix() { String keyWithoutDuplicates = removeDuplicateChars(key + \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"); matrix = new char[5][5]; int index = 0; for (int i = 0; i < 5; i++) { for (int j = 0; j < 5; j++) { matrix[i][j] = keyWithoutDuplicates.charAt(index); index++; } } } private String removeDuplicateChars(String str) { StringBuilder result = new StringBuilder(); for (int i = 0; i < str.length(); i++) { if (result.indexOf(String.valueOf(str.charAt(i))) == -1) { result.append(str.charAt(i)); } } return result.toString(); } private String prepareText(String text) { text = text.toUpperCase().replaceAll(\"[^A-Z]\", \"\"); StringBuilder preparedText = new StringBuilder(); char prevChar = '\\0'; for (char c : text.toCharArray()) { if (c != prevChar) { preparedText.append(c); prevChar = c; } else { preparedText.append('X').append(c); prevChar = '\\0'; } } if (preparedText.length() % 2 != 0) { preparedText.append('X'); } return preparedText.toString(); } private int[] findPosition(char c) { int[] pos = new int[2]; for (int i = 0; i < 5; i++) { for (int j = 0; j < 5; j++) { if (matrix[i][j] == c) { pos[0] = i; pos[1] = j; return pos; } } } return pos; } public void printMatrix() { System.out.println(\"\\nPlayfair Cipher Matrix:\"); for (int i = 0; i < 5; i++) { for (int j = 0; j < 5; j++) { System.out.print(matrix[i][j] + \" \"); } System.out.println(); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.geometry; import com.thealgorithms.geometry.Point; import java.util.Comparator; final class Point$PolarOrder implements Comparator { private /* synthetic */ Point a; private Point$PolarOrder(Point point) { this.a = point; } public final int compare(Point point, Point point2) { int n = point.a - this.a.a; int n2 = point.b - this.a.b; int n3 = point2.a - this.a.a; int n4 = point2.b - this.a.b; if (n2 >= 0 && n4 < 0) { return -1; } if (n4 >= 0 && n2 < 0) { return 1; } if (n2 == 0 && n4 == 0) { return Integer.compare(n3, n); } return -Point.orientation(this.a, point, point2); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.geometry; import com.thealgorithms.geometry.Point; import java.util.Comparator; final class Point$PolarOrder implements Comparator { private /* synthetic */ Point a; private Point$PolarOrder(Point point) { this.a = point; } public final int compare(Point point, Point point2) { int n = point.a - this.a.a; int n2 = point.b - this.a.b; int n3 = point2.a - this.a.a; int n4 = point2.b - this.a.b; if (n2 >= 0 && n4 < 0) { return -1; } if (n4 >= 0 && n2 < 0) { return 1; } if (n2 == 0 && n4 == 0) { return Integer.compare(n3, n); } return -Point.orientation(this.a, point, point2); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.lineclipping.utils; import java.util.Objects; public class Point { public double x; public double y; public Point() { } public Point(double d, double d2) { this.x = d; this.y = d2; } public boolean equals(Object object) { if (this == object) { return true; } if (!(object instanceof Point)) { return false; } object = (Point)object; return Double.compare(this.x, ((Point)object).x) == 0 && Double.compare(this.y, ((Point)object).y) == 0; } public int hashCode() { return Objects.hash(this.x, this.y); } public String toString() { return \"(\" + this.x + \", \" + this.y + \")\"; } }", "deobfuscated_code": "package com.thealgorithms.lineclipping.utils; import java.util.Objects; /** * @author moksedursohan * @since 10/4/24 */ public class Point { public double x; public double y; public Point() { } public Point(double x, double y) { this.x = x; this.y = y; } @Override public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof Point point)) { return false; } return Double.compare(x, point.x) == 0 && Double.compare(y, point.y) == 0; } @Override public int hashCode() { return Objects.hash(x, y); } @Override public String toString() { return \"(\" + x + \", \" + y + \")\"; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class PollardRho { private PollardRho() { } }", "deobfuscated_code": "package com.thealgorithms.maths; /* * Java program for pollard rho algorithm * The algorithm is used to factorize a number n = pq, * where p is a non-trivial factor. * Pollard's rho algorithm is an algorithm for integer factorization * and it takes as its inputs n, the integer to be factored; * and g(x), a polynomial in x computed modulo n. * In the original algorithm, g(x) = ((x ^ 2)  1) mod n, * but nowadays it is more common to use g(x) = ((x ^ 2) + 1 ) mod n. * The output is either a non-trivial factor of n, or failure. * It performs the following steps: * x  2 * y  2 * d  1 * while d = 1: * x  g(x) * y  g(g(y)) * d  gcd(|x - y|, n) * if d = n: * return failure * else: * return d * Here x and y corresponds to xi and xj in the previous section. * Note that this algorithm may fail to find a nontrivial factor even when n is composite. * In that case, the method can be tried again, using a starting value other than 2 or a different g(x) * * Wikipedia: https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm * * Author: Akshay Dubey (https://github.com/itsAkshayDubey) * * */ public final class PollardRho { private PollardRho() { } /** * This method returns a polynomial in x computed modulo n * * @param base Integer base of the polynomial * @param modulus Integer is value which is to be used to perform modulo operation over the * polynomial * @return Integer (((base * base) - 1) % modulus) */ static int g(int base, int modulus) { return ((base * base) - 1) % modulus; } /** * This method returns a non-trivial factor of given integer number * * @param number Integer is a integer value whose non-trivial factor is to be found * @return Integer non-trivial factor of number * @throws RuntimeException object if GCD of given number cannot be found */ static int pollardRho(int number) { int x = 2; int y = 2; int d = 1; while (d == 1) { // tortoise move x = g(x, number); // hare move y = g(g(y, number), number); // check GCD of |x-y| and number d = GCD.gcd(Math.abs(x - y), number); } if (d == number) { throw new RuntimeException(\"GCD cannot be found.\"); } return d; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; public final class Polybius { private static final char[][] a = new char[][]{{'A', 'B', 'C', 'D', 'E'}, {'F', 'G', 'H', 'I', 'J'}, {'K', 'L', 'M', 'N', 'O'}, {'P', 'Q', 'R', 'S', 'T'}, {'V', 'W', 'X', 'Y', 'Z'}}; private Polybius() { } public static String encrypt(String object) { object = ((String)object).toUpperCase().toCharArray(); StringBuilder stringBuilder = new StringBuilder(); for (Object object2 : object) { StringBuilder stringBuilder2 = new StringBuilder(); block1: for (int i = 0; i < a.length; ++i) { for (int j = 0; j < a[i].length; ++j) { if (object2 != a[i][j]) continue; stringBuilder2.append(i).append(j); continue block1; } } String string = stringBuilder2.toString(); stringBuilder.append(string); } return stringBuilder.toString(); } public static String decrypt(String object) { object = ((String)object).toCharArray(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < ((Object)object).length; i += 2) { int n = Character.getNumericValue((char)object[i]); int n2 = Character.getNumericValue((char)object[i + 1]); stringBuilder.append(a[n][n2]); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; /** * A Java implementation of Polybius Cipher * Polybius is a substitution cipher method * It was invented by a greek philosopher that name is Polybius * Letters in alphabet takes place to two dimension table. * Encrypted text is created according to row and column in two dimension table * Decrypted text is generated by looking at the row and column respectively * Additionally, some letters in english alphabet deliberately throws such as U because U is very * similar with V * * @author Hikmet AKIR * @since 08-07-2022+03:00 */ public final class Polybius { private Polybius() { } private static final char[][] KEY = { // 0 1 2 3 4 /* 0 */ {'A', 'B', 'C', 'D', 'E'}, /* 1 */ {'F', 'G', 'H', 'I', 'J'}, /* 2 */ {'K', 'L', 'M', 'N', 'O'}, /* 3 */ {'P', 'Q', 'R', 'S', 'T'}, /* 4 */ {'V', 'W', 'X', 'Y', 'Z'}, }; private static String findLocationByCharacter(final char character) { final StringBuilder location = new StringBuilder(); for (int i = 0; i < KEY.length; i++) { for (int j = 0; j < KEY[i].length; j++) { if (character == KEY[i][j]) { location.append(i).append(j); break; } } } return location.toString(); } public static String encrypt(final String plaintext) { final char[] chars = plaintext.toUpperCase().toCharArray(); final StringBuilder ciphertext = new StringBuilder(); for (char aChar : chars) { String location = findLocationByCharacter(aChar); ciphertext.append(location); } return ciphertext.toString(); } public static String decrypt(final String ciphertext) { final char[] chars = ciphertext.toCharArray(); final StringBuilder plaintext = new StringBuilder(); for (int i = 0; i < chars.length; i += 2) { int pozitionX = Character.getNumericValue(chars[i]); int pozitionY = Character.getNumericValue(chars[i + 1]); plaintext.append(KEY[pozitionX][pozitionY]); } return plaintext.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; public final class PostOrderTraversal { private PostOrderTraversal() { } public static List recursivePostOrder(BinaryTree$Node binaryTree$Node) { ArrayList arrayList = new ArrayList(); PostOrderTraversal.a(binaryTree$Node, arrayList); return arrayList; } public static List iterativePostOrder(BinaryTree$Node binaryTree$Node) { LinkedList<Integer> linkedList = new LinkedList<Integer>(); if (binaryTree$Node == null) { return linkedList; } ArrayDeque<BinaryTree$Node> arrayDeque = new ArrayDeque<BinaryTree$Node>(); arrayDeque.push(binaryTree$Node); while (!arrayDeque.isEmpty()) { binaryTree$Node = (BinaryTree$Node)arrayDeque.pop(); linkedList.addFirst(binaryTree$Node.data); if (binaryTree$Node.left != null) { arrayDeque.push(binaryTree$Node.left); } if (binaryTree$Node.right == null) continue; arrayDeque.push(binaryTree$Node.right); } return linkedList; } private static void a(BinaryTree$Node binaryTree$Node, List list) { if (binaryTree$Node == null) { return; } PostOrderTraversal.a(binaryTree$Node.left, list); PostOrderTraversal.a(binaryTree$Node.right, list); list.add(binaryTree$Node.data); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Deque; import java.util.LinkedList; import java.util.List; /** * Given tree is traversed in a 'post-order' way: LEFT -> RIGHT -> ROOT. * Below are given the recursive and iterative implementations. * <p> * Complexities: * Recursive: O(n) - time, O(n) - space, where 'n' is the number of nodes in a tree. * <p> * Iterative: O(n) - time, O(h) - space, where 'n' is the number of nodes in a tree * and 'h' is the height of a binary tree. * In the worst case 'h' can be O(n) if tree is completely unbalanced, for instance: * 5 * \\ * 6 * \\ * 7 * \\ * 8 * * @author Albina Gimaletdinova on 21/02/2023 */ public final class PostOrderTraversal { private PostOrderTraversal() { } public static List<Integer> recursivePostOrder(BinaryTree.Node root) { List<Integer> result = new ArrayList<>(); recursivePostOrder(root, result); return result; } public static List<Integer> iterativePostOrder(BinaryTree.Node root) { LinkedList<Integer> result = new LinkedList<>(); if (root == null) { return result; } Deque<BinaryTree.Node> stack = new ArrayDeque<>(); stack.push(root); while (!stack.isEmpty()) { BinaryTree.Node node = stack.pop(); result.addFirst(node.data); if (node.left != null) { stack.push(node.left); } if (node.right != null) { stack.push(node.right); } } return result; } private static void recursivePostOrder(BinaryTree.Node root, List<Integer> result) { if (root == null) { return; } recursivePostOrder(root.left, result); recursivePostOrder(root.right, result); result.add(root.data); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Set; import java.util.Stack; public final class PostfixEvaluator { private static final Set a = Set.of(\"+\", \"-\", \"*\", \"/\"); private PostfixEvaluator() { } public static int evaluatePostfix(String stringArray) { Stack<Integer> stack = new Stack<Integer>(); for (String string : stringArray.split(\"\\\\s+\")) { String string2 = string; if (a.contains(string2)) { int n; int n2 = (Integer)stack.pop(); int n3 = n = ((Integer)stack.pop()).intValue(); n = n2; int n4 = n3; stack.push(switch (string) { case \"+\" -> n4 + n; case \"-\" -> n4 - n; case \"*\" -> n4 * n; case \"/\" -> n4 / n; default -> throw new IllegalArgumentException(\"Invalid operator\"); }); continue; } stack.push(Integer.valueOf(string)); } if (stack.size() != 1) { throw new IllegalArgumentException(\"Invalid expression\"); } return (Integer)stack.pop(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Set; import java.util.Stack; /** * Evaluate a postfix (Reverse Polish) expression using a stack. * * <p>Example: Expression \"5 6 + 2 *\" results in 22. * <p>Applications: Used in calculators and expression evaluation in compilers. * * @author Hardvan */ public final class PostfixEvaluator { private PostfixEvaluator() { } private static final Set<String> OPERATORS = Set.of(\"+\", \"-\", \"*\", \"/\"); /** * Evaluates the given postfix expression and returns the result. * * @param expression The postfix expression as a string with operands and operators separated by spaces. * @return The result of evaluating the postfix expression. * @throws IllegalArgumentException if the expression is invalid. */ public static int evaluatePostfix(String expression) { Stack<Integer> stack = new Stack<>(); for (String token : expression.split(\"\\\\s+\")) { if (isOperator(token)) { int operand2 = stack.pop(); int operand1 = stack.pop(); stack.push(applyOperator(token, operand1, operand2)); } else { stack.push(Integer.valueOf(token)); } } if (stack.size() != 1) { throw new IllegalArgumentException(\"Invalid expression\"); } return stack.pop(); } /** * Checks if the given token is an operator. * * @param token The token to check. * @return true if the token is an operator, false otherwise. */ private static boolean isOperator(String token) { return OPERATORS.contains(token); } /** * Applies the given operator to the two operands. * * @param operator The operator to apply. * @param a The first operand. * @param b The second operand. * @return The result of applying the operator to the operands. */ private static int applyOperator(String operator, int a, int b) { return switch (operator) { case \"+\" -> a + b; case \"-\" -> a - b; case \"*\" -> a * b; case \"/\" -> a / b; default -> throw new IllegalArgumentException(\"Invalid operator\"); }; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Stack; public final class PostfixToInfix { private PostfixToInfix() { } public static boolean isOperator(char c) { return c == '+' || c == '-' || c == '/' || c == '*' || c == '^'; } public static boolean isValidPostfixExpression(String object) { if (((String)object).length() == 1 && Character.isAlphabetic(((String)object).charAt(0))) { return true; } if (((String)object).length() < 3) { return false; } int n = 0; int n2 = 0; char[] cArray = ((String)object).toCharArray(); object = cArray; int n3 = cArray.length; for (int i = 0; i < n3; ++i) { Object object2 = object[i]; if (PostfixToInfix.isOperator((char)object2)) { if (++n2 < n) continue; return false; } ++n; } return n == n2 + 1; } public static String getPostfixToInfix(String object) { if (((String)object).isEmpty()) { return \"\"; } if (!PostfixToInfix.isValidPostfixExpression((String)object)) { throw new IllegalArgumentException(\"Invalid Postfix Expression\"); } Stack<String> stack = new Stack<String>(); StringBuilder stringBuilder = new StringBuilder(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object2 = object[i]; if (!PostfixToInfix.isOperator((char)object2)) { stack.push(Character.toString((char)object2)); continue; } String string = (String)stack.pop(); String string2 = (String)stack.pop(); stringBuilder.append('(').append(string2).append((char)object2).append(string).append(')'); stack.push(stringBuilder.toString()); stringBuilder.setLength(0); } return (String)stack.pop(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; /** * Postfix to Infix implementation via Stack * * Function: String getPostfixToInfix(String postfix) * Returns the Infix Expression for the given postfix parameter. * * Avoid using parentheses/brackets/braces for the postfix string. * Postfix Expressions don't require these. * * * @author nikslyon19 (Nikhil Bisht) * */ public final class PostfixToInfix { private PostfixToInfix() { } /** * Determines if a given character is a valid arithmetic operator. * * @param token the character to check * @return true if the character is an operator, false otherwise */ public static boolean isOperator(char token) { return token == '+' || token == '-' || token == '/' || token == '*' || token == '^'; } /** * Validates whether a given string is a valid postfix expression. * * A valid postfix expression must meet these criteria: * 1. It should have at least one operator and two operands. * 2. The number of operands should always be greater than the number of operators at any point in the traversal. * * @param postfix the postfix expression string to validate * @return true if the expression is valid, false otherwise */ public static boolean isValidPostfixExpression(String postfix) { if (postfix.length() == 1 && (Character.isAlphabetic(postfix.charAt(0)))) { return true; } if (postfix.length() < 3) { return false; // Postfix expression should have at least one operator and two operands } int operandCount = 0; int operatorCount = 0; for (char token : postfix.toCharArray()) { if (isOperator(token)) { operatorCount++; if (operatorCount >= operandCount) { return false; // Invalid: more operators than operands at any point } } else { operandCount++; } } return operandCount == operatorCount + 1; } /** * Converts a valid postfix expression to an infix expression. * * @param postfix the postfix expression to convert * @return the equivalent infix expression * @throws IllegalArgumentException if the postfix expression is invalid */ public static String getPostfixToInfix(String postfix) { if (postfix.isEmpty()) { return \"\"; } if (!isValidPostfixExpression(postfix)) { throw new IllegalArgumentException(\"Invalid Postfix Expression\"); } Stack<String> stack = new Stack<>(); StringBuilder valueString = new StringBuilder(); for (char token : postfix.toCharArray()) { if (!isOperator(token)) { stack.push(Character.toString(token)); } else { String operandB = stack.pop(); String operandA = stack.pop(); valueString.append('(').append(operandA).append(token).append(operandB).append(')'); stack.push(valueString.toString()); valueString.setLength(0); } } return stack.pop(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class Pow { private Pow() { } public static long pow(int n, int n2) { if (n2 < 0) { throw new IllegalArgumentException(\"Exponent must be non-negative.\"); } long l = 1L; for (int i = 1; i <= n2; ++i) { l *= (long)n; } return l; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * A utility class for computing exponentiation (power) of integers. * <p> * This class provides a method to calculate the value of a base raised to a given exponent using a simple iterative approach. * For example, given a base {@code a} and an exponent {@code b}, the class computes {@code a}<sup>{@code b}</sup>. * </p> */ public final class Pow { private Pow() { } /** * Computes the value of the base raised to the power of the exponent. * <p> * The method calculates {@code a}<sup>{@code b}</sup> by iteratively multiplying the base {@code a} with itself {@code b} times. * If the exponent {@code b} is negative, an {@code IllegalArgumentException} is thrown. * </p> * * @param a the base of the exponentiation. Must be a non-negative integer. * @param b the exponent to which the base {@code a} is raised. Must be a non-negative integer. * @return the result of {@code a}<sup>{@code b}</sup> as a {@code long}. * @throws IllegalArgumentException if {@code b} is negative. */ public static long pow(int a, int b) { if (b < 0) { throw new IllegalArgumentException(\"Exponent must be non-negative.\"); } long result = 1; for (int i = 1; i <= b; i++) { result *= a; } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class PowerOfTwoOrNot { private PowerOfTwoOrNot() { } public static boolean checkIfPowerOfTwoOrNot(int n) { if (n != 0) { int n2 = n; if ((n2 & n2 - 1) == 0) { return true; } } return false; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * A utility to check if a given number is power of two or not. For example 8,16 * etc. */ public final class PowerOfTwoOrNot { private PowerOfTwoOrNot() { } /** * Checks whether given number is power of two or not. * * @param number the number to check * @return {@code true} if given number is power of two, otherwise * {@code false} */ public static boolean checkIfPowerOfTwoOrNot(final int number) { return number != 0 && ((number & (number - 1)) == 0); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; public class PowerSum { public int powSum(int n, int n2) { if (n == 0 && n2 == 0) { return 1; } return this.a(n, n2, 1, 0); } private int a(int n, int n2, int n3, int n4) { int n5 = n4 + (int)Math.pow(n3, n2); if (n5 == n) { return 1; } if (n5 > n) { return 0; } return this.a(n, n2, n3 + 1, n5) + this.a(n, n2, n3 + 1, n4); } }", "deobfuscated_code": "package com.thealgorithms.backtracking; /** * Problem Statement: * Find the number of ways that a given integer, N, can be expressed as the sum of the Xth powers * of unique, natural numbers. * For example, if N=100 and X=3, we have to find all combinations of unique cubes adding up to 100. * The only solution is 1^3 + 2^3 + 3^3 + 4^3. Therefore, the output will be 1. * * N is represented by the parameter 'targetSum' in the code. * X is represented by the parameter 'power' in the code. */ public class PowerSum { /** * Calculates the number of ways to express the target sum as a sum of Xth powers of unique natural numbers. * * @param targetSum The target sum to achieve (N in the problem statement) * @param power The power to raise natural numbers to (X in the problem statement) * @return The number of ways to express the target sum */ public int powSum(int targetSum, int power) { // Special case: when both targetSum and power are zero if (targetSum == 0 && power == 0) { return 1; // by convention, one way to sum to zero: use nothing } return sumRecursive(targetSum, power, 1, 0); } /** * Recursively calculates the number of ways to express the remaining sum as a sum of Xth powers. * * @param remainingSum The remaining sum to achieve * @param power The power to raise natural numbers to (X in the problem statement) * @param currentNumber The current natural number being considered * @param currentSum The current sum of powered numbers * @return The number of valid combinations */ private int sumRecursive(int remainingSum, int power, int currentNumber, int currentSum) { int newSum = currentSum + (int) Math.pow(currentNumber, power); if (newSum == remainingSum) { return 1; } if (newSum > remainingSum) { return 0; } return sumRecursive(remainingSum, power, currentNumber + 1, newSum) + sumRecursive(remainingSum, power, currentNumber + 1, currentSum); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class PowerUsingRecursion { private PowerUsingRecursion() { } public static double power(double d, int n) { if (n == 0) { return 1.0; } double d2 = d; return d2 * PowerUsingRecursion.power(d2, n - 1); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * calculate Power using Recursion * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi) */ public final class PowerUsingRecursion { private PowerUsingRecursion() { } public static double power(double base, int exponent) { // Base case: anything raised to the power of 0 is 1 if (exponent == 0) { return 1; } // Recursive case: base ^ exponent = base * base ^ (exponent - 1) // Recurse with a smaller exponent and multiply with base return base * power(base, exponent - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; public final class PreOrderTraversal { private PreOrderTraversal() { } public static List recursivePreOrder(BinaryTree$Node binaryTree$Node) { ArrayList arrayList = new ArrayList(); PreOrderTraversal.a(binaryTree$Node, arrayList); return arrayList; } public static List iterativePreOrder(BinaryTree$Node binaryTree$Node) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); if (binaryTree$Node == null) { return arrayList; } LinkedList<BinaryTree$Node> linkedList = new LinkedList<BinaryTree$Node>(); linkedList.push(binaryTree$Node); while (!linkedList.isEmpty()) { binaryTree$Node = (BinaryTree$Node)linkedList.pop(); arrayList.add(binaryTree$Node.data); if (binaryTree$Node.right != null) { linkedList.push(binaryTree$Node.right); } if (binaryTree$Node.left == null) continue; linkedList.push(binaryTree$Node.left); } return arrayList; } private static void a(BinaryTree$Node binaryTree$Node, List list) { while (binaryTree$Node != null) { list.add(binaryTree$Node.data); PreOrderTraversal.a(binaryTree$Node.left, list); binaryTree$Node = binaryTree$Node.right; } return; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayList; import java.util.Deque; import java.util.LinkedList; import java.util.List; /** * Given tree is traversed in a 'pre-order' way: ROOT -> LEFT -> RIGHT. * Below are given the recursive and iterative implementations. * * Complexities: * Recursive: O(n) - time, O(n) - space, where 'n' is the number of nodes in a tree. * * Iterative: O(n) - time, O(h) - space, where 'n' is the number of nodes in a tree * and 'h' is the height of a binary tree. * In the worst case 'h' can be O(n) if tree is completely unbalanced, for instance: * 5 * \\ * 6 * \\ * 7 * \\ * 8 * * @author Albina Gimaletdinova on 17/02/2023 */ public final class PreOrderTraversal { private PreOrderTraversal() { } public static List<Integer> recursivePreOrder(BinaryTree.Node root) { List<Integer> result = new ArrayList<>(); recursivePreOrder(root, result); return result; } public static List<Integer> iterativePreOrder(BinaryTree.Node root) { List<Integer> result = new ArrayList<>(); if (root == null) { return result; } Deque<BinaryTree.Node> stack = new LinkedList<>(); stack.push(root); while (!stack.isEmpty()) { BinaryTree.Node node = stack.pop(); result.add(node.data); if (node.right != null) { stack.push(node.right); } if (node.left != null) { stack.push(node.left); } } return result; } private static void recursivePreOrder(BinaryTree.Node root, List<Integer> result) { if (root == null) { return; } result.add(root.data); recursivePreOrder(root.left, result); recursivePreOrder(root.right, result); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.devutils.entities.ProcessDetails; import java.util.ArrayList; import java.util.Collection; import java.util.Comparator; import java.util.List; import java.util.PriorityQueue; public class PreemptivePriorityScheduling { private List a; private List b; public PreemptivePriorityScheduling(Collection collection) { this.a = new ArrayList(collection); this.b = new ArrayList(); } public void scheduleProcesses() { PriorityQueue<ProcessDetails> priorityQueue = new PriorityQueue<ProcessDetails>(Comparator.comparingInt(ProcessDetails::getPriority).reversed().thenComparingInt(ProcessDetails::getArrivalTime)); int n = 0; ArrayList arrayList = new ArrayList(); while (!this.a.isEmpty() || !priorityQueue.isEmpty()) { ArrayList arrayList2 = arrayList; int n2 = n; Object object = this; ((PreemptivePriorityScheduling)object).a.removeIf(processDetails -> { if (processDetails.getArrivalTime() <= n2) { arrayList2.add(processDetails); return true; } return false; }); priorityQueue.addAll(arrayList); arrayList.clear(); if (!priorityQueue.isEmpty()) { object = priorityQueue.poll(); this.b.add(((ProcessDetails)object).getProcessId()); Object object2 = object; ((ProcessDetails)object2).setBurstTime(((ProcessDetails)object2).getBurstTime() - 1); if (((ProcessDetails)object).getBurstTime() > 0) { priorityQueue.add((ProcessDetails)object); } } else { this.b.add(\"Idle\"); } ++n; } } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import com.thealgorithms.devutils.entities.ProcessDetails; import java.util.ArrayList; import java.util.Collection; import java.util.Comparator; import java.util.List; import java.util.PriorityQueue; /** * Preemptive Priority Scheduling Algorithm * * @author [Bama Charan Chhandogi](https://www.github.com/BamaCharanChhandogi) */ public class PreemptivePriorityScheduling { protected final List<ProcessDetails> processes; protected final List<String> ganttChart; public PreemptivePriorityScheduling(Collection<ProcessDetails> processes) { this.processes = new ArrayList<>(processes); this.ganttChart = new ArrayList<>(); } public void scheduleProcesses() { PriorityQueue<ProcessDetails> readyQueue = new PriorityQueue<>(Comparator.comparingInt(ProcessDetails::getPriority).reversed().thenComparingInt(ProcessDetails::getArrivalTime)); int currentTime = 0; List<ProcessDetails> arrivedProcesses = new ArrayList<>(); while (!processes.isEmpty() || !readyQueue.isEmpty()) { updateArrivedProcesses(currentTime, arrivedProcesses); readyQueue.addAll(arrivedProcesses); arrivedProcesses.clear(); if (!readyQueue.isEmpty()) { ProcessDetails currentProcess = readyQueue.poll(); ganttChart.add(currentProcess.getProcessId()); currentProcess.setBurstTime(currentProcess.getBurstTime() - 1); if (currentProcess.getBurstTime() > 0) { readyQueue.add(currentProcess); } } else { ganttChart.add(\"Idle\"); } currentTime++; } } private void updateArrivedProcesses(int currentTime, List<ProcessDetails> arrivedProcesses) { processes.removeIf(process -> { if (process.getArrivalTime() <= currentTime) { arrivedProcesses.add(process); return true; } return false; }); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Set; import java.util.Stack; public final class PrefixEvaluator { private static final Set a = Set.of(\"+\", \"-\", \"*\", \"/\"); private PrefixEvaluator() { } public static int evaluatePrefix(String stringArray) { Stack<Integer> stack = new Stack<Integer>(); stringArray = stringArray.split(\"\\\\s+\"); for (int i = stringArray.length - 1; i >= 0; --i) { String string = stringArray[i]; String string2 = string; if (a.contains(string2)) { int n = (Integer)stack.pop(); int n2 = (Integer)stack.pop(); int n3 = n; stack.push(switch (string) { case \"+\" -> n3 + n2; case \"-\" -> n3 - n2; case \"*\" -> n3 * n2; case \"/\" -> n3 / n2; default -> throw new IllegalArgumentException(\"Invalid operator\"); }); continue; } stack.push(Integer.valueOf(string)); } if (stack.size() != 1) { throw new IllegalArgumentException(\"Invalid expression\"); } return (Integer)stack.pop(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Set; import java.util.Stack; /** * Evaluate a prefix (Polish) expression using a stack. * * <p>Example: Expression \"+ * 2 3 4\" results in 10. * <p>Applications: Useful for implementing compilers and interpreters. * * @author Hardvan */ public final class PrefixEvaluator { private PrefixEvaluator() { } private static final Set<String> OPERATORS = Set.of(\"+\", \"-\", \"*\", \"/\"); /** * Evaluates the given prefix expression and returns the result. * * @param expression The prefix expression as a string with operands and operators separated by spaces. * @return The result of evaluating the prefix expression. * @throws IllegalArgumentException if the expression is invalid. */ public static int evaluatePrefix(String expression) { Stack<Integer> stack = new Stack<>(); String[] tokens = expression.split(\"\\\\s+\"); for (int i = tokens.length - 1; i >= 0; i--) { String token = tokens[i]; if (isOperator(token)) { int operand1 = stack.pop(); int operand2 = stack.pop(); stack.push(applyOperator(token, operand1, operand2)); } else { stack.push(Integer.valueOf(token)); } } if (stack.size() != 1) { throw new IllegalArgumentException(\"Invalid expression\"); } return stack.pop(); } /** * Checks if the given token is an operator. * * @param token The token to check. * @return true if the token is an operator, false otherwise. */ private static boolean isOperator(String token) { return OPERATORS.contains(token); } /** * Applies the given operator to the two operands. * * @param operator The operator to apply. * @param a The first operand. * @param b The second operand. * @return The result of applying the operator to the operands. */ private static int applyOperator(String operator, int a, int b) { return switch (operator) { case \"+\" -> a + b; case \"-\" -> a - b; case \"*\" -> a * b; case \"/\" -> a / b; default -> throw new IllegalArgumentException(\"Invalid operator\"); }; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Stack; public final class PrefixToInfix { private PrefixToInfix() { } public static boolean isOperator(char c) { return c == '+' || c == '-' || c == '/' || c == '*' || c == '^'; } public static String getPrefixToInfix(String string) { if (string == null) { throw new NullPointerException(\"Null prefix expression\"); } if (string.isEmpty()) { return \"\"; } Stack<Object> stack = new Stack<Object>(); for (int i = string.length() - 1; i >= 0; --i) { char c = string.charAt(i); if (PrefixToInfix.isOperator(c)) { String string2 = (String)stack.pop(); String string3 = (String)stack.pop(); String string4 = \"(\" + string2 + c + string3 + \")\"; stack.push(string4); continue; } stack.push(Character.toString(c)); } if (stack.size() != 1) { throw new ArithmeticException(\"Malformed prefix expression\"); } return (String)stack.pop(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; /** * Converts a prefix expression to an infix expression using a stack. * * The input prefix expression should consist of * valid operands (letters or digits) and operators (+, -, *, /, ^). * Parentheses are not required in the prefix string. */ public final class PrefixToInfix { private PrefixToInfix() { } /** * Determines if a given character is a valid arithmetic operator. * * @param token the character to check * @return true if the character is an operator, false otherwise */ public static boolean isOperator(char token) { return token == '+' || token == '-' || token == '/' || token == '*' || token == '^'; } /** * Converts a valid prefix expression to an infix expression. * * @param prefix the prefix expression to convert * @return the equivalent infix expression * @throws NullPointerException if the prefix expression is null */ public static String getPrefixToInfix(String prefix) { if (prefix == null) { throw new NullPointerException(\"Null prefix expression\"); } if (prefix.isEmpty()) { return \"\"; } Stack<String> stack = new Stack<>(); // Iterate over the prefix expression from right to left for (int i = prefix.length() - 1; i >= 0; i--) { char token = prefix.charAt(i); if (isOperator(token)) { // Pop two operands from stack String operandA = stack.pop(); String operandB = stack.pop(); // Form the infix expression with parentheses String infix = \"(\" + operandA + token + operandB + \")\"; // Push the resulting infix expression back onto the stack stack.push(infix); } else { // Push operand onto stack stack.push(Character.toString(token)); } } if (stack.size() != 1) { throw new ArithmeticException(\"Malformed prefix expression\"); } return stack.pop(); // final element on the stack is the full infix expression } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; public class PrimMST { public int[] primMST(int[][] nArray) { int n; int[] nArray2 = new int[5]; int[] nArray3 = new int[5]; Boolean[] booleanArray = new Boolean[5]; for (n = 0; n < 5; ++n) { nArray3[n] = Integer.MAX_VALUE; booleanArray[n] = Boolean.FALSE; } nArray3[0] = 0; nArray2[0] = -1; for (n = 0; n < 4; ++n) { Boolean[] booleanArray2 = booleanArray; int[] nArray4 = nArray3; int n2 = Integer.MAX_VALUE; int n3 = -1; for (int i = 0; i < 5; ++i) { if (booleanArray2[i].booleanValue() || nArray4[i] >= n2) continue; n2 = nArray4[i]; n3 = i; } int n4 = n3; booleanArray[n4] = Boolean.TRUE; for (int i = 0; i < 5; ++i) { if (nArray[n4][i] == 0 || booleanArray[i].booleanValue() || nArray[n4][i] >= nArray3[i]) continue; nArray2[i] = n4; nArray3[i] = nArray[n4][i]; } } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; /** * A Java program for Prim's Minimum Spanning Tree (MST) algorithm. * Adjacency matrix representation of the graph. */ public class PrimMST { // Number of vertices in the graph private static final int V = 5; // A utility function to find the vertex with the minimum key // value, from the set of vertices not yet included in the MST int minKey(int[] key, Boolean[] mstSet) { int min = Integer.MAX_VALUE; int minIndex = -1; for (int v = 0; v < V; v++) { if (!mstSet[v] && key[v] < min) { min = key[v]; minIndex = v; } } return minIndex; } // Function to construct MST for a graph using adjacency matrix representation public int[] primMST(int[][] graph) { int[] parent = new int[V]; // Array to store constructed MST int[] key = new int[V]; // Key values to pick minimum weight edge Boolean[] mstSet = new Boolean[V]; // Vertices not yet included in MST // Initialize all keys as INFINITE and mstSet[] as false for (int i = 0; i < V; i++) { key[i] = Integer.MAX_VALUE; mstSet[i] = Boolean.FALSE; } // Always include the first vertex in MST key[0] = 0; // Make key 0 to pick the first vertex parent[0] = -1; // First node is always root of MST // The MST will have V vertices for (int count = 0; count < V - 1; count++) { // Pick the minimum key vertex not yet included in MST int u = minKey(key, mstSet); mstSet[u] = Boolean.TRUE; // Update key value and parent index of adjacent vertices of the picked vertex for (int v = 0; v < V; v++) { if (graph[u][v] != 0 && !mstSet[v] && graph[u][v] < key[v]) { parent[v] = u; key[v] = graph[u][v]; } } } return parent; // Return the MST parent array } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths.Prime; import java.util.Scanner; public final class PrimeCheck { private PrimeCheck() { } public static void main(String[] object) { object = new Scanner(System.in); System.out.print(\"Enter a number: \"); int n = ((Scanner)object).nextInt(); if (PrimeCheck.isPrime(n)) { System.out.println(\"algo1 verify that \" + n + \" is a prime number\"); } else { System.out.println(\"algo1 verify that \" + n + \" is not a prime number\"); } if (PrimeCheck.fermatPrimeChecking(n, 20)) { System.out.println(\"algo2 verify that \" + n + \" is a prime number\"); } else { System.out.println(\"algo2 verify that \" + n + \" is not a prime number\"); } ((Scanner)object).close(); } public static boolean isPrime(int n) { if (n == 2) { return true; } if (n < 2 || n % 2 == 0) { return false; } int n2 = (int)Math.sqrt(n); for (int i = 3; i <= n2; i += 2) { if (n % i != 0) continue; return false; } return true; } public static boolean fermatPrimeChecking(int n, int n2) { int n3 = n - 2; for (int i = 0; i < n2; ++i) { long l = (long)Math.floor(Math.random() * (double)(n3 - 2 + 1) + 2.0); long l2 = n; long l3 = n - 1; long l4 = l; long l5 = 1L; int n4 = 0; while ((long)n4 < l3) { l5 *= l4; l5 %= l2; ++n4; } if (l5 % l2 == 1L) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.maths.Prime; import java.util.Scanner; public final class PrimeCheck { private PrimeCheck() { } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(\"Enter a number: \"); int n = scanner.nextInt(); if (isPrime(n)) { System.out.println(\"algo1 verify that \" + n + \" is a prime number\"); } else { System.out.println(\"algo1 verify that \" + n + \" is not a prime number\"); } if (fermatPrimeChecking(n, 20)) { System.out.println(\"algo2 verify that \" + n + \" is a prime number\"); } else { System.out.println(\"algo2 verify that \" + n + \" is not a prime number\"); } scanner.close(); } /** * * * Checks if a number is prime or not * * @param n the number * @return {@code true} if {@code n} is prime */ public static boolean isPrime(int n) { if (n == 2) { return true; } if (n < 2 || n % 2 == 0) { return false; } for (int i = 3, limit = (int) Math.sqrt(n); i <= limit; i += 2) { if (n % i == 0) { return false; } } return true; } /** * * * Checks if a number is prime or not * * @param n the number * @return {@code true} if {@code n} is prime */ public static boolean fermatPrimeChecking(int n, int iteration) { long a; int up = n - 2; int down = 2; for (int i = 0; i < iteration; i++) { a = (long) Math.floor(Math.random() * (up - down + 1) + down); if (modPow(a, n - 1, n) != 1) { return false; } } return true; } /** * * * @param a basis * @param b exponent * @param c modulo * @return (a^b) mod c */ private static long modPow(long a, long b, long c) { long res = 1; for (int i = 0; i < b; i++) { res *= a; res %= c; } return res % c; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths.Prime; import java.util.ArrayList; import java.util.List; public final class PrimeFactorization { private PrimeFactorization() { } public static List pfactors(int n) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); if (n == 0) { return arrayList; } while (n % 2 == 0) { arrayList.add(2); n /= 2; } int n2 = 3; while ((double)n2 <= Math.sqrt(n)) { while (n % n2 == 0) { arrayList.add(n2); n /= n2; } n2 += 2; } if (n > 2) { arrayList.add(n); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.maths.Prime; /* * Authors: * (1) Aitor Fidalgo Snchez (https://github.com/aitorfi) * (2) Akshay Dubey (https://github.com/itsAkshayDubey) */ import java.util.ArrayList; import java.util.List; public final class PrimeFactorization { private PrimeFactorization() { } public static List<Integer> pfactors(int n) { List<Integer> primeFactors = new ArrayList<>(); if (n == 0) { return primeFactors; } while (n % 2 == 0) { primeFactors.add(2); n /= 2; } for (int i = 3; i <= Math.sqrt(n); i += 2) { while (n % i == 0) { primeFactors.add(i); n /= i; } } if (n > 2) { primeFactors.add(n); } return primeFactors; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.ArrayList; import java.util.List; public class PrintAMatrixInSpiralOrder { public List print(int[][] nArray, int n, int n2) { int n3 = 0; int n4 = 0; ArrayList<Integer> arrayList = new ArrayList<Integer>(); while (n3 < n && n4 < n2) { int n5; for (n5 = n4; n5 < n2; ++n5) { arrayList.add(nArray[n3][n5]); } for (n5 = ++n3; n5 < n; ++n5) { arrayList.add(nArray[n5][n2 - 1]); } --n2; if (n3 < n) { for (n5 = n2 - 1; n5 >= n4; --n5) { arrayList.add(nArray[n - 1][n5]); } --n; } if (n4 >= n2) continue; for (n5 = n - 1; n5 >= n3; --n5) { arrayList.add(nArray[n5][n4]); } ++n4; } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.ArrayList; import java.util.List; public class PrintAMatrixInSpiralOrder { /** * Search a key in row and column wise sorted matrix * * @param matrix matrix to be searched * @param row number of rows matrix has * @param col number of columns matrix has * @author Sadiul Hakim : https://github.com/sadiul-hakim */ public List<Integer> print(int[][] matrix, int row, int col) { // r traverses matrix row wise from first int r = 0; // c traverses matrix column wise from first int c = 0; int i; List<Integer> result = new ArrayList<>(); while (r < row && c < col) { // print first row of matrix for (i = c; i < col; i++) { result.add(matrix[r][i]); } // increase r by one because first row printed r++; // print last column for (i = r; i < row; i++) { result.add(matrix[i][col - 1]); } // decrease col by one because last column has been printed col--; // print rows from last except printed elements if (r < row) { for (i = col - 1; i >= c; i--) { result.add(matrix[row - 1][i]); } row--; } // print columns from first except printed elements if (c < col) { for (i = row - 1; i >= r; i--) { result.add(matrix[i][c]); } c++; } } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.Tree; import com.thealgorithms.datastructures.trees.TreeNode; public final class PrintTopViewofTree { private PrintTopViewofTree() { } public static void main(String[] object) { object = new TreeNode(1); new TreeNode(1).b = new TreeNode(2); ((TreeNode)object).c = new TreeNode(3); ((TreeNode)object).b.c = new TreeNode(4); ((TreeNode)object).b.c.c = new TreeNode(5); ((TreeNode)object).b.c.c.c = new TreeNode(6); object = new Tree((TreeNode)object); System.out.println(\"Following are nodes in top view of Binary Tree\"); ((Tree)object).printTopView(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; // Java program to print top view of Binary tree import java.util.HashSet; import java.util.LinkedList; import java.util.Queue; // Class for a tree node class TreeNode { // Members int key; TreeNode left; TreeNode right; // Constructor TreeNode(int key) { this.key = key; left = null; right = null; } } // A class to represent a queue item. The queue is used to do Level // order traversal. Every Queue item contains node and horizontal // distance of node from root class QItem { TreeNode node; int hd; QItem(TreeNode n, int h) { node = n; hd = h; } } // Class for a Binary Tree class Tree { TreeNode root; // Constructors Tree() { root = null; } Tree(TreeNode n) { root = n; } // This method prints nodes in top view of binary tree public void printTopView() { // base case if (root == null) { return; } // Creates an empty hashset HashSet<Integer> set = new HashSet<>(); // Create a queue and add root to it Queue<QItem> queue = new LinkedList<QItem>(); queue.add(new QItem(root, 0)); // Horizontal distance of root is 0 // Standard BFS or level order traversal loop while (!queue.isEmpty()) { // Remove the front item and get its details QItem qi = queue.remove(); int hd = qi.hd; TreeNode n = qi.node; // If this is the first node at its horizontal distance, // then this node is in top view if (!set.contains(hd)) { set.add(hd); System.out.print(n.key + \" \"); } // Enqueue left and right children of current node if (n.left != null) { queue.add(new QItem(n.left, hd - 1)); } if (n.right != null) { queue.add(new QItem(n.right, hd + 1)); } } } } // Driver class to test above methods public final class PrintTopViewofTree { private PrintTopViewofTree() { } public static void main(String[] args) { /* Create following Binary Tree 1 / \\ 2 3 \\ 4 \\ 5 \\ 6*/ TreeNode root = new TreeNode(1); root.left = new TreeNode(2); root.right = new TreeNode(3); root.left.right = new TreeNode(4); root.left.right.right = new TreeNode(5); root.left.right.right.right = new TreeNode(6); Tree t = new Tree(root); System.out.println(\"Following are nodes in top view of Binary Tree\"); t.printTopView(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; class PriorityQueue { private int a = 12; private int[] b = new int[this.a]; private int c = 0; PriorityQueue() { } public void insert(int n) { if (this.isFull()) { throw new RuntimeException(\"Queue is full\"); } this.b[++this.c] = n; PriorityQueue priorityQueue = this; for (int i = (v44113).c; i > 1 && priorityQueue.b[i / 2] < priorityQueue.b[i]; i /= 2) { int n2 = priorityQueue.b[i]; priorityQueue.b[i] = priorityQueue.b[i / 2]; priorityQueue.b[i / 2] = n2; } } public int remove() { if (this.isEmpty()) { throw new RuntimeException(\"Queue is Empty\"); } int n = this.b[1]; int n2 = this.b[1]; this.b[1] = this.b[this.c]; this.b[this.c] = n2; this.b[this.c--] = 0; int n3 = 1; PriorityQueue priorityQueue = this; while (2 * n3 <= priorityQueue.c) { int n4 = 2 * n3; if (n4 < priorityQueue.c && priorityQueue.b[n4] < priorityQueue.b[n4 + 1]) { ++n4; } if (priorityQueue.b[n3] >= priorityQueue.b[n4]) break; int n5 = priorityQueue.b[n3]; priorityQueue.b[n3] = priorityQueue.b[n4]; priorityQueue.b[n4] = n5; n3 = n4; } return n; } public int peek() { return this.b[1]; } public boolean isEmpty() { return this.c == 0; } public boolean isFull() { return this.c == this.a - 1; } public int getSize() { return this.c; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; class PriorityQueue { private int a = 12; private int[] b = new int[this.a]; private int c = 0; PriorityQueue() { } public void insert(int n) { if (this.isFull()) { throw new RuntimeException(\"Queue is full\"); } this.b[++this.c] = n; PriorityQueue priorityQueue = this; for (int i = (v44113).c; i > 1 && priorityQueue.b[i / 2] < priorityQueue.b[i]; i /= 2) { int n2 = priorityQueue.b[i]; priorityQueue.b[i] = priorityQueue.b[i / 2]; priorityQueue.b[i / 2] = n2; } } public int remove() { if (this.isEmpty()) { throw new RuntimeException(\"Queue is Empty\"); } int n = this.b[1]; int n2 = this.b[1]; this.b[1] = this.b[this.c]; this.b[this.c] = n2; this.b[this.c--] = 0; int n3 = 1; PriorityQueue priorityQueue = this; while (2 * n3 <= priorityQueue.c) { int n4 = 2 * n3; if (n4 < priorityQueue.c && priorityQueue.b[n4] < priorityQueue.b[n4 + 1]) { ++n4; } if (priorityQueue.b[n3] >= priorityQueue.b[n4]) break; int n5 = priorityQueue.b[n3]; priorityQueue.b[n3] = priorityQueue.b[n4]; priorityQueue.b[n4] = n5; n3 = n4; } return n; } public int peek() { return this.b[1]; } public boolean isEmpty() { return this.c == 0; } public boolean isFull() { return this.c == this.a - 1; } public int getSize() { return this.c; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class Process { int a; int b; int c; public void execute(int n) { this.b -= n; if (this.b < 0) { this.b = 0; } } public boolean isFinished() { return this.b == 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class Process { int a; int b; int c; public void execute(int n) { this.b -= n; if (this.b < 0) { this.b = 0; } } public boolean isFinished() { return this.b == 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.devutils.entities; public class ProcessDetails { private String a; private int b; private int c; private int d; private int e; private int f; public ProcessDetails(String string, int n, int n2, int n3) { this.a = string; this.b = n; this.c = n2; this.f = n3; } public ProcessDetails(String string, int n, int n2) { this.a = string; this.b = n; this.c = n2; } public String getProcessId() { return this.a; } public int getArrivalTime() { return this.b; } public int getBurstTime() { return this.c; } public int getWaitingTime() { return this.d; } public int getTurnAroundTimeTime() { return this.e; } public int getPriority() { return this.f; } public void setProcessId(String string) { this.a = string; } public void setArrivalTime(int n) { this.b = n; } public void setBurstTime(int n) { this.c = n; } public void setWaitingTime(int n) { this.d = n; } public void setTurnAroundTimeTime(int n) { this.e = n; } }", "deobfuscated_code": "package com.thealgorithms.devutils.entities; public class ProcessDetails { private String processId; private int arrivalTime; private int burstTime; private int waitingTime; private int turnAroundTime; private int priority; public ProcessDetails(final String processId, final int arrivalTime, final int burstTime, int priority) { this.processId = processId; this.arrivalTime = arrivalTime; this.burstTime = burstTime; this.priority = priority; } public ProcessDetails(final String processId, final int arrivalTime, final int burstTime) { this.processId = processId; this.arrivalTime = arrivalTime; this.burstTime = burstTime; } public String getProcessId() { return processId; } public int getArrivalTime() { return arrivalTime; } public int getBurstTime() { return burstTime; } public int getWaitingTime() { return waitingTime; } public int getTurnAroundTimeTime() { return turnAroundTime; } public int getPriority() { return priority; } public void setProcessId(final String processId) { this.processId = processId; } public void setArrivalTime(final int arrivalTime) { this.arrivalTime = arrivalTime; } public void setBurstTime(final int burstTime) { this.burstTime = burstTime; } public void setWaitingTime(final int waitingTime) { this.waitingTime = waitingTime; } public void setTurnAroundTimeTime(final int turnAroundTime) { this.turnAroundTime = turnAroundTime; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.util.Scanner; final class ProductCipher { private ProductCipher() { } public static void main(String[] object) { object = new Scanner(System.in); try { int n; int n2; System.out.println(\"Enter the input to be encrypted: \"); CharSequence charSequence = ((Scanner)object).nextLine(); System.out.println(\" \"); System.out.println(\"Enter a number: \"); int n3 = ((Scanner)object).nextInt(); StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i < ((String)charSequence).length(); ++i) { n2 = ((String)charSequence).charAt(i); stringBuffer.append((char)(n2 + 5)); } System.out.println(\" \"); System.out.println(\"Substituted text: \"); System.out.println(stringBuffer); Object object2 = stringBuffer.toString(); n2 = ((String)object2).length() % n3; if (n2 != 0) { for (n2 = n3 - n2; n2 != 0; --n2) { object2 = (String)object2 + \"/\"; } } charSequence = new StringBuffer(); System.out.println(\" \"); System.out.println(\"Transposition Matrix: \"); for (int i = 0; i < n3; ++i) { for (n2 = 0; n2 < ((String)object2).length() / n3; ++n2) { n = ((String)object2).charAt(i + n2 * n3); System.out.print((char)n); ((StringBuffer)charSequence).append((char)n); } System.out.println(); } System.out.println(\" \"); System.out.println(\"Final encrypted text: \"); System.out.println(charSequence); n3 = ((StringBuffer)charSequence).length() / n3; StringBuffer stringBuffer2 = new StringBuffer(); for (n2 = 0; n2 < n3; ++n2) { for (n = 0; n < ((StringBuffer)charSequence).length() / n3; ++n) { char c = ((StringBuffer)charSequence).charAt(n2 + n * n3); stringBuffer2.append(c); } } StringBuffer stringBuffer3 = new StringBuffer(); for (n = 0; n < stringBuffer2.length(); ++n) { char c = stringBuffer2.charAt(n); stringBuffer3.append((char)(c - 5)); } System.out.println(\"Plaintext: \"); System.out.println(stringBuffer3); return; } finally { ((Scanner)object).close(); } } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.util.Scanner; final class ProductCipher { private ProductCipher() { } public static void main(String[] args) { try (Scanner sc = new Scanner(System.in)) { System.out.println(\"Enter the input to be encrypted: \"); String substitutionInput = sc.nextLine(); System.out.println(\" \"); System.out.println(\"Enter a number: \"); int n = sc.nextInt(); // Substitution encryption StringBuffer substitutionOutput = new StringBuffer(); for (int i = 0; i < substitutionInput.length(); i++) { char c = substitutionInput.charAt(i); substitutionOutput.append((char) (c + 5)); } System.out.println(\" \"); System.out.println(\"Substituted text: \"); System.out.println(substitutionOutput); // Transposition encryption String transpositionInput = substitutionOutput.toString(); int modulus = transpositionInput.length() % n; if (modulus != 0) { modulus = n - modulus; for (; modulus != 0; modulus--) { transpositionInput += \"/\"; } } StringBuffer transpositionOutput = new StringBuffer(); System.out.println(\" \"); System.out.println(\"Transposition Matrix: \"); for (int i = 0; i < n; i++) { for (int j = 0; j < transpositionInput.length() / n; j++) { char c = transpositionInput.charAt(i + (j * n)); System.out.print(c); transpositionOutput.append(c); } System.out.println(); } System.out.println(\" \"); System.out.println(\"Final encrypted text: \"); System.out.println(transpositionOutput); // Transposition decryption n = transpositionOutput.length() / n; StringBuffer transpositionPlaintext = new StringBuffer(); for (int i = 0; i < n; i++) { for (int j = 0; j < transpositionOutput.length() / n; j++) { char c = transpositionOutput.charAt(i + (j * n)); transpositionPlaintext.append(c); } } // Substitution decryption StringBuffer plaintext = new StringBuffer(); for (int i = 0; i < transpositionPlaintext.length(); i++) { char c = transpositionPlaintext.charAt(i); plaintext.append((char) (c - 5)); } System.out.println(\"Plaintext: \"); System.out.println(plaintext); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class PronicNumber { private PronicNumber() { } public static boolean isPronicNumber(int n) { int n2 = (int)Math.sqrt(n); return n2 * (n2 + 1) == n; } }", "deobfuscated_code": "package com.thealgorithms.maths; /* * Java program for Pronic Number * Pronic Number: A number n is a pronic number if * it is equal to product of two consecutive numbers m and m+1. * Wikipedia: https://en.wikipedia.org/wiki/Pronic_number * * Author: Akshay Dubey (https://github.com/itsAkshayDubey) * * */ public final class PronicNumber { private PronicNumber() { } /** * This method checks if the given number is pronic number or non-pronic number * * @param inputNumber Integer value which is to be checked if is a pronic number or not * @return true if input number is a pronic number, false otherwise */ static boolean isPronic(int inputNumber) { if (inputNumber == 0) { return true; } // Iterating from 0 to input_number for (int i = 0; i <= inputNumber; i++) { // Checking if product of i and (i+1) is equals input_number if (i * (i + 1) == inputNumber && i != inputNumber) { // return true if product of i and (i+1) is equals input_number return true; } } // return false if product of i and (i+1) for all values from 0 to input_number is not // equals input_number return false; } /** * This method checks if the given number is pronic number or non-pronic number using square root of number for finding divisors * * @param number Integer value which is to be checked if is a pronic number or not * @return true if input number is a pronic number, false otherwise */ public static boolean isPronicNumber(int number) { int squareRoot = (int) Math.sqrt(number); // finding just smaller divisor of the number than its square root. return squareRoot * (squareRoot + 1) == number; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class ProportionalFairScheduling$Process { String a; int b; int c; ProportionalFairScheduling$Process(String string, int n) { this.a = string; this.b = n; this.c = 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class ProportionalFairScheduling$Process { String a; int b; int c; ProportionalFairScheduling$Process(String string, int n) { this.a = string; this.b = n; this.c = 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.ProportionalFairScheduling$Process; import java.lang.invoke.CallSite; import java.util.ArrayList; import java.util.List; public final class ProportionalFairScheduling { private final List a = new ArrayList(); public final void addProcess(String string, int n) { this.a.add(new ProportionalFairScheduling$Process(string, n)); } public final void allocateResources(int n) { int n2 = this.a.stream().mapToInt(proportionalFairScheduling$Process -> proportionalFairScheduling$Process.b).sum(); for (ProportionalFairScheduling$Process proportionalFairScheduling$Process2 : this.a) { ((ProportionalFairScheduling$Process)var3_3.next()).c = (int)((double)proportionalFairScheduling$Process2.b / (double)n2 * (double)n); } } public final List getAllocatedResources() { ArrayList<CallSite> arrayList = new ArrayList<CallSite>(); for (ProportionalFairScheduling$Process proportionalFairScheduling$Process : this.a) { arrayList.add((CallSite)((Object)(proportionalFairScheduling$Process.a + \": \" + proportionalFairScheduling$Process.c))); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.List; /** * ProportionalFairScheduling allocates resources to processes based on their * proportional weight or importance. It aims to balance fairness with * priority, ensuring that higher-weight processes receive a larger share of resources. * * Use Case: Network bandwidth allocation in cellular networks (4G/5G), * where devices receive a proportional share of bandwidth. * * @author Hardvan */ public final class ProportionalFairScheduling { static class Process { String name; int weight; int allocatedResources; Process(String name, int weight) { this.name = name; this.weight = weight; this.allocatedResources = 0; } } private final List<Process> processes; public ProportionalFairScheduling() { processes = new ArrayList<>(); } public void addProcess(String name, int weight) { processes.add(new Process(name, weight)); } public void allocateResources(int totalResources) { int totalWeight = processes.stream().mapToInt(p -> p.weight).sum(); for (Process process : processes) { process.allocatedResources = (int) ((double) process.weight / totalWeight * totalResources); } } public List<String> getAllocatedResources() { List<String> allocation = new ArrayList<>(); for (Process process : processes) { allocation.add(process.name + \": \" + process.allocatedResources); } return allocation; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.Arrays; public final class PythagoreanTriple { private PythagoreanTriple() { } public static boolean isPythagTriple(int n, int n2, int n3) { if (n <= 0 || n2 <= 0 || n3 <= 0) { return false; } int[] nArray = new int[]{n, n2, n3}; Arrays.sort(nArray); n2 = nArray[0]; n3 = nArray[1]; int n4 = nArray[2]; int n5 = n2; int n6 = n3; int n7 = n4; return n5 * n5 + n6 * n6 == n7 * n7; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Utility class to check if three integers form a Pythagorean triple. * A Pythagorean triple consists of three positive integers a, b, and c, * such that a + b = c. * * Common examples: * - (3, 4, 5) * - (5, 12, 13) * * Reference: https://en.wikipedia.org/wiki/Pythagorean_triple */ public final class PythagoreanTriple { private PythagoreanTriple() { } /** * Checks whether three integers form a Pythagorean triple. * The order of parameters does not matter. * * @param a one side length * @param b another side length * @param c another side length * @return {@code true} if (a, b, c) can form a Pythagorean triple, otherwise {@code false} */ public static boolean isPythagTriple(int a, int b, int c) { if (a <= 0 || b <= 0 || c <= 0) { return false; } // Sort the sides so the largest is treated as hypotenuse int[] sides = {a, b, c}; java.util.Arrays.sort(sides); int x = sides[0]; int y = sides[1]; int hypotenuse = sides[2]; return x * x + y * y == hypotenuse * hypotenuse; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.TreeNode; class QItem { TreeNode a; int b; QItem(TreeNode treeNode, int n) { this.a = treeNode; this.b = n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.TreeNode; class QItem { TreeNode a; int b; QItem(TreeNode treeNode, int n) { this.a = treeNode; this.b = n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BoundingBox; import com.thealgorithms.datastructures.trees.Point; import java.util.ArrayList; import java.util.List; public class QuadTree { private final BoundingBox a; private final int b; private List c; private boolean d; private QuadTree e; private QuadTree f; private QuadTree g; private QuadTree h; public QuadTree(BoundingBox boundingBox, int n) { this.a = boundingBox; this.b = n; this.c = new ArrayList(); this.d = false; this.e = null; this.f = null; this.g = null; this.h = null; } public boolean insert(Point point) { if (point == null) { return false; } if (!this.a.containsPoint(point)) { return false; } if (this.c.size() < this.b) { this.c.add(point); return true; } if (!this.d) { QuadTree quadTree = this; double d = quadTree.a.halfWidth / 2.0; quadTree.e = new QuadTree(new BoundingBox(new Point(quadTree.a.center.x - d, quadTree.a.center.y + d), d), quadTree.b); quadTree.f = new QuadTree(new BoundingBox(new Point(quadTree.a.center.x + d, quadTree.a.center.y + d), d), quadTree.b); quadTree.g = new QuadTree(new BoundingBox(new Point(quadTree.a.center.x - d, quadTree.a.center.y - d), d), quadTree.b); quadTree.h = new QuadTree(new BoundingBox(new Point(quadTree.a.center.x + d, quadTree.a.center.y - d), d), quadTree.b); quadTree.d = true; } if (this.e.insert(point)) { return true; } if (this.f.insert(point)) { return true; } if (this.g.insert(point)) { return true; } return this.h.insert(point); } public List query(BoundingBox boundingBox) { ArrayList<Point> arrayList = new ArrayList<Point>(); if (!this.a.intersectsBoundingBox(boundingBox)) { return arrayList; } arrayList.addAll(this.c.stream().filter(boundingBox::containsPoint).toList()); if (this.d) { arrayList.addAll(this.e.query(boundingBox)); arrayList.addAll(this.f.query(boundingBox)); arrayList.addAll(this.g.query(boundingBox)); arrayList.addAll(this.h.query(boundingBox)); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayList; import java.util.List; /** * Point is a simple class that represents a point in 2D space. * * @see <a href=\"https://en.wikipedia.org/wiki/Point_(geometry)\">Point</a> * @author <a href=\"https://github.com/sailok\">Sailok Chinta</a> */ class Point { public double x; public double y; Point(double x, double y) { this.x = x; this.y = y; } } /** * BoundingBox is a simple class that represents a bounding box in 2D space. * * @see <a href=\"https://en.wikipedia.org/wiki/Bounding_box\">Bounding Box</a> * @author <a href=\"https://github.com/sailok\">Sailok Chinta</a> */ class BoundingBox { public Point center; public double halfWidth; BoundingBox(Point center, double halfWidth) { this.center = center; this.halfWidth = halfWidth; } /** * Checks if the point is inside the bounding box * * @param point The point to check * @return true if the point is inside the bounding box, false otherwise */ public boolean containsPoint(Point point) { return point.x >= center.x - halfWidth && point.x <= center.x + halfWidth && point.y >= center.y - halfWidth && point.y <= center.y + halfWidth; } /** * Checks if the bounding box intersects with the other bounding box * * @param otherBoundingBox The other bounding box * @return true if the bounding box intersects with the other bounding box, false otherwise */ public boolean intersectsBoundingBox(BoundingBox otherBoundingBox) { return otherBoundingBox.center.x - otherBoundingBox.halfWidth <= center.x + halfWidth && otherBoundingBox.center.x + otherBoundingBox.halfWidth >= center.x - halfWidth && otherBoundingBox.center.y - otherBoundingBox.halfWidth <= center.y + halfWidth && otherBoundingBox.center.y + otherBoundingBox.halfWidth >= center.y - halfWidth; } } /** * QuadTree is a tree data structure that is used to store spatial information * in an efficient way. * * This implementation is specific to Point QuadTrees * * @see <a href=\"https://en.wikipedia.org/wiki/Quadtree\">Quad Tree</a> * @author <a href=\"https://github.com/sailok\">Sailok Chinta</a> */ public class QuadTree { private final BoundingBox boundary; private final int capacity; private List<Point> pointList; private boolean divided; private QuadTree northWest; private QuadTree northEast; private QuadTree southWest; private QuadTree southEast; public QuadTree(BoundingBox boundary, int capacity) { this.boundary = boundary; this.capacity = capacity; this.pointList = new ArrayList<>(); this.divided = false; this.northWest = null; this.northEast = null; this.southWest = null; this.southEast = null; } /** * Inserts a point into the tree * * @param point The point to insert * @return true if the point is successfully inserted, false otherwise */ public boolean insert(Point point) { if (point == null) { return false; } // Ignore points that don't belong to this quad tree if (!boundary.containsPoint(point)) { return false; } // if the space is not already occupied, add it to the list if (pointList.size() < capacity) { pointList.add(point); return true; } // if subdivision hasn't happened, divide the tree if (!divided) { subDivide(); } // try to add the point in one of the four quadrants if (northWest.insert(point)) { return true; } if (northEast.insert(point)) { return true; } if (southWest.insert(point)) { return true; } if (southEast.insert(point)) { return true; } return false; } /** * Create four children that fully divide this quad into four quads of equal area */ private void subDivide() { double quadrantHalfWidth = boundary.halfWidth / 2; northWest = new QuadTree(new BoundingBox(new Point(boundary.center.x - quadrantHalfWidth, boundary.center.y + quadrantHalfWidth), quadrantHalfWidth), this.capacity); northEast = new QuadTree(new BoundingBox(new Point(boundary.center.x + quadrantHalfWidth, boundary.center.y + quadrantHalfWidth), quadrantHalfWidth), this.capacity); southWest = new QuadTree(new BoundingBox(new Point(boundary.center.x - quadrantHalfWidth, boundary.center.y - quadrantHalfWidth), quadrantHalfWidth), this.capacity); southEast = new QuadTree(new BoundingBox(new Point(boundary.center.x + quadrantHalfWidth, boundary.center.y - quadrantHalfWidth), quadrantHalfWidth), this.capacity); divided = true; } /** * Queries all the points that intersect with the other bounding box * * @param otherBoundingBox The other bounding box * @return List of points that intersect with the other bounding box */ public List<Point> query(BoundingBox otherBoundingBox) { List<Point> points = new ArrayList<>(); if (!boundary.intersectsBoundingBox(otherBoundingBox)) { return points; } // filter the points that intersect with the other bounding box points.addAll(pointList.stream().filter(otherBoundingBox::containsPoint).toList()); if (divided) { points.addAll(northWest.query(otherBoundingBox)); points.addAll(northEast.query(otherBoundingBox)); points.addAll(southWest.query(otherBoundingBox)); points.addAll(southEast.query(otherBoundingBox)); } return points; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.ComplexNumber; public class QuadraticEquationSolver { public ComplexNumber[] solveEquation(double d, double d2, double d3) { double d4; double d5 = d2; double d6 = d5 * d5 - d * 4.0 * d3; if (d4 > 0.0) { return new ComplexNumber[]{new ComplexNumber((-d2 + Math.sqrt(d6)) / (d * 2.0)), new ComplexNumber((-d2 - Math.sqrt(d6)) / (d * 2.0))}; } if (d6 == 0.0) { return new ComplexNumber[]{new ComplexNumber(-d2 / (d * 2.0))}; } if (d6 < 0.0) { double d7 = -d2 / (d * 2.0); double d8 = Math.sqrt(-d6) / (d * 2.0); return new ComplexNumber[]{new ComplexNumber(d7, d8), new ComplexNumber(d7, -d8)}; } return new ComplexNumber[0]; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * This class represents a complex number which has real and imaginary part */ class ComplexNumber { Double real; Double imaginary; ComplexNumber(double real, double imaginary) { this.real = real; this.imaginary = imaginary; } ComplexNumber(double real) { this.real = real; this.imaginary = null; } } /** * Quadratic Equation Formula is used to find * the roots of a quadratic equation of the form ax^2 + bx + c = 0 * * @see <a href=\"https://en.wikipedia.org/wiki/Quadratic_equation\">Quadratic Equation</a> */ public class QuadraticEquationSolver { /** * Function takes in the coefficients of the quadratic equation * * @param a is the coefficient of x^2 * @param b is the coefficient of x * @param c is the constant * @return roots of the equation which are ComplexNumber type */ public ComplexNumber[] solveEquation(double a, double b, double c) { double discriminant = b * b - 4 * a * c; // if discriminant is positive, roots will be different if (discriminant > 0) { return new ComplexNumber[] {new ComplexNumber((-b + Math.sqrt(discriminant)) / (2 * a)), new ComplexNumber((-b - Math.sqrt(discriminant)) / (2 * a))}; } // if discriminant is zero, roots will be same if (discriminant == 0) { return new ComplexNumber[] {new ComplexNumber((-b) / (2 * a))}; } // if discriminant is negative, roots will have imaginary parts if (discriminant < 0) { double realPart = -b / (2 * a); double imaginaryPart = Math.sqrt(-discriminant) / (2 * a); return new ComplexNumber[] {new ComplexNumber(realPart, imaginaryPart), new ComplexNumber(realPart, -imaginaryPart)}; } // return no roots return new ComplexNumber[] {}; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; public final class Queue { private final int a; private final Object[] b; private int c; private int d; private int e; public Queue() { this(10); } public Queue(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Queue capacity must be greater than 0\"); } this.a = n; this.b = new Object[n]; this.c = 0; this.d = -1; this.e = 0; } public final boolean insert(Object object) { if (this.isFull()) { return false; } this.d = (this.d + 1) % this.a; this.b[this.d] = object; ++this.e; return true; } public final Object remove() { if (this.isEmpty()) { throw new IllegalStateException(\"Queue is empty, cannot remove element\"); } Object object = this.b[this.c]; this.b[this.c] = null; this.c = (this.c + 1) % this.a; --this.e; return object; } public final Object peekFront() { if (this.isEmpty()) { throw new IllegalStateException(\"Queue is empty, cannot peek front\"); } return this.b[this.c]; } public final Object peekRear() { if (this.isEmpty()) { throw new IllegalStateException(\"Queue is empty, cannot peek rear\"); } return this.b[this.d]; } public final boolean isEmpty() { return this.e == 0; } public final boolean isFull() { return this.e == this.a; } public final int getSize() { return this.e; } public final String toString() { if (this.isEmpty()) { return \"[]\"; } StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"[\"); for (int i = 0; i < this.e; ++i) { int n = (this.c + i) % this.a; stringBuilder.append(this.b[n]).append(\", \"); } StringBuilder stringBuilder2 = stringBuilder; stringBuilder2.setLength(stringBuilder2.length() - 2); stringBuilder.append(\"]\"); return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.queues; /** * This class implements a Queue data structure using an array. * A queue is a first-in-first-out (FIFO) data structure where elements are * added to the rear and removed from the front. * * Note: This implementation is not thread-safe. */ public final class Queue<T> { private static final int DEFAULT_CAPACITY = 10; private final int maxSize; private final Object[] queueArray; private int front; private int rear; private int nItems; /** * Initializes a queue with a default capacity. */ public Queue() { this(DEFAULT_CAPACITY); } /** * Constructor to initialize a queue with a specified capacity. * * @param capacity The initial size of the queue. * @throws IllegalArgumentException if the capacity is less than or equal to zero. */ public Queue(int capacity) { if (capacity <= 0) { throw new IllegalArgumentException(\"Queue capacity must be greater than 0\"); } this.maxSize = capacity; this.queueArray = new Object[capacity]; this.front = 0; this.rear = -1; this.nItems = 0; } /** * Inserts an element at the rear of the queue. * * @param element Element to be added. * @return True if the element was added successfully, false if the queue is full. */ public boolean insert(T element) { if (isFull()) { return false; } rear = (rear + 1) % maxSize; queueArray[rear] = element; nItems++; return true; } /** * Removes and returns the element from the front of the queue. * * @return The element removed from the front of the queue. * @throws IllegalStateException if the queue is empty. */ @SuppressWarnings(\"unchecked\") public T remove() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty, cannot remove element\"); } T removedElement = (T) queueArray[front]; queueArray[front] = null; // Optional: Clear the reference for garbage collection front = (front + 1) % maxSize; nItems--; return removedElement; } /** * Checks the element at the front of the queue without removing it. * * @return Element at the front of the queue. * @throws IllegalStateException if the queue is empty. */ @SuppressWarnings(\"unchecked\") public T peekFront() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty, cannot peek front\"); } return (T) queueArray[front]; } /** * Checks the element at the rear of the queue without removing it. * * @return Element at the rear of the queue. * @throws IllegalStateException if the queue is empty. */ @SuppressWarnings(\"unchecked\") public T peekRear() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty, cannot peek rear\"); } return (T) queueArray[rear]; } /** * Returns true if the queue is empty. * * @return True if the queue is empty. */ public boolean isEmpty() { return nItems == 0; } /** * Returns true if the queue is full. * * @return True if the queue is full. */ public boolean isFull() { return nItems == maxSize; } /** * Returns the number of elements currently in the queue. * * @return Number of elements in the queue. */ public int getSize() { return nItems; } /** * Returns a string representation of the queue. * * @return String representation of the queue. */ @Override public String toString() { if (isEmpty()) { return \"[]\"; } StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (int i = 0; i < nItems; i++) { int index = (front + i) % maxSize; sb.append(queueArray[index]).append(\", \"); } sb.setLength(sb.length() - 2); // Remove the last comma and space sb.append(\"]\"); return sb.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; import java.util.NoSuchElementException; import java.util.Stack; public class QueueByTwoStacks { private final Stack a = new Stack(); private final Stack b = new Stack(); public void put(Object object) { this.a.push(object); } public Object get() { if (this.b.isEmpty()) { while (!this.a.isEmpty()) { this.b.push(this.a.pop()); } } if (this.b.isEmpty()) { throw new NoSuchElementException(\"Queue is empty\"); } return this.b.pop(); } public int size() { return this.a.size() + this.b.size(); } public String toString() { Stack stack = (Stack)this.b.clone(); while (!this.a.isEmpty()) { stack.push(this.a.pop()); } return \"Queue(\" + String.valueOf(stack) + \")\"; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.queues; import java.util.NoSuchElementException; import java.util.Stack; /** * A queue implementation using two stacks. This class provides methods to * enqueue (add) elements to the end of the queue and dequeue (remove) * elements from the front, while utilizing two internal stacks to manage * the order of elements. * * @param <T> The type of elements held in this queue. */ @SuppressWarnings(\"unchecked\") public class QueueByTwoStacks<T> { private final Stack<T> enqueueStk; private final Stack<T> dequeueStk; /** * Constructor that initializes two empty stacks for the queue. * The `enqueueStk` is used to push elements when enqueuing, and * the `dequeueStk` is used to pop elements when dequeuing. */ public QueueByTwoStacks() { enqueueStk = new Stack<>(); dequeueStk = new Stack<>(); } /** * Adds an element to the end of the queue. This method pushes the element * onto the `enqueueStk`. * * @param item The element to be added to the queue. */ public void put(T item) { enqueueStk.push(item); } /** * Removes and returns the element at the front of the queue. * If `dequeueStk` is empty, it transfers all elements from * `enqueueStk` to `dequeueStk` to maintain the correct FIFO * (First-In-First-Out) order before popping. * * @return The element at the front of the queue. * @throws NoSuchElementException If the queue is empty. */ public T get() { if (dequeueStk.isEmpty()) { while (!enqueueStk.isEmpty()) { dequeueStk.push(enqueueStk.pop()); } } if (dequeueStk.isEmpty()) { throw new NoSuchElementException(\"Queue is empty\"); } return dequeueStk.pop(); } /** * Returns the total number of elements currently in the queue. * This is the sum of the sizes of both stacks. * * @return The number of elements in the queue. */ public int size() { return enqueueStk.size() + dequeueStk.size(); } /** * Returns a string representation of the queue, showing the elements * in the correct order (from front to back). * The `dequeueStk` is first cloned, and then all elements from the * `enqueueStk` are added to the cloned stack in reverse order to * represent the queue accurately. * * @return A string representation of the queue. */ @Override public String toString() { Stack<T> tempStack = (Stack<T>) dequeueStk.clone(); while (!enqueueStk.isEmpty()) { tempStack.push(enqueueStk.pop()); } return \"Queue(\" + tempStack + \")\"; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Stack; public class QueueUsingTwoStacks { private final Stack a = new Stack(); private final Stack b = new Stack(); public void insert(Object object) { this.a.push(object); } public Object remove() { if (this.b.isEmpty()) { while (!this.a.isEmpty()) { this.b.push(this.a.pop()); } } return this.b.pop(); } public Object peekFront() { if (this.b.isEmpty()) { while (!this.a.isEmpty()) { this.b.push(this.a.pop()); } } return this.b.peek(); } public Object peekBack() { return this.a.peek(); } public boolean isEmpty() { return this.a.isEmpty() && this.b.isEmpty(); } public boolean isInStackEmpty() { return this.a.isEmpty(); } public boolean isOutStackEmpty() { return this.b.isEmpty(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Stack; /** * This implements Queue using two Stacks. * * <p> * Big O Runtime: insert(): O(1) remove(): O(1) amortized isEmpty(): O(1) * * <p> * A queue data structure functions the same as a real world queue. The elements * that are added first are the first to be removed. New elements are added to * the back/rear of the queue. * * @author sahilb2 (https://www.github.com/sahilb2) */ public class QueueUsingTwoStacks { private final Stack<Object> inStack; private final Stack<Object> outStack; /** * Constructor */ public QueueUsingTwoStacks() { this.inStack = new Stack<>(); this.outStack = new Stack<>(); } /** * Inserts an element at the rear of the queue * * @param x element to be added */ public void insert(Object x) { // Insert element into inStack this.inStack.push(x); } /** * Remove an element from the front of the queue * * @return the new front of the queue */ public Object remove() { if (this.outStack.isEmpty()) { // Move all elements from inStack to outStack (preserving the order) while (!this.inStack.isEmpty()) { this.outStack.push(this.inStack.pop()); } } return this.outStack.pop(); } /** * Peek at the element from the front of the queue * * @return the front element of the queue */ public Object peekFront() { if (this.outStack.isEmpty()) { // Move all elements from inStack to outStack (preserving the order) while (!this.inStack.isEmpty()) { this.outStack.push(this.inStack.pop()); } } return this.outStack.peek(); } /** * Peek at the element from the back of the queue * * @return the back element of the queue */ public Object peekBack() { return this.inStack.peek(); } /** * Returns true if the queue is empty * * @return true if the queue is empty */ public boolean isEmpty() { return (this.inStack.isEmpty() && this.outStack.isEmpty()); } /** * Returns true if the inStack is empty. * * @return true if the inStack is empty. */ public boolean isInStackEmpty() { return (inStack.isEmpty()); } /** * Returns true if the outStack is empty. * * @return true if the outStack is empty. */ public boolean isOutStackEmpty() { return (outStack.isEmpty()); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import java.util.Collections; import java.util.Comparator; import java.util.List; import java.util.Objects; public final class QuickSelect { private QuickSelect() { } public static Comparable select(List list, int n) { Objects.requireNonNull(list, \"The list of elements must not be null.\"); if (list.isEmpty()) { String string = \"The list of elements must not be empty.\"; throw new IllegalArgumentException(string); } if (n < 0) { String string = \"The index must not be negative.\"; throw new IndexOutOfBoundsException(string); } if (n >= list.size()) { String string = \"The index must be less than the number of elements.\"; throw new IndexOutOfBoundsException(string); } int n2 = n; List list2 = list; int n3 = QuickSelect.a(list2, 0, list2.size() - 1, n2); return (Comparable)list.get(n3); } private static int a(List list, int n, int n2, int n3) { while (n != n2) { int n4 = QuickSelect.a(list, n, n2); if (n3 == (n4 = QuickSelect.a(list, n, n2, n4, n3))) { return n3; } if (n3 < n4) { n2 = n4 - 1; continue; } n = n4 + 1; } return n; } private static int a(List list, int n, int n2, int n3, int n4) { Comparable comparable = (Comparable)list.get(n3); Collections.swap(list, n3, n2); n3 = n; while (n < n2) { if (((Comparable)list.get(n)).compareTo(comparable) < 0) { Collections.swap(list, n3, n); ++n3; } ++n; } n = n3; for (int i = n3; i < n2; ++i) { if (((Comparable)list.get(i)).compareTo(comparable) != 0) continue; Collections.swap(list, n, i); ++n; } Collections.swap(list, n2, n); if (n4 < n3) { return n3; } return Math.min(n4, n); } private static int a(List list, int n, int n2) { int n3; int n4; if (n2 - n < 5) { return QuickSelect.b(list, n, n2); } for (n4 = n; n4 < n2; n4 += 5) { n3 = n4 + 4; if (n3 > n2) { n3 = n2; } n3 = QuickSelect.b(list, n4, n3); int n5 = n + (n4 - n) / 5; Collections.swap(list, n3, n5); } n4 = (n2 - n) / 10 + n + 1; n3 = n + (n2 - n) / 5; return QuickSelect.a(list, n, n3, n4); } private static int b(List list, int n, int n2) { list = list.subList(n, n2); list.sort(Comparator.naturalOrder()); return n + n2 >>> 1; } }", "deobfuscated_code": "package com.thealgorithms.searches; import java.util.Collections; import java.util.Comparator; import java.util.List; import java.util.Objects; /** * An implementation of the Quickselect algorithm as described * <a href=\"https://en.wikipedia.org/wiki/Median_of_medians\">here</a>. */ public final class QuickSelect { private QuickSelect() { } /** * Selects the {@code n}-th largest element of {@code list}, i.e. the element that would * be at index n if the list was sorted. * <p> * Calling this function might change the order of elements in {@code list}. * * @param list the list of elements * @param n the index * @param <T> the type of list elements * @return the n-th largest element in the list * @throws IndexOutOfBoundsException if n is less than 0 or greater or equal to * the number of elements in the list * @throws IllegalArgumentException if the list is empty * @throws NullPointerException if {@code list} is null */ public static <T extends Comparable<T>> T select(List<T> list, int n) { Objects.requireNonNull(list, \"The list of elements must not be null.\"); if (list.isEmpty()) { String msg = \"The list of elements must not be empty.\"; throw new IllegalArgumentException(msg); } if (n < 0) { String msg = \"The index must not be negative.\"; throw new IndexOutOfBoundsException(msg); } if (n >= list.size()) { String msg = \"The index must be less than the number of elements.\"; throw new IndexOutOfBoundsException(msg); } int index = selectIndex(list, n); return list.get(index); } private static <T extends Comparable<T>> int selectIndex(List<T> list, int n) { return selectIndex(list, 0, list.size() - 1, n); } private static <T extends Comparable<T>> int selectIndex(List<T> list, int left, int right, int n) { while (true) { if (left == right) { return left; } int pivotIndex = pivot(list, left, right); pivotIndex = partition(list, left, right, pivotIndex, n); if (n == pivotIndex) { return n; } else if (n < pivotIndex) { right = pivotIndex - 1; } else { left = pivotIndex + 1; } } } private static <T extends Comparable<T>> int partition(List<T> list, int left, int right, int pivotIndex, int n) { T pivotValue = list.get(pivotIndex); Collections.swap(list, pivotIndex, right); int storeIndex = left; for (int i = left; i < right; i++) { if (list.get(i).compareTo(pivotValue) < 0) { Collections.swap(list, storeIndex, i); storeIndex++; } } int storeIndexEq = storeIndex; for (int i = storeIndex; i < right; i++) { if (list.get(i).compareTo(pivotValue) == 0) { Collections.swap(list, storeIndexEq, i); storeIndexEq++; } } Collections.swap(list, right, storeIndexEq); return (n < storeIndex) ? storeIndex : Math.min(n, storeIndexEq); } private static <T extends Comparable<T>> int pivot(List<T> list, int left, int right) { if (right - left < 5) { return partition5(list, left, right); } for (int i = left; i < right; i += 5) { int subRight = i + 4; if (subRight > right) { subRight = right; } int median5 = partition5(list, i, subRight); int rightIndex = left + (i - left) / 5; Collections.swap(list, median5, rightIndex); } int mid = (right - left) / 10 + left + 1; int rightIndex = left + (right - left) / 5; return selectIndex(list, left, rightIndex, mid); } private static <T extends Comparable<T>> int partition5(List<T> list, int left, int right) { List<T> ts = list.subList(left, right); ts.sort(Comparator.naturalOrder()); return (left + right) >>> 1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; class QuickSort implements SortAlgorithm { QuickSort() { } @Override public Comparable[] sort(Comparable[] comparableArray) { QuickSort.a(comparableArray, 0, comparableArray.length - 1); return comparableArray; } private static void a(Comparable[] comparableArray, int n, int n2) { while (n < n2) { int n3 = QuickSort.b(comparableArray, n, n2); QuickSort.a(comparableArray, n, n3 - 1); n = n3; } } private static int b(Comparable[] comparableArray, int n, int n2) { int n3 = n + (int)(Math.random() * (double)(n2 - n + 1)); SortUtils.swap(comparableArray, n3, n2); return QuickSort.c(comparableArray, n, n2); } private static int c(Comparable[] comparableArray, int n, int n2) { int n3 = n + n2 >>> 1; Comparable comparable = comparableArray[n3]; while (n <= n2) { while (SortUtils.less(comparableArray[n], comparable)) { ++n; } while (SortUtils.less(comparable, comparableArray[n2])) { --n2; } if (n > n2) continue; SortUtils.swap(comparableArray, n, n2); ++n; --n2; } return n; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * @author Varun Upadhyay (https://github.com/varunu28) * @author Podshivalov Nikita (https://github.com/nikitap492) * @see SortAlgorithm */ class QuickSort implements SortAlgorithm { /** * This method implements the Generic Quick Sort * * @param array The array to be sorted Sorts the array in increasing order */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { doSort(array, 0, array.length - 1); return array; } /** * The sorting process * * @param left The first index of an array * @param right The last index of an array * @param array The array to be sorted */ private static <T extends Comparable<T>> void doSort(T[] array, final int left, final int right) { if (left < right) { final int pivot = randomPartition(array, left, right); doSort(array, left, pivot - 1); doSort(array, pivot, right); } } /** * Randomize the array to avoid the basically ordered sequences * * @param array The array to be sorted * @param left The first index of an array * @param right The last index of an array * @return the partition index of the array */ private static <T extends Comparable<T>> int randomPartition(T[] array, final int left, final int right) { final int randomIndex = left + (int) (Math.random() * (right - left + 1)); SortUtils.swap(array, randomIndex, right); return partition(array, left, right); } /** * This method finds the partition index for an array * * @param array The array to be sorted * @param left The first index of an array * @param right The last index of an array Finds the partition index of an * array */ private static <T extends Comparable<T>> int partition(T[] array, int left, int right) { final int mid = (left + right) >>> 1; final T pivot = array[mid]; while (left <= right) { while (SortUtils.less(array[left], pivot)) { ++left; } while (SortUtils.less(pivot, array[right])) { --right; } if (left <= right) { SortUtils.swap(array, left, right); ++left; --right; } } return left; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SinglyLinkedList; import com.thealgorithms.datastructures.lists.SinglyLinkedListNode; public class QuickSortLinkedList { private final SinglyLinkedList a; private SinglyLinkedListNode b; public QuickSortLinkedList(SinglyLinkedList singlyLinkedList) { this.a = singlyLinkedList; this.b = singlyLinkedList.getHead(); } public void sortList() { this.b = this.a(this.b); this.a.setHead(this.b); } private SinglyLinkedListNode a(SinglyLinkedListNode singlyLinkedListNode) { SinglyLinkedListNode singlyLinkedListNode2; SinglyLinkedListNode singlyLinkedListNode3; if (singlyLinkedListNode == null || singlyLinkedListNode.b == null) { return singlyLinkedListNode; } SinglyLinkedListNode singlyLinkedListNode4 = singlyLinkedListNode; singlyLinkedListNode = singlyLinkedListNode.b; singlyLinkedListNode4.b = null; SinglyLinkedListNode singlyLinkedListNode5 = singlyLinkedListNode3 = new SinglyLinkedListNode(); SinglyLinkedListNode singlyLinkedListNode6 = singlyLinkedListNode2 = new SinglyLinkedListNode(); while (singlyLinkedListNode != null) { if (singlyLinkedListNode.a < singlyLinkedListNode4.a) { singlyLinkedListNode5 = singlyLinkedListNode5.b = singlyLinkedListNode; } else { singlyLinkedListNode6 = singlyLinkedListNode6.b = singlyLinkedListNode; } singlyLinkedListNode = singlyLinkedListNode.b; } singlyLinkedListNode5.b = null; singlyLinkedListNode6.b = null; singlyLinkedListNode = this.a(singlyLinkedListNode3.b); singlyLinkedListNode3 = this.a(singlyLinkedListNode2.b); if (singlyLinkedListNode == null) { singlyLinkedListNode4.b = singlyLinkedListNode3; return singlyLinkedListNode4; } singlyLinkedListNode5 = singlyLinkedListNode; while (singlyLinkedListNode5.b != null) { singlyLinkedListNode5 = singlyLinkedListNode5.b; } singlyLinkedListNode5.b = singlyLinkedListNode4; singlyLinkedListNode4.b = singlyLinkedListNode3; return singlyLinkedListNode; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; /* * * @aurthor - Prabhat-Kumar-42 * @github - https://github.com/Prabhat-Kumar-42 * * Problem : * QuickSort on Linked List * * Note: Taking head as pivot in current implementation. * N represents NULL node * Example: * * -> Given Linked List : * 5 -> 3 -> 8 -> 1 -> 10 -> 2 -> 7 -> 4 -> 9 -> 6 * * -> How Sorting will work according to the QuickSort Algo written below * * current pivot : 5 * List lessThanPivot : 3 -> 1 -> 2 -> 4 * List greaterThanPivot : 5 -> 8 -> 10 -> 7 -> 9 -> 6 * * -> reccur for lessThanPivot and greaterThanPivot * * lessThanPivot : * current pivot : 3 * lessThanPivot : 1 -> 2 * greaterThanPivot : 4 * * greaterThanPivot: * current pivot : 5 * lessThanPivot : null * greaterThanPivot : 8 -> 10 -> 7 -> 9 -> 6 * * By following the above pattern, reccuring tree will form like below : * * List-> 5 -> 3 -> 8 -> 1 -> 10 -> 2 -> 7 -> 4 -> 9 -> 6 * * Pivot : 5 * /\\ * / \\ * / \\ * / \\ * / \\ * List: (3 -> 1 -> 2 -> 4) (5 -> 8 -> 10 -> 7 -> 9 -> 6) * Pivot : 3 5 * /\\ /\\ * / \\ / \\ * / \\ / \\ * / \\ / \\ * List: (1 -> 2) (4) (N) (8 -> 10 -> 7 -> 9 -> 6) * Pivot: 1 4 8 * /\\ /\\ /\\ * / \\ / \\ / \\ * / \\ / \\ / \\ * List: (N) (2) (N) (N) (6 -> 7) (9 -> 10) * Pivot: 2 6 9 * /\\ /\\ /\\ * / \\ / \\ / \\ * / \\ / \\ / \\ * List: (N) (N) (N) (7) (N) (10) * Pivot: 7 10 * /\\ /\\ * / \\ / \\ * / \\ / \\ * (N) (N) (N) (N) * * * -> After this the tree will reccur back (or backtrack) * and the returning list from left and right subtree will attach * themselves around pivot. * i.e. , * (listFromLeftSubTree) -> (Pivot) -> (listFromRightSubtree) * * This will continue until whole list is merged back * * eg : * Megring the above Tree back we get : * * List: (1 -> 2) (4) (6 -> 7) (9 -> 10) * \\ / \\ / * \\ / \\ / * \\ / \\ / * \\ / \\ / * \\ / \\ / * \\ / \\ / * \\ / \\ / * Pivot: 3 8 * List: (1 -> 2 -> 3 -> 4) (6 -> 7 -> 8 -> 9 -> 10) * \\ / * \\ / * \\ / * \\ / * \\ / * \\ / * \\ / * \\/ * Pivot: 5 * List: (1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10) * * * -> This will result in a sorted Linked List */ public class QuickSortLinkedList { private final SinglyLinkedList list; // The linked list to be sorted private SinglyLinkedListNode head; // Head of the list /** * Constructor that initializes the QuickSortLinkedList with a given linked list. * * @param list The singly linked list to be sorted */ public QuickSortLinkedList(SinglyLinkedList list) { this.list = list; this.head = list.getHead(); } /** * Sorts the linked list using the QuickSort algorithm. * The sorted list replaces the original list within the SinglyLinkedList instance. */ public void sortList() { head = sortList(head); list.setHead(head); } /** * Recursively sorts a linked list by partitioning it around a pivot element. * * <p>Each recursive call selects a pivot, partitions the list into elements less * than the pivot and elements greater than or equal to the pivot, then combines * the sorted sublists around the pivot.</p> * * @param head The head node of the list to sort * @return The head node of the sorted linked list */ private SinglyLinkedListNode sortList(SinglyLinkedListNode head) { if (head == null || head.next == null) { return head; } SinglyLinkedListNode pivot = head; head = head.next; pivot.next = null; SinglyLinkedListNode lessHead = new SinglyLinkedListNode(); SinglyLinkedListNode lessTail = lessHead; SinglyLinkedListNode greaterHead = new SinglyLinkedListNode(); SinglyLinkedListNode greaterTail = greaterHead; while (head != null) { if (head.value < pivot.value) { lessTail.next = head; lessTail = lessTail.next; } else { greaterTail.next = head; greaterTail = greaterTail.next; } head = head.next; } lessTail.next = null; greaterTail.next = null; SinglyLinkedListNode sortedLess = sortList(lessHead.next); SinglyLinkedListNode sortedGreater = sortList(greaterHead.next); if (sortedLess == null) { pivot.next = sortedGreater; return pivot; } else { SinglyLinkedListNode current = sortedLess; while (current.next != null) { current = current.next; } current.next = pivot; pivot.next = sortedGreater; return sortedLess; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.RRCache; import com.thealgorithms.datastructures.caches.RRCache$EvictionStrategy; import com.thealgorithms.datastructures.caches.RRCache$PeriodicEvictionStrategy; import java.util.Random; import java.util.function.BiConsumer; public class RRCache$Builder { private final int a; private long b = 0L; private Random c; private BiConsumer d; private RRCache$EvictionStrategy e = new RRCache$PeriodicEvictionStrategy(100); public RRCache$Builder(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Capacity must be > 0\"); } this.a = n; } public RRCache$Builder defaultTTL(long l) { if (l < 0L) { throw new IllegalArgumentException(\"Default TTL must be >= 0\"); } this.b = l; return this; } public RRCache$Builder random(Random random) { if (random == null) { throw new IllegalArgumentException(\"Random must not be null\"); } this.c = random; return this; } public RRCache$Builder evictionListener(BiConsumer biConsumer) { if (biConsumer == null) { throw new IllegalArgumentException(\"Listener must not be null\"); } this.d = biConsumer; return this; } public RRCache build() { return new RRCache(this); } public RRCache$Builder evictionStrategy(RRCache$EvictionStrategy rRCache$EvictionStrategy) { if (rRCache$EvictionStrategy == null) { throw new IllegalArgumentException(\"Eviction strategy must not be null\"); } this.e = rRCache$EvictionStrategy; return this; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.RRCache; import com.thealgorithms.datastructures.caches.RRCache$EvictionStrategy; import com.thealgorithms.datastructures.caches.RRCache$PeriodicEvictionStrategy; import java.util.Random; import java.util.function.BiConsumer; public class RRCache$Builder { private final int a; private long b = 0L; private Random c; private BiConsumer d; private RRCache$EvictionStrategy e = new RRCache$PeriodicEvictionStrategy(100); public RRCache$Builder(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Capacity must be > 0\"); } this.a = n; } public RRCache$Builder defaultTTL(long l) { if (l < 0L) { throw new IllegalArgumentException(\"Default TTL must be >= 0\"); } this.b = l; return this; } public RRCache$Builder random(Random random) { if (random == null) { throw new IllegalArgumentException(\"Random must not be null\"); } this.c = random; return this; } public RRCache$Builder evictionListener(BiConsumer biConsumer) { if (biConsumer == null) { throw new IllegalArgumentException(\"Listener must not be null\"); } this.d = biConsumer; return this; } public RRCache build() { return new RRCache(this); } public RRCache$Builder evictionStrategy(RRCache$EvictionStrategy rRCache$EvictionStrategy) { if (rRCache$EvictionStrategy == null) { throw new IllegalArgumentException(\"Eviction strategy must not be null\"); } this.e = rRCache$EvictionStrategy; return this; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; class RRCache$CacheEntry { Object a; private long b; RRCache$CacheEntry(Object object, long l) { this.a = object; this.b = System.currentTimeMillis() + l; } final boolean a() { return System.currentTimeMillis() > this.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; class RRCache$CacheEntry { Object a; private long b; RRCache$CacheEntry(Object object, long l) { this.a = object; this.b = System.currentTimeMillis() + l; } final boolean a() { return System.currentTimeMillis() > this.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.RRCache; public interface RRCache$EvictionStrategy { public int onAccess(RRCache var1); }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.RRCache; public interface RRCache$EvictionStrategy { public int onAccess(RRCache var1); }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.RRCache; import com.thealgorithms.datastructures.caches.RRCache$EvictionStrategy; public class RRCache$NoEvictionStrategy implements RRCache$EvictionStrategy { @Override public int onAccess(RRCache rRCache) { return rRCache.a(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.RRCache; import com.thealgorithms.datastructures.caches.RRCache$EvictionStrategy; public class RRCache$NoEvictionStrategy implements RRCache$EvictionStrategy { @Override public int onAccess(RRCache rRCache) { return rRCache.a(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.RRCache; import com.thealgorithms.datastructures.caches.RRCache$EvictionStrategy; public class RRCache$PeriodicEvictionStrategy implements RRCache$EvictionStrategy { private final int a; private int b = 0; public RRCache$PeriodicEvictionStrategy(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Interval must be > 0\"); } this.a = n; } @Override public int onAccess(RRCache rRCache) { if (++this.b % this.a == 0) { return rRCache.a(); } return 0; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.RRCache; import com.thealgorithms.datastructures.caches.RRCache$EvictionStrategy; public class RRCache$PeriodicEvictionStrategy implements RRCache$EvictionStrategy { private final int a; private int b = 0; public RRCache$PeriodicEvictionStrategy(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Interval must be > 0\"); } this.a = n; } @Override public int onAccess(RRCache rRCache) { if (++this.b % this.a == 0) { return rRCache.a(); } return 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.caches; import com.thealgorithms.datastructures.caches.RRCache$Builder; import com.thealgorithms.datastructures.caches.RRCache$CacheEntry; import com.thealgorithms.datastructures.caches.RRCache$EvictionStrategy; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Random; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.function.BiConsumer; public final class RRCache { private final int a; private final long b; private final Map c; private final List d; private final Random e; private final Lock f; private long g = 0L; private long h = 0L; private final BiConsumer i; private final RRCache$EvictionStrategy j; private RRCache(RRCache$Builder rRCache$Builder) { this.a = rRCache$Builder.a; this.b = rRCache$Builder.b; this.c = new HashMap(rRCache$Builder.a); this.d = new ArrayList(rRCache$Builder.a); this.e = rRCache$Builder.c != null ? rRCache$Builder.c : new Random(); this.f = new ReentrantLock(); this.i = rRCache$Builder.d; this.j = rRCache$Builder.e; } public final Object get(Object object) { if (object == null) { throw new IllegalArgumentException(\"Key must not be null\"); } this.f.lock(); try { this.j.onAccess(this); RRCache$CacheEntry rRCache$CacheEntry = (RRCache$CacheEntry)this.c.get(object); if (rRCache$CacheEntry == null || rRCache$CacheEntry.a()) { if (rRCache$CacheEntry != null) { Object object2 = object; RRCache rRCache = this; rRCache.c.remove(object2); rRCache.d.remove(object2); this.a(object, rRCache$CacheEntry.a); } ++this.h; return null; } ++this.g; object = rRCache$CacheEntry.a; return object; } finally { this.f.unlock(); } } public final void put(Object object, Object object2) { this.put(object, object2, this.b); } public final void put(Object object, Object object2, long l) { if (object == null || object2 == null) { throw new IllegalArgumentException(\"Key and value must not be null\"); } if (l < 0L) { throw new IllegalArgumentException(\"TTL must be >= 0\"); } this.f.lock(); try { if (this.c.containsKey(object)) { this.c.put(object, new RRCache$CacheEntry(object2, l)); return; } this.a(); if (this.c.size() >= this.a) { int n = this.e.nextInt(this.d.size()); Object e = this.d.remove(n); RRCache$CacheEntry rRCache$CacheEntry = (RRCache$CacheEntry)this.c.remove(e); this.a(e, rRCache$CacheEntry.a); } this.c.put(object, new RRCache$CacheEntry(object2, l)); this.d.add(object); return; } finally { this.f.unlock(); } } private int a() { Iterator iterator = this.d.iterator(); int n = 0; while (iterator.hasNext()) { Object e = iterator.next(); RRCache$CacheEntry rRCache$CacheEntry = (RRCache$CacheEntry)this.c.get(e); if (rRCache$CacheEntry == null || !rRCache$CacheEntry.a()) continue; iterator.remove(); this.c.remove(e); ++n; this.a(e, rRCache$CacheEntry.a); } return n; } private void a(Object object, Object object2) { if (this.i != null) { try { this.i.accept(object, object2); return; } catch (Exception exception) { System.err.println(\"Eviction listener failed: \" + exception.getMessage()); } } } public final long getHits() { this.f.lock(); try { long l = this.g; return l; } finally { this.f.unlock(); } } public final long getMisses() { this.f.lock(); try { long l = this.h; return l; } finally { this.f.unlock(); } } public final int size() { this.f.lock(); try { int n = this.c.size(); int n2 = this.j.onAccess(this); if (n2 > 0) { return n -= n2; } n = 0; for (Map.Entry entry : this.c.entrySet()) { if (((RRCache$CacheEntry)entry.getValue()).a()) continue; ++n; } int n3 = n; return n3; } finally { this.f.unlock(); } } public final RRCache$EvictionStrategy getEvictionStrategy() { return this.j; } public final String toString() { this.f.lock(); try { HashMap hashMap = new HashMap(); for (Map.Entry entry : this.c.entrySet()) { if (((RRCache$CacheEntry)entry.getValue()).a()) continue; hashMap.put(entry.getKey(), ((RRCache$CacheEntry)entry.getValue()).a); } String string = String.format(\"Cache(capacity=%d, size=%d, hits=%d, misses=%d, entries=%s)\", this.a, hashMap.size(), this.g, this.h, hashMap); return string; } finally { this.f.unlock(); } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.caches; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Random; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.function.BiConsumer; /** * A thread-safe generic cache implementation using the Random Replacement (RR) eviction policy. * <p> * The cache holds a fixed number of entries, defined by its capacity. When the cache is full and a * new entry is added, one of the existing entries is selected at random and evicted to make space. * <p> * Optionally, entries can have a time-to-live (TTL) in milliseconds. If a TTL is set, entries will * automatically expire and be removed upon access or insertion attempts. * <p> * Features: * <ul> * <li>Random eviction when capacity is exceeded</li> * <li>Optional TTL (time-to-live in milliseconds) per entry or default TTL for all entries</li> * <li>Thread-safe access using locking</li> * <li>Hit and miss counters for cache statistics</li> * <li>Eviction listener callback support</li> * </ul> * * @param <K> the type of keys maintained by this cache * @param <V> the type of mapped values * See <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#Random_replacement_(RR)\">Random Replacement</a> * @author Kevin Babu (<a href=\"https://www.github.com/KevinMwita7\">GitHub</a>) */ public final class RRCache<K, V> { private final int capacity; private final long defaultTTL; private final Map<K, CacheEntry<V>> cache; private final List<K> keys; private final Random random; private final Lock lock; private long hits = 0; private long misses = 0; private final BiConsumer<K, V> evictionListener; private final EvictionStrategy<K, V> evictionStrategy; /** * Internal structure to store value + expiry timestamp. * * @param <V> the type of the value being cached */ private static class CacheEntry<V> { V value; long expiryTime; /** * Constructs a new {@code CacheEntry} with the specified value and time-to-live (TTL). * * @param value the value to cache * @param ttlMillis the time-to-live in milliseconds */ CacheEntry(V value, long ttlMillis) { this.value = value; this.expiryTime = System.currentTimeMillis() + ttlMillis; } /** * Checks if the cache entry has expired. * * @return {@code true} if the current time is past the expiration time; {@code false} otherwise */ boolean isExpired() { return System.currentTimeMillis() > expiryTime; } } /** * Constructs a new {@code RRCache} instance using the provided {@link Builder}. * * <p>This constructor initializes the cache with the specified capacity and default TTL, * sets up internal data structures (a {@code HashMap} for cache entries and an {@code ArrayList} * for key tracking), and configures eviction and randomization behavior. * * @param builder the {@code Builder} object containing configuration parameters */ private RRCache(Builder<K, V> builder) { this.capacity = builder.capacity; this.defaultTTL = builder.defaultTTL; this.cache = new HashMap<>(builder.capacity); this.keys = new ArrayList<>(builder.capacity); this.random = builder.random != null ? builder.random : new Random(); this.lock = new ReentrantLock(); this.evictionListener = builder.evictionListener; this.evictionStrategy = builder.evictionStrategy; } /** * Retrieves the value associated with the specified key from the cache. * * <p>If the key is not present or the corresponding entry has expired, this method * returns {@code null}. If an expired entry is found, it will be removed and the * eviction listener (if any) will be notified. Cache hit-and-miss statistics are * also updated accordingly. * * @param key the key whose associated value is to be returned; must not be {@code null} * @return the cached value associated with the key, or {@code null} if not present or expired * @throws IllegalArgumentException if {@code key} is {@code null} */ public V get(K key) { if (key == null) { throw new IllegalArgumentException(\"Key must not be null\"); } lock.lock(); try { evictionStrategy.onAccess(this); CacheEntry<V> entry = cache.get(key); if (entry == null || entry.isExpired()) { if (entry != null) { removeKey(key); notifyEviction(key, entry.value); } misses++; return null; } hits++; return entry.value; } finally { lock.unlock(); } } /** * Adds a key-value pair to the cache using the default time-to-live (TTL). * * <p>The key may overwrite an existing entry. The actual insertion is delegated * to the overloaded {@link #put(K, V, long)} method. * * @param key the key to cache the value under * @param value the value to be cached */ public void put(K key, V value) { put(key, value, defaultTTL); } /** * Adds a key-value pair to the cache with a specified time-to-live (TTL). * * <p>If the key already exists, its value is updated and its TTL is reset. If the key * does not exist and the cache is full, a random entry is evicted to make space. * Expired entries are also cleaned up prior to any eviction. The eviction listener * is notified when an entry gets evicted. * * @param key the key to associate with the cached value; must not be {@code null} * @param value the value to be cached; must not be {@code null} * @param ttlMillis the time-to-live for this entry in milliseconds; must be >= 0 * @throws IllegalArgumentException if {@code key} or {@code value} is {@code null}, or if {@code ttlMillis} is negative */ public void put(K key, V value, long ttlMillis) { if (key == null || value == null) { throw new IllegalArgumentException(\"Key and value must not be null\"); } if (ttlMillis < 0) { throw new IllegalArgumentException(\"TTL must be >= 0\"); } lock.lock(); try { if (cache.containsKey(key)) { cache.put(key, new CacheEntry<>(value, ttlMillis)); return; } evictExpired(); if (cache.size() >= capacity) { int idx = random.nextInt(keys.size()); K evictKey = keys.remove(idx); CacheEntry<V> evictVal = cache.remove(evictKey); notifyEviction(evictKey, evictVal.value); } cache.put(key, new CacheEntry<>(value, ttlMillis)); keys.add(key); } finally { lock.unlock(); } } /** * Removes all expired entries from the cache. * * <p>This method iterates through the list of cached keys and checks each associated * entry for expiration. Expired entries are removed from both the key tracking list * and the cache map. For each eviction, the eviction listener is notified. */ private int evictExpired() { Iterator<K> it = keys.iterator(); int expiredCount = 0; while (it.hasNext()) { K k = it.next(); CacheEntry<V> entry = cache.get(k); if (entry != null && entry.isExpired()) { it.remove(); cache.remove(k); ++expiredCount; notifyEviction(k, entry.value); } } return expiredCount; } /** * Removes the specified key and its associated entry from the cache. * * <p>This method deletes the key from both the cache map and the key tracking list. * * @param key the key to remove from the cache */ private void removeKey(K key) { cache.remove(key); keys.remove(key); } /** * Notifies the eviction listener, if one is registered, that a key-value pair has been evicted. * * <p>If the {@code evictionListener} is not {@code null}, it is invoked with the provided key * and value. Any exceptions thrown by the listener are caught and logged to standard error, * preventing them from disrupting cache operations. * * @param key the key that was evicted * @param value the value that was associated with the evicted key */ private void notifyEviction(K key, V value) { if (evictionListener != null) { try { evictionListener.accept(key, value); } catch (Exception e) { System.err.println(\"Eviction listener failed: \" + e.getMessage()); } } } /** * Returns the number of successful cache lookups (hits). * * @return the number of cache hits */ public long getHits() { lock.lock(); try { return hits; } finally { lock.unlock(); } } /** * Returns the number of failed cache lookups (misses), including expired entries. * * @return the number of cache misses */ public long getMisses() { lock.lock(); try { return misses; } finally { lock.unlock(); } } /** * Returns the current number of entries in the cache, excluding expired ones. * * @return the current cache size */ public int size() { lock.lock(); try { int cachedSize = cache.size(); int evictedCount = evictionStrategy.onAccess(this); if (evictedCount > 0) { return cachedSize - evictedCount; } // This runs if periodic eviction does not occur int count = 0; for (Map.Entry<K, CacheEntry<V>> entry : cache.entrySet()) { if (!entry.getValue().isExpired()) { ++count; } } return count; } finally { lock.unlock(); } } /** * Returns the current {@link EvictionStrategy} used by this cache instance. * @return the eviction strategy currently assigned to this cache */ public EvictionStrategy<K, V> getEvictionStrategy() { return evictionStrategy; } /** * Returns a string representation of the cache, including metadata and current non-expired entries. * * <p>The returned string includes the cache's capacity, current size (excluding expired entries), * hit-and-miss counts, and a map of all non-expired key-value pairs. This method acquires a lock * to ensure thread-safe access. * * @return a string summarizing the state of the cache */ @Override public String toString() { lock.lock(); try { Map<K, V> visible = new HashMap<>(); for (Map.Entry<K, CacheEntry<V>> entry : cache.entrySet()) { if (!entry.getValue().isExpired()) { visible.put(entry.getKey(), entry.getValue().value); } } return String.format(\"Cache(capacity=%d, size=%d, hits=%d, misses=%d, entries=%s)\", capacity, visible.size(), hits, misses, visible); } finally { lock.unlock(); } } /** * A strategy interface for controlling when expired entries are evicted from the cache. * * <p>Implementations decide whether and when to trigger {@link RRCache#evictExpired()} based * on cache usage patterns. This allows for flexible eviction behaviour such as periodic cleanup, * or no automatic cleanup. * * @param <K> the type of keys maintained by the cache * @param <V> the type of cached values */ public interface EvictionStrategy<K, V> { /** * Called on each cache access (e.g., {@link RRCache#get(Object)}) to optionally trigger eviction. * * @param cache the cache instance on which this strategy is applied * @return the number of expired entries evicted during this access */ int onAccess(RRCache<K, V> cache); } /** * An eviction strategy that performs eviction of expired entries on each call. * * @param <K> the type of keys * @param <V> the type of values */ public static class NoEvictionStrategy<K, V> implements EvictionStrategy<K, V> { @Override public int onAccess(RRCache<K, V> cache) { return cache.evictExpired(); } } /** * An eviction strategy that triggers eviction every fixed number of accesses. * * <p>This deterministic strategy ensures cleanup occurs at predictable intervals, * ideal for moderately active caches where memory usage is a concern. * * @param <K> the type of keys * @param <V> the type of values */ public static class PeriodicEvictionStrategy<K, V> implements EvictionStrategy<K, V> { private final int interval; private int counter = 0; /** * Constructs a periodic eviction strategy. * * @param interval the number of accesses between evictions; must be > 0 * @throws IllegalArgumentException if {@code interval} is less than or equal to 0 */ public PeriodicEvictionStrategy(int interval) { if (interval <= 0) { throw new IllegalArgumentException(\"Interval must be > 0\"); } this.interval = interval; } @Override public int onAccess(RRCache<K, V> cache) { if (++counter % interval == 0) { return cache.evictExpired(); } return 0; } } /** * A builder for constructing an {@link RRCache} instance with customizable settings. * * <p>Allows configuring capacity, default TTL, random eviction behavior, eviction listener, * and a pluggable eviction strategy. Call {@link #build()} to create the configured cache instance. * * @param <K> the type of keys maintained by the cache * @param <V> the type of values stored in the cache */ public static class Builder<K, V> { private final int capacity; private long defaultTTL = 0; private Random random; private BiConsumer<K, V> evictionListener; private EvictionStrategy<K, V> evictionStrategy = new RRCache.PeriodicEvictionStrategy<>(100); /** * Creates a new {@code Builder} with the specified cache capacity. * * @param capacity the maximum number of entries the cache can hold; must be > 0 * @throws IllegalArgumentException if {@code capacity} is less than or equal to 0 */ public Builder(int capacity) { if (capacity <= 0) { throw new IllegalArgumentException(\"Capacity must be > 0\"); } this.capacity = capacity; } /** * Sets the default time-to-live (TTL) in milliseconds for cache entries. * * @param ttlMillis the TTL duration in milliseconds; must be >= 0 * @return this builder instance for chaining * @throws IllegalArgumentException if {@code ttlMillis} is negative */ public Builder<K, V> defaultTTL(long ttlMillis) { if (ttlMillis < 0) { throw new IllegalArgumentException(\"Default TTL must be >= 0\"); } this.defaultTTL = ttlMillis; return this; } /** * Sets the {@link Random} instance to be used for random eviction selection. * * @param r a non-null {@code Random} instance * @return this builder instance for chaining * @throws IllegalArgumentException if {@code r} is {@code null} */ public Builder<K, V> random(Random r) { if (r == null) { throw new IllegalArgumentException(\"Random must not be null\"); } this.random = r; return this; } /** * Sets an eviction listener to be notified when entries are evicted from the cache. * * @param listener a {@link BiConsumer} that accepts evicted keys and values; must not be {@code null} * @return this builder instance for chaining * @throws IllegalArgumentException if {@code listener} is {@code null} */ public Builder<K, V> evictionListener(BiConsumer<K, V> listener) { if (listener == null) { throw new IllegalArgumentException(\"Listener must not be null\"); } this.evictionListener = listener; return this; } /** * Builds and returns a new {@link RRCache} instance with the configured parameters. * * @return a fully configured {@code RRCache} instance */ public RRCache<K, V> build() { return new RRCache<>(this); } /** * Sets the eviction strategy used to determine when to clean up expired entries. * * @param strategy an {@link EvictionStrategy} implementation; must not be {@code null} * @return this builder instance * @throws IllegalArgumentException if {@code strategy} is {@code null} */ public Builder<K, V> evictionStrategy(EvictionStrategy<K, V> strategy) { if (strategy == null) { throw new IllegalArgumentException(\"Eviction strategy must not be null\"); } this.evictionStrategy = strategy; return this; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import java.util.List; public class RRScheduling { private List a; public void scheduleProcesses() { RRScheduling rRScheduling = this; List cfr_ignored_0 = rRScheduling.a; throw new NullPointerException(); } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import com.thealgorithms.devutils.entities.ProcessDetails; import java.util.Arrays; import java.util.LinkedList; import java.util.List; import java.util.Queue; /** * @author Md Asif Joardar * The Round-robin scheduling algorithm is a kind of preemptive First come, First Serve CPU * Scheduling algorithm. This can be understood here - * https://www.scaler.com/topics/round-robin-scheduling-in-os/ */ public class RRScheduling { private List<ProcessDetails> processes; private int quantumTime; RRScheduling(final List<ProcessDetails> processes, int quantumTime) { this.processes = processes; this.quantumTime = quantumTime; } public void scheduleProcesses() { evaluateTurnAroundTime(); evaluateWaitingTime(); } private void evaluateTurnAroundTime() { int processesNumber = processes.size(); if (processesNumber == 0) { return; } Queue<Integer> queue = new LinkedList<>(); queue.add(0); int currentTime = 0; // keep track of the time int completed = 0; int[] mark = new int[processesNumber]; Arrays.fill(mark, 0); mark[0] = 1; // a copy of burst time to store the remaining burst time int[] remainingBurstTime = new int[processesNumber]; for (int i = 0; i < processesNumber; i++) { remainingBurstTime[i] = processes.get(i).getBurstTime(); } while (completed != processesNumber) { int index = queue.poll(); if (remainingBurstTime[index] == processes.get(index).getBurstTime()) { currentTime = Math.max(currentTime, processes.get(index).getArrivalTime()); } if (remainingBurstTime[index] - quantumTime > 0) { remainingBurstTime[index] -= quantumTime; currentTime += quantumTime; } else { currentTime += remainingBurstTime[index]; processes.get(index).setTurnAroundTimeTime(currentTime - processes.get(index).getArrivalTime()); completed++; remainingBurstTime[index] = 0; } // If some process has arrived when this process was executing, insert them into the // queue. for (int i = 1; i < processesNumber; i++) { if (remainingBurstTime[i] > 0 && processes.get(i).getArrivalTime() <= currentTime && mark[i] == 0) { mark[i] = 1; queue.add(i); } } // If the current process has burst time remaining, push the process into the queue // again. if (remainingBurstTime[index] > 0) { queue.add(index); } // If the queue is empty, pick the first process from the list that is not completed. if (queue.isEmpty()) { for (int i = 1; i < processesNumber; i++) { if (remainingBurstTime[i] > 0) { mark[i] = 1; queue.add(i); break; } } } } } private void evaluateWaitingTime() { for (final var process : processes) { process.setWaitingTime(process.getTurnAroundTimeTime() - process.getBurstTime()); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.math.BigInteger; import java.security.SecureRandom; public class RSA { private BigInteger a; private BigInteger b; private BigInteger c; public RSA(int n) { this.generateKeys(n); } public synchronized String encrypt(String string) { if (string.isEmpty()) { throw new IllegalArgumentException(\"Message is empty\"); } return new BigInteger(string.getBytes()).modPow(this.c, this.a).toString(); } public synchronized BigInteger encrypt(BigInteger bigInteger) { return bigInteger.modPow(this.c, this.a); } public synchronized String decrypt(String string) { if (string.isEmpty()) { throw new IllegalArgumentException(\"Message is empty\"); } return new String(new BigInteger(string).modPow(this.b, this.a).toByteArray()); } public synchronized BigInteger decrypt(BigInteger bigInteger) { return bigInteger.modPow(this.b, this.a); } public final synchronized void generateKeys(int n) { SecureRandom secureRandom = new SecureRandom(); BigInteger bigInteger = new BigInteger(n / 2, 100, secureRandom); BigInteger bigInteger2 = new BigInteger(n / 2, 100, secureRandom); this.a = bigInteger.multiply(bigInteger2); bigInteger2 = bigInteger.subtract(BigInteger.ONE).multiply(bigInteger2.subtract(BigInteger.ONE)); this.c = BigInteger.valueOf(3L); while (bigInteger2.gcd(this.c).intValue() > 1) { this.c = this.c.add(BigInteger.TWO); } this.b = this.c.modInverse(bigInteger2); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.math.BigInteger; import java.security.SecureRandom; /** * RSA is an asymmetric cryptographic algorithm used for secure data encryption and decryption. * It relies on a pair of keys: a public key (used for encryption) and a private key * (used for decryption). The algorithm is based on the difficulty of factoring large prime numbers. * * This implementation includes key generation, encryption, and decryption methods that can handle both * text-based messages and BigInteger inputs. For more details on RSA: * <a href=\"https://en.wikipedia.org/wiki/RSA_(cryptosystem)\">RSA Cryptosystem - Wikipedia</a>. * * Example Usage: * <pre> * RSA rsa = new RSA(1024); * String encryptedMessage = rsa.encrypt(\"Hello RSA!\"); * String decryptedMessage = rsa.decrypt(encryptedMessage); * System.out.println(decryptedMessage); // Output: Hello RSA! * </pre> * * Note: The key size directly affects the security and performance of the RSA algorithm. * Larger keys are more secure but slower to compute. * * @author Nguyen Duy Tiep * @version 23-Oct-17 */ public class RSA { private BigInteger modulus; private BigInteger privateKey; private BigInteger publicKey; /** * Constructor that generates RSA keys with the specified number of bits. * * @param bits The bit length of the keys to be generated. Common sizes include 512, 1024, 2048, etc. */ public RSA(int bits) { generateKeys(bits); } /** * Encrypts a text message using the RSA public key. * * @param message The plaintext message to be encrypted. * @throws IllegalArgumentException If the message is empty. * @return The encrypted message represented as a String. */ public synchronized String encrypt(String message) { if (message.isEmpty()) { throw new IllegalArgumentException(\"Message is empty\"); } return (new BigInteger(message.getBytes())).modPow(publicKey, modulus).toString(); } /** * Encrypts a BigInteger message using the RSA public key. * * @param message The plaintext message as a BigInteger. * @return The encrypted message as a BigInteger. */ public synchronized BigInteger encrypt(BigInteger message) { return message.modPow(publicKey, modulus); } /** * Decrypts an encrypted message (as String) using the RSA private key. * * @param encryptedMessage The encrypted message to be decrypted, represented as a String. * @throws IllegalArgumentException If the message is empty. * @return The decrypted plaintext message as a String. */ public synchronized String decrypt(String encryptedMessage) { if (encryptedMessage.isEmpty()) { throw new IllegalArgumentException(\"Message is empty\"); } return new String((new BigInteger(encryptedMessage)).modPow(privateKey, modulus).toByteArray()); } /** * Decrypts an encrypted BigInteger message using the RSA private key. * * @param encryptedMessage The encrypted message as a BigInteger. * @return The decrypted plaintext message as a BigInteger. */ public synchronized BigInteger decrypt(BigInteger encryptedMessage) { return encryptedMessage.modPow(privateKey, modulus); } /** * Generates a new RSA key pair (public and private keys) with the specified bit length. * Steps: * 1. Generate two large prime numbers p and q. * 2. Compute the modulus n = p * q. * 3. Compute Euler's totient function: (n) = (p-1) * (q-1). * 4. Choose a public key e (starting from 3) that is coprime with (n). * 5. Compute the private key d as the modular inverse of e mod (n). * The public key is (e, n) and the private key is (d, n). * * @param bits The bit length of the keys to be generated. */ public final synchronized void generateKeys(int bits) { SecureRandom random = new SecureRandom(); BigInteger p = new BigInteger(bits / 2, 100, random); BigInteger q = new BigInteger(bits / 2, 100, random); modulus = p.multiply(q); BigInteger phi = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE)); publicKey = BigInteger.valueOf(3L); while (phi.gcd(publicKey).intValue() > 1) { publicKey = publicKey.add(BigInteger.TWO); } privateKey = publicKey.modInverse(phi); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.Scanner; public final class RabinKarp { public static Scanner scanner = null; public static final int ALPHABET_SIZE = 256; private RabinKarp() { } public static void main(String[] object) { int n; scanner = new Scanner(System.in); System.out.println(\"Enter String\"); object = scanner.nextLine(); System.out.println(\"Enter pattern\"); String string = scanner.nextLine(); int n2 = 101; Object object2 = object; int n3 = string.length(); int n4 = ((String)object2).length(); int n5 = 0; int n6 = 0; int n7 = (int)Math.pow(256.0, n3 - 1) % 101; for (n = 0; n < n3; ++n) { n6 = (n6 * 256 + string.charAt(n)) % 101; n5 = (n5 * 256 + ((String)object2).charAt(n)) % 101; } for (n = 0; n <= n4 - n3; ++n) { if (n6 == n5) { int n8; for (n8 = 0; n8 < n3 && ((String)object2).charAt(n + n8) == string.charAt(n8); ++n8) { } if (n8 == n3) { System.out.println(\"Pattern found at index \" + n); } } if (n >= n4 - n3 || (n5 = (256 * (n5 - ((String)object2).charAt(n) * n7) + ((String)object2).charAt(n + n3)) % 101) >= 0) continue; n5 += 101; } } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.Scanner; /** * @author Prateek Kumar Oraon (https://github.com/prateekKrOraon) * An implementation of Rabin-Karp string matching algorithm Program will simply end if there is no match */ public final class RabinKarp { private RabinKarp() { } public static Scanner scanner = null; public static final int ALPHABET_SIZE = 256; public static void main(String[] args) { scanner = new Scanner(System.in); System.out.println(\"Enter String\"); String text = scanner.nextLine(); System.out.println(\"Enter pattern\"); String pattern = scanner.nextLine(); int q = 101; searchPat(text, pattern, q); } private static void searchPat(String text, String pattern, int q) { int m = pattern.length(); int n = text.length(); int t = 0; int p = 0; int h = 1; int j = 0; int i = 0; h = (int) Math.pow(ALPHABET_SIZE, m - 1) % q; for (i = 0; i < m; i++) { // hash value is calculated for each character and then added with the hash value of the // next character for pattern as well as the text for length equal to the length of // pattern p = (ALPHABET_SIZE * p + pattern.charAt(i)) % q; t = (ALPHABET_SIZE * t + text.charAt(i)) % q; } for (i = 0; i <= n - m; i++) { // if the calculated hash value of the pattern and text matches then // all the characters of the pattern is matched with the text of length equal to length // of the pattern if all matches then pattern exist in string if not then the hash value // of the first character of the text is subtracted and hash value of the next character // after the end of the evaluated characters is added if (p == t) { // if hash value matches then the individual characters are matched for (j = 0; j < m; j++) { // if not matched then break out of the loop if (text.charAt(i + j) != pattern.charAt(j)) { break; } } // if all characters are matched then pattern exist in the string if (j == m) { System.out.println(\"Pattern found at index \" + i); } } // if i<n-m then hash value of the first character of the text is subtracted and hash // value of the next character after the end of the evaluated characters is added to get // the hash value of the next window of characters in the text if (i < n - m) { t = (ALPHABET_SIZE * (t - text.charAt(i) * h) + text.charAt(i + m)) % q; // if hash value becomes less than zero than q is added to make it positive if (t < 0) { t = (t + q); } } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; public final class RabinKarpAlgorithm { private RabinKarpAlgorithm() { } public static int search(String string, String string2, int n) { int n2; int n3 = string.length(); int n4 = string2.length(); int n5 = 0; int n6 = 0; int n7 = 1; for (n2 = 0; n2 < n3 - 1; ++n2) { n7 = (n7 << 8) % n; } for (n2 = 0; n2 < n3; ++n2) { n5 = (n5 * 256 + string.charAt(n2)) % n; n6 = (n6 * 256 + string2.charAt(n2)) % n; } for (n2 = 0; n2 <= n4 - n3; ++n2) { if (n5 == n6) { int n8; for (n8 = 0; n8 < n3 && string2.charAt(n2 + n8) == string.charAt(n8); ++n8) { } if (n8 == n3) { int n9 = n2; return n9; } } if (n2 >= n4 - n3 || (n6 = (256 * (n6 - string2.charAt(n2) * n7) + string2.charAt(n2 + n3)) % n) >= 0) continue; n6 += n; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; // Implementation of Rabin Karp Algorithm public final class RabinKarpAlgorithm { private RabinKarpAlgorithm() { } private static final int ALPHABET_SIZE = 256; public static int search(String pattern, String text, int primeNumber) { int index = -1; // -1 here represents not found int patternLength = pattern.length(); int textLength = text.length(); int hashForPattern = 0; int hashForText = 0; int h = 1; // The value of h would be \"pow(d, patternLength-1)%primeNumber\" for (int i = 0; i < patternLength - 1; i++) { h = (h * ALPHABET_SIZE) % primeNumber; } // Calculate the hash value of pattern and first // window of text for (int i = 0; i < patternLength; i++) { hashForPattern = (ALPHABET_SIZE * hashForPattern + pattern.charAt(i)) % primeNumber; hashForText = (ALPHABET_SIZE * hashForText + text.charAt(i)) % primeNumber; } // Slide the pattern over text one by one for (int i = 0; i <= textLength - patternLength; i++) { /* Check the hash values of current window of text and pattern. If the hash values match then only check for characters one by one*/ int j = 0; if (hashForPattern == hashForText) { /* Check for characters one by one */ for (j = 0; j < patternLength; j++) { if (text.charAt(i + j) != pattern.charAt(j)) { break; } } // if hashForPattern == hashForText and pattern[0...patternLength-1] = text[i, i+1, ...i+patternLength-1] if (j == patternLength) { index = i; return index; } } // Calculate hash value for next window of text: Remove // leading digit, add trailing digit if (i < textLength - patternLength) { hashForText = (ALPHABET_SIZE * (hashForText - text.charAt(i) * h) + text.charAt(i + patternLength)) % primeNumber; // handling negative hashForText if (hashForText < 0) { hashForText = (hashForText + primeNumber); } } } return index; // return -1 if pattern does not found } } // This code is contributed by nuclode"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.maths.NumberOfDigits; import java.util.Arrays; public final class RadixSort { private RadixSort() { } public static int[] sort(int[] nArray) { if (nArray.length == 0) { return nArray; } int[] nArray2 = nArray; for (int n : nArray) { if (n >= 0) continue; throw new IllegalArgumentException(\"Array contains non-positive integers.\"); } nArray2 = nArray; int n = Arrays.stream(nArray).max().getAsInt(); int n2 = 0; int n3 = 1; while (n2 < NumberOfDigits.numberOfDigits(n)) { int[] nArray3; int n4; int n5; int n6 = n3; int[] nArray4 = nArray2; int n7 = n6; int[] nArray5 = nArray2; int[] nArray6 = new int[10]; for (int i = 0; i < nArray5.length; ++i) { n5 = n7; n4 = nArray5[i]; int n8 = n4 / n5 % 10; nArray6[n8] = nArray6[n8] + 1; } nArray5 = nArray6; for (n7 = 1; n7 < 10; ++n7) { int n9 = n7; nArray5[n9] = nArray5[n9] + nArray5[n7 - 1]; } n7 = n6; nArray5 = nArray4; int[] nArray7 = new int[nArray4.length]; for (n6 = nArray5.length - 1; n6 >= 0; --n6) { n5 = n7; n4 = nArray5[n6]; n4 = n4 / n5 % 10; nArray7[nArray6[n4] - 1] = nArray5[n6]; int n10 = n4; nArray6[n10] = nArray6[n10] - 1; } int[] nArray8 = nArray3 = nArray7; nArray5 = nArray4; System.arraycopy(nArray8, 0, nArray5, 0, nArray5.length); ++n2; n3 *= 10; } return nArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import com.thealgorithms.maths.NumberOfDigits; import java.util.Arrays; /** * This class provides an implementation of the radix sort algorithm. * It sorts an array of nonnegative integers in increasing order. */ public final class RadixSort { private static final int BASE = 10; private RadixSort() { } /** * Sorts an array of nonnegative integers using the radix sort algorithm. * * @param array the array to be sorted * @return the sorted array * @throws IllegalArgumentException if any negative integers are found */ public static int[] sort(int[] array) { if (array.length == 0) { return array; } checkForNegativeInput(array); radixSort(array); return array; } /** * Checks if the array contains any negative integers. * * @param array the array to be checked * @throws IllegalArgumentException if any negative integers are found */ private static void checkForNegativeInput(int[] array) { for (int number : array) { if (number < 0) { throw new IllegalArgumentException(\"Array contains non-positive integers.\"); } } } private static void radixSort(int[] array) { final int max = Arrays.stream(array).max().getAsInt(); for (int i = 0, exp = 1; i < NumberOfDigits.numberOfDigits(max); i++, exp *= BASE) { countingSortByDigit(array, exp); } } /** * A utility method to perform counting sort of array[] according to the digit represented by exp. * * @param array the array to be sorted * @param exp the exponent representing the current digit position */ private static void countingSortByDigit(int[] array, int exp) { int[] count = countDigits(array, exp); accumulateCounts(count); int[] output = buildOutput(array, exp, count); copyOutput(array, output); } private static int[] countDigits(int[] array, int exp) { int[] count = new int[BASE]; for (int i = 0; i < array.length; i++) { count[getDigit(array[i], exp)]++; } return count; } private static int getDigit(int number, int position) { return (number / position) % BASE; } private static void accumulateCounts(int[] count) { for (int i = 1; i < BASE; i++) { count[i] += count[i - 1]; } } private static int[] buildOutput(int[] array, int exp, int[] count) { int[] output = new int[array.length]; for (int i = array.length - 1; i >= 0; i--) { int digit = getDigit(array[i], exp); output[count[digit] - 1] = array[i]; count[digit]--; } return output; } private static void copyOutput(int[] array, int[] output) { System.arraycopy(output, 0, array, 0, array.length); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.util.Arrays; public class RailFenceCipher { public String encrypt(String charSequence, int n) { int n2; if (n == 1 || n >= ((String)charSequence).length()) { return charSequence; } int n3 = 1; char[][] cArray = new char[n][((String)charSequence).length()]; for (n2 = 0; n2 < n; ++n2) { Arrays.fill(cArray[n2], '\\n'); } n2 = 0; int n4 = 0; int n5 = 0; while (n4 < ((String)charSequence).length()) { if (n2 == 0) { n3 = 1; } else if (n2 == n - 1) { n3 = 0; } cArray[n2][n4] = ((String)charSequence).charAt(n5); ++n4; n2 = n3 != 0 ? ++n2 : --n2; ++n5; } charSequence = new StringBuilder(); char[][] cArray2 = cArray; n3 = cArray.length; for (int i = 0; i < n3; ++i) { char[] cArray3 = cArray2[i]; char[] cArray4 = cArray3; cArray4 = cArray3; n4 = cArray3.length; for (n5 = 0; n5 < n4; ++n5) { char c = cArray4[n5]; if (c == '\\n') continue; ((StringBuilder)charSequence).append(c); } } return ((StringBuilder)charSequence).toString(); } public String decrypt(String string, int n) { int n2; if (n == 1 || n >= string.length()) { return string; } boolean bl = true; char[][] cArray = new char[n][string.length()]; int n3 = 0; for (n2 = 0; n2 < string.length(); ++n2) { if (n3 == 0) { bl = true; } else if (n3 == n - 1) { bl = false; } cArray[n3][n2] = 42; if (bl) { ++n3; continue; } --n3; } n3 = 0; for (int i = 0; i < n; ++i) { for (n2 = 0; n2 < string.length(); ++n2) { if (cArray[i][n2] != '*') continue; cArray[i][n2] = string.charAt(n3++); } } StringBuilder stringBuilder = new StringBuilder(); n3 = 0; for (n2 = 0; n2 < string.length(); ++n2) { if (n3 == 0) { bl = true; } else if (n3 == n - 1) { bl = false; } stringBuilder.append(cArray[n3][n2]); if (bl) { ++n3; continue; } --n3; } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.util.Arrays; /** * The rail fence cipher (also called a zigzag cipher) is a classical type of transposition cipher. * It derives its name from the manner in which encryption is performed, in analogy to a fence built with horizontal rails. * https://en.wikipedia.org/wiki/Rail_fence_cipher * @author https://github.com/Krounosity */ public class RailFenceCipher { // Encrypts the input string using the rail fence cipher method with the given number of rails. public String encrypt(String str, int rails) { // Base case of single rail or rails are more than the number of characters in the string if (rails == 1 || rails >= str.length()) { return str; } // Boolean flag to determine if the movement is downward or upward in the rail matrix. boolean down = true; // Create a 2D array to represent the rails (rows) and the length of the string (columns). char[][] strRail = new char[rails][str.length()]; // Initialize all positions in the rail matrix with a placeholder character ('\\n'). for (int i = 0; i < rails; i++) { Arrays.fill(strRail[i], '\\n'); } int row = 0; // Start at the first row int col = 0; // Start at the first column int i = 0; // Fill the rail matrix with characters from the string based on the rail pattern. while (col < str.length()) { // Change direction to down when at the first row. if (row == 0) { down = true; } // Change direction to up when at the last row. else if (row == rails - 1) { down = false; } // Place the character in the current position of the rail matrix. strRail[row][col] = str.charAt(i); col++; // Move to the next column. // Move to the next row based on the direction. if (down) { row++; } else { row--; } i++; } // Construct the encrypted string by reading characters row by row. StringBuilder encryptedString = new StringBuilder(); for (char[] chRow : strRail) { for (char ch : chRow) { if (ch != '\\n') { encryptedString.append(ch); } } } return encryptedString.toString(); } // Decrypts the input string using the rail fence cipher method with the given number of rails. public String decrypt(String str, int rails) { // Base case of single rail or rails are more than the number of characters in the string if (rails == 1 || rails >= str.length()) { return str; } // Boolean flag to determine if the movement is downward or upward in the rail matrix. boolean down = true; // Create a 2D array to represent the rails (rows) and the length of the string (columns). char[][] strRail = new char[rails][str.length()]; int row = 0; // Start at the first row int col = 0; // Start at the first column // Mark the pattern on the rail matrix using '*'. while (col < str.length()) { // Change direction to down when at the first row. if (row == 0) { down = true; } // Change direction to up when at the last row. else if (row == rails - 1) { down = false; } // Mark the current position in the rail matrix. strRail[row][col] = '*'; col++; // Move to the next column. // Move to the next row based on the direction. if (down) { row++; } else { row--; } } int index = 0; // Index to track characters from the input string. // Fill the rail matrix with characters from the input string based on the marked pattern. for (int i = 0; i < rails; i++) { for (int j = 0; j < str.length(); j++) { if (strRail[i][j] == '*') { strRail[i][j] = str.charAt(index++); } } } // Construct the decrypted string by following the zigzag pattern. StringBuilder decryptedString = new StringBuilder(); row = 0; // Reset to the first row col = 0; // Reset to the first column while (col < str.length()) { // Change direction to down when at the first row. if (row == 0) { down = true; } // Change direction to up when at the last row. else if (row == rails - 1) { down = false; } // Append the character from the rail matrix to the decrypted string. decryptedString.append(strRail[row][col]); col++; // Move to the next column. // Move to the next row based on the direction. if (down) { row++; } else { row--; } } return decryptedString.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; class RandomNode$ListNode { int a; RandomNode$ListNode b; RandomNode$ListNode(int n) { this.a = n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; class RandomNode$ListNode { int a; RandomNode$ListNode b; RandomNode$ListNode(int n) { this.a = n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.RandomNode$ListNode; import java.util.ArrayList; import java.util.List; import java.util.Random; public class RandomNode { private final List a = new ArrayList(); private int b; private static final Random c = new Random(); public RandomNode(RandomNode$ListNode randomNode$ListNode) { while (randomNode$ListNode != null) { this.a.add(randomNode$ListNode.a); randomNode$ListNode = randomNode$ListNode.b; ++this.b; } } public int getRandom() { int n = c.nextInt(this.b); return (Integer)this.a.get(n); } public static void main(String[] object) { object = new RandomNode$ListNode(15); new RandomNode$ListNode(15).b = new RandomNode$ListNode(25); object.b.b = new RandomNode$ListNode(4); object.b.b.b = new RandomNode$ListNode(1); object.b.b.b.b = new RandomNode$ListNode(78); object.b.b.b.b.b = new RandomNode$ListNode(63); object = new RandomNode((RandomNode$ListNode)object); int n = object.getRandom(); System.out.println(\"Random Node : \" + n); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; import java.util.ArrayList; import java.util.List; import java.util.Random; /** * @author <a href=\"https://github.com/skmodi649\">Suraj Kumar</a> * <p> * PROBLEM DESCRIPTION : * There is a single linked list and we are supposed to find a random node in the given linked list * <p> * ALGORITHM : * Step 1 : START * Step 2 : Create an arraylist of type integer * Step 3 : Declare an integer type variable for size and linked list type for head * Step 4 : We will use two methods, one for traversing through the linked list using while loop and * also increase the size by 1 * <p> * (a) RandomNode(head) * (b) run a while loop till null; * (c) add the value to arraylist; * (d) increase the size; * <p> * Step 5 : Now use another method for getting random values using Math.random() and return the * value present in arraylist for the calculated index Step 6 : Now in main() method we will simply * insert nodes in the linked list and then call the appropriate method and then print the random * node generated Step 7 : STOP */ public class RandomNode { private final List<Integer> list; private int size; private static final Random RAND = new Random(); static class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } } public RandomNode(ListNode head) { list = new ArrayList<>(); ListNode temp = head; // Now using while loop to traverse through the linked list and // go on adding values and increasing the size value by 1 while (temp != null) { list.add(temp.val); temp = temp.next; size++; } } public int getRandom() { int index = RAND.nextInt(size); return list.get(index); } /** * OUTPUT : * First output : * Random Node : 25 * Second output : * Random Node : 78 * Time Complexity : O(n) * Auxiliary Space Complexity : O(1) * Time Complexity : O(n) * Auxiliary Space Complexity : O(1) * Time Complexity : O(n) * Auxiliary Space Complexity : O(1) */ // Driver program to test above functions public static void main(String[] args) { ListNode head = new ListNode(15); head.next = new ListNode(25); head.next.next = new ListNode(4); head.next.next.next = new ListNode(1); head.next.next.next.next = new ListNode(78); head.next.next.next.next.next = new ListNode(63); RandomNode list = new RandomNode(head); int randomNum = list.getRandom(); System.out.println(\"Random Node : \" + randomNum); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.List; import java.util.Random; public final class RandomScheduling { private final List a; private final Random b; public RandomScheduling(Collection collection, Random random) { this.a = new ArrayList(collection); this.b = random; } public final List schedule() { ArrayList arrayList = new ArrayList(this.a); Collections.shuffle(arrayList, this.b); return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.List; import java.util.Random; /** * RandomScheduling is an algorithm that assigns tasks in a random order. * It doesn't consider priority, deadlines, or burst times, making it * inefficient but useful in scenarios where fairness or unpredictability * is required (e.g., load balancing in distributed systems). * * Use Case: Distributed systems where randomness helps avoid task starvation. * * @author Hardvan */ public final class RandomScheduling { private final List<String> tasks; private final Random random; /** * Constructs a new RandomScheduling instance. * * @param tasks A collection of task names to be scheduled. * @param random A Random instance for generating random numbers. */ public RandomScheduling(Collection<String> tasks, Random random) { this.tasks = new ArrayList<>(tasks); this.random = random; } /** * Schedules the tasks randomly and returns the randomized order. * * @return A list representing the tasks in their randomized execution order. */ public List<String> schedule() { List<String> shuffledTasks = new ArrayList<>(tasks); Collections.shuffle(shuffledTasks, random); return shuffledTasks; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; import java.util.HashSet; import java.util.Random; public class RandomSearch implements SearchAlgorithm { private final Random a = new Random(); @Override public int find(Comparable[] comparableArray, Comparable comparable) { HashSet<Integer> hashSet = new HashSet<Integer>(); int n = comparableArray.length; while (hashSet.size() < n) { int n2 = this.a.nextInt(n); if (comparableArray[n2].compareTo(comparable) == 0) { return n2; } hashSet.add(n2); } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; import java.util.HashSet; import java.util.Random; import java.util.Set; /** * A Random Search algorithm that randomly selects an index and checks if the * value at that index matches the target. It repeats the process until it * finds the target or checks all elements. * * <p> * Time Complexity: O(n) in the worst case. * </p> * * @author Hardvan */ public class RandomSearch implements SearchAlgorithm { private final Random random = new Random(); /** * Finds the index of a given element using random search. * * @param array Array to search through * @param key Element to search for * @return Index of the element if found, -1 otherwise */ @Override public <T extends Comparable<T>> int find(T[] array, T key) { Set<Integer> visitedIndices = new HashSet<>(); int size = array.length; while (visitedIndices.size() < size) { int randomIndex = random.nextInt(size); if (array[randomIndex].compareTo(key) == 0) { return randomIndex; } visitedIndices.add(randomIndex); } return -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; public class RandomizedClosestPair$Point { public final double x; public final double y; public RandomizedClosestPair$Point(double d, double d2) { this.x = d; this.y = d2; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; public class RandomizedClosestPair$Point { public final double x; public final double y; public RandomizedClosestPair$Point(double d, double d2) { this.x = d; this.y = d2; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import com.thealgorithms.randomized.RandomizedClosestPair$Point; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.List; import java.util.Random; public final class RandomizedClosestPair { private RandomizedClosestPair() { throw new UnsupportedOperationException(\"Utility class\"); } public static double findClosestPairDistance(RandomizedClosestPair$Point[] object) { object = new ArrayList<RandomizedClosestPair$Point>(Arrays.asList(object)); Collections.shuffle(object, new Random()); object = object.toArray(new RandomizedClosestPair$Point[0]); Arrays.sort(object, Comparator.comparingDouble(randomizedClosestPair$Point -> randomizedClosestPair$Point.x)); RandomizedClosestPair$Point[] randomizedClosestPair$PointArray = (RandomizedClosestPair$Point[])object.clone(); Arrays.sort(randomizedClosestPair$PointArray, Comparator.comparingDouble(randomizedClosestPair$Point -> randomizedClosestPair$Point.y)); return RandomizedClosestPair.a((RandomizedClosestPair$Point[])object, randomizedClosestPair$PointArray); } private static double a(RandomizedClosestPair$Point[] object, RandomizedClosestPair$Point[] randomizedClosestPair$PointArray) { int n = ((Object)object).length; if (n <= 3) { return RandomizedClosestPair.a((RandomizedClosestPair$Point[])object); } int n2 = n / 2; Object randomizedClosestPair$Point = object[n2]; RandomizedClosestPair$Point[] object22 = (RandomizedClosestPair$Point[])Arrays.copyOfRange(object, 0, n2); object = (RandomizedClosestPair$Point[])Arrays.copyOfRange(object, n2, n); ArrayList<RandomizedClosestPair$Point> arrayList = new ArrayList<RandomizedClosestPair$Point>(); ArrayList<RandomizedClosestPair$Point> arrayList2 = new ArrayList<RandomizedClosestPair$Point>(); RandomizedClosestPair$Point[] randomizedClosestPair$PointArray2 = randomizedClosestPair$PointArray; int n3 = randomizedClosestPair$PointArray.length; for (int i = 0; i < n3; ++i) { RandomizedClosestPair$Point randomizedClosestPair$Point2; RandomizedClosestPair$Point randomizedClosestPair$Point3 = randomizedClosestPair$PointArray2[i]; if (randomizedClosestPair$Point2.x <= ((RandomizedClosestPair$Point)randomizedClosestPair$Point).x) { arrayList.add(randomizedClosestPair$Point3); continue; } arrayList2.add(randomizedClosestPair$Point3); } double d = RandomizedClosestPair.a(object22, arrayList.toArray(new RandomizedClosestPair$Point[0])); double d2 = RandomizedClosestPair.a((RandomizedClosestPair$Point[])object, arrayList2.toArray(new RandomizedClosestPair$Point[0])); double d3 = Math.min(d, d2); object = new ArrayList(); for (RandomizedClosestPair$Point randomizedClosestPair$Point4 : randomizedClosestPair$PointArray) { RandomizedClosestPair$Point randomizedClosestPair$Point5; if (!(Math.abs(randomizedClosestPair$Point5.x - ((RandomizedClosestPair$Point)randomizedClosestPair$Point).x) < d3)) continue; object.add(randomizedClosestPair$Point4); } return Math.min(d3, RandomizedClosestPair.a((List)object, d3)); } private static double a(RandomizedClosestPair$Point[] randomizedClosestPair$PointArray) { double d = Double.POSITIVE_INFINITY; for (int i = 0; i < randomizedClosestPair$PointArray.length; ++i) { for (int j = i + 1; j < randomizedClosestPair$PointArray.length; ++j) { d = Math.min(d, RandomizedClosestPair.a(randomizedClosestPair$PointArray[i], randomizedClosestPair$PointArray[j])); } } return d; } private static double a(List list, double d) { double d2 = d; int n = list.size(); for (int i = 0; i < n; ++i) { for (int j = i + 1; j < n && ((RandomizedClosestPair$Point)list.get((int)j)).y - ((RandomizedClosestPair$Point)list.get((int)i)).y < d2; ++j) { d2 = Math.min(d2, RandomizedClosestPair.a((RandomizedClosestPair$Point)list.get(i), (RandomizedClosestPair$Point)list.get(j))); } } return d2; } private static double a(RandomizedClosestPair$Point randomizedClosestPair$Point, RandomizedClosestPair$Point randomizedClosestPair$Point2) { return Math.hypot(randomizedClosestPair$Point.x - randomizedClosestPair$Point2.x, randomizedClosestPair$Point.y - randomizedClosestPair$Point2.y); } }", "deobfuscated_code": "package com.thealgorithms.randomized; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.List; import java.util.Random; /** * Randomized Closest Pair of Points Algorithm * * Use Case: * - Efficiently finds the closest pair of points in a 2D plane. * - Applicable in computational geometry, clustering, and graphics. * * Time Complexity: * - Expected: O(n log n) using randomized divide and conquer * * @see <a href=\"https://en.wikipedia.org/wiki/Closest_pair_of_points_problem\">Closest Pair of Points - Wikipedia</a> */ public final class RandomizedClosestPair { // Prevent instantiation of utility class private RandomizedClosestPair() { throw new UnsupportedOperationException(\"Utility class\"); } public static class Point { public final double x; public final double y; public Point(double x, double y) { this.x = x; this.y = y; } } public static double findClosestPairDistance(Point[] points) { List<Point> shuffled = new ArrayList<>(Arrays.asList(points)); Collections.shuffle(shuffled, new Random()); Point[] px = shuffled.toArray(new Point[0]); Arrays.sort(px, Comparator.comparingDouble(p -> p.x)); Point[] py = px.clone(); Arrays.sort(py, Comparator.comparingDouble(p -> p.y)); return closestPair(px, py); } private static double closestPair(Point[] px, Point[] py) { int n = px.length; if (n <= 3) { return bruteForce(px); } int mid = n / 2; Point midPoint = px[mid]; Point[] qx = Arrays.copyOfRange(px, 0, mid); Point[] rx = Arrays.copyOfRange(px, mid, n); List<Point> qy = new ArrayList<>(); List<Point> ry = new ArrayList<>(); for (Point p : py) { if (p.x <= midPoint.x) { qy.add(p); } else { ry.add(p); } } double d1 = closestPair(qx, qy.toArray(new Point[0])); double d2 = closestPair(rx, ry.toArray(new Point[0])); double d = Math.min(d1, d2); List<Point> strip = new ArrayList<>(); for (Point p : py) { if (Math.abs(p.x - midPoint.x) < d) { strip.add(p); } } return Math.min(d, stripClosest(strip, d)); } private static double bruteForce(Point[] points) { double min = Double.POSITIVE_INFINITY; for (int i = 0; i < points.length; i++) { for (int j = i + 1; j < points.length; j++) { min = Math.min(min, distance(points[i], points[j])); } } return min; } private static double stripClosest(List<Point> strip, double d) { double min = d; int n = strip.size(); for (int i = 0; i < n; i++) { for (int j = i + 1; j < n && (strip.get(j).y - strip.get(i).y) < min; j++) { min = Math.min(min, distance(strip.get(i), strip.get(j))); } } return min; } private static double distance(Point p1, Point p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import java.util.Random; public final class RandomizedMatrixMultiplicationVerification { private RandomizedMatrixMultiplicationVerification() { } public static boolean verify(int[][] nArray, int[][] nArray2, int[][] nArray3, int n) { int n2 = nArray.length; Random random = new Random(); for (int i = 0; i < n; ++i) { int n3; int n4; int[] nArray4 = new int[n2]; for (int j = 0; j < n2; ++j) { nArray4[j] = random.nextInt(2); } int[] nArray5 = new int[n2]; for (int j = 0; j < n2; ++j) { for (n4 = 0; n4 < n2; ++n4) { int n5 = j; nArray5[n5] = nArray5[n5] + nArray2[j][n4] * nArray4[n4]; } } int[] nArray6 = new int[n2]; for (n4 = 0; n4 < n2; ++n4) { for (n3 = 0; n3 < n2; ++n3) { int n6 = n4; nArray6[n6] = nArray6[n6] + nArray[n4][n3] * nArray5[n3]; } } int[] nArray7 = new int[n2]; for (n3 = 0; n3 < n2; ++n3) { for (int j = 0; j < n2; ++j) { int n7 = n3; nArray7[n7] = nArray7[n7] + nArray3[n3][j] * nArray4[j]; } } for (n3 = 0; n3 < n2; ++n3) { if (nArray6[n3] == nArray7[n3]) continue; return false; } } return true; } }", "deobfuscated_code": "package com.thealgorithms.randomized; import java.util.Random; public final class RandomizedMatrixMultiplicationVerification { private RandomizedMatrixMultiplicationVerification() { // Prevent instantiation of utility class } /** * Verifies whether A  B == C using Freivalds' algorithm. * @param A Left matrix * @param B Right matrix * @param C Product matrix to verify * @param iterations Number of randomized checks * @return true if likely AB == C; false if definitely not */ public static boolean verify(int[][] a, int[][] b, int[][] c, int iterations) { int n = a.length; Random random = new Random(); for (int iter = 0; iter < iterations; iter++) { // Step 1: Generate random 0/1 vector int[] r = new int[n]; for (int i = 0; i < n; i++) { r[i] = random.nextInt(2); } // Step 2: Compute br = b  r int[] br = new int[n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { br[i] += b[i][j] * r[j]; } } // Step 3: Compute a(br) int[] abr = new int[n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { abr[i] += a[i][j] * br[j]; } } // Step 4: Compute cr = c  r int[] cr = new int[n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { cr[i] += c[i][j] * r[j]; } } // Step 5: Compare abr and cr for (int i = 0; i < n; i++) { if (abr[i] != cr[i]) { return false; } } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; public final class RandomizedQuickSort { private RandomizedQuickSort() { throw new UnsupportedOperationException(\"Utility class\"); } public static void randomizedQuickSort(int[] nArray, int n, int n2) { while (n < n2) { int n3 = n2; int n4 = n; int[] nArray2 = nArray; int n5 = n4 + (int)(Math.random() * (double)(n3 - n4 + 1)); int n6 = nArray2[n5]; RandomizedQuickSort.a(nArray2, n5, n3); n5 = n4; while (n4 < n3) { if (nArray2[n4] < n6) { RandomizedQuickSort.a(nArray2, n5, n4); ++n5; } ++n4; } RandomizedQuickSort.a(nArray2, n5, n3); int n7 = n5; RandomizedQuickSort.randomizedQuickSort(nArray, n, n7 - 1); n = n7 + 1; } } private static void a(int[] nArray, int n, int n2) { if (n == n2) { return; } int n3 = nArray[n]; nArray[n] = nArray[n2]; nArray[n2] = n3; } }", "deobfuscated_code": "package com.thealgorithms.randomized; /** * This class implements the Randomized QuickSort algorithm. * It selects a pivot randomly to improve performance on sorted or nearly sorted data. * @author Vibhu Khera */ public final class RandomizedQuickSort { private RandomizedQuickSort() { throw new UnsupportedOperationException(\"Utility class\"); } /** * Sorts the array using the randomized quicksort algorithm. * * @param arr the array to sort * @param low the starting index of the array * @param high the ending index of the array */ public static void randomizedQuickSort(int[] arr, int low, int high) { if (low < high) { int pivotIndex = partition(arr, low, high); randomizedQuickSort(arr, low, pivotIndex - 1); randomizedQuickSort(arr, pivotIndex + 1, high); } } /** * Partitions the array around a pivot chosen randomly. * * @param arr the array to partition * @param low the starting index * @param high the ending index * @return the index of the pivot after partitioning */ private static int partition(int[] arr, int low, int high) { int pivotIndex = low + (int) (Math.random() * (high - low + 1)); int pivotValue = arr[pivotIndex]; swap(arr, pivotIndex, high); // Move pivot to end int storeIndex = low; for (int i = low; i < high; i++) { if (arr[i] < pivotValue) { swap(arr, storeIndex, i); storeIndex++; } } swap(arr, storeIndex, high); // Move pivot to its final place return storeIndex; } /** * Swaps two elements in the array, only if the indices are different. * * @param arr the array in which elements are to be swapped * @param i the first index * @param j the second index */ private static void swap(int[] arr, int i, int j) { // Skip if indices are the same if (i == j) { return; } int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; public final class RangeInSortedArray { private RangeInSortedArray() { } public static int[] sortedRange(int[] nArray, int n) { int[] nArray2 = new int[]{-1, -1}; RangeInSortedArray.alteredBinSearchIter(nArray, n, 0, nArray.length - 1, nArray2, true); RangeInSortedArray.alteredBinSearchIter(nArray, n, 0, nArray.length - 1, nArray2, false); return nArray2; } public static void alteredBinSearch(int[] nArray, int n, int n2, int n3, int[] nArray2, boolean bl) { while (n2 <= n3) { int n4 = n2 + (n3 - n2 >>> 1); if (nArray[n4] > n) { RangeInSortedArray.alteredBinSearch(nArray, n, n2, n4 - 1, nArray2, bl); return; } if (nArray[n4] < n) { RangeInSortedArray.alteredBinSearch(nArray, n, n4 + 1, n3, nArray2, bl); return; } if (bl) { if (n4 == 0 || nArray[n4 - 1] != n) { nArray2[0] = n4; return; } RangeInSortedArray.alteredBinSearch(nArray, n, n2, n4 - 1, nArray2, bl); return; } if (n4 == nArray.length - 1 || nArray[n4 + 1] != n) { nArray2[1] = n4; return; } n2 = n4 + 1; } return; } public static void alteredBinSearchIter(int[] nArray, int n, int n2, int n3, int[] nArray2, boolean bl) { while (n2 <= n3) { int n4 = n2 + (n3 - n2 >>> 1); if (nArray[n4] > n) { n3 = n4 - 1; continue; } if (nArray[n4] >= n) { if (bl) { if (n4 == 0 || nArray[n4 - 1] != n) { nArray2[0] = n4; return; } n3 = n4 - 1; continue; } if (n4 == nArray.length - 1 || nArray[n4 + 1] != n) { nArray2[1] = n4; return; } } n2 = n4 + 1; } } public static int getCountLessThan(int[] nArray, int n) { return RangeInSortedArray.getLessThan(nArray, n, 0, nArray.length - 1); } public static int getLessThan(int[] nArray, int n, int n2, int n3) { int n4 = 0; while (n2 <= n3) { int n5 = n2 + (n3 - n2 >>> 1); if (nArray[n5] > n) { n3 = n5 - 1; continue; } n4 = n5 + 1; n2 = n5 + 1; } return n4; } }", "deobfuscated_code": "package com.thealgorithms.misc; /** * Utility class for operations to find the range of occurrences of a key * in a sorted (non-decreasing) array, and to count elements less than or equal to a given key. */ public final class RangeInSortedArray { private RangeInSortedArray() { } /** * Finds the first and last occurrence indices of the key in a sorted array. * * @param nums sorted array of integers (non-decreasing order) * @param key the target value to search for * @return int array of size two where * - index 0 is the first occurrence of key, * - index 1 is the last occurrence of key, * or [-1, -1] if the key does not exist in the array. */ public static int[] sortedRange(int[] nums, int key) { int[] range = new int[] {-1, -1}; alteredBinSearchIter(nums, key, 0, nums.length - 1, range, true); // find left boundary alteredBinSearchIter(nums, key, 0, nums.length - 1, range, false); // find right boundary return range; } /** * Recursive altered binary search to find either the leftmost or rightmost occurrence of a key. * * @param nums the sorted array * @param key the target to find * @param left current left bound in search * @param right current right bound in search * @param range array to update with boundaries: range[0] for leftmost, range[1] for rightmost * @param goLeft if true, searches for leftmost occurrence; if false, for rightmost occurrence */ public static void alteredBinSearch(int[] nums, int key, int left, int right, int[] range, boolean goLeft) { if (left > right) { return; } int mid = left + ((right - left) >>> 1); if (nums[mid] > key) { alteredBinSearch(nums, key, left, mid - 1, range, goLeft); } else if (nums[mid] < key) { alteredBinSearch(nums, key, mid + 1, right, range, goLeft); } else { if (goLeft) { if (mid == 0 || nums[mid - 1] != key) { range[0] = mid; } else { alteredBinSearch(nums, key, left, mid - 1, range, goLeft); } } else { if (mid == nums.length - 1 || nums[mid + 1] != key) { range[1] = mid; } else { alteredBinSearch(nums, key, mid + 1, right, range, goLeft); } } } } /** * Iterative altered binary search to find either the leftmost or rightmost occurrence of a key. * * @param nums the sorted array * @param key the target to find * @param left initial left bound * @param right initial right bound * @param range array to update with boundaries: range[0] for leftmost, range[1] for rightmost * @param goLeft if true, searches for leftmost occurrence; if false, for rightmost occurrence */ public static void alteredBinSearchIter(int[] nums, int key, int left, int right, int[] range, boolean goLeft) { while (left <= right) { int mid = left + ((right - left) >>> 1); if (nums[mid] > key) { right = mid - 1; } else if (nums[mid] < key) { left = mid + 1; } else { if (goLeft) { if (mid == 0 || nums[mid - 1] != key) { range[0] = mid; return; } right = mid - 1; } else { if (mid == nums.length - 1 || nums[mid + 1] != key) { range[1] = mid; return; } left = mid + 1; } } } } /** * Counts the number of elements strictly less than the given key. * * @param nums sorted array * @param key the key to compare * @return the count of elements less than the key */ public static int getCountLessThan(int[] nums, int key) { return getLessThan(nums, key, 0, nums.length - 1); } /** * Helper method using binary search to count elements less than or equal to the key. * * @param nums sorted array * @param key the key to compare * @param left current left bound * @param right current right bound * @return count of elements less than or equal to the key */ public static int getLessThan(int[] nums, int key, int left, int right) { int count = 0; while (left <= right) { int mid = left + ((right - left) >>> 1); if (nums[mid] > key) { right = mid - 1; } else { // nums[mid] <= key count = mid + 1; // all elements from 0 to mid inclusive are <= key left = mid + 1; } } return count; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.searches.SearchAlgorithm; import java.util.Scanner; public class RecursiveBinarySearch extends SearchAlgorithm { @Override public int find(Comparable[] comparableArray, Comparable comparable) { return this.binsear(comparableArray, 0, comparableArray.length - 1, comparable); } public int binsear(Comparable[] comparableArray, int n, int n2, Comparable comparable) { if (n2 >= n) { int n3 = n + (n2 - n) / 2; int n4 = comparableArray[n3].compareTo(comparable); if (n4 == 0) { return n3; } if (n4 > 0) { return this.binsear(comparableArray, n, n3 - 1, comparable); } return this.binsear(comparableArray, n3 + 1, n2, comparable); } return -1; } public static void main(String[] object) { object = new Scanner(System.in); try { int n; System.out.print(\"Enter the number of elements in the array: \"); int n2 = ((Scanner)object).nextInt(); Comparable[] comparableArray = new Integer[n2]; System.out.println(\"Enter the elements in sorted order:\"); for (n = 0; n < n2; ++n) { comparableArray[n] = ((Scanner)object).nextInt(); } System.out.print(\"Enter the target element to search for: \"); n = ((Scanner)object).nextInt(); RecursiveBinarySearch recursiveBinarySearch = new RecursiveBinarySearch(); int n3 = recursiveBinarySearch.find(comparableArray, Integer.valueOf(n)); if (n3 == -1) { System.out.println(\"Element not found in the array.\"); } else { System.out.println(\"Element found at index \" + n3); } return; } finally { ((Scanner)object).close(); } } }", "deobfuscated_code": "// Code by Pronay Debnath // Created:- 1/10/2023 // File Name should be RecursiveBinarySearch.java // Explanation:- https://www.tutorialspoint.com/java-program-for-binary-search-recursive package com.thealgorithms.searches; import java.util.Scanner; // Create a SearchAlgorithm class with a generic type abstract class SearchAlgorithm<T extends Comparable<T>> { // Abstract find method to be implemented by subclasses public abstract int find(T[] arr, T target); } public class RecursiveBinarySearch<T extends Comparable<T>> extends SearchAlgorithm<T> { // Override the find method as required @Override public int find(T[] arr, T target) { // Call the recursive binary search function return binsear(arr, 0, arr.length - 1, target); } // Recursive binary search function public int binsear(T[] arr, int left, int right, T target) { if (right >= left) { int mid = left + (right - left) / 2; // Compare the element at the middle with the target int comparison = arr[mid].compareTo(target); // If the element is equal to the target, return its index if (comparison == 0) { return mid; } // If the element is greater than the target, search in the left subarray if (comparison > 0) { return binsear(arr, left, mid - 1, target); } // Otherwise, search in the right subarray return binsear(arr, mid + 1, right, target); } // Element is not present in the array return -1; } public static void main(String[] args) { try (Scanner sc = new Scanner(System.in)) { // User inputs System.out.print(\"Enter the number of elements in the array: \"); int n = sc.nextInt(); Integer[] a = new Integer[n]; // You can change the array type as needed System.out.println(\"Enter the elements in sorted order:\"); for (int i = 0; i < n; i++) { a[i] = sc.nextInt(); } System.out.print(\"Enter the target element to search for: \"); int t = sc.nextInt(); RecursiveBinarySearch<Integer> searcher = new RecursiveBinarySearch<>(); int res = searcher.find(a, t); if (res == -1) { System.out.println(\"Element not found in the array.\"); } else { System.out.println(\"Element found at index \" + res); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.RedBlackBST; class RedBlackBST$Node { int a = -1; int b = 1; RedBlackBST$Node c; RedBlackBST$Node d; RedBlackBST$Node e; private /* synthetic */ RedBlackBST f; RedBlackBST$Node(RedBlackBST redBlackBST, int n) { this.f = redBlackBST; this.c = this.f.a; this.d = this.f.a; this.e = this.f.a; this.a = n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.RedBlackBST; class RedBlackBST$Node { int a = -1; int b = 1; RedBlackBST$Node c; RedBlackBST$Node d; RedBlackBST$Node e; private /* synthetic */ RedBlackBST f; RedBlackBST$Node(RedBlackBST redBlackBST, int n) { this.f = redBlackBST; this.c = this.f.a; this.d = this.f.a; this.e = this.f.a; this.a = n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.RedBlackBST$Node; import java.util.Scanner; public class RedBlackBST { private final RedBlackBST$Node a; private RedBlackBST$Node b; public RedBlackBST() { this.b = this.a = new RedBlackBST$Node(this, -1); } public void printTree(RedBlackBST$Node redBlackBST$Node) { if (redBlackBST$Node == this.a) { return; } this.printTree(redBlackBST$Node.c); System.out.print((redBlackBST$Node.b == 0 ? \" R \" : \" B \") + \"Key: \" + redBlackBST$Node.a + \" Parent: \" + redBlackBST$Node.e.a + \"\\n\"); this.printTree(redBlackBST$Node.d); } public void printTreepre(RedBlackBST$Node redBlackBST$Node) { if (redBlackBST$Node == this.a) { return; } System.out.print((redBlackBST$Node.b == 0 ? \" R \" : \" B \") + \"Key: \" + redBlackBST$Node.a + \" Parent: \" + redBlackBST$Node.e.a + \"\\n\"); this.printTreepre(redBlackBST$Node.c); this.printTreepre(redBlackBST$Node.d); } private RedBlackBST$Node a(RedBlackBST$Node redBlackBST$Node, RedBlackBST$Node redBlackBST$Node2) { block7: { while (true) { if (this.b == this.a) { return null; } if (redBlackBST$Node.a < redBlackBST$Node2.a) { if (redBlackBST$Node2.c != this.a) { redBlackBST$Node2 = redBlackBST$Node2.c; continue; } } else { if (redBlackBST$Node.a <= redBlackBST$Node2.a) break; if (redBlackBST$Node2.d != this.a) { redBlackBST$Node2 = redBlackBST$Node2.d; continue; } } break block7; break; } if (redBlackBST$Node.a == redBlackBST$Node2.a) { return redBlackBST$Node2; } } return null; } private void a(RedBlackBST$Node redBlackBST$Node) { if (redBlackBST$Node.e != this.a) { RedBlackBST$Node redBlackBST$Node2 = redBlackBST$Node; if (redBlackBST$Node2 == redBlackBST$Node2.e.c) { redBlackBST$Node.e.c = redBlackBST$Node.d; } else { redBlackBST$Node.e.d = redBlackBST$Node.d; } redBlackBST$Node.d.e = redBlackBST$Node.e; redBlackBST$Node.e = redBlackBST$Node.d; if (redBlackBST$Node.d.c != this.a) { redBlackBST$Node.d.c.e = redBlackBST$Node; } redBlackBST$Node.d = redBlackBST$Node.d.c; redBlackBST$Node.e.c = redBlackBST$Node; return; } redBlackBST$Node = this.b.d; this.b.d = redBlackBST$Node.c; redBlackBST$Node.c.e = this.b; this.b.e = redBlackBST$Node; redBlackBST$Node.c = this.b; redBlackBST$Node.e = this.a; this.b = redBlackBST$Node; } private void b(RedBlackBST$Node redBlackBST$Node) { if (redBlackBST$Node.e != this.a) { RedBlackBST$Node redBlackBST$Node2 = redBlackBST$Node; if (redBlackBST$Node2 == redBlackBST$Node2.e.c) { redBlackBST$Node.e.c = redBlackBST$Node.c; } else { redBlackBST$Node.e.d = redBlackBST$Node.c; } redBlackBST$Node.c.e = redBlackBST$Node.e; redBlackBST$Node.e = redBlackBST$Node.c; if (redBlackBST$Node.c.d != this.a) { redBlackBST$Node.c.d.e = redBlackBST$Node; } redBlackBST$Node.c = redBlackBST$Node.c.d; redBlackBST$Node.e.d = redBlackBST$Node; return; } redBlackBST$Node = this.b.c; this.b.c = this.b.c.d; redBlackBST$Node.d.e = this.b; this.b.e = redBlackBST$Node; redBlackBST$Node.d = this.b; redBlackBST$Node.e = this.a; this.b = redBlackBST$Node; } private void b(RedBlackBST$Node redBlackBST$Node, RedBlackBST$Node redBlackBST$Node2) { if (redBlackBST$Node.e == this.a) { this.b = redBlackBST$Node2; } else { RedBlackBST$Node redBlackBST$Node3 = redBlackBST$Node; if (redBlackBST$Node3 == redBlackBST$Node3.e.c) { redBlackBST$Node.e.c = redBlackBST$Node2; } else { redBlackBST$Node.e.d = redBlackBST$Node2; } } redBlackBST$Node2.e = redBlackBST$Node.e; } public void insertDemo() { Scanner scanner = new Scanner(System.in); System.out.println(\"Add items\"); int n = scanner.nextInt(); while (n != -999) { Object object = new RedBlackBST$Node(this, n); RedBlackBST$Node redBlackBST$Node = object; object = this; RedBlackBST$Node redBlackBST$Node2 = ((RedBlackBST)object).b; if (((RedBlackBST)object).b == ((RedBlackBST)object).a) { ((RedBlackBST)object).b = redBlackBST$Node; redBlackBST$Node.b = 1; redBlackBST$Node.e = ((RedBlackBST)object).a; } else { redBlackBST$Node.b = 0; while (true) { if (redBlackBST$Node.a < redBlackBST$Node2.a) { if (redBlackBST$Node2.c == ((RedBlackBST)object).a) { redBlackBST$Node2.c = redBlackBST$Node; redBlackBST$Node.e = redBlackBST$Node2; break; } redBlackBST$Node2 = redBlackBST$Node2.c; continue; } if (redBlackBST$Node.a < redBlackBST$Node2.a) continue; if (redBlackBST$Node2.d == ((RedBlackBST)object).a) { redBlackBST$Node2.d = redBlackBST$Node; redBlackBST$Node.e = redBlackBST$Node2; break; } redBlackBST$Node2 = redBlackBST$Node2.d; } while (redBlackBST$Node.e.b == 0) { RedBlackBST$Node cfr_ignored_0 = ((RedBlackBST)object).a; if (redBlackBST$Node.e == redBlackBST$Node.e.e.c) { redBlackBST$Node2 = redBlackBST$Node.e.e.d; if (redBlackBST$Node2 != ((RedBlackBST)object).a && redBlackBST$Node2.b == 0) { redBlackBST$Node.e.b = 1; redBlackBST$Node2.b = 1; redBlackBST$Node.e.e.b = 0; redBlackBST$Node = redBlackBST$Node.e.e; continue; } RedBlackBST$Node redBlackBST$Node3 = redBlackBST$Node; if (redBlackBST$Node3 == redBlackBST$Node3.e.d) { redBlackBST$Node = redBlackBST$Node.e; ((RedBlackBST)object).a(redBlackBST$Node); } redBlackBST$Node.e.b = 1; redBlackBST$Node.e.e.b = 0; ((RedBlackBST)object).b(redBlackBST$Node.e.e); continue; } redBlackBST$Node2 = redBlackBST$Node.e.e.c; if (redBlackBST$Node2 != ((RedBlackBST)object).a && redBlackBST$Node2.b == 0) { redBlackBST$Node.e.b = 1; redBlackBST$Node2.b = 1; redBlackBST$Node.e.e.b = 0; redBlackBST$Node = redBlackBST$Node.e.e; continue; } RedBlackBST$Node redBlackBST$Node4 = redBlackBST$Node; if (redBlackBST$Node4 == redBlackBST$Node4.e.c) { redBlackBST$Node = redBlackBST$Node.e; ((RedBlackBST)object).b(redBlackBST$Node); } redBlackBST$Node.e.b = 1; redBlackBST$Node.e.e.b = 0; ((RedBlackBST)object).a(redBlackBST$Node.e.e); } ((RedBlackBST)object).b.b = 1; } n = scanner.nextInt(); } RedBlackBST redBlackBST = this; redBlackBST.printTree(redBlackBST.b); System.out.println(\"Pre order\"); RedBlackBST redBlackBST2 = this; redBlackBST2.printTreepre(redBlackBST2.b); scanner.close(); } public void deleteDemo() { boolean bl; Scanner scanner = new Scanner(System.in); System.out.println(\"Delete items\"); int n = scanner.nextInt(); RedBlackBST$Node redBlackBST$Node = new RedBlackBST$Node(this, n); System.out.print(\"Deleting item \" + n); Object object = this; Object object2 = ((RedBlackBST)object).a(redBlackBST$Node, ((RedBlackBST)object).b); if (object2 == null) { bl = false; } else { Object object3 = redBlackBST$Node; int n2 = ((RedBlackBST$Node)object3).b; if (redBlackBST$Node.c == ((RedBlackBST)object).a) { object2 = redBlackBST$Node.d; RedBlackBST$Node redBlackBST$Node2 = redBlackBST$Node; ((RedBlackBST)object).b(redBlackBST$Node2, redBlackBST$Node2.d); } else if (redBlackBST$Node.d == ((RedBlackBST)object).a) { object2 = redBlackBST$Node.c; RedBlackBST$Node redBlackBST$Node3 = redBlackBST$Node; ((RedBlackBST)object).b(redBlackBST$Node3, redBlackBST$Node3.c); } else { object3 = redBlackBST$Node.d; object2 = object; while (((RedBlackBST$Node)object3).c != ((RedBlackBST)object2).a) { object3 = ((RedBlackBST$Node)object3).c; } n2 = ((RedBlackBST$Node)object3).b; object2 = ((RedBlackBST$Node)object3).d; if (((RedBlackBST$Node)object3).e == redBlackBST$Node) { ((RedBlackBST$Node)object2).e = object3; } else { Object object4 = object3; ((RedBlackBST)object).b((RedBlackBST$Node)object4, ((RedBlackBST$Node)object4).d); ((RedBlackBST$Node)object3).d = redBlackBST$Node.d; ((RedBlackBST$Node)object3).d.e = object3; } ((RedBlackBST)object).b(redBlackBST$Node, (RedBlackBST$Node)object3); ((RedBlackBST$Node)object3).c = redBlackBST$Node.c; ((RedBlackBST$Node)object3).c.e = object3; ((RedBlackBST$Node)object3).b = redBlackBST$Node.b; } if (n2 == 1) { object3 = object2; object2 = object; while (object3 != ((RedBlackBST)object2).b && ((RedBlackBST$Node)object3).b == 1) { Object object5 = object3; if (object5 == ((RedBlackBST$Node)object5).e.c) { object = ((RedBlackBST$Node)object3).e.d; if (((RedBlackBST$Node)object).b == 0) { ((RedBlackBST$Node)object).b = 1; ((RedBlackBST$Node)object3).e.b = 0; ((RedBlackBST)object2).a(((RedBlackBST$Node)object3).e); object = ((RedBlackBST$Node)object3).e.d; } if (((RedBlackBST$Node)object).c.b == 1 && ((RedBlackBST$Node)object).d.b == 1) { ((RedBlackBST$Node)object).b = 0; object3 = ((RedBlackBST$Node)object3).e; continue; } if (((RedBlackBST$Node)object).d.b == 1) { ((RedBlackBST$Node)object).c.b = 1; ((RedBlackBST$Node)object).b = 0; ((RedBlackBST)object2).b((RedBlackBST$Node)object); object = ((RedBlackBST$Node)object3).e.d; } if (((RedBlackBST$Node)object).d.b != 0) continue; ((RedBlackBST$Node)object).b = ((RedBlackBST$Node)object3).e.b; ((RedBlackBST$Node)object3).e.b = 1; ((RedBlackBST$Node)object).d.b = 1; ((RedBlackBST)object2).a(((RedBlackBST$Node)object3).e); object3 = ((RedBlackBST)object2).b; continue; } object = ((RedBlackBST$Node)object3).e.c; if (((RedBlackBST$Node)object).b == 0) { ((RedBlackBST$Node)object).b = 1; ((RedBlackBST$Node)object3).e.b = 0; ((RedBlackBST)object2).b(((RedBlackBST$Node)object3).e); object = ((RedBlackBST$Node)object3).e.c; } if (((RedBlackBST$Node)object).d.b == 1 && ((RedBlackBST$Node)object).c.b == 1) { ((RedBlackBST$Node)object).b = 0; object3 = ((RedBlackBST$Node)object3).e; continue; } if (((RedBlackBST$Node)object).c.b == 1) { ((RedBlackBST$Node)object).d.b = 1; ((RedBlackBST$Node)object).b = 0; ((RedBlackBST)object2).a((RedBlackBST$Node)object); object = ((RedBlackBST$Node)object3).e.c; } if (((RedBlackBST$Node)object).c.b != 0) continue; ((RedBlackBST$Node)object).b = ((RedBlackBST$Node)object3).e.b; ((RedBlackBST$Node)object3).e.b = 1; ((RedBlackBST$Node)object).c.b = 1; ((RedBlackBST)object2).b(((RedBlackBST$Node)object3).e); object3 = ((RedBlackBST)object2).b; } ((RedBlackBST$Node)object3).b = 1; } bl = true; } if (bl) { System.out.print(\": deleted!\"); } else { System.out.print(\": does not exist!\"); } System.out.println(); RedBlackBST redBlackBST = this; redBlackBST.printTree(redBlackBST.b); System.out.println(\"Pre order\"); RedBlackBST redBlackBST2 = this; redBlackBST2.printTreepre(redBlackBST2.b); scanner.close(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.Scanner; /** * @author jack870131 */ public class RedBlackBST { private static final int RED = 0; private static final int BLACK = 1; private class Node { int key = -1; int color = BLACK; Node left = nil; Node right = nil; Node p = nil; Node(int key) { this.key = key; } } private final Node nil = new Node(-1); private Node root = nil; public void printTree(Node node) { if (node == nil) { return; } printTree(node.left); System.out.print(((node.color == RED) ? \" R \" : \" B \") + \"Key: \" + node.key + \" Parent: \" + node.p.key + \"\\n\"); printTree(node.right); } public void printTreepre(Node node) { if (node == nil) { return; } System.out.print(((node.color == RED) ? \" R \" : \" B \") + \"Key: \" + node.key + \" Parent: \" + node.p.key + \"\\n\"); printTreepre(node.left); printTreepre(node.right); } private Node findNode(Node findNode, Node node) { if (root == nil) { return null; } if (findNode.key < node.key) { if (node.left != nil) { return findNode(findNode, node.left); } } else if (findNode.key > node.key) { if (node.right != nil) { return findNode(findNode, node.right); } } else if (findNode.key == node.key) { return node; } return null; } private void insert(Node node) { Node temp = root; if (root == nil) { root = node; node.color = BLACK; node.p = nil; } else { node.color = RED; while (true) { if (node.key < temp.key) { if (temp.left == nil) { temp.left = node; node.p = temp; break; } else { temp = temp.left; } } else if (node.key >= temp.key) { if (temp.right == nil) { temp.right = node; node.p = temp; break; } else { temp = temp.right; } } } fixTree(node); } } private void fixTree(Node node) { while (node.p.color == RED) { Node y = nil; if (node.p == node.p.p.left) { y = node.p.p.right; if (y != nil && y.color == RED) { node.p.color = BLACK; y.color = BLACK; node.p.p.color = RED; node = node.p.p; continue; } if (node == node.p.right) { node = node.p; rotateLeft(node); } node.p.color = BLACK; node.p.p.color = RED; rotateRight(node.p.p); } else { y = node.p.p.left; if (y != nil && y.color == RED) { node.p.color = BLACK; y.color = BLACK; node.p.p.color = RED; node = node.p.p; continue; } if (node == node.p.left) { node = node.p; rotateRight(node); } node.p.color = BLACK; node.p.p.color = RED; rotateLeft(node.p.p); } } root.color = BLACK; } void rotateLeft(Node node) { if (node.p != nil) { if (node == node.p.left) { node.p.left = node.right; } else { node.p.right = node.right; } node.right.p = node.p; node.p = node.right; if (node.right.left != nil) { node.right.left.p = node; } node.right = node.right.left; node.p.left = node; } else { Node right = root.right; root.right = right.left; right.left.p = root; root.p = right; right.left = root; right.p = nil; root = right; } } void rotateRight(Node node) { if (node.p != nil) { if (node == node.p.left) { node.p.left = node.left; } else { node.p.right = node.left; } node.left.p = node.p; node.p = node.left; if (node.left.right != nil) { node.left.right.p = node; } node.left = node.left.right; node.p.right = node; } else { Node left = root.left; root.left = root.left.right; left.right.p = root; root.p = left; left.right = root; left.p = nil; root = left; } } void transplant(Node target, Node with) { if (target.p == nil) { root = with; } else if (target == target.p.left) { target.p.left = with; } else { target.p.right = with; } with.p = target.p; } Node treeMinimum(Node subTreeRoot) { while (subTreeRoot.left != nil) { subTreeRoot = subTreeRoot.left; } return subTreeRoot; } boolean delete(Node z) { Node result = findNode(z, root); if (result == null) { return false; } Node x; Node y = z; int yorigcolor = y.color; if (z.left == nil) { x = z.right; transplant(z, z.right); } else if (z.right == nil) { x = z.left; transplant(z, z.left); } else { y = treeMinimum(z.right); yorigcolor = y.color; x = y.right; if (y.p == z) { x.p = y; } else { transplant(y, y.right); y.right = z.right; y.right.p = y; } transplant(z, y); y.left = z.left; y.left.p = y; y.color = z.color; } if (yorigcolor == BLACK) { deleteFixup(x); } return true; } void deleteFixup(Node x) { while (x != root && x.color == BLACK) { if (x == x.p.left) { Node w = x.p.right; if (w.color == RED) { w.color = BLACK; x.p.color = RED; rotateLeft(x.p); w = x.p.right; } if (w.left.color == BLACK && w.right.color == BLACK) { w.color = RED; x = x.p; continue; } else if (w.right.color == BLACK) { w.left.color = BLACK; w.color = RED; rotateRight(w); w = x.p.right; } if (w.right.color == RED) { w.color = x.p.color; x.p.color = BLACK; w.right.color = BLACK; rotateLeft(x.p); x = root; } } else { Node w = x.p.left; if (w.color == RED) { w.color = BLACK; x.p.color = RED; rotateRight(x.p); w = x.p.left; } if (w.right.color == BLACK && w.left.color == BLACK) { w.color = RED; x = x.p; continue; } else if (w.left.color == BLACK) { w.right.color = BLACK; w.color = RED; rotateLeft(w); w = x.p.left; } if (w.left.color == RED) { w.color = x.p.color; x.p.color = BLACK; w.left.color = BLACK; rotateRight(x.p); x = root; } } } x.color = BLACK; } public void insertDemo() { Scanner scan = new Scanner(System.in); System.out.println(\"Add items\"); int item; Node node; item = scan.nextInt(); while (item != -999) { node = new Node(item); insert(node); item = scan.nextInt(); } printTree(root); System.out.println(\"Pre order\"); printTreepre(root); scan.close(); } public void deleteDemo() { Scanner scan = new Scanner(System.in); System.out.println(\"Delete items\"); int item; Node node; item = scan.nextInt(); node = new Node(item); System.out.print(\"Deleting item \" + item); if (delete(node)) { System.out.print(\": deleted!\"); } else { System.out.print(\": does not exist!\"); } System.out.println(); printTree(root); System.out.println(\"Pre order\"); printTreepre(root); scan.close(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class RegexMatching { private RegexMatching() { } public static boolean regexRecursion(String string, String string2) { boolean bl; if (string.length() == 0 && string2.length() == 0) { return true; } if (string.length() != 0 && string2.length() == 0) { return false; } if (string.length() == 0 && string2.length() != 0) { for (int i = 0; i < string2.length(); ++i) { if (string2.charAt(i) == '*') continue; return false; } return true; } char c = string.charAt(0); char c2 = string2.charAt(0); String string3 = string.substring(1); String string4 = string2.substring(1); if (c == c2 || c2 == '?') { bl = RegexMatching.regexRecursion(string3, string4); } else if (c2 == '*') { bl = RegexMatching.regexRecursion(string, string4); boolean bl2 = RegexMatching.regexRecursion(string3, string2); bl = bl || bl2; } else { bl = false; } return bl; } public static boolean regexRecursion(String string, String string2, int n, int n2, int[][] nArray) { boolean bl; char c; if (string.length() == n && string2.length() == n2) { return true; } if (string.length() != n && string2.length() == n2) { return false; } if (string.length() == n && string2.length() != n2) { for (int i = n2; i < string2.length(); ++i) { if (string2.charAt(i) == '*') continue; return false; } return true; } if (nArray[n][n2] != 0) { return nArray[n][n2] != 1; } char c2 = string.charAt(n); if (c2 == (c = string2.charAt(n2)) || c == '?') { bl = RegexMatching.regexRecursion(string, string2, n + 1, n2 + 1, nArray); } else if (c == '*') { c2 = (char)(RegexMatching.regexRecursion(string, string2, n, n2 + 1, nArray) ? 1 : 0); bl = RegexMatching.regexRecursion(string, string2, n + 1, n2, nArray); bl = c2 != '\\u0000' || bl; } else { bl = false; } nArray[n][n2] = bl ? 2 : 1; return bl; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Given a text and wildcard pattern implement a wildcard pattern matching * algorithm that finds if wildcard is matched with text. The matching should * cover the entire text ?-> matches single characters *-> match the sequence of * characters * * For calculation of Time and Space Complexity. Let N be length of src and M be length of pat * * Memoization vs Tabulation : https://www.geeksforgeeks.org/tabulation-vs-memoization/ * Question Link : https://practice.geeksforgeeks.org/problems/wildcard-pattern-matching/1 */ public final class RegexMatching { private RegexMatching() { } /** * Method 1: Determines if the given source string matches the given pattern using a recursive approach. * This method directly applies recursion to check if the source string matches the pattern, considering * the wildcards '?' and '*'. * * Time Complexity: O(2^(N+M)), where N is the length of the source string and M is the length of the pattern. * Space Complexity: O(N + M) due to the recursion stack. * * @param src The source string to be matched against the pattern. * @param pat The pattern containing wildcards ('*' matches a sequence of characters, '?' matches a single character). * @return {@code true} if the source string matches the pattern, {@code false} otherwise. */ public static boolean regexRecursion(String src, String pat) { if (src.length() == 0 && pat.length() == 0) { return true; } if (src.length() != 0 && pat.length() == 0) { return false; } if (src.length() == 0 && pat.length() != 0) { for (int i = 0; i < pat.length(); i++) { if (pat.charAt(i) != '*') { return false; } } return true; } char chs = src.charAt(0); char chp = pat.charAt(0); String ros = src.substring(1); String rop = pat.substring(1); boolean ans; if (chs == chp || chp == '?') { ans = regexRecursion(ros, rop); } else if (chp == '*') { boolean blank = regexRecursion(src, rop); boolean multiple = regexRecursion(ros, pat); ans = blank || multiple; } else { ans = false; } return ans; } /** * Method 2: Determines if the given source string matches the given pattern using recursion. * This method utilizes a virtual index for both the source string and the pattern to manage the recursion. * * Time Complexity: O(2^(N+M)) where N is the length of the source string and M is the length of the pattern. * Space Complexity: O(N + M) due to the recursion stack. * * @param src The source string to be matched against the pattern. * @param pat The pattern containing wildcards ('*' matches a sequence of characters, '?' matches a single character). * @param svidx The current index in the source string. * @param pvidx The current index in the pattern. * @return {@code true} if the source string matches the pattern, {@code false} otherwise. */ static boolean regexRecursion(String src, String pat, int svidx, int pvidx) { if (src.length() == svidx && pat.length() == pvidx) { return true; } if (src.length() != svidx && pat.length() == pvidx) { return false; } if (src.length() == svidx && pat.length() != pvidx) { for (int i = pvidx; i < pat.length(); i++) { if (pat.charAt(i) != '*') { return false; } } return true; } char chs = src.charAt(svidx); char chp = pat.charAt(pvidx); boolean ans; if (chs == chp || chp == '?') { ans = regexRecursion(src, pat, svidx + 1, pvidx + 1); } else if (chp == '*') { boolean blank = regexRecursion(src, pat, svidx, pvidx + 1); boolean multiple = regexRecursion(src, pat, svidx + 1, pvidx); ans = blank || multiple; } else { ans = false; } return ans; } /** * Method 3: Determines if the given source string matches the given pattern using top-down dynamic programming (memoization). * This method utilizes memoization to store intermediate results, reducing redundant computations and improving efficiency. * * Time Complexity: O(N * M), where N is the length of the source string and M is the length of the pattern. * Space Complexity: O(N * M) for the memoization table, plus additional space for the recursion stack. * * @param src The source string to be matched against the pattern. * @param pat The pattern containing wildcards ('*' matches a sequence of characters, '?' matches a single character). * @param svidx The current index in the source string. * @param pvidx The current index in the pattern. * @param strg A 2D array used for memoization to store the results of subproblems. * @return {@code true} if the source string matches the pattern, {@code false} otherwise. */ public static boolean regexRecursion(String src, String pat, int svidx, int pvidx, int[][] strg) { if (src.length() == svidx && pat.length() == pvidx) { return true; } if (src.length() != svidx && pat.length() == pvidx) { return false; } if (src.length() == svidx && pat.length() != pvidx) { for (int i = pvidx; i < pat.length(); i++) { if (pat.charAt(i) != '*') { return false; } } return true; } if (strg[svidx][pvidx] != 0) { return strg[svidx][pvidx] != 1; } char chs = src.charAt(svidx); char chp = pat.charAt(pvidx); boolean ans; if (chs == chp || chp == '?') { ans = regexRecursion(src, pat, svidx + 1, pvidx + 1, strg); } else if (chp == '*') { boolean blank = regexRecursion(src, pat, svidx, pvidx + 1, strg); boolean multiple = regexRecursion(src, pat, svidx + 1, pvidx, strg); ans = blank || multiple; } else { ans = false; } strg[svidx][pvidx] = ans ? 2 : 1; return ans; } /** * Method 4: Determines if the given source string matches the given pattern using bottom-up dynamic programming (tabulation). * This method builds a solution iteratively by filling out a table, where each cell represents whether a substring * of the source string matches a substring of the pattern. * * Time Complexity: O(N * M), where N is the length of the source string and M is the length of the pattern. * Space Complexity: O(N * M) for the table used in the tabulation process. * * @param src The source string to be matched against the pattern. * @param pat The pattern containing wildcards ('*' matches a sequence of characters, '?' matches a single character). * @return {@code true} if the source string matches the pattern, {@code false} otherwise. */ static boolean regexBU(String src, String pat) { boolean[][] strg = new boolean[src.length() + 1][pat.length() + 1]; strg[src.length()][pat.length()] = true; for (int row = src.length(); row >= 0; row--) { for (int col = pat.length() - 1; col >= 0; col--) { if (row == src.length()) { if (pat.charAt(col) == '*') { strg[row][col] = strg[row][col + 1]; } else { strg[row][col] = false; } } else { char chs = src.charAt(row); char chp = pat.charAt(col); boolean ans; if (chs == chp || chp == '?') { ans = strg[row + 1][col + 1]; } else if (chp == '*') { boolean blank = strg[row][col + 1]; boolean multiple = strg[row + 1][col]; ans = blank || multiple; } else { ans = false; } strg[row][col] = ans; } } } return strg[0][0]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; public final class RemoveDuplicateFromString { private RemoveDuplicateFromString() { } public static String removeDuplicate(String object) { if (object == null || ((String)object).isEmpty()) { return object; } StringBuilder stringBuilder = new StringBuilder(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object2 = object[i]; if (stringBuilder.indexOf(String.valueOf((char)object2)) != -1) continue; stringBuilder.append((char)object2); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.others; /** * @author Varun Upadhyay (https://github.com/varunu28) */ public final class RemoveDuplicateFromString { private RemoveDuplicateFromString() { } /** * Removes duplicate characters from the given string. * * @param input The input string from which duplicate characters need to be removed. * @return A string containing only unique characters from the input, in their original order. */ public static String removeDuplicate(String input) { if (input == null || input.isEmpty()) { return input; } StringBuilder uniqueChars = new StringBuilder(); for (char c : input.toCharArray()) { if (uniqueChars.indexOf(String.valueOf(c)) == -1) { uniqueChars.append(c); // Append character if it's not already in the StringBuilder } } return uniqueChars.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.randomized; import java.util.ArrayList; import java.util.List; import java.util.Random; public final class ReservoirSampling { private ReservoirSampling() { throw new UnsupportedOperationException(\"Utility class\"); } public static List sample(int[] nArray, int n) { if (n > nArray.length) { throw new IllegalArgumentException(\"Sample size cannot exceed stream size.\"); } ArrayList<Integer> arrayList = new ArrayList<Integer>(n); Random random = new Random(); for (int i = 0; i < nArray.length; ++i) { if (i < n) { arrayList.add(nArray[i]); continue; } int n2 = random.nextInt(i + 1); if (n2 >= n) continue; arrayList.set(n2, nArray[i]); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.randomized; import java.util.ArrayList; import java.util.List; import java.util.Random; /** * Reservoir Sampling Algorithm * * Use Case: * - Efficient for selecting k random items from a stream of unknown size * - Used in streaming systems, big data, and memory-limited environments * * Time Complexity: O(n) * Space Complexity: O(k) * * @author Michael Alexander Montoya (@cureprotocols) * @see <a href=\"https://en.wikipedia.org/wiki/Reservoir_sampling\">Reservoir Sampling - Wikipedia</a> */ public final class ReservoirSampling { // Prevent instantiation of utility class private ReservoirSampling() { throw new UnsupportedOperationException(\"Utility class\"); } /** * Selects k random elements from a stream using reservoir sampling. * * @param stream The input stream as an array of integers. * @param sampleSize The number of elements to sample. * @return A list containing k randomly selected elements. */ public static List<Integer> sample(int[] stream, int sampleSize) { if (sampleSize > stream.length) { throw new IllegalArgumentException(\"Sample size cannot exceed stream size.\"); } List<Integer> reservoir = new ArrayList<>(sampleSize); Random rand = new Random(); for (int i = 0; i < stream.length; i++) { if (i < sampleSize) { reservoir.add(stream[i]); } else { int j = rand.nextInt(i + 1); if (j < sampleSize) { reservoir.set(j, stream[i]); } } } return reservoir; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class ReturnSubsequence { private ReturnSubsequence() { } public static String[] getSubsequences(String string) { if (string.isEmpty()) { return new String[]{\"\"}; } String[] stringArray = ReturnSubsequence.getSubsequences(string.substring(1)); String[] stringArray2 = new String[2 * stringArray.length]; System.arraycopy(stringArray, 0, stringArray2, 0, stringArray.length); for (int i = 0; i < stringArray.length; ++i) { stringArray2[i + stringArray.length] = string.charAt(0) + stringArray[i]; } return stringArray2; } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * Class for generating all subsequences of a given string. */ public final class ReturnSubsequence { private ReturnSubsequence() { } /** * Generates all subsequences of the given string. * * @param input The input string. * @return An array of subsequences. */ public static String[] getSubsequences(String input) { if (input.isEmpty()) { return new String[] {\"\"}; // Return array with an empty string if input is empty } // Recursively find subsequences of the substring (excluding the first character) String[] smallerSubsequences = getSubsequences(input.substring(1)); // Create an array to hold the final subsequences, double the size of smallerSubsequences String[] result = new String[2 * smallerSubsequences.length]; // Copy the smaller subsequences directly to the result array System.arraycopy(smallerSubsequences, 0, result, 0, smallerSubsequences.length); // Prepend the first character of the input string to each of the smaller subsequences for (int i = 0; i < smallerSubsequences.length; i++) { result[i + smallerSubsequences.length] = input.charAt(0) + smallerSubsequences[i]; } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class ReverseBits { private ReverseBits() { } public static int reverseBits(int n) { int n2 = 0; for (int i = 0; i < 32; ++i) { n2 <<= 1; n2 |= n & 1; n >>= 1; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class provides a method to reverse the bits of a 32-bit integer. * Reversing the bits means that the least significant bit (LSB) becomes * the most significant bit (MSB) and vice versa. * * Example: * Input (binary): 00000010100101000001111010011100 (43261596) * Output (binary): 00111001011110000010100101000000 (964176192) * * Time Complexity: O(32) - A fixed number of 32 iterations * Space Complexity: O(1) - No extra space used * * Note: * - If the input is negative, Java handles it using twos complement representation. * - This function works on 32-bit integers by default. * * @author Bama Charan Chhandogi */ public final class ReverseBits { private ReverseBits() { } /** * Reverses the bits of a 32-bit integer. * * @param n the integer whose bits are to be reversed * @return the integer obtained by reversing the bits of the input */ public static int reverseBits(int n) { int result = 0; int bitCount = 32; for (int i = 0; i < bitCount; i++) { result <<= 1; // Left shift the result to make space for the next bit result |= (n & 1); // OR operation to set the least significant bit of result with the current bit of n n >>= 1; // Right shift n to move on to the next bit } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SinglyLinkedListNode; public class ReverseKGroup { public int length(SinglyLinkedListNode singlyLinkedListNode) { int n = 0; while (singlyLinkedListNode != null) { singlyLinkedListNode = singlyLinkedListNode.b; ++n; } return n; } public SinglyLinkedListNode reverse(SinglyLinkedListNode singlyLinkedListNode, int n, int n2) { if (n < n2) { return singlyLinkedListNode; } SinglyLinkedListNode singlyLinkedListNode2 = null; SinglyLinkedListNode singlyLinkedListNode3 = singlyLinkedListNode; SinglyLinkedListNode singlyLinkedListNode4 = null; for (int i = 0; singlyLinkedListNode3 != null && i < n2; ++i) { singlyLinkedListNode4 = singlyLinkedListNode3.b; singlyLinkedListNode3.b = singlyLinkedListNode2; singlyLinkedListNode2 = singlyLinkedListNode3; singlyLinkedListNode3 = singlyLinkedListNode4; } if (singlyLinkedListNode4 != null) { singlyLinkedListNode.b = this.reverse(singlyLinkedListNode4, n - n2, n2); } return singlyLinkedListNode2; } public SinglyLinkedListNode reverseKGroup(SinglyLinkedListNode singlyLinkedListNode, int n) { int n2 = this.length(singlyLinkedListNode); return this.reverse(singlyLinkedListNode, n2, n); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; /** * The ReverseKGroup class provides functionality to reverse nodes in a * linked list in groups of k nodes. * <p> * This algorithm follows the approach of reversing the linked list in segments of * size k. If the remaining nodes are fewer than k, they remain unchanged. * </p> * <p> * Example: * Given a linked list: 1 -> 2 -> 3 -> 4 -> 5 and k = 3, * the output will be: 3 -> 2 -> 1 -> 4 -> 5. * </p> * <p> * The implementation contains: * - {@code length(SinglyLinkedListNode head)}: A method to calculate the length of the linked list. * - {@code reverse(SinglyLinkedListNode head, int count, int k)}: A helper method that reverses the nodes * in the linked list in groups of k. * - {@code reverseKGroup(SinglyLinkedListNode head, int k)}: The main method that initiates the reversal * process by calling the reverse method. * </p> * <p> * Complexity: * <ul> * <li>Time Complexity: O(n), where n is the number of nodes in the linked list.</li> * <li>Space Complexity: O(1), as we are reversing in place.</li> * </ul> * </p> * * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi) */ public class ReverseKGroup { /** * Calculates the length of the linked list. * * @param head The head node of the linked list. * @return The total number of nodes in the linked list. */ public int length(SinglyLinkedListNode head) { SinglyLinkedListNode curr = head; int count = 0; while (curr != null) { curr = curr.next; count++; } return count; } /** * Reverses the linked list in groups of k nodes. * * @param head The head node of the linked list. * @param count The remaining number of nodes. * @param k The size of the group to reverse. * @return The new head of the reversed linked list segment. */ public SinglyLinkedListNode reverse(SinglyLinkedListNode head, int count, int k) { if (count < k) { return head; } SinglyLinkedListNode prev = null; int count1 = 0; SinglyLinkedListNode curr = head; SinglyLinkedListNode next = null; while (curr != null && count1 < k) { next = curr.next; curr.next = prev; prev = curr; curr = next; count1++; } if (next != null) { head.next = reverse(next, count - k, k); } return prev; } /** * Reverses the linked list in groups of k nodes. * * @param head The head node of the linked list. * @param k The size of the group to reverse. * @return The head of the modified linked list after reversal. */ public SinglyLinkedListNode reverseKGroup(SinglyLinkedListNode head, int k) { int count = length(head); return reverse(head, count, k); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class ReverseNumber { private ReverseNumber() { } public static int reverseNumber(int n) { if (n < 0) { throw new IllegalArgumentException(\"number must be nonnegative.\"); } int n2 = 0; while (n > 0) { n2 *= 10; n2 += n % 10; n /= 10; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * @brief utility class reversing numbers */ public final class ReverseNumber { private ReverseNumber() { } /** * @brief reverses the input number * @param number the input number * @exception IllegalArgumentException number is negative * @return the number created by reversing the order of digits of the input number */ public static int reverseNumber(int number) { if (number < 0) { throw new IllegalArgumentException(\"number must be nonnegative.\"); } int result = 0; while (number > 0) { result *= 10; result += number % 10; number /= 10; } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.stacks; import java.util.Stack; public final class ReverseStack { private ReverseStack() { } public static void reverseStack(Stack stack) { if (stack.isEmpty()) { return; } int n = (Integer)stack.pop(); ReverseStack.reverseStack(stack); ReverseStack.a(stack, n); } private static void a(Stack stack, int n) { if (stack.isEmpty()) { stack.push(n); return; } int n2 = (Integer)stack.pop(); ReverseStack.a(stack, n); stack.push(n2); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.stacks; import java.util.Stack; /** * Provides methods to reverse a stack using recursion. * * <p>This class includes methods to reverse the order of elements in a stack * without using additional data structures. Elements are inserted at the bottom * of the stack to achieve the reverse order. * * <p>Example usage: * <pre> * Stack<Integer> stack = new Stack<>(); * stack.push(1); * stack.push(2); * stack.push(3); * ReverseStack.reverseStack(stack); * </pre> * After calling {@code reverseStack(stack)}, the stack's order is reversed. * * <p>This class is final and has a private constructor to prevent instantiation. * * @author Ishika Agarwal, 2021 */ public final class ReverseStack { private ReverseStack() { } /** * Reverses the order of elements in the given stack using recursion. * Steps: * 1. Check if the stack is empty. If so, return. * 2. Pop the top element from the stack. * 3. Recursively reverse the remaining stack. * 4. Insert the originally popped element at the bottom of the reversed stack. * * @param stack the stack to reverse; should not be null */ public static void reverseStack(Stack<Integer> stack) { if (stack.isEmpty()) { return; } int element = stack.pop(); reverseStack(stack); insertAtBottom(stack, element); } /** * Inserts the specified element at the bottom of the stack. * * <p>This method is a helper for {@link #reverseStack(Stack)}. * * Steps: * 1. If the stack is empty, push the element and return. * 2. Remove the top element from the stack. * 3. Recursively insert the new element at the bottom of the stack. * 4. Push the removed element back onto the stack. * * @param stack the stack in which to insert the element; should not be null * @param element the element to insert at the bottom of the stack */ private static void insertAtBottom(Stack<Integer> stack, int element) { if (stack.isEmpty()) { stack.push(element); return; } int topElement = stack.pop(); insertAtBottom(stack, element); stack.push(topElement); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Stack; public final class ReverseStackUsingRecursion { private ReverseStackUsingRecursion() { } public static void reverse(Stack stack) { if (stack == null) { throw new IllegalArgumentException(\"Stack cannot be null\"); } if (!stack.isEmpty()) { int n = (Integer)stack.pop(); ReverseStackUsingRecursion.reverse(stack); ReverseStackUsingRecursion.a(stack, n); } } private static void a(Stack stack, int n) { if (stack.isEmpty()) { stack.push(n); return; } int n2 = (Integer)stack.pop(); ReverseStackUsingRecursion.a(stack, n); stack.push(n2); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Stack; /** * Class that provides methods to reverse a stack using recursion. */ public final class ReverseStackUsingRecursion { private ReverseStackUsingRecursion() { } /** * Reverses the elements of the given stack using recursion. * * @param stack the stack to be reversed * @throws IllegalArgumentException if the stack is null */ public static void reverse(Stack<Integer> stack) { if (stack == null) { throw new IllegalArgumentException(\"Stack cannot be null\"); } if (!stack.isEmpty()) { int topElement = stack.pop(); reverse(stack); insertAtBottom(stack, topElement); } } /** * Inserts an element at the bottom of the given stack. * * @param stack the stack where the element will be inserted * @param element the element to be inserted at the bottom */ private static void insertAtBottom(Stack<Integer> stack, int element) { if (stack.isEmpty()) { stack.push(element); } else { int topElement = stack.pop(); insertAtBottom(stack, element); stack.push(topElement); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.Stack; public final class ReverseString { private ReverseString() { } public static String reverse(String string) { return new StringBuilder(string).reverse().toString(); } public static String reverse2(String string) { if (string == null || string.isEmpty()) { return string; } char[] cArray = string.toCharArray(); int n = 0; for (int i = string.length() - 1; n < i; ++n, --i) { char c = cArray[n]; cArray[n] = cArray[i]; cArray[i] = c; } return new String(cArray); } public static String reverse3(String string) { if (string.isEmpty()) { return string; } char[] cArray = string.toCharArray(); StringBuilder stringBuilder = new StringBuilder(); for (int i = string.length() - 1; i >= 0; --i) { stringBuilder.append(cArray[i]); } return stringBuilder.toString(); } public static String reverseStringUsingStack(String object) { if (object == null) { throw new IllegalArgumentException(\"Input string cannot be null\"); } Stack<Character> stack = new Stack<Character>(); StringBuilder stringBuilder = new StringBuilder(); if (((String)object).isEmpty()) { return object; } char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object2 = object[i]; stack.push(Character.valueOf((char)object2)); } while (!stack.isEmpty()) { stringBuilder.append(stack.pop()); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.Stack; /** * Reverse String using different version */ public final class ReverseString { private ReverseString() { } /** * easiest way to reverses the string str and returns it * * @param str string to be reversed * @return reversed string */ public static String reverse(String str) { return new StringBuilder(str).reverse().toString(); } /** * second way to reverses the string str and returns it * * @param str string to be reversed * @return reversed string */ public static String reverse2(String str) { if (str == null || str.isEmpty()) { return str; } char[] value = str.toCharArray(); for (int i = 0, j = str.length() - 1; i < j; i++, j--) { char temp = value[i]; value[i] = value[j]; value[j] = temp; } return new String(value); } /** * Reverse version 3 the given string using a StringBuilder. * This method converts the string to a character array, * iterates through it in reverse order, and appends each character * to a StringBuilder. * * @param string The input string to be reversed. * @return The reversed string. */ public static String reverse3(String string) { if (string.isEmpty()) { return string; } char[] chars = string.toCharArray(); StringBuilder sb = new StringBuilder(); for (int i = string.length() - 1; i >= 0; i--) { sb.append(chars[i]); } return sb.toString(); } /** * Reverses the given string using a stack. * This method uses a stack to reverse the characters of the string. * * @param str The input string to be reversed. * @return The reversed string. */ public static String reverseStringUsingStack(String str) { // Check if the input string is null if (str == null) { throw new IllegalArgumentException(\"Input string cannot be null\"); } Stack<Character> stack = new Stack<>(); StringBuilder reversedString = new StringBuilder(); // Check if the input string is empty if (str.isEmpty()) { return str; } // Push each character of the string onto the stack for (char ch : str.toCharArray()) { stack.push(ch); } // Pop each character from the stack and append to the StringBuilder while (!stack.isEmpty()) { reversedString.append(stack.pop()); } return reversedString.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class ReverseStringRecursive { private ReverseStringRecursive() { } public static String reverse(String string) { if (string.isEmpty()) { return string; } return ReverseStringRecursive.reverse(string.substring(1)) + string.charAt(0); } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * Reverse String using Recursion */ public final class ReverseStringRecursive { private ReverseStringRecursive() { } /** * @param str string to be reversed * @return reversed string */ public static String reverse(String str) { if (str.isEmpty()) { return str; } else { return reverse(str.substring(1)) + str.charAt(0); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.Arrays; import java.util.Collections; public final class ReverseWordsInString { private ReverseWordsInString() { } public static String reverseWordsInString(String charSequenceArray) { charSequenceArray = charSequenceArray.trim().split(\"\\\\s+\"); Collections.reverse(Arrays.asList(charSequenceArray)); return String.join((CharSequence)\" \", charSequenceArray); } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.Arrays; import java.util.Collections; public final class ReverseWordsInString { private ReverseWordsInString() { } /** * @brief Reverses words in the input string * @param s the input string * @return A string created by reversing the order of the words in {@code s} */ public static String reverseWordsInString(final String s) { var words = s.trim().split(\"\\\\s+\"); Collections.reverse(Arrays.asList(words)); return String.join(\" \", words); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.util.Arrays; public final class RgbHsvConversion { private RgbHsvConversion() { } public static void main(String[] stringArray) { assert (Arrays.equals(RgbHsvConversion.hsvToRgb(0.0, 0.0, 0.0), new int[]{0, 0, 0})); assert (Arrays.equals(RgbHsvConversion.hsvToRgb(0.0, 0.0, 1.0), new int[]{255, 255, 255})); assert (Arrays.equals(RgbHsvConversion.hsvToRgb(0.0, 1.0, 1.0), new int[]{255, 0, 0})); assert (Arrays.equals(RgbHsvConversion.hsvToRgb(60.0, 1.0, 1.0), new int[]{255, 255, 0})); assert (Arrays.equals(RgbHsvConversion.hsvToRgb(120.0, 1.0, 1.0), new int[]{0, 255, 0})); assert (Arrays.equals(RgbHsvConversion.hsvToRgb(240.0, 1.0, 1.0), new int[]{0, 0, 255})); assert (Arrays.equals(RgbHsvConversion.hsvToRgb(300.0, 1.0, 1.0), new int[]{255, 0, 255})); assert (Arrays.equals(RgbHsvConversion.hsvToRgb(180.0, 0.5, 0.5), new int[]{64, 128, 128})); assert (Arrays.equals(RgbHsvConversion.hsvToRgb(234.0, 0.14, 0.88), new int[]{193, 196, 224})); assert (Arrays.equals(RgbHsvConversion.hsvToRgb(330.0, 0.75, 0.5), new int[]{128, 32, 80})); assert (RgbHsvConversion.a(RgbHsvConversion.rgbToHsv(0, 0, 0), new double[]{0.0, 0.0, 0.0})); assert (RgbHsvConversion.a(RgbHsvConversion.rgbToHsv(255, 255, 255), new double[]{0.0, 0.0, 1.0})); assert (RgbHsvConversion.a(RgbHsvConversion.rgbToHsv(255, 0, 0), new double[]{0.0, 1.0, 1.0})); assert (RgbHsvConversion.a(RgbHsvConversion.rgbToHsv(255, 255, 0), new double[]{60.0, 1.0, 1.0})); assert (RgbHsvConversion.a(RgbHsvConversion.rgbToHsv(0, 255, 0), new double[]{120.0, 1.0, 1.0})); assert (RgbHsvConversion.a(RgbHsvConversion.rgbToHsv(0, 0, 255), new double[]{240.0, 1.0, 1.0})); assert (RgbHsvConversion.a(RgbHsvConversion.rgbToHsv(255, 0, 255), new double[]{300.0, 1.0, 1.0})); assert (RgbHsvConversion.a(RgbHsvConversion.rgbToHsv(64, 128, 128), new double[]{180.0, 0.5, 0.5})); assert (RgbHsvConversion.a(RgbHsvConversion.rgbToHsv(193, 196, 224), new double[]{234.0, 0.14, 0.88})); assert (RgbHsvConversion.a(RgbHsvConversion.rgbToHsv(128, 32, 80), new double[]{330.0, 0.75, 0.5})); } public static int[] hsvToRgb(double d, double d2, double d3) { int n; int n2; int n3; double d4; if (d < 0.0 || d > 360.0) { throw new IllegalArgumentException(\"hue should be between 0 and 360\"); } if (d2 < 0.0 || d2 > 1.0) { throw new IllegalArgumentException(\"saturation should be between 0 and 1\"); } if (d3 < 0.0 || d3 > 1.0) { throw new IllegalArgumentException(\"value should be between 0 and 1\"); } double d5 = d3 * d2; double d6 = d / 60.0; double d7 = d5 * (1.0 - Math.abs(d6 % 2.0 - 1.0)); double d8 = d3 - d5; double d9 = d7; double d10 = d8; double d11 = d5; double d12 = d6; if (d4 >= 0.0 && d12 <= 1.0) { n3 = RgbHsvConversion.a(d11 + d10); n2 = RgbHsvConversion.a(d9 + d10); n = RgbHsvConversion.a(d10); } else if (d12 > 1.0 && d12 <= 2.0) { n3 = RgbHsvConversion.a(d9 + d10); n2 = RgbHsvConversion.a(d11 + d10); n = RgbHsvConversion.a(d10); } else if (d12 > 2.0 && d12 <= 3.0) { n3 = RgbHsvConversion.a(d10); n2 = RgbHsvConversion.a(d11 + d10); n = RgbHsvConversion.a(d9 + d10); } else if (d12 > 3.0 && d12 <= 4.0) { n3 = RgbHsvConversion.a(d10); n2 = RgbHsvConversion.a(d9 + d10); n = RgbHsvConversion.a(d11 + d10); } else if (d12 > 4.0 && d12 <= 5.0) { n3 = RgbHsvConversion.a(d9 + d10); n2 = RgbHsvConversion.a(d10); n = RgbHsvConversion.a(d11 + d10); } else { n3 = RgbHsvConversion.a(d11 + d10); n2 = RgbHsvConversion.a(d10); n = RgbHsvConversion.a(d9 + d10); } return new int[]{n3, n2, n}; } public static double[] rgbToHsv(int n, int n2, int n3) { double d; if (n < 0 || n > 255) { throw new IllegalArgumentException(\"red should be between 0 and 255\"); } if (n2 < 0 || n2 > 255) { throw new IllegalArgumentException(\"green should be between 0 and 255\"); } if (n3 < 0 || n3 > 255) { throw new IllegalArgumentException(\"blue should be between 0 and 255\"); } double d2 = (double)n / 255.0; double d3 = (double)n2 / 255.0; double d4 = (double)n3 / 255.0; double d5 = Math.max(Math.max(d2, d3), d4); double d6 = d5 - Math.min(Math.min(d2, d3), d4); double d7 = d = d5 == 0.0 ? 0.0 : d6 / d5; double d8 = d6 == 0.0 ? 0.0 : (d5 == d2 ? 60.0 * (0.0 + (d3 - d4) / d6) : (d5 == d3 ? 60.0 * (2.0 + (d4 - d2) / d6) : 60.0 * (4.0 + (d2 - d3) / d6))); d8 = (d8 + 360.0) % 360.0; return new double[]{d8, d, d5}; } private static boolean a(double[] dArray, double[] dArray2) { boolean bl; boolean bl2 = Math.abs(dArray[0] - dArray2[0]) < 0.2; boolean bl3 = Math.abs(dArray[1] - dArray2[1]) < 0.002; boolean bl4 = bl = Math.abs(dArray[2] - dArray2[2]) < 0.002; return bl2 && bl3 && bl; } private static int a(double d) { return (int)Math.round(d * 255.0); } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.util.Arrays; /** * The RGB color model is an additive color model in which red, green, and blue * light are added together in various ways to reproduce a broad array of * colors. The name of the model comes from the initials of the three additive * primary colors, red, green, and blue. Meanwhile, the HSV representation * models how colors appear under light. In it, colors are represented using * three components: hue, saturation and (brightness-)value. This class provides * methods for converting colors from one representation to the other. * (description adapted from <a href=\"https://en.wikipedia.org/wiki/RGB_color_model\">[1]</a> and * <a href=\"https://en.wikipedia.org/wiki/HSL_and_HSV\">[2]</a>). */ public final class RgbHsvConversion { private RgbHsvConversion() { } public static void main(String[] args) { // Expected RGB-values taken from https://www.rapidtables.com/convert/color/hsv-to-rgb.html // Test hsvToRgb-method assert Arrays.equals(hsvToRgb(0, 0, 0), new int[] {0, 0, 0}); assert Arrays.equals(hsvToRgb(0, 0, 1), new int[] {255, 255, 255}); assert Arrays.equals(hsvToRgb(0, 1, 1), new int[] {255, 0, 0}); assert Arrays.equals(hsvToRgb(60, 1, 1), new int[] {255, 255, 0}); assert Arrays.equals(hsvToRgb(120, 1, 1), new int[] {0, 255, 0}); assert Arrays.equals(hsvToRgb(240, 1, 1), new int[] {0, 0, 255}); assert Arrays.equals(hsvToRgb(300, 1, 1), new int[] {255, 0, 255}); assert Arrays.equals(hsvToRgb(180, 0.5, 0.5), new int[] {64, 128, 128}); assert Arrays.equals(hsvToRgb(234, 0.14, 0.88), new int[] {193, 196, 224}); assert Arrays.equals(hsvToRgb(330, 0.75, 0.5), new int[] {128, 32, 80}); // Test rgbToHsv-method // approximate-assertions needed because of small deviations due to converting between // int-values and double-values. assert approximatelyEqualHsv(rgbToHsv(0, 0, 0), new double[] {0, 0, 0}); assert approximatelyEqualHsv(rgbToHsv(255, 255, 255), new double[] {0, 0, 1}); assert approximatelyEqualHsv(rgbToHsv(255, 0, 0), new double[] {0, 1, 1}); assert approximatelyEqualHsv(rgbToHsv(255, 255, 0), new double[] {60, 1, 1}); assert approximatelyEqualHsv(rgbToHsv(0, 255, 0), new double[] {120, 1, 1}); assert approximatelyEqualHsv(rgbToHsv(0, 0, 255), new double[] {240, 1, 1}); assert approximatelyEqualHsv(rgbToHsv(255, 0, 255), new double[] {300, 1, 1}); assert approximatelyEqualHsv(rgbToHsv(64, 128, 128), new double[] {180, 0.5, 0.5}); assert approximatelyEqualHsv(rgbToHsv(193, 196, 224), new double[] {234, 0.14, 0.88}); assert approximatelyEqualHsv(rgbToHsv(128, 32, 80), new double[] {330, 0.75, 0.5}); } /** * Conversion from the HSV-representation to the RGB-representation. * * @param hue Hue of the color. * @param saturation Saturation of the color. * @param value Brightness-value of the color. * @return The tuple of RGB-components. */ public static int[] hsvToRgb(double hue, double saturation, double value) { if (hue < 0 || hue > 360) { throw new IllegalArgumentException(\"hue should be between 0 and 360\"); } if (saturation < 0 || saturation > 1) { throw new IllegalArgumentException(\"saturation should be between 0 and 1\"); } if (value < 0 || value > 1) { throw new IllegalArgumentException(\"value should be between 0 and 1\"); } double chroma = value * saturation; double hueSection = hue / 60; double secondLargestComponent = chroma * (1 - Math.abs(hueSection % 2 - 1)); double matchValue = value - chroma; return getRgbBySection(hueSection, chroma, matchValue, secondLargestComponent); } /** * Conversion from the RGB-representation to the HSV-representation. * * @param red Red-component of the color. * @param green Green-component of the color. * @param blue Blue-component of the color. * @return The tuple of HSV-components. */ public static double[] rgbToHsv(int red, int green, int blue) { if (red < 0 || red > 255) { throw new IllegalArgumentException(\"red should be between 0 and 255\"); } if (green < 0 || green > 255) { throw new IllegalArgumentException(\"green should be between 0 and 255\"); } if (blue < 0 || blue > 255) { throw new IllegalArgumentException(\"blue should be between 0 and 255\"); } double dRed = (double) red / 255; double dGreen = (double) green / 255; double dBlue = (double) blue / 255; double value = Math.max(Math.max(dRed, dGreen), dBlue); double chroma = value - Math.min(Math.min(dRed, dGreen), dBlue); double saturation = value == 0 ? 0 : chroma / value; double hue; if (chroma == 0) { hue = 0; } else if (value == dRed) { hue = 60 * (0 + (dGreen - dBlue) / chroma); } else if (value == dGreen) { hue = 60 * (2 + (dBlue - dRed) / chroma); } else { hue = 60 * (4 + (dRed - dGreen) / chroma); } hue = (hue + 360) % 360; return new double[] {hue, saturation, value}; } private static boolean approximatelyEqualHsv(double[] hsv1, double[] hsv2) { boolean bHue = Math.abs(hsv1[0] - hsv2[0]) < 0.2; boolean bSaturation = Math.abs(hsv1[1] - hsv2[1]) < 0.002; boolean bValue = Math.abs(hsv1[2] - hsv2[2]) < 0.002; return bHue && bSaturation && bValue; } private static int[] getRgbBySection(double hueSection, double chroma, double matchValue, double secondLargestComponent) { int red; int green; int blue; if (hueSection >= 0 && hueSection <= 1) { red = convertToInt(chroma + matchValue); green = convertToInt(secondLargestComponent + matchValue); blue = convertToInt(matchValue); } else if (hueSection > 1 && hueSection <= 2) { red = convertToInt(secondLargestComponent + matchValue); green = convertToInt(chroma + matchValue); blue = convertToInt(matchValue); } else if (hueSection > 2 && hueSection <= 3) { red = convertToInt(matchValue); green = convertToInt(chroma + matchValue); blue = convertToInt(secondLargestComponent + matchValue); } else if (hueSection > 3 && hueSection <= 4) { red = convertToInt(matchValue); green = convertToInt(secondLargestComponent + matchValue); blue = convertToInt(chroma + matchValue); } else if (hueSection > 4 && hueSection <= 5) { red = convertToInt(secondLargestComponent + matchValue); green = convertToInt(matchValue); blue = convertToInt(chroma + matchValue); } else { red = convertToInt(chroma + matchValue); green = convertToInt(matchValue); blue = convertToInt(secondLargestComponent + matchValue); } return new int[] {red, green, blue}; } private static int convertToInt(double input) { return (int) Math.round(255 * input); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class RodCutting { private RodCutting() { } public static int cutRod(int[] nArray, int n) { if (nArray == null || nArray.length == 0) { throw new IllegalArgumentException(\"Price array cannot be null or empty.\"); } if (n < 0) { throw new IllegalArgumentException(\"Rod length cannot be negative.\"); } int[] nArray2 = new int[n + 1]; int[] nArray3 = nArray2; nArray2[0] = 0; for (int i = 1; i <= n; ++i) { int n2 = Integer.MIN_VALUE; for (int j = 1; j <= i; ++j) { n2 = Math.max(n2, nArray[j - 1] + nArray3[i - j]); } nArray3[i] = n2; } return nArray3[n]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * A Dynamic Programming solution for the Rod cutting problem. * Returns the best obtainable price for a rod of length n and price[] as prices of different pieces. */ public final class RodCutting { private RodCutting() { } /** * This method calculates the maximum obtainable value for cutting a rod of length n * into different pieces, given the prices for each possible piece length. * * @param price An array representing the prices of different pieces, where price[i-1] * represents the price of a piece of length i. * @param n The length of the rod to be cut. * @throws IllegalArgumentException if the price array is null or empty, or if n is less than 0. * @return The maximum obtainable value. */ public static int cutRod(int[] price, int n) { if (price == null || price.length == 0) { throw new IllegalArgumentException(\"Price array cannot be null or empty.\"); } if (n < 0) { throw new IllegalArgumentException(\"Rod length cannot be negative.\"); } // Create an array to store the maximum obtainable values for each rod length. int[] val = new int[n + 1]; val[0] = 0; // Calculate the maximum value for each rod length from 1 to n. for (int i = 1; i <= n; i++) { int maxVal = Integer.MIN_VALUE; // Try all possible ways to cut the rod and find the maximum value. for (int j = 1; j <= i; j++) { maxVal = Math.max(maxVal, price[j - 1] + val[i - j]); } // Store the maximum value for the current rod length. val[i] = maxVal; } // The final element of 'val' contains the maximum obtainable value for a rod of length 'n'. return val[n]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class RomanNumeralUtil { private static final String[] a = new String[]{\"\", \"M\", \"MM\", \"MMM\", \"MMMM\", \"MMMMM\"}; private static final String[] b = new String[]{\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}; private static final String[] c = new String[]{\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}; private static final String[] d = new String[]{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}; private RomanNumeralUtil() { } public static String generate(int n) { if (n <= 0 || n > 5999) { throw new IllegalArgumentException(String.format(\"The number must be in the range [%d, %d]\", 1, 5999)); } return a[n / 1000] + b[n % 1000 / 100] + c[n % 100 / 10] + d[n % 10]; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * Translates numbers into the Roman Numeral System. * * @see <a href=\"https://en.wikipedia.org/wiki/Roman_numerals\">Roman * numerals</a> * @author Sokratis Fotkatzikis * @version 1.0 */ public final class RomanNumeralUtil { private RomanNumeralUtil() { } private static final int MIN_VALUE = 1; private static final int MAX_VALUE = 5999; // 1000-5999 private static final String[] RN_M = { \"\", \"M\", \"MM\", \"MMM\", \"MMMM\", \"MMMMM\", }; // 100-900 private static final String[] RN_C = { \"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", }; // 10-90 private static final String[] RN_X = { \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", }; // 1-9 private static final String[] RN_I = { \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", }; public static String generate(int number) { if (number < MIN_VALUE || number > MAX_VALUE) { throw new IllegalArgumentException(String.format(\"The number must be in the range [%d, %d]\", MIN_VALUE, MAX_VALUE)); } return (RN_M[number / 1000] + RN_C[number % 1000 / 100] + RN_X[number % 100 / 10] + RN_I[number % 10]); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.util.HashMap; class RomanToInteger$1 extends HashMap { RomanToInteger$1() { this.put(Character.valueOf('I'), 1); this.put(Character.valueOf('V'), 5); this.put(Character.valueOf('X'), 10); this.put(Character.valueOf('L'), 50); this.put(Character.valueOf('C'), 100); this.put(Character.valueOf('D'), 500); this.put(Character.valueOf('M'), 1000); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.util.HashMap; class RomanToInteger$1 extends HashMap { RomanToInteger$1() { this.put(Character.valueOf('I'), 1); this.put(Character.valueOf('V'), 5); this.put(Character.valueOf('X'), 10); this.put(Character.valueOf('L'), 50); this.put(Character.valueOf('C'), 100); this.put(Character.valueOf('D'), 500); this.put(Character.valueOf('M'), 1000); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import com.thealgorithms.conversions.RomanToInteger$1; public final class RomanToInteger { private static final RomanToInteger$1 a = new RomanToInteger$1(); private RomanToInteger() { } public static int romanToInt(String string) { if (string == null) { throw new NullPointerException(\"Input cannot be null\"); } string = string.toUpperCase(); int n = 0; int n2 = 0; for (int i = string.length() - 1; i >= 0; --i) { int n3 = string.charAt(i); if ((n3 = a.computeIfAbsent(Character.valueOf((char)n3), c -> { throw new IllegalArgumentException(\"Unknown Roman symbol: \" + c); }).intValue()) >= n2) { n += n3; n2 = n3; continue; } n -= n3; } return n; } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.util.HashMap; import java.util.Map; /** * A utility class to convert Roman numerals into integers. * * <p>Roman numerals are based on seven symbols given below: * <ul> * <li>I = 1</li> * <li>V = 5</li> * <li>X = 10</li> * <li>L = 50</li> * <li>C = 100</li> * <li>D = 500</li> * <li>M = 1000</li> * </ul> * * <p>If a smaller numeral appears before a larger numeral, it is subtracted. * Otherwise, it is added. For example: * <pre> * MCMXCIV = 1000 + (1000 - 100) + (100 - 10) + (5 - 1) = 1994 * </pre> */ public final class RomanToInteger { private static final Map<Character, Integer> ROMAN_TO_INT = new HashMap<>() { { put('I', 1); put('V', 5); put('X', 10); put('L', 50); put('C', 100); put('D', 500); put('M', 1000); } }; private RomanToInteger() { } /** * Converts a single Roman numeral character to its integer value. * * @param symbol the Roman numeral character * @return the corresponding integer value * @throws IllegalArgumentException if the symbol is not a valid Roman numeral */ private static int romanSymbolToInt(final char symbol) { return ROMAN_TO_INT.computeIfAbsent(symbol, c -> { throw new IllegalArgumentException(\"Unknown Roman symbol: \" + c); }); } /** * Converts a Roman numeral string to its integer equivalent. * Steps: * <ol> * <li>Iterate over the string from right to left.</li> * <li>For each character, convert it to an integer value.</li> * <li>If the current value is greater than or equal to the max previous value, add it.</li> * <li>Otherwise, subtract it from the sum.</li> * <li>Update the max previous value.</li> * <li>Return the sum.</li> * </ol> * * @param roman the Roman numeral string * @return the integer value of the Roman numeral * @throws IllegalArgumentException if the input contains invalid Roman characters * @throws NullPointerException if the input is {@code null} */ public static int romanToInt(String roman) { if (roman == null) { throw new NullPointerException(\"Input cannot be null\"); } roman = roman.toUpperCase(); int sum = 0; int maxPrevValue = 0; for (int i = roman.length() - 1; i >= 0; i--) { int currentValue = romanSymbolToInt(roman.charAt(i)); if (currentValue >= maxPrevValue) { sum += currentValue; maxPrevValue = currentValue; } else { sum -= currentValue; } } return sum; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix; final class Rotate { private Rotate() { } static void a(int[][] nArray) { int n; int n2; int n3; int n4 = nArray.length; for (n3 = 0; n3 < n4; ++n3) { for (n2 = 0; n2 < n4; ++n2) { if (n3 <= n2) continue; n = nArray[n3][n2]; nArray[n3][n2] = nArray[n2][n3]; nArray[n2][n3] = n; } } n3 = 0; for (n2 = n4 - 1; n3 < n2; ++n3, --n2) { for (n = 0; n < n4; ++n) { int n5 = nArray[n3][n]; nArray[n3][n] = nArray[n2][n]; nArray[n2][n] = n5; } } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix; final class Rotate { private Rotate() { } static void a(int[][] nArray) { int n; int n2; int n3; int n4 = nArray.length; for (n3 = 0; n3 < n4; ++n3) { for (n2 = 0; n2 < n4; ++n2) { if (n3 <= n2) continue; n = nArray[n3][n2]; nArray[n3][n2] = nArray[n2][n3]; nArray[n2][n3] = n; } } n3 = 0; for (n2 = n4 - 1; n3 < n2; ++n3, --n2) { for (n = 0; n < n4; ++n) { int n5 = nArray[n3][n]; nArray[n3][n] = nArray[n2][n]; nArray[n2][n] = n5; } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix; import com.thealgorithms.matrix.Rotate; import java.util.Scanner; final class RotateMatrixBy90Degrees { private RotateMatrixBy90Degrees() { } public static void main(String[] object) { object = new Scanner(System.in); int n = ((Scanner)object).nextInt(); while (n-- > 0) { int n2; int n3 = ((Scanner)object).nextInt(); int[][] nArray = new int[n3][n3]; for (n2 = 0; n2 < n3; ++n2) { for (int i = 0; i < n3; ++i) { nArray[n2][i] = ((Scanner)object).nextInt(); } } Rotate.a(nArray); int[][] nArray2 = nArray; for (int i = 0; i < nArray2.length; ++i) { for (n2 = 0; n2 < nArray2[0].length; ++n2) { System.out.print(nArray2[i][n2] + \" \"); } System.out.println(\"\"); } } ((Scanner)object).close(); } }", "deobfuscated_code": "package com.thealgorithms.matrix; import java.util.Scanner; /** * Given a matrix of size n x n We have to rotate this matrix by 90 Degree Here * is the algorithm for this problem . */ final class RotateMatrixBy90Degrees { private RotateMatrixBy90Degrees() { } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int t = sc.nextInt(); while (t-- > 0) { int n = sc.nextInt(); int[][] arr = new int[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { arr[i][j] = sc.nextInt(); } } Rotate.rotate(arr); printMatrix(arr); } sc.close(); } static void printMatrix(int[][] arr) { for (int i = 0; i < arr.length; i++) { for (int j = 0; j < arr[0].length; j++) { System.out.print(arr[i][j] + \" \"); } System.out.println(\"\"); } } } /** * Class containing the algo to roate matrix by 90 degree */ final class Rotate { private Rotate() { } static void rotate(int[][] a) { int n = a.length; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (i > j) { int temp = a[i][j]; a[i][j] = a[j][i]; a[j][i] = temp; } } } int i = 0; int k = n - 1; while (i < k) { for (int j = 0; j < n; j++) { int temp = a[i][j]; a[i][j] = a[k][j]; a[k][j] = temp; } i++; k--; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SinglyLinkedListNode; public class RotateSinglyLinkedLists { public SinglyLinkedListNode rotateRight(SinglyLinkedListNode singlyLinkedListNode, int n) { if (singlyLinkedListNode == null || singlyLinkedListNode.b == null || n == 0) { return singlyLinkedListNode; } SinglyLinkedListNode singlyLinkedListNode2 = singlyLinkedListNode; int n2 = 1; while (singlyLinkedListNode2.b != null) { singlyLinkedListNode2 = singlyLinkedListNode2.b; ++n2; } singlyLinkedListNode2.b = singlyLinkedListNode; n %= n2; for (n = n2 - n; n > 0; --n) { singlyLinkedListNode2 = singlyLinkedListNode2.b; } singlyLinkedListNode = singlyLinkedListNode2.b; singlyLinkedListNode2.b = null; return singlyLinkedListNode; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; /** * The RotateSinglyLinkedLists class provides a method to rotate a singly linked list * to the right by a specified number of positions. * <p> * In a right rotation by `k` steps, each node in the list moves `k` positions to the right. * Nodes that are rotated off the end of the list are placed back at the beginning. * </p> * <p> * Example: * Given linked list: 1 -> 2 -> 3 -> 4 -> 5 and k = 2, the output will be: * 4 -> 5 -> 1 -> 2 -> 3. * </p> * <p> * Edge Cases: * <ul> * <li>If the list is empty, returns null.</li> * <li>If `k` is 0 or a multiple of the list length, the list remains unchanged.</li> * </ul> * </p> * <p> * Complexity: * <ul> * <li>Time Complexity: O(n), where n is the number of nodes in the linked list.</li> * <li>Space Complexity: O(1), as we only use a constant amount of additional space.</li> * </ul> * </p> * * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi) */ public class RotateSinglyLinkedLists { /** * Rotates a singly linked list to the right by `k` positions. * * @param head The head node of the singly linked list. * @param k The number of positions to rotate the list to the right. * @return The head of the rotated linked list. */ public SinglyLinkedListNode rotateRight(SinglyLinkedListNode head, int k) { if (head == null || head.next == null || k == 0) { return head; } SinglyLinkedListNode curr = head; int len = 1; while (curr.next != null) { curr = curr.next; len++; } curr.next = head; k = k % len; k = len - k; while (k > 0) { curr = curr.next; k--; } head = curr.next; curr.next = null; return head; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class Rotation { private Rotation() { } public static void main(String[] objectArray) { assert (Rotation.rotation(\"abcdef\", 2).equals(\"cdefab\")); char[] cArray = \"abcdef\".toCharArray(); objectArray = cArray; Rotation.rotation(cArray, 2); assert (new String((char[])objectArray).equals(\"cdefab\")); } public static String rotation(String string, int n) { return string.substring(n) + string.substring(0, n); } public static void rotation(char[] cArray, int n) { Rotation.reverse(cArray, 0, n - 1); Rotation.reverse(cArray, n, cArray.length - 1); Rotation.reverse(cArray, 0, cArray.length - 1); } public static void reverse(char[] cArray, int n, int n2) { while (n < n2) { char c = cArray[n]; cArray[n] = cArray[n2]; cArray[n2] = c; ++n; --n2; } } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * Given a string, moving several characters in front of the string to the end * of the string. For example, move the two characters'a' and 'b' in front of * the string \"abcdef\" to the end of the string, so that the original string * becomes the string \"cdefab\" */ public final class Rotation { private Rotation() { } public static void main(String[] args) { assert rotation(\"abcdef\", 2).equals(\"cdefab\"); char[] values = \"abcdef\".toCharArray(); rotation(values, 2); assert new String(values).equals(\"cdefab\"); } /** * Move {@code n} characters in front of given string to the end of string * time complexity: O(n) space complexity: O(n) * * @param s given string * @param n the total characters to be moved * @return string after rotation */ public static String rotation(String s, int n) { return s.substring(n) + s.substring(0, n); } /** * Move {@code n} characters in front of given character array to the end of * array time complexity: O(n) space complexity: O(1) * * @param values given character array * @param n the total characters to be moved */ public static void rotation(char[] values, int n) { reverse(values, 0, n - 1); reverse(values, n, values.length - 1); reverse(values, 0, values.length - 1); } /** * Reverse character array * * @param values character array * @param from begin index of given array * @param to end index of given array */ public static void reverse(char[] values, int from, int to) { while (from < to) { char temp = values[from]; values[from] = values[to]; values[to] = temp; from++; to--; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.MatrixSearchAlgorithm; public class RowColumnWiseSorted2dArrayBinarySearch implements MatrixSearchAlgorithm { @Override public int[] find(Comparable[][] comparableArray, Comparable comparable) { return RowColumnWiseSorted2dArrayBinarySearch.search(comparableArray, comparable); } public static int[] search(Comparable[][] comparableArray, Comparable comparable) { int n = 0; int n2 = comparableArray[0].length - 1; while (n < comparableArray.length && n2 >= 0) { int n3 = comparable.compareTo(comparableArray[n][n2]); if (n3 == 0) { return new int[]{n, n2}; } if (n3 > 0) { ++n; continue; } --n2; } return new int[]{-1, -1}; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.MatrixSearchAlgorithm; /** * The search is for any array which is sorted row and column-wise too. For ex : * {{10, 20, 30, 40}, * {15, 25, 35, 45}, * {18, 28, 38, 48}, * {21, 31, 41, 51}} * * This array is sorted in both row and column manner. * In this two pointers are taken, the first points to the 0th row and the second one points to end * column, and then the element corresponding to the pointers placed in the array is compared with * the target that either its equal, greater or smaller than the target. If the element is equal to * the target, the co-ordinates of that element is returned i.e. an array of the two pointers will * be returned, else if the target is greater than corresponding element then the pointer pointing * to the 0th row will be incremented by 1, else if the target is lesser than the corresponding * element then the pointer pointing to the end column will be decremented by 1. And if the element * doesn't exist in the array, an array * {-1, -1} will be returned. */ public class RowColumnWiseSorted2dArrayBinarySearch implements MatrixSearchAlgorithm { @Override public <T extends Comparable<T>> int[] find(T[][] matrix, T key) { return search(matrix, key); } public static <T extends Comparable<T>> int[] search(T[][] matrix, T target) { int rowPointer = 0; // The pointer at 0th row int colPointer = matrix[0].length - 1; // The pointer at end column while (rowPointer < matrix.length && colPointer >= 0) { int comp = target.compareTo(matrix[rowPointer][colPointer]); if (comp == 0) { return new int[] {rowPointer, colPointer}; } else if (comp > 0) { rowPointer++; // Incrementing the row pointer if the target is greater } else { colPointer--; // Decrementing the column pointer if the target is lesser } } return new int[] {-1, -1}; // The not found condition } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.devutils.entities.ProcessDetails; import java.util.ArrayList; import java.util.Comparator; import java.util.Iterator; import java.util.List; public class SJFScheduling { private final List a; private final List b; public SJFScheduling(List list) { this.a = new ArrayList(list); this.b = new ArrayList(); list = this.a; list.sort(Comparator.comparingInt(ProcessDetails::getArrivalTime)); } public void scheduleProcesses() { ArrayList<ProcessDetails> arrayList = new ArrayList<ProcessDetails>(); int n = this.a.size(); int n2 = 0; int n3 = 0; Iterator iterator = this.a.iterator(); ProcessDetails processDetails = null; if (iterator.hasNext()) { processDetails = (ProcessDetails)iterator.next(); } while (n3 < n) { while (processDetails != null && processDetails.getArrivalTime() <= n2) { arrayList.add(processDetails); if (iterator.hasNext()) { processDetails = (ProcessDetails)iterator.next(); continue; } processDetails = null; } Object object = arrayList; if ((object = (ProcessDetails)object.stream().min(Comparator.comparingInt(ProcessDetails::getBurstTime)).orElse(null)) == null) { ++n2; continue; } n2 += ((ProcessDetails)object).getBurstTime(); this.b.add(((ProcessDetails)object).getProcessId()); arrayList.remove(object); ++n3; } } public List getSchedule() { return this.b; } public List getProcesses() { return List.copyOf(this.a); } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import com.thealgorithms.devutils.entities.ProcessDetails; import java.util.ArrayList; import java.util.Collection; import java.util.Comparator; import java.util.Iterator; import java.util.List; /** * Shortest Job First (SJF) Scheduling Algorithm: * Executes processes with the shortest burst time first among the ones that have arrived. */ public class SJFScheduling { private final List<ProcessDetails> processes; private final List<String> schedule; public SJFScheduling(final List<ProcessDetails> processes) { this.processes = new ArrayList<>(processes); this.schedule = new ArrayList<>(); sortProcessesByArrivalTime(this.processes); } private static void sortProcessesByArrivalTime(List<ProcessDetails> processes) { processes.sort(Comparator.comparingInt(ProcessDetails::getArrivalTime)); } /** * Executes the SJF scheduling algorithm and builds the execution order. */ public void scheduleProcesses() { List<ProcessDetails> ready = new ArrayList<>(); int size = processes.size(); int time = 0; int executed = 0; Iterator<ProcessDetails> processIterator = processes.iterator(); // This will track the next process to be checked for arrival time ProcessDetails nextProcess = null; if (processIterator.hasNext()) { nextProcess = processIterator.next(); } while (executed < size) { // Load all processes that have arrived by current time while (nextProcess != null && nextProcess.getArrivalTime() <= time) { ready.add(nextProcess); if (processIterator.hasNext()) { nextProcess = processIterator.next(); } else { nextProcess = null; } } ProcessDetails running = findShortestJob(ready); if (running == null) { time++; } else { time += running.getBurstTime(); schedule.add(running.getProcessId()); ready.remove(running); executed++; } } } /** * Finds the process with the shortest job of all the ready processes (based on a process * @param readyProcesses an array list of ready processes * @return returns the process' with the shortest burst time OR NULL if there are no ready * processes */ private ProcessDetails findShortestJob(Collection<ProcessDetails> readyProcesses) { return readyProcesses.stream().min(Comparator.comparingInt(ProcessDetails::getBurstTime)).orElse(null); } /** * Returns the computed schedule after calling scheduleProcesses(). */ public List<String> getSchedule() { return schedule; } public List<ProcessDetails> getProcesses() { return List.copyOf(processes); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.devutils.entities.ProcessDetails; import java.util.ArrayList; import java.util.List; public class SRTFScheduling { private List a = new ArrayList(); private List b = new ArrayList(); public SRTFScheduling(ArrayList arrayList) { this.a = arrayList; } public void evaluateScheduling() { int n; int n2 = 0; int n3 = 0; int n4 = this.a.size(); int[] nArray = new int[n4]; for (n = 0; n < n4; ++n) { nArray[n] = ((ProcessDetails)this.a.get(n)).getBurstTime(); n2 += ((ProcessDetails)this.a.get(n)).getBurstTime(); } if (((ProcessDetails)this.a.get(0)).getArrivalTime() != 0) { n2 += ((ProcessDetails)this.a.get(0)).getArrivalTime(); } if (((ProcessDetails)this.a.get(0)).getArrivalTime() != 0) { for (n = 0; n < ((ProcessDetails)this.a.get(0)).getArrivalTime(); ++n) { this.b.add(null); } } for (n = ((ProcessDetails)this.a.get(0)).getArrivalTime(); n < n2; ++n) { for (int i = 0; i < n4; ++i) { if (((ProcessDetails)this.a.get(i)).getArrivalTime() > n || (nArray[i] >= nArray[n3] || nArray[i] <= 0) && nArray[n3] != 0) continue; n3 = i; } this.b.add(((ProcessDetails)this.a.get(n3)).getProcessId()); int n5 = n3; nArray[n5] = nArray[n5] - 1; } } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import com.thealgorithms.devutils.entities.ProcessDetails; import java.util.ArrayList; import java.util.List; /** * Implementation of Shortest Remaining Time First Scheduling Algorithm. * In the SRTF scheduling algorithm, the process with the smallest amount of time remaining until completion is selected to execute. * Example: * Consider the processes p1, p2 and the following table with info about their arrival and burst time: * Process | Burst Time | Arrival Time * P1 | 6 ms | 0 ms * P2 | 2 ms | 1 ms * In this example, P1 will be executed at time = 0 until time = 1 when P2 arrives. At time = 2, P2 will be executed until time = 4. At time 4, P2 is done, and P1 is executed again to be done. * That's a simple example of how the algorithm works. * More information you can find here -> https://en.wikipedia.org/wiki/Shortest_remaining_time */ public class SRTFScheduling { protected List<ProcessDetails> processes; protected List<String> ready; /** * Constructor * @param processes ArrayList of ProcessDetails given as input */ public SRTFScheduling(ArrayList<ProcessDetails> processes) { this.processes = new ArrayList<>(); ready = new ArrayList<>(); this.processes = processes; } public void evaluateScheduling() { int time = 0; int cr = 0; // cr=current running process, time= units of time int n = processes.size(); int[] remainingTime = new int[n]; /* calculating remaining time of every process and total units of time */ for (int i = 0; i < n; i++) { remainingTime[i] = processes.get(i).getBurstTime(); time += processes.get(i).getBurstTime(); } /* if the first process doesn't arrive at 0, we have more units of time */ if (processes.get(0).getArrivalTime() != 0) { time += processes.get(0).getArrivalTime(); } /* printing id of the process which is executed at every unit of time */ // if the first process doesn't arrive at 0, we print only \\n until it arrives if (processes.get(0).getArrivalTime() != 0) { for (int i = 0; i < processes.get(0).getArrivalTime(); i++) { ready.add(null); } } for (int i = processes.get(0).getArrivalTime(); i < time; i++) { /* checking if there's a process with remaining time less than current running process. If we find it, then it executes. */ for (int j = 0; j < n; j++) { if (processes.get(j).getArrivalTime() <= i && (remainingTime[j] < remainingTime[cr] && remainingTime[j] > 0 || remainingTime[cr] == 0)) { cr = j; } } ready.add(processes.get(cr).getProcessId()); remainingTime[cr]--; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling.diskscheduling; import java.util.ArrayList; import java.util.Collection; import java.util.List; public class SSFScheduling { private int a; public SSFScheduling(int n) { this.a = n; } public List execute(Collection arrayList) { arrayList = new ArrayList(arrayList); ArrayList<Integer> arrayList2 = new ArrayList<Integer>(); while (!arrayList.isEmpty()) { Object object = arrayList; SSFScheduling sSFScheduling = this; int n = Integer.MAX_VALUE; int n2 = -1; object = object.iterator(); while (object.hasNext()) { int n3 = (Integer)object.next(); int n4 = Math.abs(sSFScheduling.a - n3); if (n4 >= n) continue; n = n4; n2 = n3; } int n5 = n2; arrayList2.add(n5); arrayList.remove((Object)n5); this.a = n5; } return arrayList2; } public int getCurrentPosition() { return this.a; } }", "deobfuscated_code": "package com.thealgorithms.scheduling.diskscheduling; import java.util.ArrayList; import java.util.Collection; import java.util.List; /** *https://en.wikipedia.org/wiki/Shortest_seek_first * Shortest Seek First (SFF) Scheduling algorithm implementation. * The SFF algorithm selects the next request to be serviced based on the shortest distance * from the current position of the disk arm. It continuously evaluates all pending requests * and chooses the one that requires the least amount of movement to service. * * This approach minimizes the average seek time, making it efficient in terms of response * time for individual requests. However, it may lead to starvation for requests located * further away from the current position of the disk arm. * * The SFF algorithm is particularly effective in systems where quick response time * is crucial, as it ensures that the most accessible requests are prioritized for servicing. */ public class SSFScheduling { private int currentPosition; public SSFScheduling(int currentPosition) { this.currentPosition = currentPosition; } public List<Integer> execute(Collection<Integer> requests) { List<Integer> result = new ArrayList<>(requests); List<Integer> orderedRequests = new ArrayList<>(); while (!result.isEmpty()) { int closest = findClosest(result); orderedRequests.add(closest); result.remove(Integer.valueOf(closest)); currentPosition = closest; } return orderedRequests; } private int findClosest(List<Integer> requests) { int minDistance = Integer.MAX_VALUE; int closest = -1; for (int request : requests) { int distance = Math.abs(currentPosition - request); if (distance < minDistance) { minDistance = distance; closest = request; } } return closest; } public int getCurrentPosition() { return currentPosition; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; public final class SaddlebackSearch { private SaddlebackSearch() { } }", "deobfuscated_code": "package com.thealgorithms.searches; /** * Program to perform Saddleback Search Given a sorted 2D array(elements are * sorted across every row and column, assuming ascending order) of size n*m we * can search a given element in O(n+m) * * <p> * we start from bottom left corner if the current element is greater than the * given element then we move up else we move right Sample Input: 5 5 * ->Dimensions -10 -5 -3 4 9 -6 -2 0 5 10 -4 -1 1 6 12 2 3 7 8 13 100 120 130 * 140 150 140 ->element to be searched output: 4 3 // first value is row, * second one is column * * @author Nishita Aggarwal */ public final class SaddlebackSearch { private SaddlebackSearch() { } /** * This method performs Saddleback Search * * @param arr The **Sorted** array in which we will search the element. * @param row the current row. * @param col the current column. * @param key the element that we want to search for. * @throws IllegalArgumentException if the array is empty. * @return The index(row and column) of the element if found. Else returns * -1 -1. */ static int[] find(int[][] arr, int row, int col, int key) { if (arr.length == 0) { throw new IllegalArgumentException(\"Array is empty\"); } // array to store the answer row and column int[] ans = {-1, -1}; if (row < 0 || col >= arr[row].length) { return ans; } if (arr[row][col] == key) { ans[0] = row; ans[1] = col; return ans; } // if the current element is greater than the given element then we move up else if (arr[row][col] > key) { return find(arr, row - 1, col, key); } // else we move right return find(arr, row, col + 1, key); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.ArrayDeque; public final class SameTreesCheck { private SameTreesCheck() { } public static boolean check(BinaryTree$Node binaryTree$Node, BinaryTree$Node binaryTree$Node2) { if (binaryTree$Node == null && binaryTree$Node2 == null) { return true; } if (binaryTree$Node == null || binaryTree$Node2 == null) { return false; } ArrayDeque<BinaryTree$Node> arrayDeque = new ArrayDeque<BinaryTree$Node>(); ArrayDeque<BinaryTree$Node> arrayDeque2 = new ArrayDeque<BinaryTree$Node>(); arrayDeque.add(binaryTree$Node); arrayDeque2.add(binaryTree$Node2); while (!arrayDeque.isEmpty() && !arrayDeque2.isEmpty()) { binaryTree$Node = (BinaryTree$Node)arrayDeque.poll(); if (!SameTreesCheck.a(binaryTree$Node, binaryTree$Node2 = (BinaryTree$Node)arrayDeque2.poll())) { return false; } if (binaryTree$Node == null) continue; if (!SameTreesCheck.a(binaryTree$Node.left, binaryTree$Node2.left)) { return false; } if (binaryTree$Node.left != null) { arrayDeque.add(binaryTree$Node.left); arrayDeque2.add(binaryTree$Node2.left); } if (!SameTreesCheck.a(binaryTree$Node.right, binaryTree$Node2.right)) { return false; } if (binaryTree$Node.right == null) continue; arrayDeque.add(binaryTree$Node.right); arrayDeque2.add(binaryTree$Node2.right); } return true; } private static boolean a(BinaryTree$Node binaryTree$Node, BinaryTree$Node binaryTree$Node2) { if (binaryTree$Node == null && binaryTree$Node2 == null) { return true; } if (binaryTree$Node == null || binaryTree$Node2 == null) { return false; } return binaryTree$Node.data == binaryTree$Node2.data; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayDeque; import java.util.Deque; /** * Given 2 binary trees. * This code checks whether they are the same (structurally identical and have the same values) or * not. <p> Example: * 1. Binary trees: * 1 1 * / \\ / \\ * 2 3 2 3 * /\\ /\\ /\\ /\\ * 4 5 6 7 4 5 6 7 * These trees are the same, so the code returns 'true'. * <p> * 2. Binary trees: * 1 1 * / \\ * 2 2 * These trees are NOT the same (the structure differs), so the code returns 'false'. * <p> * This solution implements the breadth-first search (BFS) algorithm. * For each tree we create a queue and iterate the trees using these queues. * On each step we check the nodes for equality, and if the nodes are not the same, return false. * Otherwise, add children nodes to the queues and continue traversing the trees. * <p> * Complexities: * O(N) - time, where N is the number of nodes in a binary tree, * O(N) - space, where N is the number of nodes in a binary tree. * * @author Albina Gimaletdinova on 13/01/2023 */ public final class SameTreesCheck { private SameTreesCheck() { } public static boolean check(BinaryTree.Node p, BinaryTree.Node q) { if (p == null && q == null) { return true; } if (p == null || q == null) { return false; } Deque<BinaryTree.Node> q1 = new ArrayDeque<>(); Deque<BinaryTree.Node> q2 = new ArrayDeque<>(); q1.add(p); q2.add(q); while (!q1.isEmpty() && !q2.isEmpty()) { BinaryTree.Node first = q1.poll(); BinaryTree.Node second = q2.poll(); // check that some node can be null // if the check is true: both nodes are null or both nodes are not null if (!equalNodes(first, second)) { return false; } if (first != null) { if (!equalNodes(first.left, second.left)) { return false; } if (first.left != null) { q1.add(first.left); q2.add(second.left); } if (!equalNodes(first.right, second.right)) { return false; } if (first.right != null) { q1.add(first.right); q2.add(second.right); } } } return true; } private static boolean equalNodes(BinaryTree.Node p, BinaryTree.Node q) { if (p == null && q == null) { return true; } if (p == null || q == null) { return false; } return p.data == q.data; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling.diskscheduling; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class ScanScheduling { private int a; private int b; private boolean c; public ScanScheduling(int n, boolean bl, int n2) { this.a = n; this.c = bl; this.b = n2; } public List execute(List object) { if (object.isEmpty()) { return new ArrayList(); } ArrayList arrayList = new ArrayList(); ArrayList<Integer> arrayList2 = new ArrayList<Integer>(); ArrayList<Integer> arrayList3 = new ArrayList<Integer>(); object = object.iterator(); while (object.hasNext()) { int n = (Integer)object.next(); if (n < this.a) { arrayList2.add(n); continue; } arrayList3.add(n); } Collections.sort(arrayList2); Collections.sort(arrayList3); if (this.c) { arrayList.addAll(arrayList3); arrayList.add(this.b - 1); Collections.reverse(arrayList2); arrayList.addAll(arrayList2); } else { Collections.reverse(arrayList2); arrayList.addAll(arrayList2); arrayList.add(0); arrayList.addAll(arrayList3); } return arrayList; } public int getHeadPosition() { return this.a; } public boolean isMovingUp() { return this.c; } }", "deobfuscated_code": "package com.thealgorithms.scheduling.diskscheduling; import java.util.ArrayList; import java.util.Collections; import java.util.List; /** * https://en.wikipedia.org/wiki/Elevator_algorithm * SCAN Scheduling algorithm implementation. * The SCAN algorithm moves the disk arm towards one end of the disk, servicing all requests * along the way until it reaches the end. Once it reaches the end, it reverses direction * and services the requests on its way back. * * This algorithm ensures that all requests are serviced in a fair manner, * while minimizing the seek time for requests located close to the current position * of the disk arm. * * The SCAN algorithm is particularly useful in environments with a large number of * disk requests, as it reduces the overall movement of the disk arm compared to */ public class ScanScheduling { private int headPosition; private int diskSize; private boolean movingUp; public ScanScheduling(int headPosition, boolean movingUp, int diskSize) { this.headPosition = headPosition; this.movingUp = movingUp; this.diskSize = diskSize; } public List<Integer> execute(List<Integer> requests) { // If the request list is empty, return an empty result if (requests.isEmpty()) { return new ArrayList<>(); } List<Integer> result = new ArrayList<>(); List<Integer> left = new ArrayList<>(); List<Integer> right = new ArrayList<>(); // Separate requests into those smaller than the current head position and those larger for (int request : requests) { if (request < headPosition) { left.add(request); } else { right.add(request); } } // Sort the requests Collections.sort(left); Collections.sort(right); // Simulate the disk head movement if (movingUp) { // Head moving upward, process right-side requests first result.addAll(right); // After reaching the end of the disk, reverse direction and process left-side requests result.add(diskSize - 1); // Simulate the head reaching the end of the disk Collections.reverse(left); result.addAll(left); } else { // Head moving downward, process left-side requests first Collections.reverse(left); result.addAll(left); // After reaching the start of the disk, reverse direction and process right-side requests result.add(0); // Simulate the head reaching the start of the disk result.addAll(right); } return result; } public int getHeadPosition() { return headPosition; } public boolean isMovingUp() { return movingUp; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; abstract class SearchAlgorithm { SearchAlgorithm() { } public abstract int find(Comparable[] var1, Comparable var2); }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; abstract class SearchAlgorithm { SearchAlgorithm() { } public abstract int find(Comparable[] var1, Comparable var2); }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; public class SearchInARowAndColWiseSortedMatrix { public int[] search(int[][] nArray, int n) { int n2 = nArray.length; int n3 = 0; int n4 = n2 - 1; int[] nArray2 = new int[]{-1, -1}; while (n3 < n2 && n4 >= 0) { if (nArray[n3][n4] == n) { nArray2[0] = n3; nArray2[1] = n4; return nArray2; } if (n > nArray[n3][n4]) { ++n3; continue; } --n4; } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.searches; public class SearchInARowAndColWiseSortedMatrix { /** * Search a key in row and column wise sorted matrix * * @param matrix matrix to be searched * @param value Key being searched for * @author Sadiul Hakim : https://github.com/sadiul-hakim */ public int[] search(int[][] matrix, int value) { int n = matrix.length; // This variable iterates over rows int i = 0; // This variable iterates over columns int j = n - 1; int[] result = {-1, -1}; while (i < n && j >= 0) { if (matrix[i][j] == value) { result[0] = i; result[1] = j; return result; } if (value > matrix[i][j]) { i++; } else { j--; } } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import java.util.Objects; class SearchResult { private int b; double a; SearchResult(int n, double d) { this.b = n; this.a = d; } public int getDocId() { return this.b; } public String toString() { return \"SearchResult{docId=\" + this.b + \", relevanceScore=\" + this.a + \"}\"; } public boolean equals(Object object) { if (this == object) { return true; } if (object == null || this.getClass() != object.getClass()) { return false; } object = (SearchResult)object; return this.b == ((SearchResult)object).b && Double.compare(((SearchResult)object).a, this.a) == 0; } public int hashCode() { return Objects.hash(this.b, this.a); } public double getRelevanceScore() { return this.a; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import java.util.Objects; class SearchResult { private int b; double a; SearchResult(int n, double d) { this.b = n; this.a = d; } public int getDocId() { return this.b; } public String toString() { return \"SearchResult{docId=\" + this.b + \", relevanceScore=\" + this.a + \"}\"; } public boolean equals(Object object) { if (this == object) { return true; } if (object == null || this.getClass() != object.getClass()) { return false; } object = (SearchResult)object; return this.b == ((SearchResult)object).b && Double.compare(((SearchResult)object).a, this.a) == 0; } public int hashCode() { return Objects.hash(this.b, this.a); } public double getRelevanceScore() { return this.a; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SinglyLinkedList; import com.thealgorithms.datastructures.lists.SinglyLinkedListNode; public class SearchSinglyLinkedListRecursion extends SinglyLinkedList { private boolean a(SinglyLinkedListNode singlyLinkedListNode, int n) { return singlyLinkedListNode != null && (singlyLinkedListNode.a == n || this.a(singlyLinkedListNode.b, n)); } @Override public boolean search(int n) { SearchSinglyLinkedListRecursion searchSinglyLinkedListRecursion = this; return searchSinglyLinkedListRecursion.a(searchSinglyLinkedListRecursion.getHead(), n); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; /** * The SearchSinglyLinkedListRecursion class extends SinglyLinkedList and provides * a method to search for a value in a singly linked list using recursion. * <p> * This class demonstrates a recursive approach to check if a given integer value is * present in the linked list. The search method calls a private recursive helper method * `searchRecursion`, which checks each node's value and moves to the next node if necessary. * </p> * <p> * Example: * Given a list containing the values 1 -> 2 -> 3 -> 4, calling search(3) will return `true`, * while calling search(5) will return `false`. * </p> * <p> * Complexity: * <ul> * <li>Time Complexity: O(n), where n is the number of nodes in the linked list.</li> * <li>Space Complexity: O(n), due to the recursive call stack in the worst case.</li> * </ul> * </p> */ public class SearchSinglyLinkedListRecursion extends SinglyLinkedList { /** * Recursively searches for a given value in the linked list. * * @param node the head node to start the search. * @param key the integer value to be searched for. * @return {@code true} if the value `key` is present in the list; otherwise, {@code false}. */ private boolean searchRecursion(SinglyLinkedListNode node, int key) { return (node != null && (node.value == key || searchRecursion(node.next, key))); } /** * Public search method to determine if a key is present in the linked list. * * @param key the integer value to be searched for. * @return {@code true} if the value `key` is present in the list; otherwise, {@code false}. */ @Override public boolean search(int key) { return searchRecursion(getHead(), key); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; class Searcher extends Thread { private final int a; private final int b; private boolean c; @Override public void run() { this.c = false; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; class Searcher extends Thread { private final int a; private final int b; private boolean c; @Override public void run() { this.c = false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.function.BiPredicate; public final class SecondMinMax { private SecondMinMax() { } private static int a(int[] nArray, int n, BiPredicate biPredicate) { int[] nArray2 = nArray; if (nArray.length < 2) { throw new IllegalArgumentException(\"Input array must have length of at least two\"); } int n2 = n; int n3 = n; for (int n4 : nArray) { if (biPredicate.test(n4, n2)) { n3 = n2; n2 = n4; continue; } if (!biPredicate.test(n4, n3) || n4 == n2) continue; n3 = n4; } n2 = n3; int n5 = n; if (n2 == n5) { throw new IllegalArgumentException(\"Input array should have at least 2 distinct elements\"); } return n3; } public static int findSecondMin(int[] nArray) { return SecondMinMax.a(nArray, Integer.MAX_VALUE, (n, n2) -> n < n2); } public static int findSecondMax(int[] nArray) { return SecondMinMax.a(nArray, Integer.MIN_VALUE, (n, n2) -> n > n2); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.function.BiPredicate; public final class SecondMinMax { /** * Utility class for finding second maximum or minimum based on BiPredicate * @exception IllegalArgumentException => if input array is of length less than 2 also if all elements are same * @return the second minimum / maximum value from the input array * @author Bharath Sanjeevi ( https://github.com/BharathSanjeeviT ) */ private SecondMinMax() { } private static int secondBest(final int[] arr, final int initialVal, final BiPredicate<Integer, Integer> isBetter) { checkInput(arr); int best = initialVal; int secBest = initialVal; for (final int num : arr) { if (isBetter.test(num, best)) { secBest = best; best = num; } else if ((isBetter.test(num, secBest)) && (num != best)) { secBest = num; } } checkOutput(secBest, initialVal); return secBest; } /** * @brief Finds the Second minimum / maximum value from the array * @param arr the input array * @exception IllegalArgumentException => if input array is of length less than 2 also if all elements are same * @return the second minimum / maximum value from the input array * @author Bharath Sanjeevi ( https://github.com/BharathSanjeeviT ) */ public static int findSecondMin(final int[] arr) { return secondBest(arr, Integer.MAX_VALUE, (a, b) -> a < b); } public static int findSecondMax(final int[] arr) { return secondBest(arr, Integer.MIN_VALUE, (a, b) -> a > b); } private static void checkInput(final int[] arr) { if (arr.length < 2) { throw new IllegalArgumentException(\"Input array must have length of at least two\"); } } private static void checkOutput(final int secNum, final int initialVal) { if (secNum == initialVal) { throw new IllegalArgumentException(\"Input array should have at least 2 distinct elements\"); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; public class SegmentTree { private int[] a; private int b; private int[] c; public SegmentTree(int n, int[] nArray) { this.b = n; int n2 = (int)Math.ceil(Math.log(n) / Math.log(2.0)); n2 = 2 * (int)Math.pow(2.0, n2) - 1; this.a = new int[n2]; this.c = nArray; this.b = n; this.constructTree(nArray, 0, n - 1, 0); } public final int constructTree(int[] nArray, int n, int n2, int n3) { if (n == n2) { this.a[n3] = nArray[n]; return nArray[n]; } int n4 = n + (n2 - n) / 2; this.a[n3] = this.constructTree(nArray, n, n4, (n3 << 1) + 1) + this.constructTree(nArray, n4 + 1, n2, (n3 << 1) + 2); return this.a[n3]; } private void a(int n, int n2, int n3, int n4, int n5) { while (true) { if (n3 < n || n3 > n2) { return; } int n6 = n5; this.a[n6] = this.a[n6] + n4; if (n == n2) break; int n7 = n + (n2 - n) / 2; this.a(n, n7, n3, n4, (n5 << 1) + 1); n5 = (n5 << 1) + 2; n = n7 + 1; } } public void update(int n, int n2) { if (n < 0 || n > this.b) { return; } int n3 = n2 - this.c[n]; this.c[n] = n2; this.a(0, this.b - 1, n, n3, 0); } private int b(int n, int n2, int n3, int n4, int n5) { if (n3 <= n && n4 >= n2) { return this.a[n5]; } if (n3 > n2 || n4 < n) { return 0; } int n6 = n + (n2 - n) / 2; return this.b(n, n6, n3, n4, (n5 << 1) + 1) + this.b(n6 + 1, n2, n3, n4, (n5 << 1) + 2); } public int getSum(int n, int n2) { if (n < 0 || n2 > this.b || n > n2) { return 0; } return this.b(0, this.b - 1, n, n2, 0); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; public class SegmentTree { private int[] segTree; private int n; private int[] arr; /* Constructor which takes the size of the array and the array as a parameter*/ public SegmentTree(int n, int[] arr) { this.n = n; int x = (int) (Math.ceil(Math.log(n) / Math.log(2))); int segSize = 2 * (int) Math.pow(2, x) - 1; this.segTree = new int[segSize]; this.arr = arr; this.n = n; constructTree(arr, 0, n - 1, 0); } /* A function which will create the segment tree*/ public final int constructTree(int[] arr, int start, int end, int index) { if (start == end) { this.segTree[index] = arr[start]; return arr[start]; } int mid = start + (end - start) / 2; this.segTree[index] = constructTree(arr, start, mid, index * 2 + 1) + constructTree(arr, mid + 1, end, index * 2 + 2); return this.segTree[index]; } /* A function which will update the value at a index i. This will be called by the update function internally*/ private void updateTree(int start, int end, int index, int diff, int segIndex) { if (index < start || index > end) { return; } this.segTree[segIndex] += diff; if (start != end) { int mid = start + (end - start) / 2; updateTree(start, mid, index, diff, segIndex * 2 + 1); updateTree(mid + 1, end, index, diff, segIndex * 2 + 2); } } /* A function to update the value at a particular index*/ public void update(int index, int value) { if (index < 0 || index > n) { return; } int diff = value - arr[index]; arr[index] = value; updateTree(0, n - 1, index, diff, 0); } /* A function to get the sum of the elements from index l to index r. This will be called * internally*/ private int getSumTree(int start, int end, int qStart, int qEnd, int segIndex) { if (qStart <= start && qEnd >= end) { return this.segTree[segIndex]; } if (qStart > end || qEnd < start) { return 0; } int mid = start + (end - start) / 2; return (getSumTree(start, mid, qStart, qEnd, segIndex * 2 + 1) + getSumTree(mid + 1, end, qStart, qEnd, segIndex * 2 + 2)); } /* A function to query the sum of the subarray [start...end]*/ public int getSum(int start, int end) { if (start < 0 || end > n || start > end) { return 0; } return getSumTree(0, n - 1, start, end, 0); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class SelectionSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { for (int i = 0; i < comparableArray.length - 1; ++i) { int n = i; Comparable[] comparableArray2 = comparableArray; int n2 = n++; while (n < comparableArray2.length) { if (SortUtils.less(comparableArray2[n], comparableArray2[n2])) { n2 = n; } ++n; } int n3 = n2; SortUtils.swap(comparableArray, i, n3); } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; public class SelectionSort implements SortAlgorithm { /** * Sorts an array of comparable elements in increasing order using the selection sort algorithm. * * @param array the array to be sorted * @param <T> the class of array elements * @return the sorted array */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { for (int i = 0; i < array.length - 1; i++) { final int minIndex = findIndexOfMin(array, i); SortUtils.swap(array, i, minIndex); } return array; } private static <T extends Comparable<T>> int findIndexOfMin(T[] array, final int startIndex) { int minIndex = startIndex; for (int i = startIndex + 1; i < array.length; i++) { if (SortUtils.less(array[i], array[minIndex])) { minIndex = i; } } return minIndex; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class SelectionSortRecursive implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length == 0) { return comparableArray; } SelectionSortRecursive.a(comparableArray, 0); return comparableArray; } private static void a(Comparable[] comparableArray, int n) { while (n != comparableArray.length - 1) { SortUtils.swap(comparableArray, n, SelectionSortRecursive.b(comparableArray, n)); ++n; } return; } private static int b(Comparable[] comparableArray, int n) { if (n == comparableArray.length - 1) { return n; } int n2 = SelectionSortRecursive.b(comparableArray, n + 1); if (SortUtils.less(comparableArray[n], comparableArray[n2])) { return n; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * Class that implements the Selection Sort algorithm using recursion. */ public class SelectionSortRecursive implements SortAlgorithm { /** * Sorts an array using recursive selection sort. * * @param array the array to be sorted * @param <T> the type of elements in the array (must be Comparable) * @return the sorted array */ public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length == 0) { return array; } recursiveSelectionSort(array, 0); return array; } /** * Recursively sorts the array using selection sort. * * @param array the array to be sorted * @param index the current index to start sorting from * @param <T> the type of elements in the array (must be Comparable) */ private static <T extends Comparable<T>> void recursiveSelectionSort(T[] array, final int index) { if (index == array.length - 1) { return; } SortUtils.swap(array, index, findMinIndex(array, index)); // Recursively call selection sort for the remaining array recursiveSelectionSort(array, index + 1); } /** * Finds the index of the minimum element in the array starting from the given index. * * @param array the array to search * @param start the starting index for the search * @param <T> the type of elements in the array * @return the index of the minimum element */ private static <T extends Comparable<T>> int findMinIndex(T[] array, final int start) { // Base case: if start is the last index, return start if (start == array.length - 1) { return start; } // Recursive call to find the minimum index in the rest of the array final int minIndexInRest = findMinIndex(array, start + 1); // Return the index of the smaller element between array[start] and the minimum element in the rest of the array return SortUtils.less(array[start], array[minIndexInRest]) ? start : minIndexInRest; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class SelfAdjustingScheduling$Task implements Comparable { String a; int b; int c; SelfAdjustingScheduling$Task(String string, int n) { this.a = string; this.b = 0; this.c = n; } public int compareTo(SelfAdjustingScheduling$Task selfAdjustingScheduling$Task) { return Integer.compare(this.c, selfAdjustingScheduling$Task.c); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class SelfAdjustingScheduling$Task implements Comparable { String a; int b; int c; SelfAdjustingScheduling$Task(String string, int n) { this.a = string; this.b = 0; this.c = n; } public int compareTo(SelfAdjustingScheduling$Task selfAdjustingScheduling$Task) { return Integer.compare(this.c, selfAdjustingScheduling$Task.c); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.SelfAdjustingScheduling$Task; import java.util.PriorityQueue; public final class SelfAdjustingScheduling { private final PriorityQueue a = new PriorityQueue(); public final void addTask(String string, int n) { this.a.offer(new SelfAdjustingScheduling$Task(string, n)); } public final String scheduleNext() { SelfAdjustingScheduling$Task selfAdjustingScheduling$Task; if (this.a.isEmpty()) { return null; } SelfAdjustingScheduling$Task selfAdjustingScheduling$Task2 = selfAdjustingScheduling$Task = (SelfAdjustingScheduling$Task)this.a.poll(); ++selfAdjustingScheduling$Task.b; selfAdjustingScheduling$Task2.c += selfAdjustingScheduling$Task2.b; this.a.offer(selfAdjustingScheduling$Task); return selfAdjustingScheduling$Task.a; } public final boolean isEmpty() { return this.a.isEmpty(); } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.PriorityQueue; /** * SelfAdjustingScheduling is an algorithm where tasks dynamically adjust * their priority based on real-time feedback, such as wait time and CPU usage. * Tasks that wait longer will automatically increase their priority, * allowing for better responsiveness and fairness in task handling. * * Use Case: Real-time systems that require dynamic prioritization * of tasks to maintain system responsiveness and fairness. * * @author Hardvan */ public final class SelfAdjustingScheduling { private static class Task implements Comparable<Task> { String name; int waitTime; int priority; Task(String name, int priority) { this.name = name; this.waitTime = 0; this.priority = priority; } void incrementWaitTime() { waitTime++; priority = priority + waitTime; } @Override public int compareTo(Task other) { return Integer.compare(this.priority, other.priority); } } private final PriorityQueue<Task> taskQueue; public SelfAdjustingScheduling() { taskQueue = new PriorityQueue<>(); } public void addTask(String name, int priority) { taskQueue.offer(new Task(name, priority)); } public String scheduleNext() { if (taskQueue.isEmpty()) { return null; } Task nextTask = taskQueue.poll(); nextTask.incrementWaitTime(); taskQueue.offer(nextTask); return nextTask.name; } public boolean isEmpty() { return taskQueue.isEmpty(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class ShellSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length == 0) { return comparableArray; } int n = comparableArray.length; int n2 = 1; while (n2 < n / 3) { n2 = 3 * n2 + 1; } while (n2 > 0) { int n3 = n2; Comparable[] comparableArray2 = comparableArray; for (int i = n3; i < comparableArray2.length; ++i) { Comparable comparable = comparableArray2[i]; for (int j = i; j >= n3 && SortUtils.less(comparable, comparableArray2[j - n3]); j -= n3) { comparableArray2[j] = comparableArray2[j - n3]; } comparableArray2[j] = comparable; } n = n2; n2 = n / 3; } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; public class ShellSort implements SortAlgorithm { /** * Implements generic shell sort. * * @param array the array to be sorted. * @param <T> the type of elements in the array. * @return the sorted array. */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length == 0) { return array; } int gap = calculateInitialGap(array.length); while (gap > 0) { performGapInsertionSort(array, gap); gap = calculateNextGap(gap); } return array; } /** * Calculates the initial gap value using the Knuth sequence. * * @param length the length of the array. * @return the initial gap value. */ private int calculateInitialGap(final int length) { int gap = 1; while (gap < length / 3) { gap = 3 * gap + 1; } return gap; } /** * Calculates the next gap value. * * @param currentGap the current gap value. * @return the next gap value. */ private int calculateNextGap(final int currentGap) { return currentGap / 3; } /** * Performs an insertion sort for the specified gap value. * * @param array the array to be sorted. * @param gap the current gap value. * @param <T> the type of elements in the array. */ private <T extends Comparable<T>> void performGapInsertionSort(final T[] array, final int gap) { for (int i = gap; i < array.length; i++) { T temp = array[i]; int j; for (j = i; j >= gap && SortUtils.less(temp, array[j - gap]); j -= gap) { array[j] = array[j - gap]; } array[j] = temp; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; final class ShortestCommonSupersequenceLength { private ShortestCommonSupersequenceLength() { } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Class that provides methods to calculate the length of the shortest * supersequence of two given strings. The shortest supersequence is the smallest string * that contains both given strings as subsequences. */ final class ShortestCommonSupersequenceLength { private ShortestCommonSupersequenceLength() { } /** * Finds the length of the shortest supersequence of two given strings. * The shortest supersequence is defined as the smallest string that contains both * given strings as subsequences. * * @param x The first input string. * @param y The second input string. * @return The length of the shortest supersequence of the two strings. */ static int shortestSuperSequence(String x, String y) { int m = x.length(); int n = y.length(); // find lcs int l = lcs(x, y, m, n); // Result is sum of input string // lengths - length of lcs return m + n - l; } /** * Calculates the length of the longest common subsequence (LCS) between two strings. * The LCS is the longest sequence that can be derived from both strings by deleting some * (or none) of the characters without changing the order of the remaining characters. * * @param x The first input string. * @param y The second input string. * @param m The length of the first input string. * @param n The length of the second input string. * @return The length of the longest common subsequence of the two strings. */ static int lcs(String x, String y, int m, int n) { int[][] lN = new int[m + 1][n + 1]; int i; int j; // Following steps build lN[m + 1][n + 1] // in bottom up fashion. Note that // lN[i][j] contains length of lNCS // of x[0..i - 1]and y[0..j - 1] for (i = 0; i <= m; i++) { for (j = 0; j <= n; j++) { if (i == 0 || j == 0) { lN[i][j] = 0; } else if (x.charAt(i - 1) == y.charAt(j - 1)) { lN[i][j] = lN[i - 1][j - 1] + 1; } else { lN[i][j] = Math.max(lN[i - 1][j], lN[i][j - 1]); } } } // lN[m][n] contains length of LCS // for x[0..n - 1] and y[0..m - 1] return lN[m][n]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.slidingwindow; import com.thealgorithms.slidingwindow.ShortestCoprimeSegment; import java.util.LinkedList; class ShortestCoprimeSegment$DoubleStack { private LinkedList a; private LinkedList b = new LinkedList(); ShortestCoprimeSegment$DoubleStack() { this.a = new LinkedList(); this.b.add(0L); } public void push(long l) { this.a.addLast(l); long l2 = l; long l3 = (Long)this.b.getLast(); this.b.addLast(ShortestCoprimeSegment.a(l3, l2)); } public long top() { return (Long)this.b.getLast(); } public long pop() { long l = (Long)this.a.getLast(); this.a.removeLast(); this.b.removeLast(); return l; } public boolean isEmpty() { return this.a.isEmpty(); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.slidingwindow; import com.thealgorithms.slidingwindow.ShortestCoprimeSegment; import java.util.LinkedList; class ShortestCoprimeSegment$DoubleStack { private LinkedList a; private LinkedList b = new LinkedList(); ShortestCoprimeSegment$DoubleStack() { this.a = new LinkedList(); this.b.add(0L); } public void push(long l) { this.a.addLast(l); long l2 = l; long l3 = (Long)this.b.getLast(); this.b.addLast(ShortestCoprimeSegment.a(l3, l2)); } public long top() { return (Long)this.b.getLast(); } public long pop() { long l = (Long)this.a.getLast(); this.a.removeLast(); this.b.removeLast(); return l; } public boolean isEmpty() { return this.a.isEmpty(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.slidingwindow; import com.thealgorithms.slidingwindow.ShortestCoprimeSegment$DoubleStack; import java.util.Arrays; public final class ShortestCoprimeSegment { private ShortestCoprimeSegment() { } public static long[] shortestCoprimeSegment(long[] lArray) { if (lArray == null || lArray.length == 0) { return new long[0]; } ShortestCoprimeSegment$DoubleStack shortestCoprimeSegment$DoubleStack = new ShortestCoprimeSegment$DoubleStack(); ShortestCoprimeSegment$DoubleStack shortestCoprimeSegment$DoubleStack2 = new ShortestCoprimeSegment$DoubleStack(); int n = lArray.length; int n2 = 0; int n3 = n + 1; int n4 = -1; block0: for (int i = 0; i < n; ++i) { shortestCoprimeSegment$DoubleStack2.push(lArray[i]); while (true) { ShortestCoprimeSegment$DoubleStack shortestCoprimeSegment$DoubleStack3 = shortestCoprimeSegment$DoubleStack2; ShortestCoprimeSegment$DoubleStack shortestCoprimeSegment$DoubleStack4 = shortestCoprimeSegment$DoubleStack; if (!(ShortestCoprimeSegment.a(shortestCoprimeSegment$DoubleStack4.top(), shortestCoprimeSegment$DoubleStack3.top()) == 1L)) continue block0; shortestCoprimeSegment$DoubleStack3 = shortestCoprimeSegment$DoubleStack2; shortestCoprimeSegment$DoubleStack4 = shortestCoprimeSegment$DoubleStack; if (shortestCoprimeSegment$DoubleStack4.isEmpty()) { while (!shortestCoprimeSegment$DoubleStack3.isEmpty()) { shortestCoprimeSegment$DoubleStack4.push(shortestCoprimeSegment$DoubleStack3.pop()); } } shortestCoprimeSegment$DoubleStack4.pop(); if (n3 > i - n2 + 1) { n4 = n2; n3 = i - n2 + 1; } ++n2; } } if (n3 > n) { n3 = -1; } if (n3 == -1) { return new long[0]; } int n5 = n4; return Arrays.copyOfRange(lArray, n5, n5 + n3); } private static long a(long l, long l2) { while (true) { if (l < l2) { long l3 = l2; l2 = l; l = l3; continue; } if (l2 == 0L) { return l; } l %= l2; } } }", "deobfuscated_code": "package com.thealgorithms.slidingwindow; import java.util.Arrays; import java.util.LinkedList; /** * The Sliding Window technique together with 2-stack technique is used to find coprime segment of minimal size in an array. * Segment a[i],...,a[i+l] is coprime if gcd(a[i], a[i+1], ..., a[i+l]) = 1 * <p> * Run-time complexity: O(n log n) * What is special about this 2-stack technique is that it enables us to remove element a[i] and find gcd(a[i+1],...,a[i+l]) in amortized O(1) time. * For 'remove' worst-case would be O(n) operation, but this happens rarely. * Main observation is that each element gets processed a constant amount of times, hence complexity will be: * O(n log n), where log n comes from complexity of gcd. * <p> * More generally, the 2-stack technique enables us to 'remove' an element fast if it is known how to 'add' an element fast to the set. * In our case 'adding' is calculating d' = gcd(a[i],...,a[i+l+1]), when d = gcd(a[i],...a[i]) with d' = gcd(d, a[i+l+1]). * and removing is find gcd(a[i+1],...,a[i+l]). We don't calculate it explicitly, but it is pushed in the stack which we can pop in O(1). * <p> * One can change methods 'legalSegment' and function 'f' in DoubleStack to adapt this code to other sliding-window type problems. * I recommend this article for more explanations: \"<a href=\"https://codeforces.com/edu/course/2/lesson/9/2\">CF Article</a>\">Article 1</a> or <a href=\"https://usaco.guide/gold/sliding-window?lang=cpp#method-2---two-stacks\">USACO Article</a> * <p> * Another method to solve this problem is through segment trees. Then query operation would have O(log n), not O(1) time, but runtime complexity would still be O(n log n) * * @author DomTr (<a href=\"https://github.com/DomTr\">Github</a>) */ public final class ShortestCoprimeSegment { // Prevent instantiation private ShortestCoprimeSegment() { } /** * @param arr is the input array * @return shortest segment in the array which has gcd equal to 1. If no such segment exists or array is empty, returns empty array */ public static long[] shortestCoprimeSegment(long[] arr) { if (arr == null || arr.length == 0) { return new long[] {}; } DoubleStack front = new DoubleStack(); DoubleStack back = new DoubleStack(); int n = arr.length; int l = 0; int shortestLength = n + 1; int beginsAt = -1; // beginning index of the shortest coprime segment for (int i = 0; i < n; i++) { back.push(arr[i]); while (legalSegment(front, back)) { remove(front, back); if (shortestLength > i - l + 1) { beginsAt = l; shortestLength = i - l + 1; } l++; } } if (shortestLength > n) { shortestLength = -1; } if (shortestLength == -1) { return new long[] {}; } return Arrays.copyOfRange(arr, beginsAt, beginsAt + shortestLength); } private static boolean legalSegment(DoubleStack front, DoubleStack back) { return gcd(front.top(), back.top()) == 1; } private static long gcd(long a, long b) { if (a < b) { return gcd(b, a); } else if (b == 0) { return a; } else { return gcd(a % b, b); } } /** * This solves the problem of removing elements quickly. * Even though the worst case of 'remove' method is O(n), it is a very pessimistic view. * We will need to empty out 'back', only when 'from' is empty. * Consider element x when it is added to stack 'back'. * After some time 'front' becomes empty and x goes to 'front'. Notice that in the for-loop we proceed further and x will never come back to any stacks 'back' or 'front'. * In other words, every element gets processed by a constant number of operations. * So 'remove' amortized runtime is actually O(n). */ private static void remove(DoubleStack front, DoubleStack back) { if (front.isEmpty()) { while (!back.isEmpty()) { front.push(back.pop()); } } front.pop(); } /** * DoubleStack serves as a collection of two stacks. One is a normal stack called 'stack', the other 'values' stores gcd-s up until some index. */ private static class DoubleStack { LinkedList<Long> stack; LinkedList<Long> values; DoubleStack() { values = new LinkedList<>(); stack = new LinkedList<>(); values.add(0L); // Initialise with 0 which is neutral element in terms of gcd, i.e. gcd(a,0) = a } long f(long a, long b) { // Can be replaced with other function return gcd(a, b); } public void push(long x) { stack.addLast(x); values.addLast(f(values.getLast(), x)); } public long top() { return values.getLast(); } public long pop() { long res = stack.getLast(); stack.removeLast(); values.removeLast(); return res; } public boolean isEmpty() { return stack.isEmpty(); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import java.util.Random; public final class ShuffleArray { private ShuffleArray() { } public static void shuffle(int[] nArray) { if (nArray == null) { throw new IllegalArgumentException(\"Input array must not be null\"); } Random random = new Random(); for (int i = nArray.length - 1; i > 0; --i) { int n; int n2 = n = random.nextInt(i + 1); int n3 = i; int[] nArray2 = nArray; if (n3 == n2) continue; int n4 = nArray2[n3]; nArray2[n3] = nArray2[n2]; nArray2[n2] = n4; } } }", "deobfuscated_code": "package com.thealgorithms.misc; import java.util.Random; /** * The Fisher-Yates (Knuth) Shuffle algorithm randomly permutes an array's * elements, ensuring each permutation is equally likely. * * <p> * Worst-case performance O(n) * Best-case performance O(n) * Average performance O(n) * Worst-case space complexity O(1) * * This class provides a static method to shuffle an array in place. * * @author Rashi Dashore (https://github.com/rashi07dashore) */ public final class ShuffleArray { private ShuffleArray() { } /** * Shuffles the provided array in-place using the FisherYates algorithm. * * @param arr the array to shuffle; must not be {@code null} * @throws IllegalArgumentException if the input array is {@code null} */ public static void shuffle(int[] arr) { if (arr == null) { throw new IllegalArgumentException(\"Input array must not be null\"); } Random random = new Random(); for (int i = arr.length - 1; i > 0; i--) { int j = random.nextInt(i + 1); swap(arr, i, j); } } /** * Swaps two elements in an array. * * @param arr the array * @param i index of first element * @param j index of second element */ private static void swap(int[] arr, int i, int j) { if (i != j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; enum SieveOfEratosthenes$Type { PRIME, NOT_PRIME; }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; enum SieveOfEratosthenes$Type { PRIME, NOT_PRIME; }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import com.thealgorithms.maths.SieveOfEratosthenes$Type; import java.util.Arrays; public final class SieveOfEratosthenes { private SieveOfEratosthenes() { } public static int[] findPrimesTill(int n) { int n2 = n; if (n <= 0) { throw new IllegalArgumentException(\"n must be positive.\"); } SieveOfEratosthenes$Type[] sieveOfEratosthenes$TypeArray = new SieveOfEratosthenes$Type[n + 1]; Arrays.fill((Object[])sieveOfEratosthenes$TypeArray, (Object)SieveOfEratosthenes$Type.PRIME); sieveOfEratosthenes$TypeArray[0] = SieveOfEratosthenes$Type.NOT_PRIME; sieveOfEratosthenes$TypeArray[1] = SieveOfEratosthenes$Type.NOT_PRIME; double d = Math.sqrt(n); int n3 = 2; while ((double)n3 <= d) { if (sieveOfEratosthenes$TypeArray[n3] == SieveOfEratosthenes$Type.PRIME) { int n4 = 2; while (n3 * n4 <= n) { sieveOfEratosthenes$TypeArray[n3 * n4] = SieveOfEratosthenes$Type.NOT_PRIME; ++n4; } } ++n3; } SieveOfEratosthenes$Type[] sieveOfEratosthenes$TypeArray2 = sieveOfEratosthenes$TypeArray; SieveOfEratosthenes$Type[] sieveOfEratosthenes$TypeArray3 = sieveOfEratosthenes$TypeArray; int n5 = (int)Arrays.stream(sieveOfEratosthenes$TypeArray3).filter(sieveOfEratosthenes$Type -> sieveOfEratosthenes$Type == SieveOfEratosthenes$Type.PRIME).count(); int[] nArray = new int[n5]; int n6 = 0; for (n3 = 0; n3 < sieveOfEratosthenes$TypeArray2.length; ++n3) { if (sieveOfEratosthenes$TypeArray2[n3] != SieveOfEratosthenes$Type.PRIME) continue; nArray[n6++] = n3; } return nArray; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.Arrays; /** * @brief utility class implementing <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">Sieve of Eratosthenes</a> */ public final class SieveOfEratosthenes { private SieveOfEratosthenes() { } private static void checkInput(int n) { if (n <= 0) { throw new IllegalArgumentException(\"n must be positive.\"); } } private static Type[] sievePrimesTill(int n) { checkInput(n); Type[] isPrimeArray = new Type[n + 1]; Arrays.fill(isPrimeArray, Type.PRIME); isPrimeArray[0] = Type.NOT_PRIME; isPrimeArray[1] = Type.NOT_PRIME; double cap = Math.sqrt(n); for (int i = 2; i <= cap; i++) { if (isPrimeArray[i] == Type.PRIME) { for (int j = 2; i * j <= n; j++) { isPrimeArray[i * j] = Type.NOT_PRIME; } } } return isPrimeArray; } private static int countPrimes(Type[] isPrimeArray) { return (int) Arrays.stream(isPrimeArray).filter(element -> element == Type.PRIME).count(); } private static int[] extractPrimes(Type[] isPrimeArray) { int numberOfPrimes = countPrimes(isPrimeArray); int[] primes = new int[numberOfPrimes]; int primeIndex = 0; for (int curNumber = 0; curNumber < isPrimeArray.length; ++curNumber) { if (isPrimeArray[curNumber] == Type.PRIME) { primes[primeIndex++] = curNumber; } } return primes; } /** * @brief finds all of the prime numbers up to the given upper (inclusive) limit * @param n upper (inclusive) limit * @exception IllegalArgumentException n is non-positive * @return the array of all primes up to the given number (inclusive) */ public static int[] findPrimesTill(int n) { return extractPrimes(sievePrimesTill(n)); } private enum Type { PRIME, NOT_PRIME, } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.devutils.nodes; import com.thealgorithms.devutils.nodes.Node; public class SimpleNode extends Node { private SimpleNode a; public SimpleNode() { } public SimpleNode(Object object) { super(object); } public SimpleNode(Object object, SimpleNode simpleNode) { super(object); this.a = simpleNode; } public boolean hasNext() { return this.a != null; } public SimpleNode getNextNode() { return this.a; } public void setNextNode(SimpleNode simpleNode) { this.a = simpleNode; } }", "deobfuscated_code": "package com.thealgorithms.devutils.nodes; /** * Simple Node implementation that holds a reference to the next Node. * * @param <E> The type of the data held in the Node. * * @author <a href=\"https://github.com/aitorfi\">aitorfi</a> */ public class SimpleNode<E> extends Node<E> { /** * Reference to the next Node. */ private SimpleNode<E> nextNode; /** * Empty contructor. */ public SimpleNode() { super(); } /** * Initializes the Nodes' data. * * @param data Value to which data will be initialized. * @see Node#Node(Object) */ public SimpleNode(E data) { super(data); } /** * Initializes the Nodes' data and next node reference. * * @param data Value to which data will be initialized. * @param nextNode Value to which the next node reference will be set. */ public SimpleNode(E data, SimpleNode<E> nextNode) { super(data); this.nextNode = nextNode; } /** * @return True if there is a next node, otherwise false. */ public boolean hasNext() { return (nextNode != null); } public SimpleNode<E> getNextNode() { return nextNode; } public void setNextNode(SimpleNode<E> nextNode) { this.nextNode = nextNode; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.util.HashMap; public class SimpleSubCipher { public String encode(String string, String string2) { int n; StringBuilder stringBuilder = new StringBuilder(); HashMap<Character, Character> hashMap = new HashMap<Character, Character>(); char c = 'a'; char c2 = 'A'; string2 = string2.toLowerCase(); String string3 = string2.toUpperCase(); for (n = 0; n < string2.length(); ++n) { char c3 = c; c = (char)(c3 + 1); hashMap.put(Character.valueOf(c3), Character.valueOf(string2.charAt(n))); char c4 = c2; c2 = (char)(c4 + 1); hashMap.put(Character.valueOf(c4), Character.valueOf(string3.charAt(n))); } for (n = 0; n < string.length(); ++n) { if (Character.isAlphabetic(string.charAt(n))) { stringBuilder.append(hashMap.get(Character.valueOf(string.charAt(n)))); continue; } stringBuilder.append(string.charAt(n)); } return stringBuilder.toString(); } public String decode(String string, String string2) { int n; StringBuilder stringBuilder = new StringBuilder(); HashMap<Character, Character> hashMap = new HashMap<Character, Character>(); char c = 'a'; char c2 = 'A'; string2 = string2.toLowerCase(); String string3 = string2.toUpperCase(); for (n = 0; n < string2.length(); ++n) { char c3 = c; c = (char)(c3 + 1); hashMap.put(Character.valueOf(string2.charAt(n)), Character.valueOf(c3)); char c4 = c2; c2 = (char)(c4 + 1); hashMap.put(Character.valueOf(string3.charAt(n)), Character.valueOf(c4)); } for (n = 0; n < string.length(); ++n) { if (Character.isAlphabetic(string.charAt(n))) { stringBuilder.append(hashMap.get(Character.valueOf(string.charAt(n)))); continue; } stringBuilder.append(string.charAt(n)); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.util.HashMap; import java.util.Map; /** * The simple substitution cipher is a cipher that has been in use for many * hundreds of years (an excellent history is given in Simon Singhs 'the Code * Book'). It basically consists of substituting every plaintext character for a * different ciphertext character. It differs from the Caesar cipher in that the * cipher alphabet is not simply the alphabet shifted, it is completely jumbled. */ public class SimpleSubCipher { /** * Encrypt text by replacing each element with its opposite character. * * @param message * @param cipherSmall * @return Encrypted message */ public String encode(String message, String cipherSmall) { StringBuilder encoded = new StringBuilder(); // This map is used to encode Map<Character, Character> cipherMap = new HashMap<>(); char beginSmallLetter = 'a'; char beginCapitalLetter = 'A'; cipherSmall = cipherSmall.toLowerCase(); String cipherCapital = cipherSmall.toUpperCase(); // To handle Small and Capital letters for (int i = 0; i < cipherSmall.length(); i++) { cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i)); cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i)); } for (int i = 0; i < message.length(); i++) { if (Character.isAlphabetic(message.charAt(i))) { encoded.append(cipherMap.get(message.charAt(i))); } else { encoded.append(message.charAt(i)); } } return encoded.toString(); } /** * Decrypt message by replacing each element with its opposite character in * cipher. * * @param encryptedMessage * @param cipherSmall * @return message */ public String decode(String encryptedMessage, String cipherSmall) { StringBuilder decoded = new StringBuilder(); Map<Character, Character> cipherMap = new HashMap<>(); char beginSmallLetter = 'a'; char beginCapitalLetter = 'A'; cipherSmall = cipherSmall.toLowerCase(); String cipherCapital = cipherSmall.toUpperCase(); for (int i = 0; i < cipherSmall.length(); i++) { cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++); cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++); } for (int i = 0; i < encryptedMessage.length(); i++) { if (Character.isAlphabetic(encryptedMessage.charAt(i))) { decoded.append(cipherMap.get(encryptedMessage.charAt(i))); } else { decoded.append(encryptedMessage.charAt(i)); } } return decoded.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.devutils.nodes; import com.thealgorithms.devutils.nodes.TreeNode; public class SimpleTreeNode extends TreeNode { private SimpleTreeNode a; private SimpleTreeNode b; public SimpleTreeNode() { } public SimpleTreeNode(Object object) { super(object); } public SimpleTreeNode(Object object, SimpleTreeNode simpleTreeNode) { super(object, simpleTreeNode); } public SimpleTreeNode(Object object, SimpleTreeNode simpleTreeNode, SimpleTreeNode simpleTreeNode2, SimpleTreeNode simpleTreeNode3) { super(object, simpleTreeNode); this.a = simpleTreeNode2; this.b = simpleTreeNode3; } @Override public boolean isLeafNode() { return this.a == null && this.b == null; } public SimpleTreeNode getLeftNode() { return this.a; } public void setLeftNode(SimpleTreeNode simpleTreeNode) { this.a = simpleTreeNode; } public SimpleTreeNode getRightNode() { return this.b; } public void setRightNode(SimpleTreeNode simpleTreeNode) { this.b = simpleTreeNode; } }", "deobfuscated_code": "package com.thealgorithms.devutils.nodes; /** * Simple TreeNode extension that holds references to two child Nodes (left and * right). * * @param <E> The type of the data held in the Node. * * @author <a href=\"https://github.com/aitorfi\">aitorfi</a> */ public class SimpleTreeNode<E> extends TreeNode<E> { /** * Refrence to the child Node on the left. */ private SimpleTreeNode<E> leftNode; /** * Refrence to the child Node on the right. */ private SimpleTreeNode<E> rightNode; /** * Empty contructor. */ public SimpleTreeNode() { super(); } /** * Initializes the Nodes' data. * * @param data Value to which data will be initialized. * @see TreeNode#TreeNode(Object) */ public SimpleTreeNode(E data) { super(data); } /** * Initializes the Nodes' data and parent node reference. * * @param data Value to which data will be initialized. * @param parentNode Value to which the nodes' parent reference will be set. * @see TreeNode#TreeNode(Object, Node) */ public SimpleTreeNode(E data, SimpleTreeNode<E> parentNode) { super(data, parentNode); } /** * Initializes the Nodes' data and parent and child nodes references. * * @param data Value to which data will be initialized. * @param parentNode Value to which the nodes' parent reference will be set. * @param leftNode Value to which the nodes' left child reference will be * set. * @param rightNode Value to which the nodes' right child reference will be * set. */ public SimpleTreeNode(E data, SimpleTreeNode<E> parentNode, SimpleTreeNode<E> leftNode, SimpleTreeNode<E> rightNode) { super(data, parentNode); this.leftNode = leftNode; this.rightNode = rightNode; } /** * @return True if the node is a leaf node, otherwise false. * @see TreeNode#isLeafNode() */ @Override public boolean isLeafNode() { return (leftNode == null && rightNode == null); } public SimpleTreeNode<E> getLeftNode() { return leftNode; } public void setLeftNode(SimpleTreeNode<E> leftNode) { this.leftNode = leftNode; } public SimpleTreeNode<E> getRightNode() { return rightNode; } public void setRightNode(SimpleTreeNode<E> rightNode) { this.rightNode = rightNode; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.TreeMap; public class SimpsonIntegration { public static void main(String[] object) { object = new SimpsonIntegration(); int cfr_ignored_0 = 16 % 2; double cfr_ignored_1 = 2.0 / 16.0; double d = ((SimpsonIntegration)object).simpsonsMethod(16, 0.125, 1.0); System.out.println(\"The integral is equal to: \" + d); } public double simpsonsMethod(int n, double d, double d2) { TreeMap<Integer, Double> treeMap = new TreeMap<Integer, Double>(); double d3 = d2; for (int i = 0; i <= n; ++i) { double d4 = this.f(d3); treeMap.put(i, d4); d3 += d; } double d5 = 0.0; for (n = 0; n < treeMap.size(); ++n) { if (n == 0 || n == treeMap.size() - 1) { d5 += ((Double)treeMap.get(n)).doubleValue(); System.out.println(\"Multiply f(x\" + n + \") by 1\"); continue; } if (n % 2 != 0) { d5 += 4.0 * (Double)treeMap.get(n); System.out.println(\"Multiply f(x\" + n + \") by 4\"); continue; } d5 += 2.0 * (Double)treeMap.get(n); System.out.println(\"Multiply f(x\" + n + \") by 2\"); } d5 = d / 3.0 * d5; return d5; } public double f(double d) { return Math.exp(-d) * (4.0 - Math.pow(d, 2.0)); } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.TreeMap; public class SimpsonIntegration { /* * Calculate definite integrals by using Composite Simpson's rule. * Wiki: https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule * Given f a function and an even number N of intervals that divide the integration interval * e.g. [a, b], we calculate the step h = (b-a)/N and create a table that contains all the x * points of the real axis xi = x0 + i*h and the value f(xi) that corresponds to these xi. * * To evaluate the integral i use the formula below: * I = h/3 * {f(x0) + 4*f(x1) + 2*f(x2) + 4*f(x3) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)} * */ public static void main(String[] args) { SimpsonIntegration integration = new SimpsonIntegration(); // Give random data for the example purposes int n = 16; double a = 1; double b = 3; // Check so that n is even if (n % 2 != 0) { System.out.println(\"n must be even number for Simpsons method. Aborted\"); System.exit(1); } // Calculate step h and evaluate the integral double h = (b - a) / (double) n; double integralEvaluation = integration.simpsonsMethod(n, h, a); System.out.println(\"The integral is equal to: \" + integralEvaluation); } /* * @param N: Number of intervals (must be even number N=2*k) * @param h: Step h = (b-a)/N * @param a: Starting point of the interval * @param b: Ending point of the interval * * The interpolation points xi = x0 + i*h are stored the treeMap data * * @return result of the integral evaluation */ public double simpsonsMethod(int n, double h, double a) { TreeMap<Integer, Double> data = new TreeMap<>(); // Key: i, Value: f(xi) double temp; double xi = a; // Initialize the variable xi = x0 + 0*h // Create the table of xi and yi points for (int i = 0; i <= n; i++) { temp = f(xi); // Get the value of the function at that point data.put(i, temp); xi += h; // Increase the xi to the next point } // Apply the formula double integralEvaluation = 0; for (int i = 0; i < data.size(); i++) { if (i == 0 || i == data.size() - 1) { integralEvaluation += data.get(i); System.out.println(\"Multiply f(x\" + i + \") by 1\"); } else if (i % 2 != 0) { integralEvaluation += (double) 4 * data.get(i); System.out.println(\"Multiply f(x\" + i + \") by 4\"); } else { integralEvaluation += (double) 2 * data.get(i); System.out.println(\"Multiply f(x\" + i + \") by 2\"); } } // Multiply by h/3 integralEvaluation = h / 3 * integralEvaluation; // Return the result return integralEvaluation; } // Sample function f // Function f(x) = e^(-x) * (4 - x^2) public double f(double x) { return Math.exp(-x) * (4 - Math.pow(x, 2)); // return Math.sqrt(x); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class SingleBitOperations { private SingleBitOperations() { } public static int flipBit(int n, int n2) { return n ^ 1 << n2; } public static int setBit(int n, int n2) { return n | 1 << n2; } public static int clearBit(int n, int n2) { return n & ~(1 << n2); } public static int getBit(int n, int n2) { return n >> n2 & 1; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * A utility class for performing single-bit operations on integers. * These operations include flipping, setting, clearing, and getting * individual bits at specified positions. * * Bit positions are zero-indexed (i.e., the least significant bit is at position 0). * These methods leverage bitwise operations for optimal performance. * * Examples: * - `flipBit(3, 1)` flips the bit at index 1 in binary `11` (result: `1`). * - `setBit(4, 0)` sets the bit at index 0 in `100` (result: `101` or 5). * - `clearBit(7, 1)` clears the bit at index 1 in `111` (result: `101` or 5). * - `getBit(6, 0)` checks if the least significant bit is set (result: `0`). * * Time Complexity: O(1) for all operations. * * Author: lukasb1b (https://github.com/lukasb1b) */ public final class SingleBitOperations { private SingleBitOperations() { } /** * Flips (toggles) the bit at the specified position. * * @param num the input number * @param bit the position of the bit to flip (0-indexed) * @return the new number after flipping the specified bit */ public static int flipBit(final int num, final int bit) { return num ^ (1 << bit); } /** * Sets the bit at the specified position to 1. * * @param num the input number * @param bit the position of the bit to set (0-indexed) * @return the new number after setting the specified bit to 1 */ public static int setBit(final int num, final int bit) { return num | (1 << bit); } /** * Clears the bit at the specified position (sets it to 0). * * @param num the input number * @param bit the position of the bit to clear (0-indexed) * @return the new number after clearing the specified bit */ public static int clearBit(final int num, final int bit) { return num & ~(1 << bit); } /** * Gets the bit value (0 or 1) at the specified position. * * @param num the input number * @param bit the position of the bit to retrieve (0-indexed) * @return 1 if the bit is set, 0 otherwise */ public static int getBit(final int num, final int bit) { return (num >> bit) & 1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class SingleElement { private SingleElement() { throw new UnsupportedOperationException(\"Utility Class\"); } public static int findSingleElement(int[] nArray) { int n = 0; for (int i = 0; i < nArray.length; ++i) { n ^= nArray[i]; } return n; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * Utility class to find the single non-duplicate element from an array * where all other elements appear twice. * <p> * The algorithm runs in O(n) time complexity and O(1) space complexity * using bitwise XOR. * </p> * * @author <a href=\"http://github.com/tuhinm2002\">Tuhin M</a> */ public final class SingleElement { /** * Private constructor to prevent instantiation of this utility class. * Throws an UnsupportedOperationException if attempted. */ private SingleElement() { throw new UnsupportedOperationException(\"Utility Class\"); } /** * Finds the single non-duplicate element in an array where every other * element appears exactly twice. Uses bitwise XOR to achieve O(n) time * complexity and O(1) space complexity. * * @param arr the input array containing integers where every element * except one appears exactly twice * @return the single non-duplicate element */ public static int findSingleElement(int[] arr) { int ele = 0; for (int i = 0; i < arr.length; i++) { ele ^= arr[i]; } return ele; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SinglyLinkedList; import com.thealgorithms.datastructures.lists.SinglyLinkedListNode; import java.util.Iterator; import java.util.NoSuchElementException; class SinglyLinkedList$SinglyLinkedListIterator implements Iterator { private SinglyLinkedListNode a; SinglyLinkedList$SinglyLinkedListIterator(SinglyLinkedList singlyLinkedList) { this.a = singlyLinkedList.a; } @Override public boolean hasNext() { return this.a != null; } public Integer next() { if (!this.hasNext()) { throw new NoSuchElementException(); } int n = this.a.a; this.a = this.a.b; return n; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SinglyLinkedList; import com.thealgorithms.datastructures.lists.SinglyLinkedListNode; import java.util.Iterator; import java.util.NoSuchElementException; class SinglyLinkedList$SinglyLinkedListIterator implements Iterator { private SinglyLinkedListNode a; SinglyLinkedList$SinglyLinkedListIterator(SinglyLinkedList singlyLinkedList) { this.a = singlyLinkedList.a; } @Override public boolean hasNext() { return this.a != null; } public Integer next() { if (!this.hasNext()) { throw new NoSuchElementException(); } int n = this.a.a; this.a = this.a.b; return n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SinglyLinkedList$SinglyLinkedListIterator; import com.thealgorithms.datastructures.lists.SinglyLinkedListNode; import java.util.Iterator; import java.util.StringJoiner; public class SinglyLinkedList implements Iterable { private SinglyLinkedListNode a; private int b; public SinglyLinkedList() { this.a = null; this.b = 0; } public SinglyLinkedList(SinglyLinkedListNode singlyLinkedListNode, int n) { this.a = singlyLinkedListNode; this.b = n; } public boolean detectLoop() { SinglyLinkedListNode singlyLinkedListNode = this.a; SinglyLinkedListNode singlyLinkedListNode2 = this.a; while (singlyLinkedListNode != null && singlyLinkedListNode.b != null) { singlyLinkedListNode = singlyLinkedListNode.b.b; singlyLinkedListNode2 = singlyLinkedListNode2.b; if (singlyLinkedListNode != singlyLinkedListNode2) continue; return true; } return false; } public SinglyLinkedListNode middle() { if (this.a == null) { return null; } SinglyLinkedListNode singlyLinkedListNode = this.a; SinglyLinkedListNode singlyLinkedListNode2 = singlyLinkedListNode.b; while (singlyLinkedListNode2 != null && singlyLinkedListNode2.b != null) { singlyLinkedListNode = singlyLinkedListNode.b; singlyLinkedListNode2 = singlyLinkedListNode2.b.b; } return singlyLinkedListNode; } public void swapNodes(int n, int n2) { if (n == n2) { return; } SinglyLinkedListNode singlyLinkedListNode = null; SinglyLinkedListNode singlyLinkedListNode2 = this.a; while (singlyLinkedListNode2 != null && singlyLinkedListNode2.a != n) { singlyLinkedListNode = singlyLinkedListNode2; singlyLinkedListNode2 = singlyLinkedListNode2.b; } SinglyLinkedListNode singlyLinkedListNode3 = null; SinglyLinkedListNode singlyLinkedListNode4 = this.a; while (singlyLinkedListNode4 != null && singlyLinkedListNode4.a != n2) { singlyLinkedListNode3 = singlyLinkedListNode4; singlyLinkedListNode4 = singlyLinkedListNode4.b; } if (singlyLinkedListNode2 == null || singlyLinkedListNode4 == null) { return; } if (singlyLinkedListNode != null) { singlyLinkedListNode.b = singlyLinkedListNode4; } else { this.a = singlyLinkedListNode4; } if (singlyLinkedListNode3 != null) { singlyLinkedListNode3.b = singlyLinkedListNode2; } else { this.a = singlyLinkedListNode2; } singlyLinkedListNode3 = singlyLinkedListNode2.b; singlyLinkedListNode2.b = singlyLinkedListNode4.b; singlyLinkedListNode4.b = singlyLinkedListNode3; } public SinglyLinkedListNode reverseListIter(SinglyLinkedListNode singlyLinkedListNode) { SinglyLinkedListNode singlyLinkedListNode2 = null; while (singlyLinkedListNode != null && singlyLinkedListNode.b != null) { SinglyLinkedListNode singlyLinkedListNode3 = singlyLinkedListNode.b; singlyLinkedListNode.b = singlyLinkedListNode2; singlyLinkedListNode2 = singlyLinkedListNode; singlyLinkedListNode = singlyLinkedListNode3; } if (singlyLinkedListNode != null) { singlyLinkedListNode.b = singlyLinkedListNode2; singlyLinkedListNode2 = singlyLinkedListNode; } return singlyLinkedListNode2; } public SinglyLinkedListNode reverseListRec(SinglyLinkedListNode singlyLinkedListNode) { if (singlyLinkedListNode == null || singlyLinkedListNode.b == null) { return singlyLinkedListNode; } SinglyLinkedListNode singlyLinkedListNode2 = this.reverseListRec(singlyLinkedListNode.b); singlyLinkedListNode.b.b = singlyLinkedListNode; singlyLinkedListNode.b = null; return singlyLinkedListNode2; } public void clear() { SinglyLinkedListNode singlyLinkedListNode = this.a; while (singlyLinkedListNode != null) { singlyLinkedListNode = singlyLinkedListNode.b; } this.a = null; this.b = 0; } public boolean isEmpty() { return this.b == 0; } public int size() { return this.b; } public SinglyLinkedListNode getHead() { return this.a; } public void setHead(SinglyLinkedListNode singlyLinkedListNode) { this.a = singlyLinkedListNode; } public int count() { int n = 0; Iterator iterator = this.iterator(); while (iterator.hasNext()) { Integer cfr_ignored_0 = (Integer)iterator.next(); ++n; } return n; } public boolean search(int n) { for (Integer n2 : this) { if (n2 != n) continue; return true; } return false; } public String toString() { StringJoiner stringJoiner = new StringJoiner(\"->\"); for (Integer n : this) { stringJoiner.add(\"\" + n); } return stringJoiner.toString(); } public void deleteDuplicates() { SinglyLinkedListNode singlyLinkedListNode = this.a; SinglyLinkedListNode singlyLinkedListNode2 = this.a; while (singlyLinkedListNode2 != null) { if (singlyLinkedListNode2.b != null && singlyLinkedListNode2.a == singlyLinkedListNode2.b.a) { while (singlyLinkedListNode2.b != null && singlyLinkedListNode2.a == singlyLinkedListNode2.b.a) { singlyLinkedListNode2 = singlyLinkedListNode2.b; } singlyLinkedListNode.b = singlyLinkedListNode2.b; } singlyLinkedListNode2 = singlyLinkedListNode = singlyLinkedListNode.b; } } public void print() { SinglyLinkedListNode singlyLinkedListNode = this.a; while (singlyLinkedListNode != null && singlyLinkedListNode.b != null) { System.out.print(singlyLinkedListNode.a + \"->\"); singlyLinkedListNode = singlyLinkedListNode.b; } if (singlyLinkedListNode != null) { System.out.print(singlyLinkedListNode.a); System.out.println(); } } public void insertHead(int n) { this.insertNth(n, 0); } public void insert(int n) { this.insertNth(n, this.b); } public void insertNth(int n, int n2) { this.checkBounds(n2, 0, this.b); SinglyLinkedListNode singlyLinkedListNode = new SinglyLinkedListNode(n); if (this.a == null) { this.a = singlyLinkedListNode; ++this.b; return; } if (n2 == 0) { singlyLinkedListNode.b = this.a; this.a = singlyLinkedListNode; ++this.b; return; } SinglyLinkedListNode singlyLinkedListNode2 = this.a; for (int i = 0; i < n2 - 1; ++i) { singlyLinkedListNode2 = singlyLinkedListNode2.b; } singlyLinkedListNode.b = singlyLinkedListNode2.b; singlyLinkedListNode2.b = singlyLinkedListNode; ++this.b; } public void deleteHead() { this.deleteNth(0); } public void delete() { SinglyLinkedList singlyLinkedList = this; singlyLinkedList.deleteNth(singlyLinkedList.b - 1); } public void deleteNth(int n) { this.checkBounds(n, 0, this.b - 1); if (n == 0) { this.a = this.a.b; --this.b; return; } SinglyLinkedListNode singlyLinkedListNode = this.a; for (int i = 0; i < n - 1; ++i) { singlyLinkedListNode = singlyLinkedListNode.b; } singlyLinkedListNode.b = singlyLinkedListNode.b.b; --this.b; } public int getNth(int n) { this.checkBounds(n, 0, this.b - 1); SinglyLinkedListNode singlyLinkedListNode = this.a; for (int i = 0; i < n; ++i) { singlyLinkedListNode = singlyLinkedListNode.b; } return singlyLinkedListNode.a; } public void checkBounds(int n, int n2, int n3) { if (n > n3 || n < n2) { throw new IndexOutOfBoundsException(\"\" + n); } } public static void main(String[] object) { object = new SinglyLinkedList(); assert (((SinglyLinkedList)object).isEmpty()); assert (((SinglyLinkedList)object).size() == 0 && ((SinglyLinkedList)object).count() == 0); assert (((SinglyLinkedList)object).toString().isEmpty()); ((SinglyLinkedList)object).insertHead(5); ((SinglyLinkedList)object).insertHead(7); ((SinglyLinkedList)object).insertHead(10); ((SinglyLinkedList)object).insert(3); ((SinglyLinkedList)object).insertNth(1, 4); assert (((SinglyLinkedList)object).toString().equals(\"10->7->5->3->1\")); System.out.println(object); assert (((SinglyLinkedList)object).search(10) && ((SinglyLinkedList)object).search(5) && ((SinglyLinkedList)object).search(1) && !((SinglyLinkedList)object).search(100)); assert (((SinglyLinkedList)object).getNth(0) == 10 && ((SinglyLinkedList)object).getNth(2) == 5 && ((SinglyLinkedList)object).getNth(4) == 1); ((SinglyLinkedList)object).deleteHead(); ((SinglyLinkedList)object).deleteNth(1); ((SinglyLinkedList)object).delete(); assert (((SinglyLinkedList)object).toString().equals(\"7->3\")); System.out.println(object); assert (((SinglyLinkedList)object).b == 2 && ((SinglyLinkedList)object).size() == ((SinglyLinkedList)object).count()); ((SinglyLinkedList)object).clear(); assert (((SinglyLinkedList)object).isEmpty()); try { ((SinglyLinkedList)object).delete(); assert (false); } catch (Exception exception) {} object = new SinglyLinkedList(); SinglyLinkedListNode singlyLinkedListNode = new SinglyLinkedListNode(0, new SinglyLinkedListNode(2, new SinglyLinkedListNode(3, new SinglyLinkedListNode(3, new SinglyLinkedListNode(4))))); ((SinglyLinkedList)object).setHead(singlyLinkedListNode); ((SinglyLinkedList)object).deleteDuplicates(); ((SinglyLinkedList)object).print(); } public Iterator iterator() { return new SinglyLinkedList$SinglyLinkedListIterator(this); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.StringJoiner; /** * <a href=\"https://en.wikipedia.org/wiki/Linked_list\">wikipedia</a> */ public class SinglyLinkedList implements Iterable<Integer> { /** * Head refer to the front of the list */ private SinglyLinkedListNode head; /** * Size of SinglyLinkedList */ private int size; /** * Init SinglyLinkedList */ public SinglyLinkedList() { head = null; size = 0; } /** * Init SinglyLinkedList with specified head node and size * * @param head the head node of list * @param size the size of list */ public SinglyLinkedList(SinglyLinkedListNode head, int size) { this.head = head; this.size = size; } /** * Detects if there is a loop in the singly linked list using floy'd turtle * and hare algorithm. * */ public boolean detectLoop() { SinglyLinkedListNode currentNodeFast = head; SinglyLinkedListNode currentNodeSlow = head; while (currentNodeFast != null && currentNodeFast.next != null) { currentNodeFast = currentNodeFast.next.next; currentNodeSlow = currentNodeSlow.next; if (currentNodeFast == currentNodeSlow) { return true; } } return false; } /** * Return the node in the middle of the list * If the length of the list is even then return item number length/2 * @return middle node of the list */ public SinglyLinkedListNode middle() { if (head == null) { return null; } SinglyLinkedListNode firstCounter = head; SinglyLinkedListNode secondCounter = firstCounter.next; while (secondCounter != null && secondCounter.next != null) { firstCounter = firstCounter.next; secondCounter = secondCounter.next.next; } return firstCounter; } /** * Swaps nodes of two given values a and b. * */ public void swapNodes(int valueFirst, int valueSecond) { if (valueFirst == valueSecond) { return; } SinglyLinkedListNode previousA = null; SinglyLinkedListNode currentA = head; while (currentA != null && currentA.value != valueFirst) { previousA = currentA; currentA = currentA.next; } SinglyLinkedListNode previousB = null; SinglyLinkedListNode currentB = head; while (currentB != null && currentB.value != valueSecond) { previousB = currentB; currentB = currentB.next; } /* If either of 'a' or 'b' is not present, then return */ if (currentA == null || currentB == null) { return; } // If 'a' is not head node of list if (previousA != null) { previousA.next = currentB; } else { // make 'b' as the new head head = currentB; } // If 'b' is not head node of list if (previousB != null) { previousB.next = currentA; } else { // Make 'a' as new head head = currentA; } // Swap next pointer var temp = currentA.next; currentA.next = currentB.next; currentB.next = temp; } /** * Reverse a singly linked list[Iterative] from a given node till the end * */ public SinglyLinkedListNode reverseListIter(SinglyLinkedListNode node) { SinglyLinkedListNode prev = null; SinglyLinkedListNode curr = node; while (curr != null && curr.next != null) { var next = curr.next; curr.next = prev; prev = curr; curr = next; } // when curr.next==null, the current element is left without pointing it to its prev,so if (curr != null) { curr.next = prev; prev = curr; } // prev will be pointing to the last element in the Linkedlist, it will be the new head of // the reversed linkedlist return prev; } /** * Reverse a singly linked list[Recursive] from a given node till the end * */ public SinglyLinkedListNode reverseListRec(SinglyLinkedListNode head) { if (head == null || head.next == null) { return head; } SinglyLinkedListNode prev = null; SinglyLinkedListNode h2 = reverseListRec(head.next); head.next.next = head; head.next = prev; return h2; } /** * Clear all nodes in the list */ public void clear() { SinglyLinkedListNode cur = head; while (cur != null) { cur = cur.next; } head = null; size = 0; } /** * Checks if the list is empty * * @return {@code true} if list is empty, otherwise {@code false}. */ public boolean isEmpty() { return size == 0; } /** * Returns the size of the linked list. * * @return the size of the list. */ public int size() { return size; } /** * Get head of the list. * * @return head of the list. */ public SinglyLinkedListNode getHead() { return head; } /** * Set head of the list. * */ public void setHead(SinglyLinkedListNode head) { this.head = head; } /** * Calculate the count of the list manually * * @return count of the list */ public int count() { int count = 0; for (final var element : this) { ++count; } return count; } /** * Test if the value key is present in the list. * * @param key the value to be searched. * @return {@code true} if key is present in the list, otherwise * {@code false}. */ public boolean search(final int key) { for (final var element : this) { if (element == key) { return true; } } return false; } @Override public String toString() { StringJoiner joiner = new StringJoiner(\"->\"); for (final var element : this) { joiner.add(element + \"\"); } return joiner.toString(); } public void deleteDuplicates() { SinglyLinkedListNode pred = head; // predecessor = the node // having sublist of its duplicates SinglyLinkedListNode newHead = head; while (newHead != null) { // if it's a beginning of duplicates sublist // skip all duplicates if (newHead.next != null && newHead.value == newHead.next.value) { // move till the end of duplicates sublist while (newHead.next != null && newHead.value == newHead.next.value) { newHead = newHead.next; } // skip all duplicates pred.next = newHead.next; newHead = null; // otherwise, move predecessor } // move forward pred = pred.next; newHead = pred; } } public void print() { SinglyLinkedListNode temp = head; while (temp != null && temp.next != null) { System.out.print(temp.value + \"->\"); temp = temp.next; } if (temp != null) { System.out.print(temp.value); System.out.println(); } } /** * Inserts an element at the head of the list * * @param x element to be added */ public void insertHead(int x) { insertNth(x, 0); } /** * Insert an element at the tail of the list * * @param data element to be added */ public void insert(int data) { insertNth(data, size); } /** * Inserts a new node at a specified position of the list * * @param data data to be stored in a new node * @param position position at which a new node is to be inserted */ public void insertNth(int data, int position) { checkBounds(position, 0, size); SinglyLinkedListNode newNode = new SinglyLinkedListNode(data); if (head == null) { /* the list is empty */ head = newNode; size++; return; } if (position == 0) { /* insert at the head of the list */ newNode.next = head; head = newNode; size++; return; } SinglyLinkedListNode cur = head; for (int i = 0; i < position - 1; ++i) { cur = cur.next; } newNode.next = cur.next; cur.next = newNode; size++; } /** * Deletes a node at the head */ public void deleteHead() { deleteNth(0); } /** * Deletes an element at the tail */ public void delete() { deleteNth(size - 1); } /** * Deletes an element at Nth position */ public void deleteNth(int position) { checkBounds(position, 0, size - 1); if (position == 0) { head = head.next; /* clear to let GC do its work */ size--; return; } SinglyLinkedListNode cur = head; for (int i = 0; i < position - 1; ++i) { cur = cur.next; } cur.next = cur.next.next; size--; } /** * Return element at special index. * * @param index given index of element * @return element at special index. */ public int getNth(int index) { checkBounds(index, 0, size - 1); SinglyLinkedListNode cur = head; for (int i = 0; i < index; ++i) { cur = cur.next; } return cur.value; } /** * @param position to check position * @param low low index * @param high high index * @throws IndexOutOfBoundsException if {@code position} not in range * {@code low} to {@code high} */ public void checkBounds(int position, int low, int high) { if (position > high || position < low) { throw new IndexOutOfBoundsException(position + \"\"); } } /** * Driver Code */ public static void main(String[] arg) { SinglyLinkedList list = new SinglyLinkedList(); assert list.isEmpty(); assert list.size() == 0 && list.count() == 0; assert list.toString().isEmpty(); /* Test insert function */ list.insertHead(5); list.insertHead(7); list.insertHead(10); list.insert(3); list.insertNth(1, 4); assert list.toString().equals(\"10->7->5->3->1\"); System.out.println(list); /* Test search function */ assert list.search(10) && list.search(5) && list.search(1) && !list.search(100); /* Test get function */ assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1; /* Test delete function */ list.deleteHead(); list.deleteNth(1); list.delete(); assert list.toString().equals(\"7->3\"); System.out.println(list); assert list.size == 2 && list.size() == list.count(); list.clear(); assert list.isEmpty(); try { list.delete(); assert false; /* this should not happen */ } catch (Exception e) { assert true; /* this should happen */ } SinglyLinkedList instance = new SinglyLinkedList(); SinglyLinkedListNode head = new SinglyLinkedListNode(0, new SinglyLinkedListNode(2, new SinglyLinkedListNode(3, new SinglyLinkedListNode(3, new SinglyLinkedListNode(4))))); instance.setHead(head); instance.deleteDuplicates(); instance.print(); } @Override public Iterator<Integer> iterator() { return new SinglyLinkedListIterator(); } private class SinglyLinkedListIterator implements Iterator<Integer> { private SinglyLinkedListNode current; SinglyLinkedListIterator() { current = head; } @Override public boolean hasNext() { return current != null; } @Override public Integer next() { if (!hasNext()) { throw new NoSuchElementException(); } final var value = current.value; current = current.next; return value; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; class SinglyLinkedListNode { int a; SinglyLinkedListNode b = null; SinglyLinkedListNode() { } SinglyLinkedListNode(int n) { this(n, null); } SinglyLinkedListNode(int n, SinglyLinkedListNode singlyLinkedListNode) { this.a = n; this.b = singlyLinkedListNode; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; /** * This class is the nodes of the SinglyLinked List. They consist of a value and * a pointer to the node after them. */ class SinglyLinkedListNode { int value; SinglyLinkedListNode next = null; SinglyLinkedListNode() { } /** * Constructor * * @param value Value to be put in the node */ SinglyLinkedListNode(int value) { this(value, null); } /** * Constructor * * @param value Value to be put in the node * @param next Reference to the next node */ SinglyLinkedListNode(int value, SinglyLinkedListNode next) { this.value = value; this.next = next; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SkipList$HeightStrategy; import java.util.Random; public class SkipList$BernoulliHeightStrategy implements SkipList$HeightStrategy { private final double a; private static final Random b = new Random(); public SkipList$BernoulliHeightStrategy() { this.a = 0.5; } public SkipList$BernoulliHeightStrategy(double d) { if (d <= 0.0 || d >= 1.0) { throw new IllegalArgumentException(\"Probability should be from 0 to 1. But was: \" + d); } this.a = d; } @Override public int height(int n) { long l = Math.round(Math.log10(n) / Math.log10(1.0 / this.a)); if (l > Integer.MAX_VALUE) { throw new IllegalArgumentException(); } return (int)l; } @Override public int nodeHeight(int n) { int n2 = 0; double d = 100.0 * (1.0 - this.a); while ((double)(b.nextInt(Integer.MAX_VALUE) % 100 + 1) > d) { if (n2 + 1 >= n) { return n2; } ++n2; } return n2; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SkipList$HeightStrategy; import java.util.Random; public class SkipList$BernoulliHeightStrategy implements SkipList$HeightStrategy { private final double a; private static final Random b = new Random(); public SkipList$BernoulliHeightStrategy() { this.a = 0.5; } public SkipList$BernoulliHeightStrategy(double d) { if (d <= 0.0 || d >= 1.0) { throw new IllegalArgumentException(\"Probability should be from 0 to 1. But was: \" + d); } this.a = d; } @Override public int height(int n) { long l = Math.round(Math.log10(n) / Math.log10(1.0 / this.a)); if (l > Integer.MAX_VALUE) { throw new IllegalArgumentException(); } return (int)l; } @Override public int nodeHeight(int n) { int n2 = 0; double d = 100.0 * (1.0 - this.a); while ((double)(b.nextInt(Integer.MAX_VALUE) % 100 + 1) > d) { if (n2 + 1 >= n) { return n2; } ++n2; } return n2; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; public interface SkipList$HeightStrategy { public int height(int var1); public int nodeHeight(int var1); }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; public interface SkipList$HeightStrategy { public int height(int var1); public int nodeHeight(int var1); }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import java.util.Arrays; import java.util.List; class SkipList$Node { private final Object a; private final int b; private final List c; private final List d; SkipList$Node(Object object, int n) { this.a = object; this.b = n; this.c = Arrays.asList(new SkipList$Node[n + 1]); this.d = Arrays.asList(new SkipList$Node[n + 1]); } public SkipList$Node next(int n) { this.a(n); return (SkipList$Node)this.c.get(n); } public void setNext(int n, SkipList$Node skipList$Node) { this.c.set(n, skipList$Node); } public void setPrevious(int n, SkipList$Node skipList$Node) { this.d.set(n, skipList$Node); } public SkipList$Node previous(int n) { this.a(n); return (SkipList$Node)this.d.get(n); } public Object getValue() { return this.a; } private void a(int n) { if (n < 0 || n > this.b) { throw new IllegalArgumentException(); } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import java.util.Arrays; import java.util.List; class SkipList$Node { private final Object a; private final int b; private final List c; private final List d; SkipList$Node(Object object, int n) { this.a = object; this.b = n; this.c = Arrays.asList(new SkipList$Node[n + 1]); this.d = Arrays.asList(new SkipList$Node[n + 1]); } public SkipList$Node next(int n) { this.a(n); return (SkipList$Node)this.c.get(n); } public void setNext(int n, SkipList$Node skipList$Node) { this.c.set(n, skipList$Node); } public void setPrevious(int n, SkipList$Node skipList$Node) { this.d.set(n, skipList$Node); } public SkipList$Node previous(int n) { this.a(n); return (SkipList$Node)this.d.get(n); } public Object getValue() { return this.a; } private void a(int n) { if (n < 0 || n > this.b) { throw new IllegalArgumentException(); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SkipList$BernoulliHeightStrategy; import com.thealgorithms.datastructures.lists.SkipList$HeightStrategy; import com.thealgorithms.datastructures.lists.SkipList$Node; import java.util.ArrayList; import java.util.Collections; import java.util.Objects; import java.util.stream.Collectors; import java.util.stream.IntStream; public class SkipList { private final SkipList$Node a; private final int b; private final SkipList$HeightStrategy c; private int d; public SkipList() { this(100, new SkipList$BernoulliHeightStrategy()); } public SkipList(int n, SkipList$HeightStrategy skipList$HeightStrategy) { this.c = skipList$HeightStrategy; this.b = skipList$HeightStrategy.height(n); this.a = new SkipList$Node(null, this.b); this.d = 0; } public void add(Comparable object) { Objects.requireNonNull(object); SkipList$Node skipList$Node = this.a; int n = this.b; SkipList$Node[] skipList$NodeArray = new SkipList$Node[this.b + 1]; while (n >= 0) { SkipList$Node skipList$Node2 = skipList$Node.next(n); if (skipList$Node2 == null || ((Comparable)skipList$Node2.getValue()).compareTo(object) > 0) { skipList$NodeArray[n] = skipList$Node; --n; continue; } skipList$Node = skipList$Node2; } int n2 = this.c.nodeHeight(this.b); object = new SkipList$Node(object, n2); for (int i = 0; i <= n2; ++i) { if (skipList$NodeArray[i].next(i) != null) { ((SkipList$Node)object).setNext(i, skipList$NodeArray[i].next(i)); skipList$NodeArray[i].next(i).setPrevious(i, (SkipList$Node)object); } skipList$NodeArray[i].setNext(i, (SkipList$Node)object); ((SkipList$Node)object).setPrevious(i, skipList$NodeArray[i]); } ++this.d; } public Comparable get(int n) { SkipList$Node skipList$Node = this.a; for (int i = -1; i != n; ++i) { skipList$Node = skipList$Node.next(0); } return (Comparable)skipList$Node.a; } public void remove(Comparable comparable) { Objects.requireNonNull(comparable); SkipList$Node skipList$Node = this.a; int n = this.b; while (n >= 0) { SkipList$Node skipList$Node2 = skipList$Node.next(n); if (comparable.equals(skipList$Node.getValue())) break; if (skipList$Node2 == null || ((Comparable)skipList$Node2.getValue()).compareTo(comparable) > 0) { --n; continue; } skipList$Node = skipList$Node2; } for (int i = 0; i <= n; ++i) { skipList$Node.previous(i).setNext(i, skipList$Node.next(i)); if (skipList$Node.next(i) == null) continue; skipList$Node.next(i).setPrevious(i, skipList$Node.previous(i)); } --this.d; } public boolean contains(Comparable comparable) { Objects.requireNonNull(comparable); SkipList$Node skipList$Node = this.a; int n = this.b; while (n >= 0) { SkipList$Node skipList$Node2 = skipList$Node.next(n); if (comparable.equals(skipList$Node.getValue())) { return true; } if (skipList$Node2 == null || ((Comparable)skipList$Node2.getValue()).compareTo(comparable) > 0) { --n; continue; } skipList$Node = skipList$Node2; } return false; } public int size() { return this.d; } public String toString() { Object object = new ArrayList<boolean[]>(); int n2 = this.d + 1; for (int i = 0; i <= this.b; ++i) { object.add(new boolean[n2]); } SkipList$Node skipList$Node = this.a; int n3 = 0; while (skipList$Node != null) { for (int i = 0; i <= skipList$Node.b; ++i) { ((boolean[])object.get((int)i))[n3] = true; } skipList$Node = skipList$Node.next(0); ++n3; } Collections.reverse(object); String string = object.stream().map(blArray -> { StringBuilder stringBuilder = new StringBuilder(); for (boolean bl : blArray) { if (bl) { stringBuilder.append(\"[ ]\"); } else { stringBuilder.append(\"---\"); } stringBuilder.append(\" \"); } return stringBuilder.toString(); }).collect(Collectors.joining(\"\\n\")); object = IntStream.range(0, n2 - 1).mapToObj(n -> String.format(\"%3d\", n)).collect(Collectors.joining(\" \")); return string + String.format(\"%n H %s%n\", object); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.Objects; import java.util.Random; import java.util.stream.Collectors; import java.util.stream.IntStream; /** * Skip list is a data structure that allows {@code O(log n)} search complexity * as well as {@code O(log n)} insertion complexity within an ordered sequence * of {@code n} elements. Thus it can get the best features of a sorted array * (for searching) while maintaining a linked list-like structure that allows * insertion, which is not possible with a static array. * <p> * A skip list is built in layers. The bottom layer is an ordinary ordered * linked list. Each higher layer acts as an \"express lane\" for the lists * below. * <pre> * [ ] ------> [ ] --> [ ] * [ ] --> [ ] [ ] --> [ ] * [ ] [ ] [ ] [ ] [ ] [ ] * H 0 1 2 3 4 * </pre> * * @param <E> type of elements * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a> */ @SuppressWarnings({\"rawtypes\", \"unchecked\"}) public class SkipList<E extends Comparable<E>> { /** * Node before first node. */ private final Node<E> head; /** * Maximum layers count. * Calculated by {@link #heightStrategy}. */ private final int height; /** * Function for determining height of new nodes. * @see HeightStrategy */ private final HeightStrategy heightStrategy; /** * Current count of elements in list. */ private int size; private static final int DEFAULT_CAPACITY = 100; public SkipList() { this(DEFAULT_CAPACITY, new BernoulliHeightStrategy()); } public SkipList(int expectedCapacity, HeightStrategy heightStrategy) { this.heightStrategy = heightStrategy; this.height = heightStrategy.height(expectedCapacity); this.head = new Node<>(null, this.height); this.size = 0; } public void add(E e) { Objects.requireNonNull(e); Node<E> current = head; int layer = height; Node<E>[] toFix = new Node[height + 1]; while (layer >= 0) { Node<E> next = current.next(layer); if (next == null || next.getValue().compareTo(e) > 0) { toFix[layer] = current; layer--; } else { current = next; } } int nodeHeight = heightStrategy.nodeHeight(height); Node<E> node = new Node<>(e, nodeHeight); for (int i = 0; i <= nodeHeight; i++) { if (toFix[i].next(i) != null) { node.setNext(i, toFix[i].next(i)); toFix[i].next(i).setPrevious(i, node); } toFix[i].setNext(i, node); node.setPrevious(i, toFix[i]); } size++; } public E get(int index) { int counter = -1; // head index Node<E> current = head; while (counter != index) { current = current.next(0); counter++; } return current.value; } public void remove(E e) { Objects.requireNonNull(e); Node<E> current = head; int layer = height; while (layer >= 0) { Node<E> next = current.next(layer); if (e.equals(current.getValue())) { break; } else if (next == null || next.getValue().compareTo(e) > 0) { layer--; } else { current = next; } } for (int i = 0; i <= layer; i++) { current.previous(i).setNext(i, current.next(i)); if (current.next(i) != null) { current.next(i).setPrevious(i, current.previous(i)); } } size--; } /** * A search for a target element begins at the head element in the top * list, and proceeds horizontally until the current element is greater * than or equal to the target. If the current element is equal to the * target, it has been found. If the current element is greater than the * target, or the search reaches the end of the linked list, the procedure * is repeated after returning to the previous element and dropping down * vertically to the next lower list. * * @param e element whose presence in this list is to be tested * @return true if this list contains the specified element */ public boolean contains(E e) { Objects.requireNonNull(e); Node<E> current = head; int layer = height; while (layer >= 0) { Node<E> next = current.next(layer); if (e.equals(current.getValue())) { return true; } else if (next == null || next.getValue().compareTo(e) > 0) { layer--; } else { current = next; } } return false; } public int size() { return size; } /** * Print height distribution of the nodes in a manner: * <pre> * [ ] --- --- [ ] --- [ ] * [ ] --- [ ] [ ] --- [ ] * [ ] [ ] [ ] [ ] [ ] [ ] * H 0 1 2 3 4 * </pre> * Values of nodes is not presented. * * @return string representation */ @Override public String toString() { List<boolean[]> layers = new ArrayList<>(); int sizeWithHeader = size + 1; for (int i = 0; i <= height; i++) { layers.add(new boolean[sizeWithHeader]); } Node<E> current = head; int position = 0; while (current != null) { for (int i = 0; i <= current.height; i++) { layers.get(i)[position] = true; } current = current.next(0); position++; } Collections.reverse(layers); String result = layers.stream() .map(layer -> { StringBuilder acc = new StringBuilder(); for (boolean b : layer) { if (b) { acc.append(\"[ ]\"); } else { acc.append(\"---\"); } acc.append(\" \"); } return acc.toString(); }) .collect(Collectors.joining(\"\\n\")); String positions = IntStream.range(0, sizeWithHeader - 1).mapToObj(i -> String.format(\"%3d\", i)).collect(Collectors.joining(\" \")); return result + String.format(\"%n H %s%n\", positions); } /** * Value container. * Each node have pointers to the closest nodes left and right from current * on each layer of nodes height. * @param <E> type of elements */ private static class Node<E> { private final E value; private final int height; private final List<Node<E>> forward; private final List<Node<E>> backward; @SuppressWarnings(\"unchecked\") Node(E value, int height) { this.value = value; this.height = height; // predefined size lists with null values in every cell this.forward = Arrays.asList(new Node[height + 1]); this.backward = Arrays.asList(new Node[height + 1]); } public Node<E> next(int layer) { checkLayer(layer); return forward.get(layer); } public void setNext(int layer, Node<E> node) { forward.set(layer, node); } public void setPrevious(int layer, Node<E> node) { backward.set(layer, node); } public Node<E> previous(int layer) { checkLayer(layer); return backward.get(layer); } public E getValue() { return value; } private void checkLayer(int layer) { if (layer < 0 || layer > height) { throw new IllegalArgumentException(); } } } /** * Height strategy is a way of calculating maximum height for skip list * and height for each node. * @see BernoulliHeightStrategy */ public interface HeightStrategy { int height(int expectedSize); int nodeHeight(int heightCap); } /** * In most common skip list realisation element in layer {@code i} appears * in layer {@code i+1} with some fixed probability {@code p}. * Two commonly used values for {@code p} are 1/2 and 1/4. * Probability of appearing element in layer {@code i} could be calculated * with <code>P = p<sup>i</sup>(1 - p)</code> * <p> * Maximum height that would give the best search complexity * calculated by <code>log<sub>1/p</sub>n</code> * where {@code n} is an expected count of elements in list. */ public static class BernoulliHeightStrategy implements HeightStrategy { private final double probability; private static final double DEFAULT_PROBABILITY = 0.5; private static final Random RANDOM = new Random(); public BernoulliHeightStrategy() { this.probability = DEFAULT_PROBABILITY; } public BernoulliHeightStrategy(double probability) { if (probability <= 0 || probability >= 1) { throw new IllegalArgumentException(\"Probability should be from 0 to 1. But was: \" + probability); } this.probability = probability; } @Override public int height(int expectedSize) { long height = Math.round(Math.log10(expectedSize) / Math.log10(1 / probability)); if (height > Integer.MAX_VALUE) { throw new IllegalArgumentException(); } return (int) height; } @Override public int nodeHeight(int heightCap) { int level = 0; double border = 100 * (1 - probability); while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) { if (level + 1 >= heightCap) { return level; } level++; } return level; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; public class SkylineAlgorithm$Point { private int a; private int b; public SkylineAlgorithm$Point(int n, int n2) { this.a = n; this.b = n2; } public int getX() { return this.a; } public int getY() { return this.b; } public boolean dominates(SkylineAlgorithm$Point skylineAlgorithm$Point) { return this.a < skylineAlgorithm$Point.a && this.b <= skylineAlgorithm$Point.b || this.a <= skylineAlgorithm$Point.a && this.b < skylineAlgorithm$Point.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; public class SkylineAlgorithm$Point { private int a; private int b; public SkylineAlgorithm$Point(int n, int n2) { this.a = n; this.b = n2; } public int getX() { return this.a; } public int getY() { return this.b; } public boolean dominates(SkylineAlgorithm$Point skylineAlgorithm$Point) { return this.a < skylineAlgorithm$Point.a && this.b <= skylineAlgorithm$Point.b || this.a <= skylineAlgorithm$Point.a && this.b < skylineAlgorithm$Point.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; import com.thealgorithms.divideandconquer.SkylineAlgorithm$Point; import java.util.Comparator; class SkylineAlgorithm$XComparator implements Comparator { public int compare(SkylineAlgorithm$Point skylineAlgorithm$Point, SkylineAlgorithm$Point skylineAlgorithm$Point2) { return Integer.compare(skylineAlgorithm$Point.a, skylineAlgorithm$Point2.a); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; import com.thealgorithms.divideandconquer.SkylineAlgorithm$Point; import java.util.Comparator; class SkylineAlgorithm$XComparator implements Comparator { public int compare(SkylineAlgorithm$Point skylineAlgorithm$Point, SkylineAlgorithm$Point skylineAlgorithm$Point2) { return Integer.compare(skylineAlgorithm$Point.a, skylineAlgorithm$Point2.a); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; import com.thealgorithms.divideandconquer.SkylineAlgorithm$Point; import java.util.ArrayList; public class SkylineAlgorithm { private ArrayList a = new ArrayList(); public ArrayList getPoints() { return this.a; } public ArrayList produceSubSkyLines(ArrayList arrayList) { int n = arrayList.size(); if (n == 1) { return arrayList; } if (n == 2) { if (((SkylineAlgorithm$Point)arrayList.get(0)).dominates((SkylineAlgorithm$Point)arrayList.get(1))) { arrayList.remove(1); } else if (((SkylineAlgorithm$Point)arrayList.get(1)).dominates((SkylineAlgorithm$Point)arrayList.get(0))) { arrayList.remove(0); } return arrayList; } ArrayList<SkylineAlgorithm$Point> arrayList2 = new ArrayList<SkylineAlgorithm$Point>(); ArrayList<SkylineAlgorithm$Point> arrayList3 = new ArrayList<SkylineAlgorithm$Point>(); for (int i = 0; i < arrayList.size(); ++i) { if (i < arrayList.size() / 2) { arrayList2.add((SkylineAlgorithm$Point)arrayList.get(i)); continue; } arrayList3.add((SkylineAlgorithm$Point)arrayList.get(i)); } ArrayList arrayList4 = this.produceSubSkyLines(arrayList2); arrayList = this.produceSubSkyLines(arrayList3); return this.produceFinalSkyLine(arrayList4, arrayList); } public ArrayList produceFinalSkyLine(ArrayList arrayList, ArrayList arrayList2) { int n; int n2; for (n2 = 0; n2 < arrayList.size() - 1; ++n2) { if (((SkylineAlgorithm$Point)arrayList.get((int)n2)).a != ((SkylineAlgorithm$Point)arrayList.get((int)(n2 + 1))).a || ((SkylineAlgorithm$Point)arrayList.get((int)n2)).b <= ((SkylineAlgorithm$Point)arrayList.get((int)(n2 + 1))).b) continue; arrayList.remove(n2); --n2; } n2 = ((SkylineAlgorithm$Point)arrayList.get((int)0)).b; for (n = 1; n < arrayList.size(); ++n) { if (n2 <= ((SkylineAlgorithm$Point)arrayList.get((int)n)).b || (n2 = ((SkylineAlgorithm$Point)arrayList.get((int)n)).b) != 1) continue; n = arrayList.size(); } for (n = 0; n < arrayList2.size(); ++n) { if (((SkylineAlgorithm$Point)arrayList2.get((int)n)).b < n2) continue; arrayList2.remove(n); --n; } arrayList.addAll(arrayList2); return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.divideandconquer; import java.util.ArrayList; import java.util.Comparator; /** * @author dimgrichr * <p> * Space complexity: O(n) Time complexity: O(nlogn), because it is a divide and * conquer algorithm */ public class SkylineAlgorithm { private ArrayList<Point> points; /** * Main constructor of the application. ArrayList points gets created, which * represents the sum of all edges. */ public SkylineAlgorithm() { points = new ArrayList<>(); } /** * @return points, the ArrayList that includes all points. */ public ArrayList<Point> getPoints() { return points; } /** * The main divide and conquer, and also recursive algorithm. It gets an * ArrayList full of points as an argument. If the size of that ArrayList is * 1 or 2, the ArrayList is returned as it is, or with one less point (if * the initial size is 2 and one of it's points, is dominated by the other * one). On the other hand, if the ArrayList's size is bigger than 2, the * function is called again, twice, with arguments the corresponding half of * the initial ArrayList each time. Once the flashback has ended, the * function produceFinalSkyLine gets called, in order to produce the final * skyline, and return it. * * @param list, the initial list of points * @return leftSkyLine, the combination of first half's and second half's * skyline * @see Point */ public ArrayList<Point> produceSubSkyLines(ArrayList<Point> list) { // part where function exits flashback int size = list.size(); if (size == 1) { return list; } else if (size == 2) { if (list.get(0).dominates(list.get(1))) { list.remove(1); } else { if (list.get(1).dominates(list.get(0))) { list.remove(0); } } return list; } // recursive part of the function ArrayList<Point> leftHalf = new ArrayList<>(); ArrayList<Point> rightHalf = new ArrayList<>(); for (int i = 0; i < list.size(); i++) { if (i < list.size() / 2) { leftHalf.add(list.get(i)); } else { rightHalf.add(list.get(i)); } } ArrayList<Point> leftSubSkyLine = produceSubSkyLines(leftHalf); ArrayList<Point> rightSubSkyLine = produceSubSkyLines(rightHalf); // skyline is produced return produceFinalSkyLine(leftSubSkyLine, rightSubSkyLine); } /** * The first half's skyline gets cleared from some points that are not part * of the final skyline (Points with same x-value and different y=values. * The point with the smallest y-value is kept). Then, the minimum y-value * of the points of first half's skyline is found. That helps us to clear * the second half's skyline, because, the points of second half's skyline * that have greater y-value of the minimum y-value that we found before, * are dominated, so they are not part of the final skyline. Finally, the * \"cleaned\" first half's and second half's skylines, are combined, * producing the final skyline, which is returned. * * @param left the skyline of the left part of points * @param right the skyline of the right part of points * @return left the final skyline */ public ArrayList<Point> produceFinalSkyLine(ArrayList<Point> left, ArrayList<Point> right) { // dominated points of ArrayList left are removed for (int i = 0; i < left.size() - 1; i++) { if (left.get(i).x == left.get(i + 1).x && left.get(i).y > left.get(i + 1).y) { left.remove(i); i--; } } // minimum y-value is found int min = left.get(0).y; for (int i = 1; i < left.size(); i++) { if (min > left.get(i).y) { min = left.get(i).y; if (min == 1) { i = left.size(); } } } // dominated points of ArrayList right are removed for (int i = 0; i < right.size(); i++) { if (right.get(i).y >= min) { right.remove(i); i--; } } // final skyline found and returned left.addAll(right); return left; } public static class Point { private int x; private int y; /** * The main constructor of Point Class, used to represent the 2 * Dimension points. * * @param x the point's x-value. * @param y the point's y-value. */ public Point(int x, int y) { this.x = x; this.y = y; } /** * @return x, the x-value */ public int getX() { return x; } /** * @return y, the y-value */ public int getY() { return y; } /** * Based on the skyline theory, it checks if the point that calls the * function dominates the argument point. * * @param p1 the point that is compared * @return true if the point wich calls the function dominates p1 false * otherwise. */ public boolean dominates(Point p1) { // checks if p1 is dominated return ((this.x < p1.x && this.y <= p1.y) || (this.x <= p1.x && this.y < p1.y)); } } /** * It is used to compare the 2 Dimension points, based on their x-values, in * order get sorted later. */ class XComparator implements Comparator<Point> { @Override public int compare(Point a, Point b) { return Integer.compare(a.x, b.x); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.SkylineProblem; public class SkylineProblem$Building { public int left; public int height; public int right; public SkylineProblem$Building(SkylineProblem skylineProblem, int n, int n2, int n3) { this.left = n; this.height = n2; this.right = n3; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.SkylineProblem; public class SkylineProblem$Building { public int left; public int height; public int right; public SkylineProblem$Building(SkylineProblem skylineProblem, int n, int n2, int n3) { this.left = n; this.height = n2; this.right = n3; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.SkylineProblem; public class SkylineProblem$Skyline { public int coordinates; public int height; public SkylineProblem$Skyline(SkylineProblem skylineProblem, int n, int n2) { this.coordinates = n; this.height = n2; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.SkylineProblem; public class SkylineProblem$Skyline { public int coordinates; public int height; public SkylineProblem$Skyline(SkylineProblem skylineProblem, int n, int n2) { this.coordinates = n; this.height = n2; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.SkylineProblem$Building; import com.thealgorithms.others.SkylineProblem$Skyline; import java.util.ArrayList; public class SkylineProblem { private SkylineProblem$Building[] a; private int b; public void add(int n, int n2, int n3) { ++this.b; new SkylineProblem$Building(this, n, n2, n3); throw new NullPointerException(); } public ArrayList findSkyline(int n, int n2) { if (n == n2) { new ArrayList(); new SkylineProblem$Skyline; throw new NullPointerException(); } int n3 = (n + n2) / 2; ArrayList arrayList = this.findSkyline(n, n3); ArrayList arrayList2 = this.findSkyline(n3 + 1, n2); return this.mergeSkyline(arrayList, arrayList2); } public ArrayList mergeSkyline(ArrayList arrayList, ArrayList arrayList2) { int n = 0; int n2 = 0; ArrayList<SkylineProblem$Skyline> arrayList3 = new ArrayList<SkylineProblem$Skyline>(); int n3 = 0; while (!arrayList.isEmpty() && !arrayList2.isEmpty()) { int n4; if (((SkylineProblem$Skyline)arrayList.get((int)0)).coordinates < ((SkylineProblem$Skyline)arrayList2.get((int)0)).coordinates) { n4 = ((SkylineProblem$Skyline)arrayList.get((int)0)).coordinates; n = ((SkylineProblem$Skyline)arrayList.get((int)0)).height; if (n < n2) { arrayList.remove(0); if (n3 == n2) continue; arrayList3.add(new SkylineProblem$Skyline(this, n4, n2)); continue; } n3 = n; arrayList.remove(0); arrayList3.add(new SkylineProblem$Skyline(this, n4, n)); continue; } n4 = ((SkylineProblem$Skyline)arrayList2.get((int)0)).coordinates; n2 = ((SkylineProblem$Skyline)arrayList2.get((int)0)).height; if (n2 < n) { arrayList2.remove(0); if (n3 == n) continue; arrayList3.add(new SkylineProblem$Skyline(this, n4, n)); continue; } n3 = n2; arrayList2.remove(0); arrayList3.add(new SkylineProblem$Skyline(this, n4, n2)); } while (!arrayList.isEmpty()) { arrayList3.add((SkylineProblem$Skyline)arrayList.get(0)); arrayList.remove(0); } while (!arrayList2.isEmpty()) { arrayList3.add((SkylineProblem$Skyline)arrayList2.get(0)); arrayList2.remove(0); } return arrayList3; } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.ArrayList; /** * The {@code SkylineProblem} class is used to solve the skyline problem using a * divide-and-conquer approach. * It reads input for building data, processes it to find the skyline, and * prints the skyline. */ public class SkylineProblem { Building[] building; int count; /** * Adds a building with the given left, height, and right values to the * buildings list. * * @param left The left x-coordinate of the building. * @param height The height of the building. * @param right The right x-coordinate of the building. */ public void add(int left, int height, int right) { building[count++] = new Building(left, height, right); } /** * Computes the skyline for a range of buildings using the divide-and-conquer * strategy. * * @param start The starting index of the buildings to process. * @param end The ending index of the buildings to process. * @return A list of {@link Skyline} objects representing the computed skyline. */ public ArrayList<Skyline> findSkyline(int start, int end) { // Base case: only one building, return its skyline. if (start == end) { ArrayList<Skyline> list = new ArrayList<>(); list.add(new Skyline(building[start].left, building[start].height)); list.add(new Skyline(building[end].right, 0)); // Add the end of the building return list; } int mid = (start + end) / 2; ArrayList<Skyline> sky1 = this.findSkyline(start, mid); // Find the skyline of the left half ArrayList<Skyline> sky2 = this.findSkyline(mid + 1, end); // Find the skyline of the right half return this.mergeSkyline(sky1, sky2); // Merge the two skylines } /** * Merges two skylines (sky1 and sky2) into one combined skyline. * * @param sky1 The first skyline list. * @param sky2 The second skyline list. * @return A list of {@link Skyline} objects representing the merged skyline. */ public ArrayList<Skyline> mergeSkyline(ArrayList<Skyline> sky1, ArrayList<Skyline> sky2) { int currentH1 = 0; int currentH2 = 0; ArrayList<Skyline> skyline = new ArrayList<>(); int maxH = 0; // Merge the two skylines while (!sky1.isEmpty() && !sky2.isEmpty()) { if (sky1.get(0).coordinates < sky2.get(0).coordinates) { int currentX = sky1.get(0).coordinates; currentH1 = sky1.get(0).height; if (currentH1 < currentH2) { sky1.remove(0); if (maxH != currentH2) { skyline.add(new Skyline(currentX, currentH2)); } } else { maxH = currentH1; sky1.remove(0); skyline.add(new Skyline(currentX, currentH1)); } } else { int currentX = sky2.get(0).coordinates; currentH2 = sky2.get(0).height; if (currentH2 < currentH1) { sky2.remove(0); if (maxH != currentH1) { skyline.add(new Skyline(currentX, currentH1)); } } else { maxH = currentH2; sky2.remove(0); skyline.add(new Skyline(currentX, currentH2)); } } } // Add any remaining points from sky1 or sky2 while (!sky1.isEmpty()) { skyline.add(sky1.get(0)); sky1.remove(0); } while (!sky2.isEmpty()) { skyline.add(sky2.get(0)); sky2.remove(0); } return skyline; } /** * A class representing a point in the skyline with its x-coordinate and height. */ public class Skyline { public int coordinates; public int height; /** * Constructor for the {@code Skyline} class. * * @param coordinates The x-coordinate of the skyline point. * @param height The height of the skyline at the given coordinate. */ public Skyline(int coordinates, int height) { this.coordinates = coordinates; this.height = height; } } /** * A class representing a building with its left, height, and right * x-coordinates. */ public class Building { public int left; public int height; public int right; /** * Constructor for the {@code Building} class. * * @param left The left x-coordinate of the building. * @param height The height of the building. * @param right The right x-coordinate of the building. */ public Building(int left, int height, int right) { this.left = left; this.height = height; this.right = right; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class SlackTimeScheduling$Task { String a; private int b; private int c; SlackTimeScheduling$Task(String string, int n, int n2) { this.a = string; this.b = n; this.c = n2; } int a() { return this.c - this.b; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; class SlackTimeScheduling$Task { String a; private int b; private int c; SlackTimeScheduling$Task(String string, int n, int n2) { this.a = string; this.b = n; this.c = n2; } int a() { return this.c - this.b; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.scheduling; import com.thealgorithms.scheduling.SlackTimeScheduling$Task; import java.util.ArrayList; import java.util.Comparator; import java.util.List; public class SlackTimeScheduling { private final List a = new ArrayList(); public void addTask(String string, int n, int n2) { this.a.add(new SlackTimeScheduling$Task(string, n, n2)); } public List scheduleTasks() { this.a.sort(Comparator.comparingInt(SlackTimeScheduling$Task::a)); ArrayList<String> arrayList = new ArrayList<String>(); for (SlackTimeScheduling$Task slackTimeScheduling$Task : this.a) { arrayList.add(slackTimeScheduling$Task.a); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.scheduling; import java.util.ArrayList; import java.util.Comparator; import java.util.List; /** * SlackTimeScheduling is an algorithm that prioritizes tasks based on their * slack time, which is defined as the difference between the task's deadline * and the time required to execute it. Tasks with less slack time are prioritized. * * Use Case: Real-time systems with hard deadlines, such as robotics or embedded systems. * * @author Hardvan */ public class SlackTimeScheduling { static class Task { String name; int executionTime; int deadline; Task(String name, int executionTime, int deadline) { this.name = name; this.executionTime = executionTime; this.deadline = deadline; } int getSlackTime() { return deadline - executionTime; } } private final List<Task> tasks; public SlackTimeScheduling() { tasks = new ArrayList<>(); } /** * Adds a task to the scheduler. * * @param name the name of the task * @param executionTime the time required to execute the task * @param deadline the deadline by which the task must be completed */ public void addTask(String name, int executionTime, int deadline) { tasks.add(new Task(name, executionTime, deadline)); } /** * Schedules the tasks based on their slack time. * * @return the order in which the tasks should be executed */ public List<String> scheduleTasks() { tasks.sort(Comparator.comparingInt(Task::getSlackTime)); List<String> scheduledOrder = new ArrayList<>(); for (Task task : tasks) { scheduledOrder.add(task.name); } return scheduledOrder; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; import java.util.LinkedList; public final class SlidingWindowMaximum { private SlidingWindowMaximum() { } public static int[] maxSlidingWindow(int[] nArray, int n) { int n2 = nArray.length; if (n2 < n || n == 0) { return new int[0]; } int[] nArray2 = new int[n2 - n + 1]; LinkedList<Integer> linkedList = new LinkedList<Integer>(); for (int i = 0; i < n2; ++i) { if (!linkedList.isEmpty() && (Integer)linkedList.peekFirst() < i - n + 1) { linkedList.pollFirst(); } while (!linkedList.isEmpty() && nArray[(Integer)linkedList.peekLast()] < nArray[i]) { linkedList.pollLast(); } linkedList.offerLast(i); if (i < n - 1) continue; nArray2[i - n + 1] = nArray[(Integer)linkedList.peekFirst()]; } return nArray2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.queues; import java.util.Deque; import java.util.LinkedList; /** * The {@code SlidingWindowMaximum} class provides a method to efficiently compute * the maximum element within every sliding window of size {@code k} in a given array. * * <p>The algorithm uses a deque to maintain the indices of useful elements within * the current sliding window. The time complexity of this approach is O(n) since * each element is processed at most twice. * * @author Hardvan */ public final class SlidingWindowMaximum { private SlidingWindowMaximum() { } /** * Returns an array of the maximum values for each sliding window of size {@code k}. * <p>If {@code nums} has fewer elements than {@code k}, the result will be an empty array. * <p>Example: * <pre> * Input: nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3 * Output: [3, 3, 5, 5, 6, 7] * </pre> * * @param nums the input array of integers * @param k the size of the sliding window * @return an array containing the maximum element for each sliding window */ public static int[] maxSlidingWindow(int[] nums, int k) { int n = nums.length; if (n < k || k == 0) { return new int[0]; } int[] result = new int[n - k + 1]; Deque<Integer> deque = new LinkedList<>(); for (int i = 0; i < n; i++) { // Remove elements from the front of the deque if they are out of the current window if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) { deque.pollFirst(); } // Remove elements from the back if they are smaller than the current element while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) { deque.pollLast(); } // Add the current element's index to the deque deque.offerLast(i); // Store the maximum element for the current window (starting from the k-1th element) if (i >= k - 1) { result[i - k + 1] = nums[deque.peekFirst()]; } } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class SlowSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { this.a(comparableArray, 0, comparableArray.length - 1); return comparableArray; } private void a(Comparable[] comparableArray, int n, int n2) { while (!SortUtils.a(Integer.valueOf(n), Integer.valueOf(n2))) { int n3 = n + n2 >>> 1; this.a(comparableArray, n, n3); this.a(comparableArray, n3 + 1, n2); if (SortUtils.less(comparableArray[n2], comparableArray[n3])) { SortUtils.swap(comparableArray, n2, n3); } --n2; } return; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * @author Amir Hassan (https://github.com/ahsNT) * @see SortAlgorithm */ public class SlowSort implements SortAlgorithm { @Override public <T extends Comparable<T>> T[] sort(T[] unsortedArray) { sort(unsortedArray, 0, unsortedArray.length - 1); return unsortedArray; } private <T extends Comparable<T>> void sort(T[] array, int i, int j) { if (SortUtils.greaterOrEqual(i, j)) { return; } final int m = (i + j) >>> 1; sort(array, i, m); sort(array, m + 1, j); if (SortUtils.less(array[j], array[m])) { SortUtils.swap(array, j, m); } sort(array, i, j - 1); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.NoSuchElementException; import java.util.Stack; public class SmallestElementConstantTime { private Stack a = new Stack(); private Stack b = new Stack(); public void push(int n) { if (this.a.isEmpty()) { this.a.push(n); this.b.push(n); return; } this.a.push(n); if (n < (Integer)this.b.peek()) { this.b.push(n); } } public void pop() { if (this.a.isEmpty()) { throw new NoSuchElementException(\"Stack is empty\"); } int n = (Integer)this.a.pop(); if (n == (Integer)this.b.peek()) { this.b.pop(); } } public Integer getMinimumElement() { if (this.b.isEmpty()) { return null; } return (Integer)this.b.peek(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.NoSuchElementException; import java.util.Stack; /** * A class that implements a stack that gives the minimum element in O(1) time. * The mainStack is used to store the all the elements of the stack * While the minStack stores the minimum elements * When we want to get a minimum element, we call the top of the minimum stack * * Problem: https://www.baeldung.com/cs/stack-constant-time */ public class SmallestElementConstantTime { private Stack<Integer> mainStack; // initialize a mainStack private Stack<Integer> minStack; // initialize a minStack /** * Constructs two empty stacks */ public SmallestElementConstantTime() { mainStack = new Stack<>(); minStack = new Stack<>(); } /** * Pushes an element onto the top of the stack. * Checks if the element is the minimum or not * If so, then pushes to the minimum stack * @param data The element to be pushed onto the stack. */ public void push(int data) { if (mainStack.isEmpty()) { mainStack.push(data); minStack.push(data); return; } mainStack.push(data); if (data < minStack.peek()) { minStack.push(data); } } /** * Pops an element from the stack. * Checks if the element to be popped is the minimum or not * If so, then pop from the minStack * * @throws NoSuchElementException if the stack is empty. */ public void pop() { if (mainStack.isEmpty()) { throw new NoSuchElementException(\"Stack is empty\"); } int ele = mainStack.pop(); if (ele == minStack.peek()) { minStack.pop(); } } /** * Returns the minimum element present in the stack * * @return The element at the top of the minStack, or null if the stack is empty. */ public Integer getMinimumElement() { if (minStack.isEmpty()) { return null; } return minStack.peek(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.Random; final class SolovayStrassenPrimalityTest { private final Random a; private SolovayStrassenPrimalityTest(int n) { this.a = new Random(n); } public static SolovayStrassenPrimalityTest getSolovayStrassenPrimalityTest(int n) { return new SolovayStrassenPrimalityTest(n); } public final int calculateJacobi(long l, long l2) { if (l2 <= 0L || l2 % 2L == 0L) { return 0; } l %= l2; int n = 1; while (l != 0L) { long l3; while (l % 2L == 0L) { l /= 2L; l3 = l2 % 8L; if (l3 != 3L && l3 != 5L) continue; n = -n; } l3 = l; l = l2; l2 = l3; if (l % 4L == 3L && l2 % 4L == 3L) { n = -n; } l %= l2; } if (l2 == 1L) { return n; } return 0; } public final boolean solovayStrassen(long l, int n) { if (l <= 1L) { return false; } if (l <= 3L) { return true; } for (int i = 0; i < n; ++i) { long l2 = Math.abs(this.a.nextLong() % (l - 1L)) + 2L; long l3 = l2 % (l - 1L) + 1L; long l4 = (l + (long)this.calculateJacobi(l3, l)) % l; long l5 = l; long l6 = l3; long l7 = 1L; long l8 = l6; for (long j = (l - 1L) / 2L; j > 0L; j /= 2L) { if (j % 2L == 1L) { l7 = l7 * l8 % l5; } long l9 = l8; l8 = l9 * l9 % l5; } long l10 = l7 % l5; if (l4 != 0L && l10 == l4) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.Random; /** * This class implements the Solovay-Strassen primality test, * which is a probabilistic algorithm to determine whether a number is prime. * The algorithm is based on properties of the Jacobi symbol and modular exponentiation. * * For more information, go to {@link https://en.wikipedia.org/wiki/Solovay%E2%80%93Strassen_primality_test} */ final class SolovayStrassenPrimalityTest { private final Random random; /** * Constructs a SolovayStrassenPrimalityTest instance with a specified seed for randomness. * * @param seed the seed for generating random numbers */ private SolovayStrassenPrimalityTest(int seed) { random = new Random(seed); } /** * Factory method to create an instance of SolovayStrassenPrimalityTest. * * @param seed the seed for generating random numbers * @return a new instance of SolovayStrassenPrimalityTest */ public static SolovayStrassenPrimalityTest getSolovayStrassenPrimalityTest(int seed) { return new SolovayStrassenPrimalityTest(seed); } /** * Calculates modular exponentiation using the method of exponentiation by squaring. * * @param base the base number * @param exponent the exponent * @param mod the modulus * @return (base^exponent) mod mod */ private static long calculateModularExponentiation(long base, long exponent, long mod) { long x = 1; // This will hold the result of (base^exponent) % mod long y = base; // This holds the current base value being squared while (exponent > 0) { // If exponent is odd, multiply the current base (y) with x if (exponent % 2 == 1) { x = x * y % mod; // Update result with current base } // Square the base for the next iteration y = y * y % mod; // Update base to be y^2 exponent = exponent / 2; // Halve the exponent for next iteration } return x % mod; // Return final result after all iterations } /** * Computes the Jacobi symbol (a/n), which is a generalization of the Legendre symbol. * * @param a the numerator * @param num the denominator (must be an odd positive integer) * @return the Jacobi symbol value: 1, -1, or 0 */ public int calculateJacobi(long a, long num) { // Check if num is non-positive or even; Jacobi symbol is not defined in these cases if (num <= 0 || num % 2 == 0) { return 0; } a = a % num; // Reduce a modulo num to simplify calculations int jacobi = 1; // Initialize Jacobi symbol value while (a != 0) { // While a is even, reduce it and adjust jacobi based on properties of num while (a % 2 == 0) { a /= 2; // Divide a by 2 until it becomes odd long nMod8 = num % 8; // Get num modulo 8 to check conditions for jacobi adjustment if (nMod8 == 3 || nMod8 == 5) { jacobi = -jacobi; // Flip jacobi sign based on properties of num modulo 8 } } long temp = a; // Temporarily store value of a a = num; // Set a to be num for next iteration num = temp; // Set num to be previous value of a // Adjust jacobi based on properties of both numbers when both are odd and congruent to 3 modulo 4 if (a % 4 == 3 && num % 4 == 3) { jacobi = -jacobi; // Flip jacobi sign again based on congruences } a = a % num; // Reduce a modulo num for next iteration of Jacobi computation } return (num == 1) ? jacobi : 0; // If num reduces to 1, return jacobi value, otherwise return 0 (not defined) } /** * Performs the Solovay-Strassen primality test on a given number. * * @param num the number to be tested for primality * @param iterations the number of iterations to run for accuracy * @return true if num is likely prime, false if it is composite */ public boolean solovayStrassen(long num, int iterations) { if (num <= 1) { return false; // Numbers <=1 are not prime by definition. } if (num <= 3) { return true; // Numbers <=3 are prime. } for (int i = 0; i < iterations; i++) { long r = Math.abs(random.nextLong() % (num - 1)) + 2; // Generate a non-negative random number. long a = r % (num - 1) + 1; // Choose random 'a' in range [1, n-1]. long jacobi = (num + calculateJacobi(a, num)) % num; // Calculate Jacobi symbol and adjust it modulo n. long mod = calculateModularExponentiation(a, (num - 1) / 2, num); // Calculate modular exponentiation: a^((n-1)/2) mod n. if (jacobi == 0 || mod != jacobi) { return false; // If Jacobi symbol is zero or doesn't match modular result, n is composite. } } return true; // If no contradictions found after all iterations, n is likely prime. } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.matrix; public final class SolveSystem { private SolveSystem() { } public static double[] solveSystem(double[][] dArray, double[] dArray2) { int n; for (int i = 0; i < dArray.length - 1; ++i) { double d = Math.abs(dArray[i][i]); int n2 = i; for (n = i + 1; n < dArray.length; ++n) { if (!(Math.abs(dArray[n][i]) > d)) continue; d = dArray[n][i]; n2 = n; } if (Math.abs(d) < 1.0E-8) continue; double[] dArray3 = dArray[i]; dArray[i] = dArray[n2]; dArray[n2] = dArray3; double d2 = dArray2[i]; dArray2[i] = dArray2[n2]; dArray2[n2] = d2; for (int j = i + 1; j < dArray.length; ++j) { double[] dArray4 = dArray[j]; int n3 = i; dArray4[n3] = dArray4[n3] / dArray[i][i]; for (int k = i + 1; k < dArray.length; ++k) { double[] dArray5 = dArray[j]; int n4 = k; dArray5[n4] = dArray5[n4] - dArray[j][i] * dArray[i][k]; } int n5 = j; dArray2[n5] = dArray2[n5] - dArray[j][i] * dArray2[i]; } } double[] dArray6 = new double[dArray2.length]; System.arraycopy(dArray2, 0, dArray6, 0, dArray2.length); for (int i = dArray.length - 1; i >= 0; --i) { double d = 0.0; for (n = i + 1; n < dArray.length; ++n) { d += dArray[i][n] * dArray6[n]; } dArray6[i] = dArray2[i] - d; if (!(Math.abs(dArray[i][i]) > 1.0E-8)) { throw new IllegalArgumentException(\"Matrix was found to be singular\"); } int n6 = i; dArray6[n6] = dArray6[n6] / dArray[i][i]; } return dArray6; } }", "deobfuscated_code": "package com.thealgorithms.matrix; /** * This class implements an algorithm for solving a system of equations of the form Ax=b using gaussian elimination and back substitution. * * @link <a href=\"https://en.wikipedia.org/wiki/Gaussian_elimination\">Gaussian Elimination Wiki</a> * @see InverseOfMatrix finds the full of inverse of a matrice, but is not required to solve a system. */ public final class SolveSystem { private SolveSystem() { } /** * Problem: Given a matrix A and vector b, solve the linear system Ax = b for the vector x.\\ * <p> * <b>This OVERWRITES the input matrix to save on memory</b> * * @param matrix - a square matrix of doubles * @param constants - an array of constant * @return solutions */ public static double[] solveSystem(double[][] matrix, double[] constants) { final double tol = 0.00000001; // tolerance for round off for (int k = 0; k < matrix.length - 1; k++) { // find the largest value in column (to avoid zero pivots) double maxVal = Math.abs(matrix[k][k]); int maxIdx = k; for (int j = k + 1; j < matrix.length; j++) { if (Math.abs(matrix[j][k]) > maxVal) { maxVal = matrix[j][k]; maxIdx = j; } } if (Math.abs(maxVal) < tol) { // hope the matrix works out continue; } // swap rows double[] temp = matrix[k]; matrix[k] = matrix[maxIdx]; matrix[maxIdx] = temp; double tempConst = constants[k]; constants[k] = constants[maxIdx]; constants[maxIdx] = tempConst; for (int i = k + 1; i < matrix.length; i++) { // compute multipliers and save them in the column matrix[i][k] /= matrix[k][k]; for (int j = k + 1; j < matrix.length; j++) { matrix[i][j] -= matrix[i][k] * matrix[k][j]; } constants[i] -= matrix[i][k] * constants[k]; } } // back substitution double[] x = new double[constants.length]; System.arraycopy(constants, 0, x, 0, constants.length); for (int i = matrix.length - 1; i >= 0; i--) { double sum = 0; for (int j = i + 1; j < matrix.length; j++) { sum += matrix[i][j] * x[j]; } x[i] = constants[i] - sum; if (Math.abs(matrix[i][i]) > tol) { x[i] /= matrix[i][i]; } else { throw new IllegalArgumentException(\"Matrix was found to be singular\"); } } return x; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.Arrays; import java.util.List; public interface SortAlgorithm { public Comparable[] sort(Comparable[] var1); default public List sort(List list) { List list2 = list; return Arrays.asList(this.sort(list2.toArray(new Comparable[list2.size()]))); } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.Arrays; import java.util.List; /** * The common interface of most sorting algorithms * * @author Podshivalov Nikita (https://github.com/nikitap492) */ @SuppressWarnings(\"rawtypes\") public interface SortAlgorithm { /** * Main method arrays sorting algorithms * * @param unsorted - an array should be sorted * @return a sorted array */ <T extends Comparable<T>> T[] sort(T[] unsorted); /** * Auxiliary method for algorithms what wanted to work with lists from JCF * * @param unsorted - a list should be sorted * @return a sorted list */ @SuppressWarnings(\"unchecked\") default<T extends Comparable<T>> List<T> sort(List<T> unsorted) { return Arrays.asList(sort(unsorted.toArray((T[]) new Comparable[unsorted.size()]))); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; public final class SortOrderAgnosticBinarySearch { private SortOrderAgnosticBinarySearch() { } public static int find(int[] nArray, int n) { boolean bl; int n2 = 0; int n3 = nArray.length - 1; boolean bl2 = bl = nArray[0] > nArray[n3]; while (n2 <= n3) { int n4 = n3 - n2 / 2; if (nArray[n4] == n) { return n4; } if (bl) { if (n < nArray[n4]) { n2 = n4 + 1; continue; } n3 = n4 - 1; continue; } if (n > nArray[n4]) { n2 = n4 + 1; continue; } n3 = n4 - 1; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; public final class SortOrderAgnosticBinarySearch { private SortOrderAgnosticBinarySearch() { } public static int find(int[] arr, int key) { int start = 0; int end = arr.length - 1; boolean arrDescending = arr[start] > arr[end]; // checking for Array is in ascending order or descending order. while (start <= end) { int mid = end - start / 2; if (arr[mid] == key) { return mid; } if (arrDescending) { // boolean is true then our array is in descending order if (key < arr[mid]) { start = mid + 1; } else { end = mid - 1; } } else { // otherwise our array is in ascending order if (key > arr[mid]) { start = mid + 1; } else { end = mid - 1; } } } return -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Stack; public final class SortStack { private SortStack() { } public static void sortStack(Stack stack) { if (stack.isEmpty()) { return; } int n = (Integer)stack.pop(); SortStack.sortStack(stack); SortStack.a(stack, n); } private static void a(Stack stack, int n) { if (stack.isEmpty() || n > (Integer)stack.peek()) { stack.push(n); return; } int n2 = (Integer)stack.pop(); SortStack.a(stack, n); stack.push(n2); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Stack; /** * A utility class that provides a method to sort a stack using recursion. * The elements are sorted in ascending order, with the largest element at the top. * This algorithm is implemented using only recursion and the original stack, * without utilizing any additional data structures apart from the stack itself. */ public final class SortStack { private SortStack() { } /** * Sorts the given stack in ascending order using recursion. * The sorting is performed such that the largest element ends up on top of the stack. * This method modifies the original stack and does not return a new stack. * * The algorithm works as follows: * 1. Remove the top element. * 2. Recursively sort the remaining stack. * 3. Insert the removed element back into the sorted stack at the correct position. * * @param stack The stack to be sorted, containing Integer elements. * @throws IllegalArgumentException if the stack contains `null` elements. */ public static void sortStack(Stack<Integer> stack) { if (stack.isEmpty()) { return; } int top = stack.pop(); sortStack(stack); insertInSortedOrder(stack, top); } /** * Helper method to insert an element into the correct position in a sorted stack. * This method is called recursively to place the given element into the stack * such that the stack remains sorted in ascending order. * * The element is inserted in such a way that all elements below it are smaller * (if the stack is non-empty), and elements above it are larger, maintaining * the ascending order. * * @param stack The stack in which the element needs to be inserted. * @param element The element to be inserted into the stack in sorted order. */ private static void insertInSortedOrder(Stack<Integer> stack, int element) { if (stack.isEmpty() || element > stack.peek()) { stack.push(element); return; } int top = stack.pop(); insertInSortedOrder(stack, element); stack.push(top); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; final class SortUtils { private SortUtils() { } public static void swap(Object[] objectArray, int n, int n2) { if (n != n2) { Object object = objectArray[n]; objectArray[n] = objectArray[n2]; objectArray[n2] = object; } } public static boolean less(Comparable comparable, Comparable comparable2) { return comparable.compareTo(comparable2) < 0; } public static boolean greater(Comparable comparable, Comparable comparable2) { return comparable.compareTo(comparable2) > 0; } static boolean a(Comparable comparable, Comparable comparable2) { return comparable.compareTo(comparable2) >= 0; } static void a(List object) { object = object.stream().map(Object::toString).collect(Collectors.joining(\" \")); System.out.println((String)object); } static void a(Object[] objectArray) { System.out.println(Arrays.toString(objectArray)); } public static void flip(Comparable[] comparableArray, int n, int n2) { while (n <= n2) { SortUtils.swap(comparableArray, n++, n2--); } } public static boolean isSorted(Comparable[] comparableArray) { for (int i = 1; i < comparableArray.length; ++i) { if (!SortUtils.less(comparableArray[i], comparableArray[i - 1])) continue; return false; } return true; } public static boolean isSorted(List list) { for (int i = 1; i < list.size(); ++i) { if (!SortUtils.less((Comparable)list.get(i), (Comparable)list.get(i - 1))) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; final class SortUtils { private SortUtils() { } /** * Swaps two elements at the given positions in an array. * * @param array the array in which to swap elements * @param i the index of the first element to swap * @param j the index of the second element to swap * @param <T> the type of elements in the array */ public static <T> void swap(T[] array, int i, int j) { if (i != j) { final T temp = array[i]; array[i] = array[j]; array[j] = temp; } } /** * Compares two elements to see if the first is less than the second. * * @param firstElement the first element to compare * @param secondElement the second element to compare * @return true if the first element is less than the second, false otherwise */ public static <T extends Comparable<T>> boolean less(T firstElement, T secondElement) { return firstElement.compareTo(secondElement) < 0; } /** * Compares two elements to see if the first is greater than the second. * * @param firstElement the first element to compare * @param secondElement the second element to compare * @return true if the first element is greater than the second, false otherwise */ public static <T extends Comparable<T>> boolean greater(T firstElement, T secondElement) { return firstElement.compareTo(secondElement) > 0; } /** * Compares two elements to see if the first is greater than or equal to the second. * * @param firstElement the first element to compare * @param secondElement the second element to compare * @return true if the first element is greater than or equal to the second, false otherwise */ static <T extends Comparable<T>> boolean greaterOrEqual(T firstElement, T secondElement) { return firstElement.compareTo(secondElement) >= 0; } /** * Prints the elements of a list to standard output. * * @param listToPrint the list to print */ static void print(List<?> listToPrint) { String result = listToPrint.stream().map(Object::toString).collect(Collectors.joining(\" \")); System.out.println(result); } /** * Prints the elements of an array to standard output. * * @param array the array to print */ static <T> void print(T[] array) { System.out.println(Arrays.toString(array)); } /** * Flips the order of elements in the specified range of an array. * * @param array the array whose elements are to be flipped * @param left the left boundary of the range to be flipped (inclusive) * @param right the right boundary of the range to be flipped (inclusive) */ public static <T extends Comparable<T>> void flip(T[] array, int left, int right) { while (left <= right) { swap(array, left++, right--); } } /** * Checks whether the array is sorted in ascending order. * * @param array the array to check * @return true if the array is sorted in ascending order, false otherwise */ public static <T extends Comparable<T>> boolean isSorted(T[] array) { for (int i = 1; i < array.length; i++) { if (less(array[i], array[i - 1])) { return false; } } return true; } /** * Checks whether the list is sorted in ascending order. * * @param list the list to check * @return true if the list is sorted in ascending order, false otherwise */ public static <T extends Comparable<T>> boolean isSorted(List<T> list) { for (int i = 1; i < list.size(); i++) { if (less(list.get(i), list.get(i - 1))) { return false; } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.Random; public final class SortUtilsRandomGenerator { private static final Random a; private static final long b; private SortUtilsRandomGenerator() { } public static Double[] generateArray(int n) { Double[] doubleArray = new Double[n]; for (int i = 0; i < n; ++i) { doubleArray[i] = SortUtilsRandomGenerator.generateDouble(); } return doubleArray; } public static Double generateDouble() { return a.nextDouble(); } public static int generateInt(int n) { return a.nextInt(n); } static { b = System.currentTimeMillis(); a = new Random(b); } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.Random; public final class SortUtilsRandomGenerator { private SortUtilsRandomGenerator() { } private static final Random RANDOM; private static final long SEED; static { SEED = System.currentTimeMillis(); RANDOM = new Random(SEED); } /** * Function to generate array of double values, with predefined size. * * @param size result array size * @return array of Double values, randomly generated, each element is between [0, 1) */ public static Double[] generateArray(int size) { Double[] arr = new Double[size]; for (int i = 0; i < size; i++) { arr[i] = generateDouble(); } return arr; } /** * Function to generate Double value. * * @return Double value [0, 1) */ public static Double generateDouble() { return RANDOM.nextDouble(); } /** * Function to generate int value. * * @return int value [0, n) */ public static int generateInt(int n) { return RANDOM.nextInt(n); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SortedLinkedList; public final class SortedLinkedList$Node { public final int value; public SortedLinkedList$Node next; public SortedLinkedList$Node(SortedLinkedList sortedLinkedList, int n) { this.value = n; this.next = null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SortedLinkedList; public final class SortedLinkedList$Node { public final int value; public SortedLinkedList$Node next; public SortedLinkedList$Node(SortedLinkedList sortedLinkedList, int n) { this.value = n; this.next = null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.lists; import com.thealgorithms.datastructures.lists.SortedLinkedList$Node; import java.util.ArrayList; public class SortedLinkedList { private SortedLinkedList$Node a = null; private SortedLinkedList$Node b = null; public void insert(int n) { SortedLinkedList$Node sortedLinkedList$Node = new SortedLinkedList$Node(this, n); if (this.a == null) { this.a = sortedLinkedList$Node; this.b = sortedLinkedList$Node; return; } if (n < this.a.value) { sortedLinkedList$Node.next = this.a; this.a = sortedLinkedList$Node; return; } if (n > this.b.value) { this.b.next = sortedLinkedList$Node; this.b = sortedLinkedList$Node; return; } SortedLinkedList$Node sortedLinkedList$Node2 = this.a; while (sortedLinkedList$Node2.next != null && sortedLinkedList$Node2.next.value < n) { sortedLinkedList$Node2 = sortedLinkedList$Node2.next; } sortedLinkedList$Node.next = sortedLinkedList$Node2.next; sortedLinkedList$Node2.next = sortedLinkedList$Node; if (sortedLinkedList$Node.next == null) { this.b = sortedLinkedList$Node; } } public boolean delete(int n) { if (this.a == null) { return false; } if (this.a.value == n) { if (this.a.next == null) { this.a = null; this.b = null; } else { this.a = this.a.next; } return true; } SortedLinkedList$Node sortedLinkedList$Node = this.a; while (sortedLinkedList$Node.next != null) { if (sortedLinkedList$Node.next.value == n) { if (sortedLinkedList$Node.next == this.b) { this.b = sortedLinkedList$Node; } sortedLinkedList$Node.next = sortedLinkedList$Node.next.next; return true; } sortedLinkedList$Node = sortedLinkedList$Node.next; } return false; } public boolean search(int n) { SortedLinkedList$Node sortedLinkedList$Node = this.a; while (sortedLinkedList$Node != null) { if (sortedLinkedList$Node.value == n) { return true; } sortedLinkedList$Node = sortedLinkedList$Node.next; } return false; } public boolean isEmpty() { return this.a == null; } public String toString() { if (this.a != null) { ArrayList<String> arrayList = new ArrayList<String>(); SortedLinkedList$Node sortedLinkedList$Node = this.a; while (sortedLinkedList$Node != null) { arrayList.add(String.valueOf(sortedLinkedList$Node.value)); sortedLinkedList$Node = sortedLinkedList$Node.next; } return \"[\" + String.join((CharSequence)\", \", arrayList) + \"]\"; } return \"[]\"; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.lists; import java.util.ArrayList; import java.util.List; /** * The SortedLinkedList class represents a singly linked list that maintains its elements in sorted order. * Elements are ordered based on their natural ordering, with smaller elements at the head and larger elements toward the tail. * The class provides methods for inserting, deleting, and searching elements, as well as checking if the list is empty. * <p> * This implementation utilizes a singly linked list to maintain a dynamically sorted list. * </p> * <p> * Further information can be found here: * https://runestone.academy/ns/books/published/cppds/LinearLinked/ImplementinganOrderedList.html * </p> * * <b>Usage Example:</b> * <pre> * SortedLinkedList list = new SortedLinkedList(); * list.insert(10); * list.insert(5); * list.insert(20); * System.out.println(list); // Outputs: [5, 10, 20] * </pre> */ public class SortedLinkedList { private Node head; private Node tail; /** * Initializes an empty sorted linked list. */ public SortedLinkedList() { this.head = null; this.tail = null; } /** * Inserts a new integer into the list, maintaining sorted order. * * @param value the integer to insert */ public void insert(int value) { Node newNode = new Node(value); if (head == null) { this.head = newNode; this.tail = newNode; } else if (value < head.value) { newNode.next = this.head; this.head = newNode; } else if (value > tail.value) { this.tail.next = newNode; this.tail = newNode; } else { Node temp = head; while (temp.next != null && temp.next.value < value) { temp = temp.next; } newNode.next = temp.next; temp.next = newNode; if (newNode.next == null) { this.tail = newNode; } } } /** * Deletes the first occurrence of a specified integer in the list. * * @param value the integer to delete * @return {@code true} if the element was found and deleted; {@code false} otherwise */ public boolean delete(int value) { if (this.head == null) { return false; } else if (this.head.value == value) { if (this.head.next == null) { this.head = null; this.tail = null; } else { this.head = this.head.next; } return true; } else { Node temp = this.head; while (temp.next != null) { if (temp.next.value == value) { if (temp.next == this.tail) { this.tail = temp; } temp.next = temp.next.next; return true; } temp = temp.next; } return false; } } /** * Searches for a specified integer in the list. * * @param value the integer to search for * @return {@code true} if the value is present in the list; {@code false} otherwise */ public boolean search(int value) { Node temp = this.head; while (temp != null) { if (temp.value == value) { return true; } temp = temp.next; } return false; } /** * Checks if the list is empty. * * @return {@code true} if the list is empty; {@code false} otherwise */ public boolean isEmpty() { return head == null; } /** * Returns a string representation of the sorted linked list in the format [element1, element2, ...]. * * @return a string representation of the sorted linked list */ @Override public String toString() { if (this.head != null) { List<String> elements = new ArrayList<>(); Node temp = this.head; while (temp != null) { elements.add(String.valueOf(temp.value)); temp = temp.next; } return \"[\" + String.join(\", \", elements) + \"]\"; } else { return \"[]\"; } } /** * Node represents an element in the sorted linked list. */ public final class Node { public final int value; public Node next; public Node(int value) { this.value = value; this.next = null; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; public final class Sparsity { private Sparsity() { } public static double sparsity(double[][] dArray) { if (dArray == null || dArray.length == 0 || dArray[0].length == 0) { throw new IllegalArgumentException(\"Matrix cannot be null or empty\"); } int n = 0; int n2 = 0; for (double[] dArray2 : dArray) { double[] dArray3 = dArray2; dArray3 = dArray2; int n3 = dArray2.length; for (int i = 0; i < n3; ++i) { double d = dArray3[i]; if (d == 0.0) { ++n; } ++n2; } } return (double)n / (double)n2; } }", "deobfuscated_code": "package com.thealgorithms.misc; /** * Utility class for calculating the sparsity of a matrix. * A matrix is considered sparse if a large proportion of its elements are zero. * Typically, if more than 2/3 of the elements are zero, the matrix is considered sparse. * * Sparsity is defined as: * sparsity = (number of zero elements) / (total number of elements) * * This can lead to significant computational optimizations. */ public final class Sparsity { private Sparsity() { } /** * Calculates the sparsity of a given 2D matrix. * * @param matrix the input matrix * @return the sparsity value between 0 and 1 * @throws IllegalArgumentException if the matrix is null, empty, or contains empty rows */ public static double sparsity(double[][] matrix) { if (matrix == null || matrix.length == 0 || matrix[0].length == 0) { throw new IllegalArgumentException(\"Matrix cannot be null or empty\"); } int zeroCount = 0; int totalElements = 0; // Count the number of zero elements and total elements for (double[] row : matrix) { for (double value : row) { if (value == 0.0) { zeroCount++; } totalElements++; } } // Return sparsity as a double return (double) zeroCount / totalElements; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; public class SplayTree$DuplicateKeyException extends RuntimeException { public SplayTree$DuplicateKeyException(String string) { super(string); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; public class SplayTree$DuplicateKeyException extends RuntimeException { public SplayTree$DuplicateKeyException(String string) { super(string); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; public class SplayTree$EmptyTreeException extends RuntimeException { public SplayTree$EmptyTreeException(String string) { super(string); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; public class SplayTree$EmptyTreeException extends RuntimeException { public SplayTree$EmptyTreeException(String string) { super(string); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.SplayTree$Node; import com.thealgorithms.datastructures.trees.SplayTree$TreeTraversal; import java.util.List; final class SplayTree$InOrderTraversal implements SplayTree$TreeTraversal { private SplayTree$InOrderTraversal() { } @Override public final void traverse(SplayTree$Node splayTree$Node, List list) { while (splayTree$Node != null) { this.traverse(splayTree$Node.b, list); list.add(splayTree$Node.a); splayTree$Node = splayTree$Node.c; } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.SplayTree$Node; import com.thealgorithms.datastructures.trees.SplayTree$TreeTraversal; import java.util.List; final class SplayTree$InOrderTraversal implements SplayTree$TreeTraversal { private SplayTree$InOrderTraversal() { } @Override public final void traverse(SplayTree$Node splayTree$Node, List list) { while (splayTree$Node != null) { this.traverse(splayTree$Node.b, list); list.add(splayTree$Node.a); splayTree$Node = splayTree$Node.c; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class SplayTree$Node { final int a; SplayTree$Node b; SplayTree$Node c; SplayTree$Node(int n) { this.a = n; this.b = null; this.c = null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; class SplayTree$Node { final int a; SplayTree$Node b; SplayTree$Node c; SplayTree$Node(int n) { this.a = n; this.b = null; this.c = null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.SplayTree$Node; import com.thealgorithms.datastructures.trees.SplayTree$TreeTraversal; import java.util.List; final class SplayTree$PostOrderTraversal implements SplayTree$TreeTraversal { private SplayTree$PostOrderTraversal() { } @Override public final void traverse(SplayTree$Node splayTree$Node, List list) { if (splayTree$Node != null) { this.traverse(splayTree$Node.b, list); this.traverse(splayTree$Node.c, list); list.add(splayTree$Node.a); } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.SplayTree$Node; import com.thealgorithms.datastructures.trees.SplayTree$TreeTraversal; import java.util.List; final class SplayTree$PostOrderTraversal implements SplayTree$TreeTraversal { private SplayTree$PostOrderTraversal() { } @Override public final void traverse(SplayTree$Node splayTree$Node, List list) { if (splayTree$Node != null) { this.traverse(splayTree$Node.b, list); this.traverse(splayTree$Node.c, list); list.add(splayTree$Node.a); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.SplayTree$Node; import com.thealgorithms.datastructures.trees.SplayTree$TreeTraversal; import java.util.List; final class SplayTree$PreOrderTraversal implements SplayTree$TreeTraversal { private SplayTree$PreOrderTraversal() { } @Override public final void traverse(SplayTree$Node splayTree$Node, List list) { while (splayTree$Node != null) { list.add(splayTree$Node.a); this.traverse(splayTree$Node.b, list); splayTree$Node = splayTree$Node.c; } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.SplayTree$Node; import com.thealgorithms.datastructures.trees.SplayTree$TreeTraversal; import java.util.List; final class SplayTree$PreOrderTraversal implements SplayTree$TreeTraversal { private SplayTree$PreOrderTraversal() { } @Override public final void traverse(SplayTree$Node splayTree$Node, List list) { while (splayTree$Node != null) { list.add(splayTree$Node.a); this.traverse(splayTree$Node.b, list); splayTree$Node = splayTree$Node.c; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.SplayTree$Node; import java.util.List; public interface SplayTree$TreeTraversal { public void traverse(SplayTree$Node var1, List var2); }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.SplayTree$Node; import java.util.List; public interface SplayTree$TreeTraversal { public void traverse(SplayTree$Node var1, List var2); }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.SplayTree$DuplicateKeyException; import com.thealgorithms.datastructures.trees.SplayTree$EmptyTreeException; import com.thealgorithms.datastructures.trees.SplayTree$InOrderTraversal; import com.thealgorithms.datastructures.trees.SplayTree$Node; import com.thealgorithms.datastructures.trees.SplayTree$PostOrderTraversal; import com.thealgorithms.datastructures.trees.SplayTree$PreOrderTraversal; import com.thealgorithms.datastructures.trees.SplayTree$TreeTraversal; import java.util.LinkedList; import java.util.List; public class SplayTree { public static final SplayTree$TreeTraversal PRE_ORDER = new SplayTree$PreOrderTraversal(); public static final SplayTree$TreeTraversal IN_ORDER = new SplayTree$InOrderTraversal(); public static final SplayTree$TreeTraversal POST_ORDER = new SplayTree$PostOrderTraversal(); private SplayTree$Node a; public boolean isEmpty() { return this.a == null; } public void insert(int n) { this.a = this.b(this.a, n); this.a = this.a(this.a, n); } public boolean search(int n) { this.a = this.a(this.a, n); return this.a != null && this.a.a == n; } public void delete(int n) { SplayTree$Node splayTree$Node; if (this.isEmpty()) { throw new SplayTree$EmptyTreeException(\"Cannot delete from an empty tree\"); } this.a = this.a(this.a, n); if (this.a.a != n) { return; } if (this.a.b == null) { this.a = this.a.c; return; } SplayTree$Node splayTree$Node2 = this.a; SplayTree$Node splayTree$Node3 = splayTree$Node = this.a.b; while (splayTree$Node.c != null) { splayTree$Node = splayTree$Node.c; } this.a = this.a(splayTree$Node3, splayTree$Node.a); this.a.c = splayTree$Node2.c; } public List traverse(SplayTree$TreeTraversal splayTree$TreeTraversal) { LinkedList linkedList = new LinkedList(); splayTree$TreeTraversal.traverse(this.a, linkedList); return linkedList; } private static SplayTree$Node a(SplayTree$Node splayTree$Node) { SplayTree$Node splayTree$Node2 = splayTree$Node.b; splayTree$Node.b = splayTree$Node2.c; splayTree$Node2.c = splayTree$Node; return splayTree$Node2; } private static SplayTree$Node b(SplayTree$Node splayTree$Node) { SplayTree$Node splayTree$Node2 = splayTree$Node.c; splayTree$Node.c = splayTree$Node2.b; splayTree$Node2.b = splayTree$Node; return splayTree$Node2; } private SplayTree$Node a(SplayTree$Node splayTree$Node, int n) { if (splayTree$Node == null || splayTree$Node.a == n) { return splayTree$Node; } if (splayTree$Node.a > n) { if (splayTree$Node.b == null) { return splayTree$Node; } if (splayTree$Node.b.a > n) { splayTree$Node.b.b = this.a(splayTree$Node.b.b, n); splayTree$Node = SplayTree.a(splayTree$Node); } else if (splayTree$Node.b.a < n) { splayTree$Node.b.c = this.a(splayTree$Node.b.c, n); if (splayTree$Node.b.c != null) { splayTree$Node.b = SplayTree.b(splayTree$Node.b); } } if (splayTree$Node.b == null) { return splayTree$Node; } return SplayTree.a(splayTree$Node); } if (splayTree$Node.c == null) { return splayTree$Node; } if (splayTree$Node.c.a > n) { splayTree$Node.c.b = this.a(splayTree$Node.c.b, n); if (splayTree$Node.c.b != null) { splayTree$Node.c = SplayTree.a(splayTree$Node.c); } } else if (splayTree$Node.c.a < n) { splayTree$Node.c.c = this.a(splayTree$Node.c.c, n); splayTree$Node = SplayTree.b(splayTree$Node); } if (splayTree$Node.c == null) { return splayTree$Node; } return SplayTree.b(splayTree$Node); } private SplayTree$Node b(SplayTree$Node splayTree$Node, int n) { if (splayTree$Node == null) { return new SplayTree$Node(n); } if (n < splayTree$Node.a) { splayTree$Node.b = this.b(splayTree$Node.b, n); } else if (n > splayTree$Node.a) { splayTree$Node.c = this.b(splayTree$Node.c, n); } else { throw new SplayTree$DuplicateKeyException(\"Duplicate key: \" + n); } return splayTree$Node; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.LinkedList; import java.util.List; /** * Implementation of a Splay Tree data structure. * * A splay tree is a self-adjusting binary search tree with the additional * property * that recently accessed elements are quick to access again. It performs basic * operations such as insertion, deletion, and searching in O(log n) amortized * time, * where n is the number of elements in the tree. * * The key feature of splay trees is the splay operation, which moves a node * closer * to the root of the tree when it is accessed. This operation helps to maintain * good balance and improves the overall performance of the tree. After * performing * a splay operation, the accessed node becomes the new root of the tree. * * Splay trees have applications in various areas, including caching, network * routing, * and dynamic optimality analysis. */ public class SplayTree { public static final TreeTraversal PRE_ORDER = new PreOrderTraversal(); public static final TreeTraversal IN_ORDER = new InOrderTraversal(); public static final TreeTraversal POST_ORDER = new PostOrderTraversal(); private Node root; /** * Checks if the tree is empty. * * @return True if the tree is empty, otherwise false. */ public boolean isEmpty() { return root == null; } /** * Insert a key into the SplayTree. * * @param key The key to insert. */ public void insert(final int key) { root = insertRec(root, key); root = splay(root, key); } /** * Search for a key in the SplayTree. * * @param key The key to search for. * @return True if the key is found, otherwise false. */ public boolean search(int key) { root = splay(root, key); return root != null && root.key == key; } /** * Deletes a key from the SplayTree. * * @param key The key to delete. * @throws IllegalArgumentException If the tree is empty. */ public void delete(final int key) { if (isEmpty()) { throw new EmptyTreeException(\"Cannot delete from an empty tree\"); } root = splay(root, key); if (root.key != key) { return; } if (root.left == null) { root = root.right; } else { Node temp = root; root = splay(root.left, findMax(root.left).key); root.right = temp.right; } } /** * Perform a traversal of the SplayTree. * * @param traversal The type of traversal method. * @return A list containing the keys in the specified traversal order. */ public List<Integer> traverse(TreeTraversal traversal) { List<Integer> result = new LinkedList<>(); traversal.traverse(root, result); return result; } /** * Finds the node with the maximum key in a given subtree. * * <p> * This method traverses the right children of the subtree until it finds the * rightmost node, which contains the maximum key. * </p> * * @param root The root node of the subtree. * @return The node with the maximum key in the subtree. */ private Node findMax(Node root) { while (root.right != null) { root = root.right; } return root; } /** * Zig operation. * * <p> * The zig operation is used to perform a single rotation on a node to move it * closer to * the root of the tree. It is typically applied when the node is a left child * of its parent * and needs to be rotated to the right. * </p> * * @param x The node to perform the zig operation on. * @return The new root node after the operation. */ private Node rotateRight(Node x) { Node y = x.left; x.left = y.right; y.right = x; return y; } /** * Zag operation. * * <p> * The zag operation is used to perform a single rotation on a node to move it * closer to * the root of the tree. It is typically applied when the node is a right child * of its parent * and needs to be rotated to the left. * </p> * * @param x The node to perform the zag operation on. * @return The new root node after the operation. */ private Node rotateLeft(Node x) { Node y = x.right; x.right = y.left; y.left = x; return y; } /** * Splay operation. * * <p> * The splay operation is the core operation of a splay tree. It moves a * specified node * closer to the root of the tree by performing a series of rotations. The goal * of the splay * operation is to improve the access time for frequently accessed nodes by * bringing them * closer to the root. * </p> * * <p> * The splay operation consists of three main cases: * <ul> * <li>Zig-Zig case: Perform two consecutive rotations.</li> * <li>Zig-Zag case: Perform two consecutive rotations in opposite * directions.</li> * <li>Zag-Zag case: Perform two consecutive rotations.</li> * </ul> * </p> * * <p> * After performing the splay operation, the accessed node becomes the new root * of the tree. * </p> * * @param root The root of the subtree to splay. * @param key The key to splay around. * @return The new root of the splayed subtree. */ private Node splay(Node root, final int key) { if (root == null || root.key == key) { return root; } if (root.key > key) { if (root.left == null) { return root; } // Zig-Zig case if (root.left.key > key) { root.left.left = splay(root.left.left, key); root = rotateRight(root); } else if (root.left.key < key) { root.left.right = splay(root.left.right, key); if (root.left.right != null) { root.left = rotateLeft(root.left); } } return (root.left == null) ? root : rotateRight(root); } else { if (root.right == null) { return root; } // Zag-Zag case if (root.right.key > key) { root.right.left = splay(root.right.left, key); if (root.right.left != null) { root.right = rotateRight(root.right); } } else if (root.right.key < key) { root.right.right = splay(root.right.right, key); root = rotateLeft(root); } return (root.right == null) ? root : rotateLeft(root); } } private Node insertRec(Node root, final int key) { if (root == null) { return new Node(key); } if (key < root.key) { root.left = insertRec(root.left, key); } else if (key > root.key) { root.right = insertRec(root.right, key); } else { throw new DuplicateKeyException(\"Duplicate key: \" + key); } return root; } public static class EmptyTreeException extends RuntimeException { private static final long serialVersionUID = 1L; public EmptyTreeException(String message) { super(message); } } public static class DuplicateKeyException extends RuntimeException { private static final long serialVersionUID = 1L; public DuplicateKeyException(String message) { super(message); } } private static class Node { final int key; Node left; Node right; Node(int key) { this.key = key; left = null; right = null; } } public interface TreeTraversal { /** * Recursive function for a specific order traversal. * * @param root The root of the subtree to traverse. * @param result The list to store the traversal result. */ void traverse(Node root, List<Integer> result); } private static final class InOrderTraversal implements TreeTraversal { private InOrderTraversal() { } public void traverse(Node root, List<Integer> result) { if (root != null) { traverse(root.left, result); result.add(root.key); traverse(root.right, result); } } } private static final class PreOrderTraversal implements TreeTraversal { private PreOrderTraversal() { } public void traverse(Node root, List<Integer> result) { if (root != null) { result.add(root.key); traverse(root.left, result); traverse(root.right, result); } } } private static final class PostOrderTraversal implements TreeTraversal { private PostOrderTraversal() { } public void traverse(Node root, List<Integer> result) { if (root != null) { traverse(root.left, result); traverse(root.right, result); result.add(root.key); } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.Arrays; class SpreadSort$Bucket { private Comparable[] a; private int b; SpreadSort$Bucket(int n) { this.a = new Comparable[n]; this.b = 0; } final void a(Comparable comparable) { if (this.b == this.a.length) { this.a = Arrays.copyOf(this.a, this.b << 1); } this.a[this.b++] = comparable; } final int a() { return this.b; } final Comparable[] b() { return Arrays.copyOf(this.a, this.b); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import java.util.Arrays; class SpreadSort$Bucket { private Comparable[] a; private int b; SpreadSort$Bucket(int n) { this.a = new Comparable[n]; this.b = 0; } final void a(Comparable comparable) { if (this.b == this.a.length) { this.a = Arrays.copyOf(this.a, this.b << 1); } this.a[this.b++] = comparable; } final int a() { return this.b; } final Comparable[] b() { return Arrays.copyOf(this.a, this.b); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; import com.thealgorithms.sorts.SpreadSort$Bucket; public class SpreadSort implements SortAlgorithm { private final int a; private final int b; private final int c; public SpreadSort(int n, int n2, int n3) { if (n <= 0 || n > 1000) { throw new IllegalArgumentException(\"Insertion sort threshold must be between 1 and 1000\"); } if (n2 <= 0 || n2 > 1000) { throw new IllegalArgumentException(\"Initial bucket capacity must be between 1 and 1000\"); } if (n3 <= 0 || n3 > 100) { throw new IllegalArgumentException(\"Minimum number of buckets must be between 1 and 100\"); } this.a = n; this.b = n2; this.c = n3; } public SpreadSort() { this(16, 16, 2); } @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length == 0) { return comparableArray; } this.a(comparableArray, 0, comparableArray.length - 1); return comparableArray; } private void a(Comparable[] comparableArray, int n, int n2) { Comparable comparable; if (n2 <= 0) { return; } if (n2 < this.a) { SpreadSort.d(comparableArray, 0, n2); return; } Comparable comparable2 = SpreadSort.b(comparableArray, 0, n2); if (comparable2.equals(comparable = SpreadSort.c(comparableArray, 0, n2))) { return; } int n3 = this.a(n2 + 1); SpreadSort$Bucket[] spreadSort$BucketArray = this.b(n3); SpreadSort.a(comparableArray, 0, n2, comparable2, comparable, n3, spreadSort$BucketArray); this.a(comparableArray, 0, spreadSort$BucketArray); } private static Comparable b(Comparable[] comparableArray, int n, int n2) { Comparable comparable = comparableArray[n]; ++n; while (n <= n2) { if (SortUtils.less(comparableArray[n], comparable)) { comparable = comparableArray[n]; } ++n; } return comparable; } private static Comparable c(Comparable[] comparableArray, int n, int n2) { Comparable comparable = comparableArray[n]; ++n; while (n <= n2) { if (SortUtils.greater(comparableArray[n], comparable)) { comparable = comparableArray[n]; } ++n; } return comparable; } private int a(int n) { return Math.max(n /= this.a, this.c); } private SpreadSort$Bucket[] b(int n) { SpreadSort$Bucket[] spreadSort$BucketArray = new SpreadSort$Bucket[n]; for (int i = 0; i < n; ++i) { spreadSort$BucketArray[i] = new SpreadSort$Bucket(this.b); } return spreadSort$BucketArray; } private static void a(Comparable[] comparableArray, int n, int n2, Comparable comparable, Comparable comparable2, int n3, SpreadSort$Bucket[] spreadSort$BucketArray) { double d = comparable2.compareTo(comparable); while (n <= n2) { int n4 = comparableArray[n].compareTo(comparable) * n3; n4 = (int)((double)n4 / (d + 1.0)); spreadSort$BucketArray[n4].a(comparableArray[n]); ++n; } } private void a(Comparable[] comparableArray, int n, SpreadSort$Bucket[] spreadSort$BucketArray) { for (SpreadSort$Bucket spreadSort$Bucket : spreadSort$BucketArray) { if (spreadSort$Bucket.a() <= 0) continue; Comparable[] comparableArray2 = spreadSort$Bucket.b(); this.a(comparableArray2, 0, comparableArray2.length - 1); Comparable[] comparableArray3 = comparableArray2; int n2 = comparableArray2.length; for (int i = 0; i < n2; ++i) { Comparable comparable = comparableArray3[i]; comparableArray[n++] = comparable; } } } private static void d(Comparable[] comparableArray, int n, int n2) { for (int i = n + 1; i <= n2; ++i) { Comparable comparable = comparableArray[i]; for (int j = i - 1; j >= n && SortUtils.greater(comparableArray[j], comparable); --j) { comparableArray[j + 1] = comparableArray[j]; } comparableArray[j + 1] = comparable; } } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.Arrays; /** * SpreadSort is a highly efficient sorting algorithm suitable for large datasets. * It distributes elements into buckets and recursively sorts these buckets. * This implementation is generic and can sort any array of elements that extend Comparable. */ @SuppressWarnings(\"rawtypes\") public class SpreadSort implements SortAlgorithm { private static final int MAX_INSERTION_SORT_THRESHOLD = 1000; private static final int MAX_INITIAL_BUCKET_CAPACITY = 1000; private static final int MAX_MIN_BUCKETS = 100; private final int insertionSortThreshold; private final int initialBucketCapacity; private final int minBuckets; /** * Constructor to initialize the SpreadSort algorithm with custom parameters. * * @param insertionSortThreshold the threshold for using insertion sort for small segments (1-1000) * @param initialBucketCapacity the initial capacity for each bucket (1-1000) * @param minBuckets the minimum number of buckets to use (1-100) */ public SpreadSort(int insertionSortThreshold, int initialBucketCapacity, int minBuckets) { if (insertionSortThreshold < 1 || insertionSortThreshold > MAX_INSERTION_SORT_THRESHOLD) { throw new IllegalArgumentException(\"Insertion sort threshold must be between 1 and \" + MAX_INSERTION_SORT_THRESHOLD); } if (initialBucketCapacity < 1 || initialBucketCapacity > MAX_INITIAL_BUCKET_CAPACITY) { throw new IllegalArgumentException(\"Initial bucket capacity must be between 1 and \" + MAX_INITIAL_BUCKET_CAPACITY); } if (minBuckets < 1 || minBuckets > MAX_MIN_BUCKETS) { throw new IllegalArgumentException(\"Minimum number of buckets must be between 1 and \" + MAX_MIN_BUCKETS); } this.insertionSortThreshold = insertionSortThreshold; this.initialBucketCapacity = initialBucketCapacity; this.minBuckets = minBuckets; } /** * Default constructor with predefined values. */ public SpreadSort() { this(16, 16, 2); } /** * Sorts an array using the SpreadSort algorithm. * * @param array the array to be sorted * @param <T> the type of elements in the array * @return the sorted array */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length == 0) { return array; } spreadSort(array, 0, array.length - 1); return array; } /** * Internal method to sort an array segment using the SpreadSort algorithm. * * @param array the array to be sorted * @param left the left boundary of the segment * @param right the right boundary of the segment * @param <T> the type of elements in the array */ private <T extends Comparable<T>> void spreadSort(final T[] array, final int left, final int right) { if (left >= right) { return; } // Base case for small segments if (right - left < insertionSortThreshold) { insertionSort(array, left, right); return; } T min = findMin(array, left, right); T max = findMax(array, left, right); if (min.equals(max)) { return; // All elements are the same } int numBuckets = calculateNumBuckets(right - left + 1); final Bucket<T>[] buckets = createBuckets(numBuckets); distributeElements(array, left, right, min, max, numBuckets, buckets); collectElements(array, left, buckets); } /** * Finds the minimum element in the specified segment of the array. * * @param array the array to search * @param left the left boundary of the segment * @param right the right boundary of the segment * @param <T> the type of elements in the array * @return the minimum element */ private <T extends Comparable<T>> T findMin(final T[] array, final int left, final int right) { T min = array[left]; for (int i = left + 1; i <= right; i++) { if (SortUtils.less(array[i], min)) { min = array[i]; } } return min; } /** * Finds the maximum element in the specified segment of the array. * * @param array the array to search * @param left the left boundary of the segment * @param right the right boundary of the segment * @param <T> the type of elements in the array * @return the maximum element */ private <T extends Comparable<T>> T findMax(final T[] array, final int left, final int right) { T max = array[left]; for (int i = left + 1; i <= right; i++) { if (SortUtils.greater(array[i], max)) { max = array[i]; } } return max; } /** * Calculates the number of buckets needed based on the size of the segment. * * @param segmentSize the size of the segment * @return the number of buckets */ private int calculateNumBuckets(final int segmentSize) { int numBuckets = segmentSize / insertionSortThreshold; return Math.max(numBuckets, minBuckets); } /** * Creates an array of buckets. * * @param numBuckets the number of buckets to create * @param <T> the type of elements in the buckets * @return an array of buckets */ @SuppressWarnings(\"unchecked\") private <T extends Comparable<T>> Bucket<T>[] createBuckets(final int numBuckets) { final Bucket<T>[] buckets = new Bucket[numBuckets]; for (int i = 0; i < numBuckets; i++) { buckets[i] = new Bucket<>(initialBucketCapacity); } return buckets; } /** * Distributes elements of the array segment into buckets. * * @param array the array to be sorted * @param left the left boundary of the segment * @param right the right boundary of the segment * @param min the minimum element in the segment * @param max the maximum element in the segment * @param numBuckets the number of buckets * @param buckets the array of buckets * @param <T> the type of elements in the array */ private <T extends Comparable<T>> void distributeElements(final T[] array, final int left, final int right, final T min, final T max, final int numBuckets, final Bucket<T>[] buckets) { final double range = max.compareTo(min); for (int i = left; i <= right; i++) { final int scaleRangeDifference = array[i].compareTo(min) * numBuckets; int bucketIndex = (int) (scaleRangeDifference / (range + 1)); buckets[bucketIndex].add(array[i]); } } /** * Collects elements from the buckets back into the array. * * @param array the array to be sorted * @param left the left boundary of the segment * @param buckets the array of buckets * @param <T> the type of elements in the array */ private <T extends Comparable<T>> void collectElements(final T[] array, final int left, final Bucket<T>[] buckets) { int index = left; for (Bucket<T> bucket : buckets) { if (bucket.size() > 0) { T[] bucketArray = bucket.toArray(); spreadSort(bucketArray, 0, bucketArray.length - 1); for (T element : bucketArray) { array[index++] = element; } } } } /** * Insertion sort implementation for small segments. * * @param array the array to be sorted * @param left the left boundary of the segment * @param right the right boundary of the segment * @param <T> the type of elements in the array */ private <T extends Comparable<T>> void insertionSort(final T[] array, final int left, final int right) { for (int i = left + 1; i <= right; i++) { T key = array[i]; int j = i - 1; while (j >= left && SortUtils.greater(array[j], key)) { array[j + 1] = array[j]; j--; } array[j + 1] = key; } } /** * Bucket class to hold elements during sorting. * * @param <T> the type of elements in the bucket */ private static class Bucket<T extends Comparable<T>> { private T[] elements; private int size; /** * Constructs a new bucket with initial capacity. */ @SuppressWarnings(\"unchecked\") Bucket(int initialBucketCapacity) { elements = (T[]) new Comparable[initialBucketCapacity]; size = 0; } /** * Adds an element to the bucket. * * @param element the element to add */ void add(T element) { if (size == elements.length) { elements = Arrays.copyOf(elements, size * 2); } elements[size++] = element; } /** * Returns the number of elements in the bucket. * * @return the size of the bucket */ int size() { return size; } /** * Returns an array containing all elements in the bucket. * * @return an array containing all elements in the bucket */ @SuppressWarnings(\"unchecked\") T[] toArray() { return Arrays.copyOf(elements, size); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths.Prime; import com.thealgorithms.maths.Prime.PrimeFactorization; import java.util.HashSet; import java.util.List; public final class SquareFreeInteger { private SquareFreeInteger() { } public static boolean isSquareFreeInteger(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Number must be greater than zero.\"); } List list = PrimeFactorization.pfactors(n); return list.size() == new HashSet(list).size(); } }", "deobfuscated_code": "package com.thealgorithms.maths.Prime; /* * Java program for Square free integer * This class has a function which checks * if an integer has repeated prime factors * and will return false if the number has repeated prime factors. * true otherwise * Wikipedia: https://en.wikipedia.org/wiki/Square-free_integer * * Author: Akshay Dubey (https://github.com/itsAkshayDubey) * * */ import java.util.HashSet; import java.util.List; public final class SquareFreeInteger { private SquareFreeInteger() { } /** * This method returns whether an integer is square free * * @param number Integer value which is to be checked * @return false when number has repeated prime factors * true when number has non repeated prime factors * @throws IllegalArgumentException when number is negative or zero */ public static boolean isSquareFreeInteger(int number) { if (number <= 0) { // throw exception when number is less than or is zero throw new IllegalArgumentException(\"Number must be greater than zero.\"); } // Store prime factors of number which is passed as argument // in a list List<Integer> primeFactorsList = PrimeFactorization.pfactors(number); // Create set from list of prime factors of integer number // if size of list and set is equal then the argument passed to this method is square free // if size of list and set is not equal then the argument passed to this method is not // square free return primeFactorsList.size() == new HashSet<>(primeFactorsList).size(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; public final class SquareRootBinarySearch { private SquareRootBinarySearch() { } }", "deobfuscated_code": "package com.thealgorithms.searches; /** * Given an integer x, find the square root of x. If x is not a perfect square, * then return floor(x). * <p> * For example, if x = 5, The answer should be 2 which is the floor value of 5. * <p> * The approach that will be used for solving the above problem is not going to * be a straight forward Math.sqrt(). Instead we will be using Binary Search to * find the square root of a number in the most optimised way. * * @author sahil */ public final class SquareRootBinarySearch { private SquareRootBinarySearch() { } /** * This function calculates the floor of square root of a number. We use * Binary Search algorithm to calculate the square root in a more optimised * way. * * @param num Number * @return answer */ static long squareRoot(long num) { if (num == 0 || num == 1) { return num; } long l = 1; long r = num; long ans = 0; while (l <= r) { long mid = l + (r - l) / 2; if (mid == num / mid) { return mid; } else if (mid < num / mid) { ans = mid; l = mid + 1; } else { r = mid - 1; } } return ans; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class SquareRootWithBabylonianMethod { private SquareRootWithBabylonianMethod() { } public static float squareRoot(float f) { float f2 = f; float f3 = 1.0f; while ((double)(f2 - f3) > 1.0E-6) { f2 = (f2 + f3) / 2.0f; f3 = f / f2; } return f2; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class SquareRootWithBabylonianMethod { private SquareRootWithBabylonianMethod() { } /** * get the value, return the square root * * @param num contains elements * @return the square root of num */ public static float squareRoot(float num) { float a = num; float b = 1; double e = 0.000001; while (a - b > e) { a = (a + b) / 2; b = num / a; } return a; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class SquareRootWithNewtonRaphsonMethod { private SquareRootWithNewtonRaphsonMethod() { } public static double squareRoot(int n) { double d = n; double d2 = 0.5 * (d + (double)n / d); while (Math.abs(d2 - d) > 1.0E-7) { d = d2; d2 = 0.5 * (d + (double)n / d); } return d2; } }", "deobfuscated_code": "package com.thealgorithms.maths; /* *To learn about the method, visit the link below : * https://en.wikipedia.org/wiki/Newton%27s_method * * To obtain the square root, no built-in functions should be used * * The formula to calculate the root is : root = 0.5(x + n/x), * here, n is the no. whose square root has to be calculated and * x has to be guessed such that, the calculation should result into * the square root of n. * And the root will be obtained when the error < 0.5 or the precision value can also * be changed according to the user preference. */ public final class SquareRootWithNewtonRaphsonMethod { private SquareRootWithNewtonRaphsonMethod() { } public static double squareRoot(int n) { double x = n; // initially taking a guess that x = n. double root = 0.5 * (x + n / x); // applying Newton-Raphson Method. while (Math.abs(root - x) > 0.0000001) { // root - x = error and error < 0.0000001, 0.0000001 // is the precision value taken over here. x = root; // decreasing the value of x to root, i.e. decreasing the guess. root = 0.5 * (x + n / x); } return root; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.stacks; public interface Stack { public void push(Object var1); public Object pop(); public Object peek(); public boolean isEmpty(); public int size(); public void makeEmpty(); }", "deobfuscated_code": "package com.thealgorithms.datastructures.stacks; /** * A generic interface for Stack data structures. * * @param <T> the type of elements in this stack */ public interface Stack<T> { /** * Adds an element to the top of the stack. * * @param value The element to add. */ void push(T value); /** * Removes the element at the top of this stack and returns it. * * @return The element popped from the stack. * @throws IllegalStateException if the stack is empty. */ T pop(); /** * Returns the element at the top of this stack without removing it. * * @return The element at the top of this stack. * @throws IllegalStateException if the stack is empty. */ T peek(); /** * Tests if this stack is empty. * * @return {@code true} if this stack is empty; {@code false} otherwise. */ boolean isEmpty(); /** * Returns the size of this stack. * * @return The number of elements in this stack. */ int size(); /** * Removes all elements from this stack. */ void makeEmpty(); }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.stacks; import com.thealgorithms.datastructures.stacks.Stack; public class StackArray implements Stack { private int a; private Object[] b; private int c; public StackArray() { this(10); } public StackArray(int n) { if (n <= 0) { throw new IllegalArgumentException(\"Stack size must be greater than 0\"); } this.a = n; this.b = new Object[n]; this.c = -1; } @Override public void push(Object object) { if (this.isFull()) { StackArray stackArray = this; stackArray.a(stackArray.a << 1); } this.b[++this.c] = object; } @Override public Object pop() { if (this.isEmpty()) { throw new IllegalStateException(\"Stack is empty, cannot pop element\"); } Object object = this.b[this.c--]; if (this.c + 1 < this.a / 4 && this.a > 10) { StackArray stackArray = this; stackArray.a(stackArray.a / 2); } return object; } @Override public Object peek() { if (this.isEmpty()) { throw new IllegalStateException(\"Stack is empty, cannot peek element\"); } return this.b[this.c]; } private void a(int n) { Object[] objectArray = new Object[n]; System.arraycopy(this.b, 0, objectArray, 0, this.c + 1); this.b = objectArray; this.a = n; } public boolean isFull() { return this.c + 1 == this.a; } @Override public boolean isEmpty() { return this.c == -1; } @Override public void makeEmpty() { this.c = -1; } @Override public int size() { return this.c + 1; } public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"StackArray [\"); for (int i = 0; i <= this.c; ++i) { stringBuilder.append(this.b[i]); if (i >= this.c) continue; stringBuilder.append(\", \"); } stringBuilder.append(\"]\"); return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.stacks; /** * Implements a generic stack using an array. * * <p>This stack automatically resizes when necessary, growing to accommodate additional elements and * shrinking to conserve memory when its size significantly decreases. * * <p>Elements are pushed and popped in LIFO (last-in, first-out) order, where the last element added * is the first to be removed. * * @param <T> the type of elements in this stack */ public class StackArray<T> implements Stack<T> { private static final int DEFAULT_CAPACITY = 10; private int maxSize; private T[] stackArray; private int top; /** * Creates a stack with a default capacity. */ @SuppressWarnings(\"unchecked\") public StackArray() { this(DEFAULT_CAPACITY); } /** * Creates a stack with a specified initial capacity. * * @param size the initial capacity of the stack, must be greater than 0 * @throws IllegalArgumentException if size is less than or equal to 0 */ @SuppressWarnings(\"unchecked\") public StackArray(int size) { if (size <= 0) { throw new IllegalArgumentException(\"Stack size must be greater than 0\"); } this.maxSize = size; this.stackArray = (T[]) new Object[size]; this.top = -1; } /** * Pushes an element onto the top of the stack. Resizes the stack if it is full. * * @param value the element to push */ @Override public void push(T value) { if (isFull()) { resize(maxSize * 2); } stackArray[++top] = value; } /** * Removes and returns the element from the top of the stack. Shrinks the stack if * its size is below a quarter of its capacity, but not below the default capacity. * * @return the element removed from the top of the stack * @throws IllegalStateException if the stack is empty */ @Override public T pop() { if (isEmpty()) { throw new IllegalStateException(\"Stack is empty, cannot pop element\"); } T value = stackArray[top--]; if (top + 1 < maxSize / 4 && maxSize > DEFAULT_CAPACITY) { resize(maxSize / 2); } return value; } /** * Returns the element at the top of the stack without removing it. * * @return the top element of the stack * @throws IllegalStateException if the stack is empty */ @Override public T peek() { if (isEmpty()) { throw new IllegalStateException(\"Stack is empty, cannot peek element\"); } return stackArray[top]; } /** * Resizes the internal array to a new capacity. * * @param newSize the new size of the stack array */ private void resize(int newSize) { @SuppressWarnings(\"unchecked\") T[] newArray = (T[]) new Object[newSize]; System.arraycopy(stackArray, 0, newArray, 0, top + 1); stackArray = newArray; maxSize = newSize; } /** * Checks if the stack is full. * * @return true if the stack is full, false otherwise */ public boolean isFull() { return top + 1 == maxSize; } /** * Checks if the stack is empty. * * @return true if the stack is empty, false otherwise */ @Override public boolean isEmpty() { return top == -1; } /** * Empties the stack, marking it as empty without deleting elements. Elements are * overwritten on subsequent pushes. */ @Override public void makeEmpty() { top = -1; } /** * Returns the number of elements currently in the stack. * * @return the size of the stack */ @Override public int size() { return top + 1; } /** * Returns a string representation of the stack. * * @return a string representation of the stack */ @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\"StackArray [\"); for (int i = 0; i <= top; i++) { sb.append(stackArray[i]); if (i < top) { sb.append(\", \"); } } sb.append(\"]\"); return sb.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.stacks; import com.thealgorithms.datastructures.stacks.Stack; import java.util.ArrayList; import java.util.EmptyStackException; public class StackArrayList implements Stack { private final ArrayList a = new ArrayList(); @Override public void push(Object object) { this.a.add(object); } @Override public Object pop() { if (this.isEmpty()) { throw new EmptyStackException(); } return this.a.removeLast(); } @Override public Object peek() { if (this.isEmpty()) { throw new EmptyStackException(); } return this.a.getLast(); } @Override public boolean isEmpty() { return this.a.isEmpty(); } @Override public void makeEmpty() { this.a.clear(); } @Override public int size() { return this.a.size(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.stacks; import java.util.ArrayList; import java.util.EmptyStackException; /** * A stack implementation backed by an {@link ArrayList}, offering dynamic resizing * and LIFO (Last-In-First-Out) behavior. * * <p>The stack grows dynamically as elements are added, and elements are removed * in reverse order of their addition. * * @param <T> the type of elements stored in this stack */ public class StackArrayList<T> implements Stack<T> { private final ArrayList<T> stack; /** * Constructs an empty stack. */ public StackArrayList() { stack = new ArrayList<>(); } /** * Adds an element to the top of the stack. * * @param value the element to be added */ @Override public void push(T value) { stack.add(value); } /** * Removes and returns the element from the top of the stack. * * @return the element removed from the top of the stack * @throws EmptyStackException if the stack is empty */ @Override public T pop() { if (isEmpty()) { throw new EmptyStackException(); } return stack.removeLast(); } /** * Returns the element at the top of the stack without removing it. * * @return the top element of the stack * @throws EmptyStackException if the stack is empty */ @Override public T peek() { if (isEmpty()) { throw new EmptyStackException(); } return stack.getLast(); } /** * Checks if the stack is empty. * * @return {@code true} if the stack is empty, {@code false} otherwise */ @Override public boolean isEmpty() { return stack.isEmpty(); } /** * Empties the stack, removing all elements. */ @Override public void makeEmpty() { stack.clear(); } /** * Returns the number of elements in the stack. * * @return the current size of the stack */ @Override public int size() { return stack.size(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.stacks; final class StackOfLinkedList { private StackOfLinkedList() { } }", "deobfuscated_code": "package com.thealgorithms.datastructures.stacks; import java.util.NoSuchElementException; /** * A stack implementation using a singly linked list. * * <p>This class provides methods to push, pop, and peek elements in a Last-In-First-Out (LIFO) manner. * It keeps track of the number of elements in the stack and allows checking if the stack is empty. * * <p>This implementation does not allow null elements to be pushed onto the stack. */ final class StackOfLinkedList { private StackOfLinkedList() { } } // A node class for the linked list class Node { public int data; public Node next; Node(int data) { this.data = data; this.next = null; } } /** * A class that implements a stack using a linked list. * * <p>This stack supports basic operations: * <ul> * <li>push: Adds an element to the top of the stack</li> * <li>pop: Removes and returns the top element of the stack</li> * <li>peek: Returns the top element without removing it</li> * <li>isEmpty: Checks if the stack is empty</li> * <li>getSize: Returns the current size of the stack</li> * </ul> */ class LinkedListStack { private Node head; // Top of the stack private int size; // Number of elements in the stack /** * Initializes an empty stack. */ LinkedListStack() { head = null; size = 0; } /** * Adds an element to the top of the stack. * * @param x the element to be added * @return <tt>true</tt> if the element is added successfully */ public boolean push(int x) { Node newNode = new Node(x); newNode.next = head; head = newNode; size++; return true; } /** * Removes and returns the top element of the stack. * * @return the element at the top of the stack * @throws NoSuchElementException if the stack is empty */ public int pop() { if (size == 0) { throw new NoSuchElementException(\"Empty stack. Nothing to pop\"); } Node destroy = head; head = head.next; int retValue = destroy.data; destroy = null; // Help garbage collection size--; return retValue; } /** * Returns the top element of the stack without removing it. * * @return the element at the top of the stack * @throws NoSuchElementException if the stack is empty */ public int peek() { if (size == 0) { throw new NoSuchElementException(\"Empty stack. Nothing to peek\"); } return head.data; } @Override public String toString() { Node cur = head; StringBuilder builder = new StringBuilder(); while (cur != null) { builder.append(cur.data).append(\"->\"); cur = cur.next; } return builder.replace(builder.length() - 2, builder.length(), \"\").toString(); // Remove the last \"->\" } /** * Checks if the stack is empty. * * @return <tt>true</tt> if the stack is empty, <tt>false</tt> otherwise */ public boolean isEmpty() { return size == 0; } /** * Returns the current size of the stack. * * @return the number of elements in the stack */ public int getSize() { return size; } /** * Removes all elements from the stack. */ public void makeEmpty() { head = null; size = 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.Scanner; import java.util.Stack; import java.util.Vector; public final class StackPostfixNotation { private StackPostfixNotation() { } public static int postfixEvaluate(String object) { Stack stack = new Stack(); Object object2 = object; object = stack; object2 = new Scanner((String)object2); while (((Scanner)object2).hasNext()) { if (((Scanner)object2).hasNextInt()) { ((Stack)object).push(((Scanner)object2).nextInt()); continue; } String string = ((Scanner)object2).next(); Object object3 = object; if (((Vector)object3).size() < 2) { throw new IllegalArgumentException(\"exp is not a proper postfix expression (too few arguments).\"); } int n3 = -1; switch (string.hashCode()) { case 43: { if (!string.equals(\"+\")) break; n3 = 0; break; } case 45: { if (!string.equals(\"-\")) break; n3 = 1; break; } case 42: { if (!string.equals(\"*\")) break; n3 = 2; break; } case 47: { if (!string.equals(\"/\")) break; n3 = 3; } } ((Stack)object3).push((switch (n3) { case 0 -> (n, n2) -> n2 + n; case 1 -> (n, n2) -> n2 - n; case 2 -> (n, n2) -> n2 * n; case 3 -> (n, n2) -> n2 / n; default -> throw new IllegalArgumentException(\"exp contains an unknown operation.\"); }).apply((Integer)((Stack)object3).pop(), (Integer)((Stack)object3).pop())); } ((Scanner)object2).close(); if (stack.size() != 1) { throw new IllegalArgumentException(\"exp is not a proper postfix expression.\"); } return (Integer)stack.pop(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.Scanner; import java.util.Stack; import java.util.function.BiFunction; /** * Utility class for evaluating postfix expressions using integer arithmetic. * <p> * Postfix notation, also known as Reverse Polish Notation (RPN), is a mathematical notation in which operators follow their operands. * This class provides a method to evaluate expressions written in postfix notation. * </p> * <p> * For more information on postfix notation, refer to * <a href=\"https://en.wikipedia.org/wiki/Reverse_Polish_notation\">Reverse Polish Notation (RPN) on Wikipedia</a>. * </p> */ public final class StackPostfixNotation { private StackPostfixNotation() { } private static BiFunction<Integer, Integer, Integer> getOperator(final String operationSymbol) { // note the order of operands switch (operationSymbol) { case \"+\": return (a, b) -> b + a; case \"-\": return (a, b) -> b - a; case \"*\": return (a, b) -> b * a; case \"/\": return (a, b) -> b / a; default: throw new IllegalArgumentException(\"exp contains an unknown operation.\"); } } private static void performOperation(Stack<Integer> s, final String operationSymbol) { if (s.size() < 2) { throw new IllegalArgumentException(\"exp is not a proper postfix expression (too few arguments).\"); } s.push(getOperator(operationSymbol).apply(s.pop(), s.pop())); } private static void consumeExpression(Stack<Integer> s, final String exp) { Scanner tokens = new Scanner(exp); while (tokens.hasNext()) { if (tokens.hasNextInt()) { s.push(tokens.nextInt()); } else { performOperation(s, tokens.next()); } } tokens.close(); } /** * @brief Evaluates the given postfix expression. * @param exp the expression to evaluate. * @return the value of the given expression. * @exception IllegalArgumentException exp is not a valid postix expression. */ public static int postfixEvaluate(final String exp) { Stack<Integer> s = new Stack<>(); consumeExpression(s, exp); if (s.size() != 1) { throw new IllegalArgumentException(\"exp is not a proper postfix expression.\"); } return s.pop(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.stacks; import java.util.LinkedList; import java.util.NoSuchElementException; import java.util.Queue; public class StackUsingTwoQueues { private Queue a = new LinkedList(); private Queue b = new LinkedList(); public void push(int n) { this.b.add(n); while (!this.a.isEmpty()) { this.b.add((Integer)this.a.remove()); } Queue queue = this.a; this.a = this.b; this.b = queue; } public int pop() { if (this.a.isEmpty()) { throw new NoSuchElementException(\"Stack is empty\"); } return (Integer)this.a.remove(); } public Integer peek() { if (this.a.isEmpty()) { return null; } return (Integer)this.a.peek(); } public boolean isEmpty() { return this.a.isEmpty(); } public int size() { return this.a.size(); } }", "deobfuscated_code": "package com.thealgorithms.stacks; import java.util.LinkedList; import java.util.NoSuchElementException; import java.util.Queue; /** * A class that implements a stack using two queues. * This approach ensures that the stack's LIFO (Last In, First Out) behavior * is maintained by utilizing two queues for storage. * The mainQueue is used to store the elements of the stack, while the tempQueue * is used to temporarily store elements during the push operation. */ public class StackUsingTwoQueues { private Queue<Integer> mainQueue; private Queue<Integer> tempQueue; /** * Constructs an empty stack using two queues. */ public StackUsingTwoQueues() { mainQueue = new LinkedList<>(); tempQueue = new LinkedList<>(); } /** * Pushes an element onto the top of the stack. * The newly pushed element becomes the top of the stack. * * @param item The element to be pushed onto the stack. */ public void push(int item) { tempQueue.add(item); // Move all elements from the mainQueue to tempQueue to maintain LIFO order while (!mainQueue.isEmpty()) { tempQueue.add(mainQueue.remove()); } // Swap the names of the two queues Queue<Integer> swap = mainQueue; mainQueue = tempQueue; tempQueue = swap; // tempQueue is now empty } /** * Removes and returns the element at the top of the stack. * Throws an exception if the stack is empty. * * @return The element at the top of the stack. * @throws NoSuchElementException if the stack is empty. */ public int pop() { if (mainQueue.isEmpty()) { throw new NoSuchElementException(\"Stack is empty\"); } return mainQueue.remove(); } /** * Returns the element at the top of the stack without removing it. * Returns null if the stack is empty. * * @return The element at the top of the stack, or null if the stack is empty. */ public Integer peek() { if (mainQueue.isEmpty()) { return null; } return mainQueue.peek(); } /** * Returns true if the stack is empty. * * @return true if the stack is empty; false otherwise. */ public boolean isEmpty() { return mainQueue.isEmpty(); } /** * Returns the number of elements in the stack. * * @return The size of the stack. */ public int size() { return mainQueue.size(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; import java.lang.reflect.Array; public class StalinSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length == 0) { return comparableArray; } int n = 0; for (int i = 1; i < comparableArray.length; ++i) { if (!SortUtils.a(comparableArray[i], comparableArray[n])) continue; comparableArray[++n] = comparableArray[i]; } Comparable[] comparableArray2 = (Comparable[])Array.newInstance(comparableArray.getClass().getComponentType(), n + 1); System.arraycopy(comparableArray, 0, comparableArray2, 0, n + 1); return comparableArray2; } }", "deobfuscated_code": "package com.thealgorithms.sorts; public class StalinSort implements SortAlgorithm { @SuppressWarnings(\"unchecked\") public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length == 0) { return array; } int currentIndex = 0; for (int i = 1; i < array.length; i++) { if (SortUtils.greaterOrEqual(array[i], array[currentIndex])) { currentIndex++; array[currentIndex] = array[i]; } } // Create a result array with sorted elements T[] result = (T[]) java.lang.reflect.Array.newInstance(array.getClass().getComponentType(), currentIndex + 1); System.arraycopy(array, 0, result, 0, currentIndex + 1); return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class StandardDeviation { private StandardDeviation() { } public static double stdDev(double[] dArray) { int n; double d = 0.0; double d2 = 0.0; for (n = 0; n < dArray.length; ++n) { d2 += dArray[n]; } d2 /= (double)dArray.length; for (n = 0; n < dArray.length; ++n) { d += Math.pow(dArray[n] - d2, 2.0); } return Math.sqrt(d /= (double)dArray.length); } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class StandardDeviation { private StandardDeviation() { } public static double stdDev(double[] data) { double variance = 0; double avg = 0; for (int i = 0; i < data.length; i++) { avg += data[i]; } avg /= data.length; for (int j = 0; j < data.length; j++) { variance += Math.pow((data[j] - avg), 2); } variance /= data.length; return Math.sqrt(variance); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class StandardScore { private StandardScore() { } public static double zScore(double d, double d2, double d3) { return (d - d2) / d3; } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class StandardScore { private StandardScore() { } public static double zScore(double num, double mean, double stdDev) { return (num - mean) / stdDev; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.greedyalgorithms; public final class StockProfitCalculator { private StockProfitCalculator() { } public static int maxProfit(int[] nArray) { if (nArray == null || nArray.length == 0) { return 0; } int n = nArray[0]; int n2 = 0; for (int n3 : nArray) { n = Math.min(n3, n); n2 = Math.max(n3 - n, n2); } return n2; } }", "deobfuscated_code": "package com.thealgorithms.greedyalgorithms; /** * The StockProfitCalculator class provides a method to calculate the maximum profit * that can be made from a single buy and sell of one share of stock. * The approach uses a greedy algorithm to efficiently determine the maximum profit. * * @author Hardvan */ public final class StockProfitCalculator { private StockProfitCalculator() { } /** * Calculates the maximum profit from a list of stock prices. * * @param prices an array of integers representing the stock prices on different days * @return the maximum profit that can be achieved from a single buy and sell * transaction, or 0 if no profit can be made */ public static int maxProfit(int[] prices) { if (prices == null || prices.length == 0) { return 0; } int minPrice = prices[0]; int maxProfit = 0; for (int price : prices) { minPrice = Math.min(price, minPrice); maxProfit = Math.max(price - minPrice, maxProfit); } return maxProfit; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class StoogeSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { if (comparableArray.length == 0) { return comparableArray; } this.sort(comparableArray, 0, comparableArray.length); return comparableArray; } public Comparable[] sort(Comparable[] comparableArray, int n, int n2) { int n3; if (SortUtils.less(comparableArray[n2 - 1], comparableArray[n])) { Comparable comparable = comparableArray[n]; comparableArray[n] = comparableArray[n2 - 1]; comparableArray[n2 - 1] = comparable; } if ((n3 = n2 - n) > 2) { this.sort(comparableArray, n, n2 - (n3 /= 3)); this.sort(comparableArray, n + n3, n2); this.sort(comparableArray, n, n2 - n3); } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * @author Amir Hassan (https://github.com/ahsNT) * @see SortAlgorithm */ public class StoogeSort implements SortAlgorithm { @Override public <T extends Comparable<T>> T[] sort(T[] array) { if (array.length == 0) { return array; } sort(array, 0, array.length); return array; } public <T extends Comparable<T>> T[] sort(final T[] array, final int start, final int end) { if (SortUtils.less(array[end - 1], array[start])) { final T temp = array[start]; array[start] = array[end - 1]; array[end - 1] = temp; } final int length = end - start; if (length > 2) { int third = length / 3; sort(array, start, end - third); sort(array, start + third, end); sort(array, start, end - third); } return array; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import java.util.ArrayList; import java.util.Arrays; public final class StrandSort implements SortAlgorithm { @Override public final Comparable[] sort(Comparable[] comparableArray) { ArrayList<Comparable<Object>> arrayList; ArrayList<Comparable> arrayList2 = new ArrayList<Comparable>(Arrays.asList(comparableArray)); ArrayList<Comparable> arrayList3 = arrayList2; arrayList3 = arrayList2; if (arrayList2.size() <= 1) { arrayList = arrayList3; } else { ArrayList arrayList4 = new ArrayList(); while (!arrayList3.isEmpty()) { ArrayList<Comparable> arrayList5 = new ArrayList<Comparable>(); arrayList5.add((Comparable)arrayList3.removeFirst()); int n = 0; while (n < arrayList3.size()) { if (((Comparable)arrayList5.getLast()).compareTo(arrayList3.get(n)) <= 0) { arrayList5.add((Comparable)arrayList3.remove(n)); continue; } ++n; } ArrayList<Comparable<Object>> arrayList6 = new ArrayList<Comparable<Object>>(); int n2 = 0; int n3 = 0; while (n2 < arrayList4.size() && n3 < arrayList5.size()) { if (((Comparable)arrayList4.get(n2)).compareTo(arrayList5.get(n3)) <= 0) { arrayList6.add((Comparable)arrayList4.get(n2)); ++n2; continue; } arrayList6.add((Comparable)arrayList5.get(n3)); ++n3; } arrayList6.addAll(arrayList4.subList(n2, arrayList4.size())); arrayList6.addAll(arrayList5.subList(n3, arrayList5.size())); arrayList4 = arrayList6; } arrayList = arrayList4; } arrayList3 = arrayList; return arrayList.toArray(comparableArray); } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.Arrays; import java.util.List; /** * StrandSort class implementing the SortAlgorithm interface using arrays. */ public final class StrandSort implements SortAlgorithm { /** * Sorts the given array using the Strand Sort algorithm. * * @param <T> The type of elements to be sorted, must be Comparable. * @param array The array to be sorted. * @return The sorted array. */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { List<T> unsortedList = new ArrayList<>(Arrays.asList(array)); List<T> sortedList = strandSort(unsortedList); return sortedList.toArray(array); } /** * Strand Sort algorithm that sorts a list. * * @param <T> The type of elements to be sorted, must be Comparable. * @param list The list to be sorted. * @return The sorted list. */ private static <T extends Comparable<? super T>> List<T> strandSort(List<T> list) { if (list.size() <= 1) { return list; } List<T> result = new ArrayList<>(); while (!list.isEmpty()) { final List<T> sorted = new ArrayList<>(); sorted.add(list.removeFirst()); for (int i = 0; i < list.size();) { if (sorted.getLast().compareTo(list.get(i)) <= 0) { sorted.add(list.remove(i)); } else { i++; } } result = merge(result, sorted); } return result; } /** * Merges two sorted lists into one sorted list. * * @param <T> The type of elements to be sorted, must be Comparable. * @param left The first sorted list. * @param right The second sorted list. * @return The merged sorted list. */ private static <T extends Comparable<? super T>> List<T> merge(List<T> left, List<T> right) { List<T> result = new ArrayList<>(); int i = 0; int j = 0; while (i < left.size() && j < right.size()) { if (left.get(i).compareTo(right.get(j)) <= 0) { result.add(left.get(i)); i++; } else { result.add(right.get(j)); j++; } } result.addAll(left.subList(i, left.size())); result.addAll(right.subList(j, right.size())); return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; public class StrassenMatrixMultiplication { public int[][] multiply(int[][] nArray, int[][] nArray2) { int n = nArray.length; int[][] nArray3 = new int[n][n]; if (n == 1) { nArray3[0][0] = nArray[0][0] * nArray2[0][0]; } else { int[][] nArray4 = new int[n / 2][n / 2]; int[][] nArray5 = new int[n / 2][n / 2]; int[][] nArray6 = new int[n / 2][n / 2]; int[][] nArray7 = new int[n / 2][n / 2]; int[][] nArray8 = new int[n / 2][n / 2]; int[][] nArray9 = new int[n / 2][n / 2]; int[][] nArray10 = new int[n / 2][n / 2]; int[][] nArray11 = new int[n / 2][n / 2]; this.split(nArray, nArray4, 0, 0); this.split(nArray, nArray5, 0, n / 2); this.split(nArray, nArray6, n / 2, 0); this.split(nArray, nArray7, n / 2, n / 2); this.split(nArray2, nArray8, 0, 0); this.split(nArray2, nArray9, 0, n / 2); this.split(nArray2, nArray10, n / 2, 0); this.split(nArray2, nArray11, n / 2, n / 2); StrassenMatrixMultiplication strassenMatrixMultiplication = this; nArray = strassenMatrixMultiplication.multiply(strassenMatrixMultiplication.add(nArray4, nArray7), this.add(nArray8, nArray11)); StrassenMatrixMultiplication strassenMatrixMultiplication2 = this; nArray2 = strassenMatrixMultiplication2.multiply(strassenMatrixMultiplication2.add(nArray6, nArray7), nArray8); int[][] nArray12 = this.multiply(nArray4, this.sub(nArray9, nArray11)); int[][] nArray13 = this.multiply(nArray7, this.sub(nArray10, nArray8)); StrassenMatrixMultiplication strassenMatrixMultiplication3 = this; int[][] nArray14 = strassenMatrixMultiplication3.multiply(strassenMatrixMultiplication3.add(nArray4, nArray5), nArray11); StrassenMatrixMultiplication strassenMatrixMultiplication4 = this; nArray4 = strassenMatrixMultiplication4.multiply(strassenMatrixMultiplication4.sub(nArray6, nArray4), this.add(nArray8, nArray9)); StrassenMatrixMultiplication strassenMatrixMultiplication5 = this; nArray5 = strassenMatrixMultiplication5.multiply(strassenMatrixMultiplication5.sub(nArray5, nArray7), this.add(nArray10, nArray11)); StrassenMatrixMultiplication strassenMatrixMultiplication6 = this; nArray5 = strassenMatrixMultiplication6.add(strassenMatrixMultiplication6.sub(this.add(nArray, nArray13), nArray14), nArray5); nArray6 = this.add(nArray12, nArray14); nArray7 = this.add(nArray2, nArray13); StrassenMatrixMultiplication strassenMatrixMultiplication7 = this; nArray = strassenMatrixMultiplication7.add(strassenMatrixMultiplication7.sub(this.add(nArray, nArray12), nArray2), nArray4); this.join(nArray5, nArray3, 0, 0); this.join(nArray6, nArray3, 0, n / 2); this.join(nArray7, nArray3, n / 2, 0); this.join(nArray, nArray3, n / 2, n / 2); } return nArray3; } public int[][] sub(int[][] nArray, int[][] nArray2) { int n = nArray.length; int[][] nArray3 = new int[n][n]; for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { nArray3[i][j] = nArray[i][j] - nArray2[i][j]; } } return nArray3; } public int[][] add(int[][] nArray, int[][] nArray2) { int n = nArray.length; int[][] nArray3 = new int[n][n]; for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { nArray3[i][j] = nArray[i][j] + nArray2[i][j]; } } return nArray3; } public void split(int[][] nArray, int[][] nArray2, int n, int n2) { int n3 = 0; while (n3 < nArray2.length) { int n4 = 0; int n5 = n2; while (n4 < nArray2.length) { nArray2[n3][n4] = nArray[n][n5]; ++n4; ++n5; } ++n3; ++n; } } public void join(int[][] nArray, int[][] nArray2, int n, int n2) { int n3 = 0; while (n3 < nArray.length) { int n4 = 0; int n5 = n2; while (n4 < nArray.length) { nArray2[n][n5] = nArray[n3][n4]; ++n4; ++n5; } ++n3; ++n; } } }", "deobfuscated_code": "package com.thealgorithms.divideandconquer; // Java Program to Implement Strassen Algorithm for Matrix Multiplication /* * Uses the divide and conquer approach to multiply two matrices. * Time Complexity: O(n^2.8074) better than the O(n^3) of the standard matrix multiplication * algorithm. Space Complexity: O(n^2) * * This Matrix multiplication can be performed only on square matrices * where n is a power of 2. Order of both of the matrices are n  n. * * Reference: * https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_strassens_matrix_multiplication.htm#:~:text=Strassen's%20Matrix%20multiplication%20can%20be,matrices%20are%20n%20%C3%97%20n. * https://www.geeksforgeeks.org/strassens-matrix-multiplication/ */ public class StrassenMatrixMultiplication { // Function to multiply matrices public int[][] multiply(int[][] a, int[][] b) { int n = a.length; int[][] mat = new int[n][n]; if (n == 1) { mat[0][0] = a[0][0] * b[0][0]; } else { // Dividing Matrix into parts // by storing sub-parts to variables int[][] a11 = new int[n / 2][n / 2]; int[][] a12 = new int[n / 2][n / 2]; int[][] a21 = new int[n / 2][n / 2]; int[][] a22 = new int[n / 2][n / 2]; int[][] b11 = new int[n / 2][n / 2]; int[][] b12 = new int[n / 2][n / 2]; int[][] b21 = new int[n / 2][n / 2]; int[][] b22 = new int[n / 2][n / 2]; // Dividing matrix A into 4 parts split(a, a11, 0, 0); split(a, a12, 0, n / 2); split(a, a21, n / 2, 0); split(a, a22, n / 2, n / 2); // Dividing matrix B into 4 parts split(b, b11, 0, 0); split(b, b12, 0, n / 2); split(b, b21, n / 2, 0); split(b, b22, n / 2, n / 2); // Using Formulas as described in algorithm // m1:=(A1+A3)(B1+B2) int[][] m1 = multiply(add(a11, a22), add(b11, b22)); // m2:=(A2+A4)(B3+B4) int[][] m2 = multiply(add(a21, a22), b11); // m3:=(A1A4)(B1+A4) int[][] m3 = multiply(a11, sub(b12, b22)); // m4:=A1(B2B4) int[][] m4 = multiply(a22, sub(b21, b11)); // m5:=(A3+A4)(B1) int[][] m5 = multiply(add(a11, a12), b22); // m6:=(A1+A2)(B4) int[][] m6 = multiply(sub(a21, a11), add(b11, b12)); // m7:=A4(B3B1) int[][] m7 = multiply(sub(a12, a22), add(b21, b22)); // P:=m2+m3m6m7 int[][] c11 = add(sub(add(m1, m4), m5), m7); // Q:=m4+m6 int[][] c12 = add(m3, m5); // mat:=m5+m7 int[][] c21 = add(m2, m4); // S:=m1m3m4m5 int[][] c22 = add(sub(add(m1, m3), m2), m6); join(c11, mat, 0, 0); join(c12, mat, 0, n / 2); join(c21, mat, n / 2, 0); join(c22, mat, n / 2, n / 2); } return mat; } // Function to subtract two matrices public int[][] sub(int[][] a, int[][] b) { int n = a.length; int[][] c = new int[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { c[i][j] = a[i][j] - b[i][j]; } } return c; } // Function to add two matrices public int[][] add(int[][] a, int[][] b) { int n = a.length; int[][] c = new int[n][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { c[i][j] = a[i][j] + b[i][j]; } } return c; } // Function to split parent matrix into child matrices public void split(int[][] p, int[][] c, int iB, int jB) { for (int i1 = 0, i2 = iB; i1 < c.length; i1++, i2++) { for (int j1 = 0, j2 = jB; j1 < c.length; j1++, j2++) { c[i1][j1] = p[i2][j2]; } } } // Function to join child matrices into (to) parent matrix public void join(int[][] c, int[][] p, int iB, int jB) { for (int i1 = 0, i2 = iB; i1 < c.length; i1++, i2++) { for (int j1 = 0, j2 = jB; j1 < c.length; j1++, j2++) { p[i2][j2] = c[i1][j1]; } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class StringCompression { private StringCompression() { } public static String compress(String string) { int n = 1; Object object = \"\"; if (string.length() == 1) { return \"\" + string.charAt(0); } for (int i = 0; i < string.length() - 1; ++i) { if (string.charAt(i) == string.charAt(i + 1)) { ++n; } if (i + 1 == string.length() - 1 && string.charAt(i + 1) == string.charAt(i)) { object = StringCompression.appendCount((String)object, n, string.charAt(i)); break; } if (string.charAt(i) == string.charAt(i + 1)) continue; if (i + 1 == string.length() - 1) { object = StringCompression.appendCount((String)object, n, string.charAt(i)) + string.charAt(i + 1); break; } object = StringCompression.appendCount((String)object, n, string.charAt(i)); n = 1; } return object; } public static String appendCount(String object, int n, char c) { object = n > 1 ? (String)object + c + n : (String)object + c; return object; } }", "deobfuscated_code": "package com.thealgorithms.strings; /** * References : https://en.wikipedia.org/wiki/Run-length_encoding * String compression algorithm deals with encoding the string, that is, shortening the size of the string * @author Swarga-codes (https://github.com/Swarga-codes) */ public final class StringCompression { private StringCompression() { } /** * Returns the compressed or encoded string * * @param input character array that contains the group of characters to be encoded * @return the compressed character array as string */ public static String compress(String input) { // Keeping the count as 1 since every element present will have at least a count of 1 int count = 1; String compressedString = \"\"; // Base condition to check whether the array is of size 1, if it is then we return the array if (input.length() == 1) { return \"\" + input.charAt(0); } // If the array has a length greater than 1 we move into this loop for (int i = 0; i < input.length() - 1; i++) { // here we check for similarity of the adjacent elements and change the count accordingly if (input.charAt(i) == input.charAt(i + 1)) { count = count + 1; } if ((i + 1) == input.length() - 1 && input.charAt(i + 1) == input.charAt(i)) { compressedString = appendCount(compressedString, count, input.charAt(i)); break; } else if (input.charAt(i) != input.charAt(i + 1)) { if ((i + 1) == input.length() - 1) { compressedString = appendCount(compressedString, count, input.charAt(i)) + input.charAt(i + 1); break; } else { compressedString = appendCount(compressedString, count, input.charAt(i)); count = 1; } } } return compressedString; } /** * @param res the resulting string * @param count current count * @param ch the character at a particular index * @return the res string appended with the count */ public static String appendCount(String res, int count, char ch) { if (count > 1) { res += ch + \"\" + count; } else { res += ch + \"\"; } return res; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; final class StringMatchFiniteAutomata$FiniteAutomata { private int a = 0; private final int[][] b; private StringMatchFiniteAutomata$FiniteAutomata(int[][] nArray) { this.b = nArray; } private void a(char c) { this.a = this.b[this.a][c]; } private int a() { return this.a; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; final class StringMatchFiniteAutomata$FiniteAutomata { private int a = 0; private final int[][] b; private StringMatchFiniteAutomata$FiniteAutomata(int[][] nArray) { this.b = nArray; } private void a(char c) { this.a = this.b[this.a][c]; } private int a() { return this.a; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import com.thealgorithms.strings.StringMatchFiniteAutomata$FiniteAutomata; import java.util.Set; import java.util.TreeSet; public final class StringMatchFiniteAutomata { private StringMatchFiniteAutomata() { } public static Set searchPattern(String string, String string2) { Object object = string2; int n = ((String)object).length(); int[][] nArray = new int[n + 1][65536]; for (int i = 0; i <= n; ++i) { for (int j = 0; j < 65536; ++j) { int n2; block7: { int[] nArray2 = nArray[i]; int n3 = j; int n4 = i; int n5 = n; Object object2 = object; if (n4 < n5 && n3 == ((String)object2).charAt(n4)) { n2 = n4 + 1; } else { for (n5 = n4; n5 > 0; --n5) { if (((String)object2).charAt(n5 - 1) != n3) continue; boolean bl = true; for (int k = 0; k < n5 - 1; ++k) { if (((String)object2).charAt(k) == ((String)object2).charAt(n4 - n5 + k + 1)) continue; bl = false; break; } if (!bl) continue; n2 = n5; break block7; } n2 = 0; } } nArray2[j] = n2; } } object = nArray; object = new StringMatchFiniteAutomata$FiniteAutomata((int[][])object); TreeSet<Integer> treeSet = new TreeSet<Integer>(); for (int i = 0; i < string.length(); ++i) { ((StringMatchFiniteAutomata$FiniteAutomata)object).a(string.charAt(i)); if (((StringMatchFiniteAutomata$FiniteAutomata)object).a() != string2.length()) continue; treeSet.add(i - string2.length() + 1); } return treeSet; } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.Set; import java.util.TreeSet; /** * A class to perform string matching using <a href=\"https://en.wikipedia.org/wiki/Finite-state_machine\">finite automata</a>. * * @author <a href=\"https://github.com/prateekKrOraon\">Prateek Kumar Oraon</a> */ public final class StringMatchFiniteAutomata { // Constants private static final int CHARS = Character.MAX_VALUE + 1; // Total number of characters in the input alphabet // Private constructor to prevent instantiation private StringMatchFiniteAutomata() { } /** * Searches for the pattern in the given text using finite automata. * * @param text The text to search within. * @param pattern The pattern to search for. */ public static Set<Integer> searchPattern(final String text, final String pattern) { final var stateTransitionTable = computeStateTransitionTable(pattern); FiniteAutomata finiteAutomata = new FiniteAutomata(stateTransitionTable); Set<Integer> indexFound = new TreeSet<>(); for (int i = 0; i < text.length(); i++) { finiteAutomata.consume(text.charAt(i)); if (finiteAutomata.getState() == pattern.length()) { indexFound.add(i - pattern.length() + 1); } } return indexFound; } /** * Computes the finite automata table for the given pattern. * * @param pattern The pattern to preprocess. * @return The state transition table. */ private static int[][] computeStateTransitionTable(final String pattern) { final int patternLength = pattern.length(); int[][] stateTransitionTable = new int[patternLength + 1][CHARS]; for (int state = 0; state <= patternLength; ++state) { for (int x = 0; x < CHARS; ++x) { stateTransitionTable[state][x] = getNextState(pattern, patternLength, state, x); } } return stateTransitionTable; } /** * Gets the next state for the finite automata. * * @param pattern The pattern being matched. * @param patternLength The length of the pattern. * @param state The current state. * @param x The current character from the input alphabet. * @return The next state. */ private static int getNextState(final String pattern, final int patternLength, final int state, final int x) { // If the current state is less than the length of the pattern // and the character matches the pattern character, go to the next state if (state < patternLength && x == pattern.charAt(state)) { return state + 1; } // Check for the highest prefix which is also a suffix for (int ns = state; ns > 0; ns--) { if (pattern.charAt(ns - 1) == x) { boolean match = true; for (int i = 0; i < ns - 1; i++) { if (pattern.charAt(i) != pattern.charAt(state - ns + i + 1)) { match = false; break; } } if (match) { return ns; } } } // If no prefix which is also a suffix is found, return 0 return 0; } /** * A class representing the finite automata for pattern matching. */ private static final class FiniteAutomata { private int state = 0; private final int[][] stateTransitionTable; private FiniteAutomata(int[][] stateTransitionTable) { this.stateTransitionTable = stateTransitionTable; } /** * Consumes an input character and transitions to the next state. * * @param input The input character. */ private void consume(final char input) { state = stateTransitionTable[state][input]; } /** * Gets the current state of the finite automata. * * @return The current state. */ private int getState() { return state; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; import java.util.HashMap; public class StrobogrammaticNumber { public boolean isStrobogrammatic(String string) { HashMap<Character, Character> hashMap = new HashMap<Character, Character>(); hashMap.put(Character.valueOf('0'), Character.valueOf('0')); hashMap.put(Character.valueOf('1'), Character.valueOf('1')); hashMap.put(Character.valueOf('6'), Character.valueOf('9')); hashMap.put(Character.valueOf('8'), Character.valueOf('8')); hashMap.put(Character.valueOf('9'), Character.valueOf('6')); int n = 0; for (int i = string.length() - 1; n <= i; ++n, --i) { char c = string.charAt(n); char c2 = string.charAt(i); if (hashMap.containsKey(Character.valueOf(c)) && ((Character)hashMap.get(Character.valueOf(c))).charValue() == c2) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.HashMap; import java.util.Map; /** * A strobogrammatic number is a number that remains the same when rotated 180 degrees. * In other words, the number looks the same when rotated upside down. * Examples of strobogrammatic numbers are \"69\", \"88\", \"818\", and \"101\". * Numbers like \"609\" or \"120\" are not strobogrammatic because they do not look the same when rotated. */ public class StrobogrammaticNumber { /** * Check if a number is strobogrammatic * @param number the number to be checked * @return true if the number is strobogrammatic, false otherwise */ public boolean isStrobogrammatic(String number) { Map<Character, Character> strobogrammaticMap = new HashMap<>(); strobogrammaticMap.put('0', '0'); strobogrammaticMap.put('1', '1'); strobogrammaticMap.put('6', '9'); strobogrammaticMap.put('8', '8'); strobogrammaticMap.put('9', '6'); int left = 0; int right = number.length() - 1; while (left <= right) { char leftChar = number.charAt(left); char rightChar = number.charAt(right); if (!strobogrammaticMap.containsKey(leftChar) || strobogrammaticMap.get(leftChar) != rightChar) { return false; } left++; right--; } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.graph; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.Stack; public class StronglyConnectedComponentOptimized { public void btrack(HashMap hashMap, int[] nArray, Stack stack, int n) { nArray[n] = 1; Object object = (List)hashMap.get(n); if (object != null) { object = object.iterator(); while (object.hasNext()) { int n2 = (Integer)object.next(); if (nArray[n2] != -1) continue; this.btrack(hashMap, nArray, stack, n2); } } stack.add(n); } public void btrack2(HashMap hashMap, int[] nArray, int n, List list) { nArray[n] = 1; list.add(n); Object object = (List)hashMap.get(n); if (object != null) { object = object.iterator(); while (object.hasNext()) { int n2 = (Integer)object.next(); if (nArray[n2] != -1) continue; this.btrack2(hashMap, nArray, n2, list); } } } public int getOutput(HashMap hashMap, int n) { Object object; int n2; int[] nArray = new int[n]; Arrays.fill(nArray, -1); Stack stack = new Stack(); for (int i = 0; i < n; ++i) { if (nArray[i] != -1) continue; this.btrack(hashMap, nArray, stack, i); } HashMap hashMap2 = new HashMap(); for (n2 = 0; n2 < n; ++n2) { hashMap2.put(n2, new ArrayList()); } for (n2 = 0; n2 < n; ++n2) { List list = (List)hashMap.get(n2); if (list == null) continue; object = list.iterator(); while (object.hasNext()) { int n3 = (Integer)object.next(); ((List)hashMap2.get(n3)).add(n2); } } Arrays.fill(nArray, -1); n2 = 0; while (!stack.isEmpty()) { int n4 = (Integer)stack.pop(); if (nArray[n4] != -1) continue; object = new ArrayList(); this.btrack2(hashMap2, nArray, n4, (List)object); ++n2; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.graph; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.Stack; /** * Finds the strongly connected components in a directed graph. * * @param adjList The adjacency list representation of the graph. * @param n The number of nodes in the graph. * @return The number of strongly connected components. */ public class StronglyConnectedComponentOptimized { public void btrack(HashMap<Integer, List<Integer>> adjList, int[] visited, Stack<Integer> dfsCallsNodes, int currentNode) { visited[currentNode] = 1; List<Integer> neighbors = adjList.get(currentNode); // Check for null before iterating if (neighbors != null) { for (int neighbor : neighbors) { if (visited[neighbor] == -1) { btrack(adjList, visited, dfsCallsNodes, neighbor); } } } dfsCallsNodes.add(currentNode); } public void btrack2(HashMap<Integer, List<Integer>> adjRevList, int[] visited, int currentNode, List<Integer> newScc) { visited[currentNode] = 1; newScc.add(currentNode); List<Integer> neighbors = adjRevList.get(currentNode); // Check for null before iterating if (neighbors != null) { for (int neighbor : neighbors) { if (visited[neighbor] == -1) { btrack2(adjRevList, visited, neighbor, newScc); } } } } public int getOutput(HashMap<Integer, List<Integer>> adjList, int n) { int[] visited = new int[n]; Arrays.fill(visited, -1); Stack<Integer> dfsCallsNodes = new Stack<>(); for (int i = 0; i < n; i++) { if (visited[i] == -1) { btrack(adjList, visited, dfsCallsNodes, i); } } HashMap<Integer, List<Integer>> adjRevList = new HashMap<>(); for (int i = 0; i < n; i++) { adjRevList.put(i, new ArrayList<>()); } for (int i = 0; i < n; i++) { List<Integer> neighbors = adjList.get(i); // Check for null before iterating if (neighbors != null) { for (int neighbor : neighbors) { adjRevList.get(neighbor).add(i); } } } Arrays.fill(visited, -1); int stronglyConnectedComponents = 0; while (!dfsCallsNodes.isEmpty()) { int node = dfsCallsNodes.pop(); if (visited[node] == -1) { List<Integer> newScc = new ArrayList<>(); btrack2(adjRevList, visited, node, newScc); stronglyConnectedComponents++; } } return stronglyConnectedComponents; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.List; public final class SubsequenceFinder { private SubsequenceFinder() { } public static List generateAll(List list) { ArrayList arrayList = new ArrayList(); if (list.isEmpty()) { arrayList.add(new ArrayList()); return arrayList; } ArrayList arrayList2 = new ArrayList(); SubsequenceFinder.a(list, arrayList2, 0, arrayList); return arrayList; } private static void a(List list, List list2, int n, List list3) { assert (n <= list.size()); if (n == list.size()) { list3.add(new ArrayList(list2)); return; } SubsequenceFinder.a(list, list2, n + 1, list3); list2.add(list.get(n)); SubsequenceFinder.a(list, list2, n + 1, list3); list2.removeLast(); } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.ArrayList; import java.util.List; /** * Class generates all subsequences for a given list of elements using backtracking */ public final class SubsequenceFinder { private SubsequenceFinder() { } /** * Find all subsequences of given list using backtracking * * @param sequence a list of items on the basis of which we need to generate all subsequences * @param <T> the type of elements in the array * @return a list of all subsequences */ public static <T> List<List<T>> generateAll(List<T> sequence) { List<List<T>> allSubSequences = new ArrayList<>(); if (sequence.isEmpty()) { allSubSequences.add(new ArrayList<>()); return allSubSequences; } List<T> currentSubsequence = new ArrayList<>(); backtrack(sequence, currentSubsequence, 0, allSubSequences); return allSubSequences; } /** * Iterate through each branch of states * We know that each state has exactly two branching * It terminates when it reaches the end of the given sequence * * @param sequence all elements * @param currentSubsequence current subsequence * @param index current index * @param allSubSequences contains all sequences * @param <T> the type of elements which we generate */ private static <T> void backtrack(List<T> sequence, List<T> currentSubsequence, final int index, List<List<T>> allSubSequences) { assert index <= sequence.size(); if (index == sequence.size()) { allSubSequences.add(new ArrayList<>(currentSubsequence)); return; } backtrack(sequence, currentSubsequence, index + 1, allSubSequences); currentSubsequence.add(sequence.get(index)); backtrack(sequence, currentSubsequence, index + 1, allSubSequences); currentSubsequence.removeLast(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class SubsetCount { private SubsetCount() { } public static int getCount(int[] nArray, int n) { int n2; int n3 = nArray.length; int[][] nArray2 = new int[n3][n + 1]; for (n2 = 0; n2 < n3; ++n2) { nArray2[n2][0] = 1; } if (nArray[0] <= n) { nArray2[0][nArray[0]] = 1; } for (n2 = 1; n2 <= n; ++n2) { for (int i = 1; i < n3; ++i) { int n4 = nArray2[i - 1][n2]; int n5 = 0; if (nArray[i] <= n2) { n5 = 0 + nArray2[i - 1][n - n2]; } nArray2[i][n] = n5 + n4; } } return nArray2[n3 - 1][n]; } public static int getCountSO(int[] nArray, int n) { int n2 = nArray.length; int[] nArray2 = new int[n + 1]; int[] nArray3 = nArray2; nArray2[0] = 1; if (nArray[0] <= n) { nArray3[nArray[0]] = 1; } for (int i = 1; i < n2; ++i) { int[] nArray4 = new int[n + 1]; int[] nArray5 = nArray4; nArray4[0] = 1; for (int j = 1; j <= n; ++j) { int n3 = nArray3[j]; int n4 = 0; if (nArray[i] <= j) { n4 = nArray3[j - nArray[i]]; } nArray5[j] = n3 + n4; } nArray3 = nArray5; } return nArray3[n]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Find the number of subsets present in the given array with a sum equal to target. * Based on Solution discussed on * <a href=\"https://stackoverflow.com/questions/22891076/count-number-of-subsets-with-sum-equal-to-k\">StackOverflow</a> * @author <a href=\"https://github.com/samratpodder\">Samrat Podder</a> */ public final class SubsetCount { private SubsetCount() { } /** * Dynamic Programming Implementation. * Method to find out the number of subsets present in the given array with a sum equal to * target. Time Complexity is O(n*target) and Space Complexity is O(n*target) * @param arr is the input array on which subsets are to searched * @param target is the sum of each element of the subset taken together * */ public static int getCount(int[] arr, int target) { /* * Base Cases - If target becomes zero, we have reached the required sum for the subset * If we reach the end of the array arr then, either if target==arr[end], then we add one to * the final count Otherwise we add 0 to the final count */ int n = arr.length; int[][] dp = new int[n][target + 1]; for (int i = 0; i < n; i++) { dp[i][0] = 1; } if (arr[0] <= target) { dp[0][arr[0]] = 1; } for (int t = 1; t <= target; t++) { for (int idx = 1; idx < n; idx++) { int notpick = dp[idx - 1][t]; int pick = 0; if (arr[idx] <= t) { pick += dp[idx - 1][target - t]; } dp[idx][target] = pick + notpick; } } return dp[n - 1][target]; } /** * This Method is a Space Optimized version of the getCount(int[], int) method and solves the * same problem This approach is a bit better in terms of Space Used Time Complexity is * O(n*target) and Space Complexity is O(target) * @param arr is the input array on which subsets are to searched * @param target is the sum of each element of the subset taken together */ public static int getCountSO(int[] arr, int target) { int n = arr.length; int[] prev = new int[target + 1]; prev[0] = 1; if (arr[0] <= target) { prev[arr[0]] = 1; } for (int ind = 1; ind < n; ind++) { int[] cur = new int[target + 1]; cur[0] = 1; for (int t = 1; t <= target; t++) { int notTaken = prev[t]; int taken = 0; if (arr[ind] <= t) { taken = prev[t - arr[ind]]; } cur[t] = notTaken + taken; } prev = cur; } return prev[target]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class SubsetSum { private SubsetSum() { } public static boolean subsetSum(int[] nArray, int n) { int n2 = nArray.length; boolean[] blArray = new boolean[n + 1]; boolean[] blArray2 = blArray; blArray[0] = true; for (int i = 0; i < n2; ++i) { for (int j = n; j >= nArray[i]; --j) { blArray2[j] = blArray2[j] || blArray2[j - nArray[i]]; } } return blArray2[n]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; public final class SubsetSum { private SubsetSum() { } /** * Test if a set of integers contains a subset that sums to a given integer. * * @param arr the array containing integers. * @param sum the target sum of the subset. * @return {@code true} if a subset exists that sums to the given value, * otherwise {@code false}. */ public static boolean subsetSum(int[] arr, int sum) { int n = arr.length; // Initialize a single array to store the possible sums boolean[] isSum = new boolean[sum + 1]; // Mark isSum[0] = true since a sum of 0 is always possible with 0 elements isSum[0] = true; // Iterate through each Element in the array for (int i = 0; i < n; i++) { // Traverse the isSum array backwards to prevent overwriting values for (int j = sum; j >= arr[i]; j--) { isSum[j] = isSum[j] || isSum[j - arr[i]]; } } return isSum[sum]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class SubsetSumSpaceOptimized { private SubsetSumSpaceOptimized() { } public static boolean isSubsetSum(int[] nArray, int n) { if (n < 0) { return false; } boolean[] blArray = new boolean[n + 1]; boolean[] blArray2 = blArray; blArray[0] = true; for (int n2 : nArray) { for (int i = n; i >= n2; --i) { blArray2[i] = blArray2[i] || blArray2[i - n2]; } } return blArray2[n]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * Utility class for solving the Subset Sum problem using a space-optimized dynamic programming approach. * * <p>This algorithm determines whether any subset of a given array sums up to a specific target value.</p> * * <p><b>Time Complexity:</b> O(n * sum)</p> * <p><b>Space Complexity:</b> O(sum)</p> */ public final class SubsetSumSpaceOptimized { private SubsetSumSpaceOptimized() { } /** * Determines whether there exists a subset of the given array that adds up to the specified sum. * This method uses a space-optimized dynamic programming approach with a 1D boolean array. * * @param nums The array of non-negative integers * @param targetSum The desired subset sum * @return {@code true} if such a subset exists, {@code false} otherwise */ public static boolean isSubsetSum(int[] nums, int targetSum) { if (targetSum < 0) { return false; // Subset sum can't be negative } boolean[] dp = new boolean[targetSum + 1]; dp[0] = true; // Empty subset always sums to 0 for (int number : nums) { for (int j = targetSum; j >= number; j--) { dp[j] = dp[j] || dp[j - number]; } } return dp[targetSum]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.puzzlesandgames; final class Sudoku { private Sudoku() { } public static boolean isSafe(int[][] nArray, int n, int n2, int n3) { int n4; for (n4 = 0; n4 < nArray.length; ++n4) { if (nArray[n][n4] != n3) continue; return false; } for (n4 = 0; n4 < nArray.length; ++n4) { if (nArray[n4][n2] != n3) continue; return false; } n4 = (int)Math.sqrt(nArray.length); int n5 = n; n = n5 - n5 % n4; int n6 = n2; n2 = n6 - n6 % n4; for (int i = n; i < n + n4; ++i) { for (int j = n2; j < n2 + n4; ++j) { if (nArray[i][j] != n3) continue; return false; } } return true; } public static boolean solveSudoku(int[][] nArray, int n) { int n2; int n3 = -1; int n4 = -1; boolean bl = true; for (n2 = 0; n2 < n; ++n2) { for (int i = 0; i < n; ++i) { if (nArray[n2][i] != 0) continue; n3 = n2; n4 = i; bl = false; break; } if (!bl) break; } if (bl) { return true; } for (n2 = 1; n2 <= n; ++n2) { if (!Sudoku.isSafe(nArray, n3, n4, n2)) continue; nArray[n3][n4] = n2; if (Sudoku.solveSudoku(nArray, n)) { return true; } nArray[n3][n4] = 0; } return false; } public static void print(int[][] nArray, int n) { for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { System.out.print(nArray[i][j]); System.out.print(\" \"); } System.out.print(\"\\n\"); if ((i + 1) % (int)Math.sqrt(n) != 0) continue; System.out.print(\"\"); } } public static void main(String[] object) { int[][] nArrayArray = new int[][]{{3, 0, 6, 5, 0, 8, 4, 0, 0}, {5, 2, 0, 0, 0, 0, 0, 0, 0}, {0, 8, 7, 0, 0, 0, 0, 3, 1}, {0, 0, 3, 0, 1, 0, 0, 8, 0}, {9, 0, 0, 8, 6, 3, 0, 0, 5}, {0, 5, 0, 0, 9, 0, 6, 0, 0}, {1, 3, 0, 0, 0, 0, 2, 5, 0}, {0, 0, 0, 0, 0, 0, 0, 7, 4}, {0, 0, 5, 2, 0, 6, 3, 0, 0}}; object = nArrayArray; int cfr_ignored_0 = nArrayArray.length; if (Sudoku.solveSudoku((int[][])object, 9)) { Sudoku.print((int[][])object, 9); return; } System.out.println(\"No solution\"); } }", "deobfuscated_code": "package com.thealgorithms.puzzlesandgames; /** * A class that provides methods to solve Sudoku puzzles of any n x n size * using a backtracking approach, where n must be a perfect square. * The algorithm checks for safe number placements in rows, columns, * and subgrids (which are sqrt(n) x sqrt(n) in size) and recursively solves the puzzle. * Though commonly used for 9x9 grids, it is adaptable to other valid Sudoku dimensions. */ final class Sudoku { private Sudoku() { } /** * Checks if placing a number in a specific position on the Sudoku board is safe. * The number is considered safe if it does not violate any of the Sudoku rules: * - It should not be present in the same row. * - It should not be present in the same column. * - It should not be present in the corresponding 3x3 subgrid. * - It should not be present in the corresponding subgrid, which is sqrt(n) x sqrt(n) in size (e.g., for a 9x9 grid, the subgrid will be 3x3). * * @param board The current state of the Sudoku board. * @param row The row index where the number is to be placed. * @param col The column index where the number is to be placed. * @param num The number to be placed on the board. * @return True if the placement is safe, otherwise false. */ public static boolean isSafe(int[][] board, int row, int col, int num) { // Check the row for duplicates for (int d = 0; d < board.length; d++) { if (board[row][d] == num) { return false; } } // Check the column for duplicates for (int r = 0; r < board.length; r++) { if (board[r][col] == num) { return false; } } // Check the corresponding 3x3 subgrid for duplicates int sqrt = (int) Math.sqrt(board.length); int boxRowStart = row - row % sqrt; int boxColStart = col - col % sqrt; for (int r = boxRowStart; r < boxRowStart + sqrt; r++) { for (int d = boxColStart; d < boxColStart + sqrt; d++) { if (board[r][d] == num) { return false; } } } return true; } /** * Solves the Sudoku puzzle using backtracking. * The algorithm finds an empty cell and tries placing numbers * from 1 to n, where n is the size of the board * (for example, from 1 to 9 in a standard 9x9 Sudoku). * The algorithm finds an empty cell and tries placing numbers from 1 to 9. * The standard version of Sudoku uses numbers from 1 to 9, so the algorithm can be * easily modified for other variations of the game. * If a number placement is valid (checked via `isSafe`), the number is * placed and the function recursively attempts to solve the rest of the puzzle. * If no solution is possible, the number is removed (backtracked), * and the process is repeated. * * @param board The current state of the Sudoku board. * @param n The size of the Sudoku board (typically 9 for a standard puzzle). * @return True if the Sudoku puzzle is solvable, false otherwise. */ public static boolean solveSudoku(int[][] board, int n) { int row = -1; int col = -1; boolean isEmpty = true; // Find the next empty cell for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (board[i][j] == 0) { row = i; col = j; isEmpty = false; break; } } if (!isEmpty) { break; } } // No empty space left if (isEmpty) { return true; } // Try placing numbers 1 to n in the empty cell (n should be a perfect square) // Eg: n=9 for a standard 9x9 Sudoku puzzle, n=16 for a 16x16 puzzle, etc. for (int num = 1; num <= n; num++) { if (isSafe(board, row, col, num)) { board[row][col] = num; if (solveSudoku(board, n)) { return true; } else { // replace it board[row][col] = 0; } } } return false; } /** * Prints the current state of the Sudoku board in a readable format. * Each row is printed on a new line, with numbers separated by spaces. * * @param board The current state of the Sudoku board. * @param n The size of the Sudoku board (typically 9 for a standard puzzle). */ public static void print(int[][] board, int n) { // Print the board in a nxn grid format // if n=9, print the board in a 9x9 grid format // if n=16, print the board in a 16x16 grid format for (int r = 0; r < n; r++) { for (int d = 0; d < n; d++) { System.out.print(board[r][d]); System.out.print(\" \"); } System.out.print(\"\\n\"); if ((r + 1) % (int) Math.sqrt(n) == 0) { System.out.print(\"\"); } } } /** * The driver method to demonstrate solving a Sudoku puzzle. * A sample 9x9 Sudoku puzzle is provided, and the program attempts to solve it * using the `solveSudoku` method. If a solution is found, it is printed to the console. * * @param args Command-line arguments (not used in this program). */ public static void main(String[] args) { int[][] board = new int[][] { {3, 0, 6, 5, 0, 8, 4, 0, 0}, {5, 2, 0, 0, 0, 0, 0, 0, 0}, {0, 8, 7, 0, 0, 0, 0, 3, 1}, {0, 0, 3, 0, 1, 0, 0, 8, 0}, {9, 0, 0, 8, 6, 3, 0, 0, 5}, {0, 5, 0, 0, 9, 0, 6, 0, 0}, {1, 3, 0, 0, 0, 0, 2, 5, 0}, {0, 0, 0, 0, 0, 0, 0, 7, 4}, {0, 0, 5, 2, 0, 6, 3, 0, 0}, }; int n = board.length; if (solveSudoku(board, n)) { print(board, n); } else { System.out.println(\"No solution\"); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class SumOfArithmeticSeries { private SumOfArithmeticSeries() { } public static double sumOfSeries(double d, double d2, int n) { if (n < 0) { throw new IllegalArgumentException(\"numOfTerms nonnegative.\"); } return (double)n / 2.0 * (d * 2.0 + (double)(n - 1) * d2); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * In mathematics, an arithmetic progression (AP) or arithmetic sequence is a * sequence of numbers such that the difference between the consecutive terms is * constant. Difference here means the second minus the first. For instance, the * sequence 5, 7, 9, 11, 13, 15, . . . is an arithmetic progression with common * difference of 2. * * <p> * Wikipedia: https://en.wikipedia.org/wiki/Arithmetic_progression */ public final class SumOfArithmeticSeries { private SumOfArithmeticSeries() { } /** * Calculate sum of arithmetic series * * @param firstTerm the initial term of an arithmetic series * @param commonDiff the common difference of an arithmetic series * @param numOfTerms the total terms of an arithmetic series * @return sum of given arithmetic series */ public static double sumOfSeries(final double firstTerm, final double commonDiff, final int numOfTerms) { if (numOfTerms < 0) { throw new IllegalArgumentException(\"numOfTerms nonnegative.\"); } return (numOfTerms / 2.0 * (2 * firstTerm + (numOfTerms - 1) * commonDiff)); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class SumOfDigits { private SumOfDigits() { } public static int sumOfDigits(int n) { int n2 = 0; for (n = Math.abs(n); n != 0; n /= 10) { n2 += n % 10; } return n2; } public static int sumOfDigitsRecursion(int n) { if ((n = Math.abs(n)) < 10) { return n; } return n % 10 + SumOfDigits.sumOfDigitsRecursion(n / 10); } public static int sumOfDigitsFast(int n2) { return String.valueOf(Math.abs(n2)).chars().map(n -> n - 48).reduce(0, Integer::sum); } }", "deobfuscated_code": "package com.thealgorithms.maths; public final class SumOfDigits { private SumOfDigits() { } /** * Calculate the sum of digits of a number * * @param number the number contains digits * @return sum of digits of given {@code number} */ public static int sumOfDigits(int number) { final int base = 10; number = Math.abs(number); int sum = 0; while (number != 0) { sum += number % base; number /= base; } return sum; } /** * Calculate the sum of digits of a number using recursion * * @param number the number contains digits * @return sum of digits of given {@code number} */ public static int sumOfDigitsRecursion(int number) { final int base = 10; number = Math.abs(number); return number < base ? number : number % base + sumOfDigitsRecursion(number / base); } /** * Calculate the sum of digits of a number using char array * * @param number the number contains digits * @return sum of digits of given {@code number} */ public static int sumOfDigitsFast(final int number) { return String.valueOf(Math.abs(number)).chars().map(c -> c - '0').reduce(0, Integer::sum); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class SumOfOddNumbers { private SumOfOddNumbers() { } public static int sumOfFirstNOddNumbers(int n) { if (n < 0) { throw new IllegalArgumentException(\"n must be non-negative.\"); } int n2 = n; return n2 * n2; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * This program calculates the sum of the first n odd numbers. * * https://www.cuemath.com/algebra/sum-of-odd-numbers/ */ public final class SumOfOddNumbers { private SumOfOddNumbers() { } /** * Calculate sum of the first n odd numbers * * @param n the number of odd numbers to sum * @return sum of the first n odd numbers */ public static int sumOfFirstNOddNumbers(final int n) { if (n < 0) { throw new IllegalArgumentException(\"n must be non-negative.\"); } return n * n; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class SumOfSubset { private SumOfSubset() { } public static boolean subsetSum(int[] nArray, int n, int n2) { if (n2 == 0) { return true; } if (n < 0 || n2 < 0) { return false; } boolean bl = SumOfSubset.subsetSum(nArray, n - 1, n2 - nArray[n]); boolean bl2 = SumOfSubset.subsetSum(nArray, n - 1, n2); return bl || bl2; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * A utility class that contains the Sum of Subset problem solution using * recursion. * * The Sum of Subset problem determines whether a subset of elements from a * given array sums up to a specific target value. * * Wikipedia: https://en.wikipedia.org/wiki/Subset_sum_problem */ public final class SumOfSubset { private SumOfSubset() { } /** * Determines if there exists a subset of elements in the array `arr` that * adds up to the given `key` value using recursion. * * @param arr The array of integers. * @param num The index of the current element being considered. * @param key The target sum we are trying to achieve. * @return true if a subset of `arr` adds up to `key`, false otherwise. * * This is a recursive solution that checks for two possibilities at * each step: * 1. Include the current element in the subset and check if the * remaining elements can sum up to the remaining target. * 2. Exclude the current element and check if the remaining elements * can sum up to the target without this element. */ public static boolean subsetSum(int[] arr, int num, int key) { if (key == 0) { return true; } if (num < 0 || key < 0) { return false; } boolean include = subsetSum(arr, num - 1, key - arr[num]); boolean exclude = subsetSum(arr, num - 1, key); return include || exclude; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public class SumWithoutArithmeticOperators { public int getSum(int n, int n2) { if (n2 == 0) { return n; } int n3 = n ^ n2; n = (n & n2) << 1; return this.getSum(n3, n); } }", "deobfuscated_code": "package com.thealgorithms.maths; public class SumWithoutArithmeticOperators { /** * Calculate the sum of two numbers a and b without using any arithmetic operators (+, -, *, /). * All the integers associated are unsigned 32-bit integers *https://stackoverflow.com/questions/365522/what-is-the-best-way-to-add-two-numbers-without-using-the-operator *@param a - It is the first number *@param b - It is the second number *@return returns an integer which is the sum of the first and second number */ public int getSum(int a, int b) { if (b == 0) { return a; } int sum = a ^ b; int carry = (a & b) << 1; return getSum(sum, carry); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class SwapAdjacentBits { private SwapAdjacentBits() { } public static int swapAdjacentBits(int n) { int n2 = n & 0xAAAAAAAA; n &= 0x55555555; return (n2 >>= 1) | (n <<= 1); } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * A utility class to swap every pair of adjacent bits in a given integer. * This operation shifts the even-positioned bits to odd positions and vice versa. * * Example: * - Input: 2 (binary: `10`)  Output: 1 (binary: `01`) * - Input: 43 (binary: `101011`)  Output: 23 (binary: `010111`) * * **Explanation of the Algorithm:** * 1. Mask even-positioned bits: Using `0xAAAAAAAA` (binary: `101010...`), * which selects bits in even positions. * 2. Mask odd-positioned bits: Using `0x55555555` (binary: `010101...`), * which selects bits in odd positions. * 3. Shift bits: * - Right-shift even-positioned bits by 1 to move them to odd positions. * - Left-shift odd-positioned bits by 1 to move them to even positions. * 4. Combine both shifted results using bitwise OR (`|`) to produce the final result. * * Use Case: This algorithm can be useful in applications involving low-level bit manipulation, * such as encoding, data compression, or cryptographic transformations. * * Time Complexity: O(1) (constant time, since operations are bitwise). * * Author: Lakshyajeet Singh Goyal (https://github.com/DarkMatter-999) */ public final class SwapAdjacentBits { private SwapAdjacentBits() { } /** * Swaps every pair of adjacent bits of a given integer. * Steps: * 1. Mask the even-positioned bits. * 2. Mask the odd-positioned bits. * 3. Shift the even bits to the right and the odd bits to the left. * 4. Combine the shifted bits. * * @param num the integer whose bits are to be swapped * @return the integer after swapping every pair of adjacent bits */ public static int swapAdjacentBits(int num) { // mask the even bits (0xAAAAAAAA => 10101010...) int evenBits = num & 0xAAAAAAAA; // mask the odd bits (0x55555555 => 01010101...) int oddBits = num & 0x55555555; // right shift even bits and left shift odd bits evenBits >>= 1; oddBits <<= 1; // combine shifted bits return evenBits | oddBits; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class SwapSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { int n = 0; while (n < comparableArray.length - 1) { int n2 = n; Comparable[] comparableArray2 = comparableArray; int n3 = 0; for (int i = n2 + 1; i < comparableArray2.length; ++i) { if (!SortUtils.less(comparableArray2[i], comparableArray2[n2])) continue; ++n3; } int n4 = n3; if (n4 > 0) { int n5 = n; SortUtils.swap(comparableArray, n5, n5 + n4); continue; } ++n; } return comparableArray; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * The idea of Swap-Sort is to count the number m of smaller values (that are in * A) from each element of an array A(1...n) and then swap the element with the * element in A(m+1). This ensures that the exchanged element is already in the * correct, i.e. final, position. The disadvantage of this algorithm is that * each element may only occur once, otherwise there is no termination. */ public class SwapSort implements SortAlgorithm { @Override public <T extends Comparable<T>> T[] sort(T[] array) { int index = 0; while (index < array.length - 1) { final int amountSmallerElements = this.getSmallerElementCount(array, index); if (amountSmallerElements > 0) { SortUtils.swap(array, index, index + amountSmallerElements); } else { index++; } } return array; } private <T extends Comparable<T>> int getSmallerElementCount(final T[] array, final int index) { int counter = 0; for (int i = index + 1; i < array.length; i++) { if (SortUtils.less(array[i], array[index])) { counter++; } } return counter; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.io.Serializable; import java.util.ArrayList; import java.util.List; import java.util.Stack; public class TarjansAlgorithm { private int a; private final List b = new ArrayList(); public List stronglyConnectedComponents(int n, List list) { int[] nArray = new int[n]; int[] nArray2 = new int[n]; for (int i = 0; i < n; ++i) { nArray2[i] = -1; nArray[i] = -1; } boolean[] blArray = new boolean[n]; Stack stack = new Stack(); for (int i = 0; i < n; ++i) { if (nArray2[i] != -1) continue; this.a(i, nArray, nArray2, blArray, stack, list); } return this.b; } private void a(int n, int[] nArray, int[] nArray2, boolean[] blArray, Stack stack, List list) { nArray2[n] = this.a; nArray[n] = this.a++; blArray[n] = true; stack.push(n); for (Serializable serializable : (List)list.get(n)) { if (nArray2[(Integer)serializable] == -1) { this.a((Integer)serializable, nArray, nArray2, blArray, stack, list); nArray[n] = Math.min(nArray[n], nArray[(Integer)serializable]); continue; } if (!blArray[(Integer)serializable]) continue; nArray[n] = Math.min(nArray[n], nArray2[(Integer)serializable]); } if (nArray[n] == nArray2[n]) { Serializable serializable; int n2 = -1; serializable = new ArrayList(); while (n2 != n) { n2 = (Integer)stack.pop(); serializable.add(n2); blArray[n2] = false; } this.b.add(serializable); } } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.List; import java.util.Stack; /** * Java program that implements Tarjan's Algorithm to find Strongly Connected Components (SCCs) in a directed graph. * * <p> * Tarjan's algorithm is a linear time algorithm (O(V + E)) that identifies the SCCs of a directed graph. * An SCC is a maximal subgraph where every vertex is reachable from every other vertex within the subgraph. * * <h3>Algorithm Overview:</h3> * <ul> * <li>DFS Search: A depth-first search (DFS) is performed on the graph to generate a DFS tree.</li> * <li>Identification of SCCs: SCCs correspond to subtrees within this DFS tree.</li> * <li>Low-Link Values: For each node, a low-link value is maintained, which indicates the earliest visited * vertex (the one with the minimum insertion time) that can be reached from that subtree.</li> * <li>Stack Usage: Nodes are stored in a stack during DFS. When an SCC is identified, nodes are popped from * the stack until the head of the SCC is reached.</li> * </ul> * * <p> * Example of a directed graph: * <pre> * 0 --------> 1 -------> 3 --------> 4 * ^ / * | / * | / * | / * | / * | / * | / * | / * | / * | / * V * 2 * </pre> * * <p> * For the above graph, the SCC list is as follows: * <ul> * <li>1, 2, 0</li> * <li>3</li> * <li>4</li> * </ul> * The order of nodes in an SCC does not matter as they form cycles. * * <h3>Comparison with Kosaraju's Algorithm:</h3> * <p> * Kosaraju's algorithm also identifies SCCs but does so using two DFS traversals. * In contrast, Tarjan's algorithm achieves this in a single DFS traversal, leading to improved performance * in terms of constant factors. * </p> */ public class TarjansAlgorithm { // Timer for tracking low time and insertion time private int time; // List to store all strongly connected components private final List<List<Integer>> sccList = new ArrayList<>(); /** * Finds and returns the strongly connected components (SCCs) of the directed graph. * * @param v the number of vertices in the graph * @param graph the adjacency list representation of the graph * @return a list of lists, where each inner list represents a strongly connected component */ public List<List<Integer>> stronglyConnectedComponents(int v, List<List<Integer>> graph) { // Initialize arrays for insertion time and low-link values int[] lowTime = new int[v]; int[] insertionTime = new int[v]; for (int i = 0; i < v; i++) { insertionTime[i] = -1; lowTime[i] = -1; } // Track if vertices are in the stack boolean[] isInStack = new boolean[v]; // Stack to hold nodes during DFS Stack<Integer> st = new Stack<>(); for (int i = 0; i < v; i++) { if (insertionTime[i] == -1) { stronglyConnCompsUtil(i, lowTime, insertionTime, isInStack, st, graph); } } return sccList; } /** * A utility function to perform DFS and find SCCs. * * @param u the current vertex being visited * @param lowTime array to keep track of the low-link values * @param insertionTime array to keep track of the insertion times * @param isInStack boolean array indicating if a vertex is in the stack * @param st the stack used for DFS * @param graph the adjacency list representation of the graph */ private void stronglyConnCompsUtil(int u, int[] lowTime, int[] insertionTime, boolean[] isInStack, Stack<Integer> st, List<List<Integer>> graph) { // Set insertion time and low-link value insertionTime[u] = time; lowTime[u] = time; time++; // Push current node onto the stack isInStack[u] = true; st.push(u); // Explore adjacent vertices for (Integer vertex : graph.get(u)) { if (insertionTime[vertex] == -1) { stronglyConnCompsUtil(vertex, lowTime, insertionTime, isInStack, st, graph); // Update low-link value lowTime[u] = Math.min(lowTime[u], lowTime[vertex]); } else if (isInStack[vertex]) { // Vertex is in the stack; update low-link value lowTime[u] = Math.min(lowTime[u], insertionTime[vertex]); } } // Check if the current vertex is the root of an SCC if (lowTime[u] == insertionTime[u]) { int w = -1; List<Integer> scc = new ArrayList<>(); // Pop vertices from the stack until the root is found while (w != u) { w = st.pop(); scc.add(w); isInStack[w] = false; } sccList.add(scc); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.Node; class Task { private int[] a; Task() { } public Node sortByMergeSort(Node node) { if (node == null || node.b == null) { return node; } Node node2 = node; int n = 0; while (node2 != null) { ++n; node2 = node2.b; } int n2 = n; this.a = new int[n2]; n = 0; Node node3 = node; while (node3 != null) { this.a[n++] = node3.a; node3 = node3.b; } n = 0; Task task = this; task.a(task.a, 0, n2 - 1); node3 = node; while (node3 != null) { node3.a = this.a[n++]; node3 = node3.b; } return node; } private void a(int[] nArray, int n, int n2) { if (n < n2) { int n3 = (n + n2) / 2; this.a(nArray, n, n3); this.a(nArray, n3 + 1, n2); this.a(nArray, n, n3, n2); } } private void a(int[] nArray, int n, int n2, int n3) { int n4 = n; int n5 = 0; int n6 = n2 + 1; int[] nArray2 = new int[n3 - n + 1]; while (n4 <= n2 && n6 <= n3) { if (nArray[n6] >= nArray[n4]) { nArray2[n5++] = nArray[n4++]; continue; } nArray2[n5++] = nArray[n6++]; } while (n4 <= n2) { nArray2[n5++] = nArray[n4++]; } while (n6 <= n3) { nArray2[n5++] = nArray[n6++]; } for (int i = n; i <= n3; ++i) { this.a[i] = nArray2[i - n]; } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.Node; class Task { private int[] a; Task() { } public Node sortByMergeSort(Node node) { if (node == null || node.b == null) { return node; } Node node2 = node; int n = 0; while (node2 != null) { ++n; node2 = node2.b; } int n2 = n; this.a = new int[n2]; n = 0; Node node3 = node; while (node3 != null) { this.a[n++] = node3.a; node3 = node3.b; } n = 0; Task task = this; task.a(task.a, 0, n2 - 1); node3 = node; while (node3 != null) { node3.a = this.a[n++]; node3 = node3.b; } return node; } private void a(int[] nArray, int n, int n2) { if (n < n2) { int n3 = (n + n2) / 2; this.a(nArray, n, n3); this.a(nArray, n3 + 1, n2); this.a(nArray, n, n3, n2); } } private void a(int[] nArray, int n, int n2, int n3) { int n4 = n; int n5 = 0; int n6 = n2 + 1; int[] nArray2 = new int[n3 - n + 1]; while (n4 <= n2 && n6 <= n3) { if (nArray[n6] >= nArray[n4]) { nArray2[n5++] = nArray[n4++]; continue; } nArray2[n5++] = nArray[n6++]; } while (n4 <= n2) { nArray2[n5++] = nArray[n4++]; } while (n6 <= n3) { nArray2[n5++] = nArray[n6++]; } for (int i = n; i <= n3; ++i) { this.a[i] = nArray2[i - n]; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.Node; class Task1 { Task1() { } public Node sortByInsertionSort(Node node) { if (node == null || node.b == null) { return node; } Node node2 = node; int n = 0; while (node2 != null) { ++n; node2 = node2.b; } int n2 = n; int[] nArray = new int[n2]; int[] nArray2 = nArray; nArray[0] = node.a; Node node3 = node.b; n = 1; while (node3 != null) { for (int i = n - 1; i >= 0 && nArray2[i] > node3.a; --i) { nArray2[i + 1] = nArray2[i]; } nArray2[i + 1] = node3.a; node3 = node3.b; ++n; } n = 0; node3 = node; while (node3 != null) { node3.a = nArray2[n++]; node3 = node3.b; } return node; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.Node; class Task1 { Task1() { } public Node sortByInsertionSort(Node node) { if (node == null || node.b == null) { return node; } Node node2 = node; int n = 0; while (node2 != null) { ++n; node2 = node2.b; } int n2 = n; int[] nArray = new int[n2]; int[] nArray2 = nArray; nArray[0] = node.a; Node node3 = node.b; n = 1; while (node3 != null) { for (int i = n - 1; i >= 0 && nArray2[i] > node3.a; --i) { nArray2[i + 1] = nArray2[i]; } nArray2[i + 1] = node3.a; node3 = node3.b; ++n; } n = 0; node3 = node; while (node3 != null) { node3.a = nArray2[n++]; node3 = node3.b; } return node; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.Node; class Task2 { Task2() { } public Node sortByHeapSort(Node node) { int n; if (node == null || node.b == null) { return node; } Object object = node; int n2 = 0; Node node2 = object; while (node2 != null) { ++n2; node2 = node2.b; } int n3 = n2; int[] nArray = new int[n3]; int n4 = 0; object = node; while (object != null) { nArray[n4++] = ((Node)object).a; object = ((Node)object).b; } n4 = 0; int[] nArray2 = nArray; object = this; n2 = nArray2.length; for (n = n2 / 2 - 1; n >= 0; --n) { ((Task2)object).a(nArray2, n2, n); } for (n = n2 - 1; n > 0; --n) { n2 = nArray2[0]; nArray2[0] = nArray2[n]; nArray2[n] = n2; ((Task2)object).a(nArray2, n, 0); } object = node; while (object != null) { ((Node)object).a = nArray[n4++]; object = ((Node)object).b; } return node; } private void a(int[] nArray, int n, int n2) { while (true) { int n3 = n2; int n4 = 2 * n2 + 1; int n5 = 2 * n2 + 2; if (n4 < n && nArray[n4] > nArray[n3]) { n3 = n4; } if (n5 < n && nArray[n5] > nArray[n3]) { n3 = n5; } if (n3 == n2) break; n4 = nArray[n3]; nArray[n3] = nArray[n2]; nArray[n2] = n4; n2 = n3; } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.Node; class Task2 { Task2() { } public Node sortByHeapSort(Node node) { int n; if (node == null || node.b == null) { return node; } Object object = node; int n2 = 0; Node node2 = object; while (node2 != null) { ++n2; node2 = node2.b; } int n3 = n2; int[] nArray = new int[n3]; int n4 = 0; object = node; while (object != null) { nArray[n4++] = ((Node)object).a; object = ((Node)object).b; } n4 = 0; int[] nArray2 = nArray; object = this; n2 = nArray2.length; for (n = n2 / 2 - 1; n >= 0; --n) { ((Task2)object).a(nArray2, n2, n); } for (n = n2 - 1; n > 0; --n) { n2 = nArray2[0]; nArray2[0] = nArray2[n]; nArray2[n] = n2; ((Task2)object).a(nArray2, n, 0); } object = node; while (object != null) { ((Node)object).a = nArray[n4++]; object = ((Node)object).b; } return node; } private void a(int[] nArray, int n, int n2) { while (true) { int n3 = n2; int n4 = 2 * n2 + 1; int n5 = 2 * n2 + 2; if (n4 < n && nArray[n4] > nArray[n3]) { n3 = n4; } if (n5 < n && nArray[n5] > nArray[n3]) { n3 = n5; } if (n3 == n2) break; n4 = nArray[n3]; nArray[n3] = nArray[n2]; nArray[n2] = n4; n2 = n3; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; public class TernarySearch implements SearchAlgorithm { @Override public int find(Comparable[] comparableArray, Comparable comparable) { return this.a(comparableArray, comparable, 0, comparableArray.length - 1); } private int a(Comparable[] comparableArray, Comparable comparable, int n, int n2) { while (n <= n2) { int n3 = n + (n2 - n) / 3; int n4 = n + 2 * (n2 - n) / 3; if (comparable.compareTo(comparableArray[n3]) == 0) { return n3; } if (comparable.compareTo(comparableArray[n4]) == 0) { return n4; } if (comparable.compareTo(comparableArray[n3]) < 0) { n2 = --n3; continue; } if (comparable.compareTo(comparableArray[n4]) > 0) { n = ++n4; continue; } n2 = n4; n = n3; } return -1; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; /** * A ternary search algorithm is a technique in computer science for finding the * minimum or maximum of a unimodal function The algorithm determines either * that the minimum or maximum cannot be in the first third of the domain or * that it cannot be in the last third of the domain, then repeats on the * remaining third. * * <p> * Worst-case performance (log3(N)) Best-case performance O(1) Average * performance (log3(N)) Worst-case space complexity O(1) * * @author Podshivalov Nikita (https://github.com/nikitap492) * @see SearchAlgorithm * @see IterativeBinarySearch */ public class TernarySearch implements SearchAlgorithm { /** * @param arr The **Sorted** array in which we will search the element. * @param value The value that we want to search for. * @return The index of the element if found. Else returns -1. */ @Override public <T extends Comparable<T>> int find(T[] arr, T value) { return ternarySearch(arr, value, 0, arr.length - 1); } /** * @param arr The **Sorted** array in which we will search the element. * @param key The value that we want to search for. * @param start The starting index from which we will start Searching. * @param end The ending index till which we will Search. * @return Returns the index of the Element if found. Else returns -1. */ private <T extends Comparable<T>> int ternarySearch(T[] arr, T key, int start, int end) { if (start > end) { return -1; } /* First boundary: add 1/3 of length to start */ int mid1 = start + (end - start) / 3; /* Second boundary: add 2/3 of length to start */ int mid2 = start + 2 * (end - start) / 3; if (key.compareTo(arr[mid1]) == 0) { return mid1; } else if (key.compareTo(arr[mid2]) == 0) { return mid2; } /* Search the first (1/3) rd part of the array.*/ else if (key.compareTo(arr[mid1]) < 0) { return ternarySearch(arr, key, start, --mid1); } /* Search 3rd (1/3)rd part of the array */ else if (key.compareTo(arr[mid2]) > 0) { return ternarySearch(arr, key, ++mid2, end); } /* Search middle (1/3)rd part of the array */ else { return ternarySearch(arr, key, mid1, mid2); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.misc; import java.util.AbstractCollection; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.List; public class ThreeSumProblem { public List bruteForce(int[] nArray, int n) { ArrayList arrayList = new ArrayList(); for (int i = 0; i < nArray.length; ++i) { for (int j = i + 1; j < nArray.length; ++j) { for (int k = j + 1; k < nArray.length; ++k) { if (nArray[i] + nArray[j] + nArray[k] != n) continue; ArrayList<Integer> arrayList2 = new ArrayList<Integer>(); arrayList2.add(nArray[i]); arrayList2.add(nArray[j]); arrayList2.add(nArray[k]); Collections.sort(arrayList2); arrayList.add(arrayList2); } } } arrayList = new ArrayList(new LinkedHashSet(arrayList)); return arrayList; } public List twoPointer(int[] nArray, int n) { AbstractCollection abstractCollection; Arrays.sort(nArray); ArrayList<AbstractCollection> arrayList = new ArrayList<AbstractCollection>(); for (int i = 0; i < nArray.length - 1; ++i) { int n2 = i + 1; int n3 = nArray.length - 1; while (n2 < n3) { if (nArray[n2] + nArray[n3] + nArray[i] == n) { abstractCollection = new ArrayList<Integer>(); abstractCollection.add(nArray[i]); abstractCollection.add(nArray[n2]); abstractCollection.add(nArray[n3]); arrayList.add(abstractCollection); ++n2; --n3; continue; } if (nArray[n2] + nArray[n3] + nArray[i] < n) { ++n2; continue; } --n3; } } abstractCollection = new LinkedHashSet(arrayList); return new ArrayList(abstractCollection); } public List hashMap(int[] nArray, int n) { int n2; Arrays.sort(nArray); HashSet hashSet = new HashSet(); HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>(); for (n2 = 0; n2 < nArray.length; ++n2) { hashMap.put(nArray[n2], n2); } for (n2 = 0; n2 < nArray.length; ++n2) { for (int i = n2 + 1; i < nArray.length; ++i) { int n3 = n - nArray[n2] - nArray[i]; if (!hashMap.containsKey(n3) || (Integer)hashMap.get(n3) <= i) continue; ArrayList<Integer> arrayList = new ArrayList<Integer>(); arrayList.add(nArray[n2]); arrayList.add(nArray[i]); arrayList.add(n3); hashSet.add(arrayList); } } return new ArrayList(hashSet); } }", "deobfuscated_code": "package com.thealgorithms.misc; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.List; import java.util.Set; public class ThreeSumProblem { public List<List<Integer>> bruteForce(int[] nums, int target) { List<List<Integer>> arr = new ArrayList<List<Integer>>(); for (int i = 0; i < nums.length; i++) { for (int j = i + 1; j < nums.length; j++) { for (int k = j + 1; k < nums.length; k++) { if (nums[i] + nums[j] + nums[k] == target) { List<Integer> temp = new ArrayList<>(); temp.add(nums[i]); temp.add(nums[j]); temp.add(nums[k]); Collections.sort(temp); arr.add(temp); } } } } arr = new ArrayList<List<Integer>>(new LinkedHashSet<List<Integer>>(arr)); return arr; } public List<List<Integer>> twoPointer(int[] nums, int target) { Arrays.sort(nums); List<List<Integer>> arr = new ArrayList<List<Integer>>(); int start = 0; int end = 0; int i = 0; while (i < nums.length - 1) { start = i + 1; end = nums.length - 1; while (start < end) { if (nums[start] + nums[end] + nums[i] == target) { List<Integer> temp = new ArrayList<>(); temp.add(nums[i]); temp.add(nums[start]); temp.add(nums[end]); arr.add(temp); start++; end--; } else if (nums[start] + nums[end] + nums[i] < target) { start += 1; } else { end -= 1; } } i++; } Set<List<Integer>> set = new LinkedHashSet<List<Integer>>(arr); return new ArrayList<List<Integer>>(set); } public List<List<Integer>> hashMap(int[] nums, int target) { Arrays.sort(nums); Set<List<Integer>> ts = new HashSet<>(); HashMap<Integer, Integer> hm = new HashMap<>(); for (int i = 0; i < nums.length; i++) { hm.put(nums[i], i); } for (int i = 0; i < nums.length; i++) { for (int j = i + 1; j < nums.length; j++) { int t = target - nums[i] - nums[j]; if (hm.containsKey(t) && hm.get(t) > j) { List<Integer> temp = new ArrayList<>(); temp.add(nums[i]); temp.add(nums[j]); temp.add(t); ts.add(temp); } } } return new ArrayList<>(ts); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.divideandconquer; public final class TilingProblem { private static int a = 1; private static int[][] b; private TilingProblem() { } public static int[][] solveTiling(int n, int n2, int n3) { int n4 = n; b = new int[n4][n4]; TilingProblem.a(n, 0, 0, n2, n3); return b; } private static void a(int n, int n2, int n3, int n4, int n5) { while (n != 1) { int n6; ++a; if (n4 < n2 + (n /= 2) && n5 < n3 + n) { TilingProblem.a(n, n2, n3, n4, n5); } else { TilingProblem.b[n2 + n - 1][n3 + n - 1] = n6; TilingProblem.a(n, n2, n3, n2 + n - 1, n3 + n - 1); } if (n4 < n2 + n && n5 >= n3 + n) { TilingProblem.a(n, n2, n3 + n, n4, n5); } else { TilingProblem.b[n2 + n - 1][n3 + n] = n6; TilingProblem.a(n, n2, n3 + n, n2 + n - 1, n3 + n); } if (n4 >= n2 + n && n5 < n3 + n) { TilingProblem.a(n, n2 + n, n3, n4, n5); } else { TilingProblem.b[n2 + n][n3 + n - 1] = n6; TilingProblem.a(n, n2 + n, n3, n2 + n, n3 + n - 1); } if (n4 >= n2 + n && n5 >= n3 + n) { TilingProblem.a(n, n2 + n, n3 + n, n4, n5); return; } TilingProblem.b[n2 + n][n3 + n] = n6; n5 = n3 + n; n4 = n2 + n; n3 += n; n2 += n; } return; } }", "deobfuscated_code": "package com.thealgorithms.divideandconquer; /** * This class provides a solution to the Tiling Problem using divide-and-conquer. * <p> * The Tiling Problem involves filling a 2^n x 2^n board with a single missing * square using L-shaped tiles (each tile covers exactly three squares). * The algorithm recursively divides the board into four quadrants, places an * L-shaped tile in the appropriate quadrant, and fills the remaining areas. * * <p>Applications: * - Used in graphics and image processing. * - Helpful in solving puzzles and tiling problems in competitive programming. * * @author Hardvan */ public final class TilingProblem { private TilingProblem() { } /** * A counter used to label the L-shaped tiles placed on the board. */ private static int tile = 1; /** * A 2D array representing the board to be tiled. */ private static int[][] board; /** * Solves the tiling problem for a 2^n x 2^n board with one missing square. * * @param size The size of the board (must be a power of 2). * @param missingRow The row index of the missing square. * @param missingCol The column index of the missing square. * @return A 2D array representing the tiled board with L-shaped tiles. */ public static int[][] solveTiling(int size, int missingRow, int missingCol) { board = new int[size][size]; fillBoard(size, 0, 0, missingRow, missingCol); return board; } /** * Recursively fills the board with L-shaped tiles. * * <p>The board is divided into four quadrants. Depending on the location of * the missing square, an L-shaped tile is placed at the center of the board * to cover three of the four quadrants. The process is then repeated for * each quadrant until the entire board is filled. * * @param size The current size of the sub-board. * @param row The starting row index of the current sub-board. * @param col The starting column index of the current sub-board. * @param missingRow The row index of the missing square within the board. * @param missingCol The column index of the missing square within the board. */ private static void fillBoard(int size, int row, int col, int missingRow, int missingCol) { if (size == 1) { return; } int half = size / 2; int t = tile++; // Top-left quadrant if (missingRow < row + half && missingCol < col + half) { fillBoard(half, row, col, missingRow, missingCol); } else { board[row + half - 1][col + half - 1] = t; fillBoard(half, row, col, row + half - 1, col + half - 1); } // Top-right quadrant if (missingRow < row + half && missingCol >= col + half) { fillBoard(half, row, col + half, missingRow, missingCol); } else { board[row + half - 1][col + half] = t; fillBoard(half, row, col + half, row + half - 1, col + half); } // Bottom-left quadrant if (missingRow >= row + half && missingCol < col + half) { fillBoard(half, row + half, col, missingRow, missingCol); } else { board[row + half][col + half - 1] = t; fillBoard(half, row + half, col, row + half, col + half - 1); } // Bottom-right quadrant if (missingRow >= row + half && missingCol >= col + half) { fillBoard(half, row + half, col + half, missingRow, missingCol); } else { board[row + half][col + half] = t; fillBoard(half, row + half, col + half, row + half, col + half); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.InsertionSort; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; class TimSort implements SortAlgorithm { private Comparable[] a; TimSort() { } /* * Unable to fully structure code */ @Override public Comparable[] sort(Comparable[] var1_1) { var2_2 = var1_1.length; var3_3 = new InsertionSort(); for (var4_5 = 0; var4_5 < var2_2; var4_5 += 32) { v0 = var4_5; var3_3.sort(var1_1, v0, Math.min(v0 + 32, var2_2)); } this.a = new Comparable[var2_2]; var4_5 = 32; while (var4_5 < var2_2) { for (var3_4 = 0; var3_4 < var2_2 - var4_5; var3_4 += v1 + v1) { v2 = var3_4; var9_10 = Math.min(var3_4 + var4_5 + var4_5 - 1, var2_2 - 1); var8_9 = v2 + var4_5 - 1; var7_8 = v2; var6_7 = var1_1; var5_6 = this; var10_11 = var7_8; var11_12 = var8_9 + 1; System.arraycopy(var6_7, var7_8, var5_6.a, var7_8, var9_10 + 1 - var7_8); while (var7_8 <= var9_10) { if (var11_12 > var9_10) ** GOTO lbl-1000 if (var10_11 > var8_9) { var6_7[var7_8] = var5_6.a[var11_12++]; } else if (SortUtils.less(var5_6.a[var11_12], var5_6.a[var10_11])) { var6_7[var7_8] = var5_6.a[var11_12++]; } else lbl-1000: // 2 sources { var6_7[var7_8] = var5_6.a[var10_11++]; } ++var7_8; } v1 = var4_5; } v3 = var4_5; var4_5 = v3 + v3; } return var1_1; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import static com.thealgorithms.sorts.SortUtils.less; /** * This is simplified TimSort algorithm implementation. The original one is more complicated. * <p> * For more details @see <a href=\"https://en.wikipedia.org/wiki/Timsort\">TimSort Algorithm</a> */ @SuppressWarnings({\"rawtypes\", \"unchecked\"}) class TimSort implements SortAlgorithm { private static final int SUB_ARRAY_SIZE = 32; private Comparable[] aux; @Override public <T extends Comparable<T>> T[] sort(T[] array) { final int n = array.length; InsertionSort insertionSort = new InsertionSort(); for (int i = 0; i < n; i += SUB_ARRAY_SIZE) { insertionSort.sort(array, i, Math.min(i + SUB_ARRAY_SIZE, n)); } aux = new Comparable[n]; for (int sz = SUB_ARRAY_SIZE; sz < n; sz = sz + sz) { for (int lo = 0; lo < n - sz; lo += sz + sz) { merge(array, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, n - 1)); } } return array; } private <T extends Comparable<T>> void merge(T[] a, final int lo, final int mid, final int hi) { int i = lo; int j = mid + 1; System.arraycopy(a, lo, aux, lo, hi + 1 - lo); for (int k = lo; k <= hi; k++) { if (j > hi) { a[k] = (T) aux[i++]; } else if (i > mid) { a[k] = (T) aux[j++]; } else if (less(aux[j], aux[i])) { a[k] = (T) aux[j++]; } else { a[k] = (T) aux[i++]; } } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.queues; import java.util.concurrent.TimeUnit; public final class TokenBucket { private final int a; private final int b; private int c; private long d; public TokenBucket(int n, int n2) { this.a = n; this.b = n2; this.c = n; this.d = System.nanoTime(); } public final synchronized boolean allowRequest() { TokenBucket tokenBucket = this; long l = System.nanoTime(); long l2 = (l - tokenBucket.d) / TimeUnit.SECONDS.toNanos(1L) * (long)tokenBucket.b; tokenBucket.c = Math.min(tokenBucket.a, tokenBucket.c + (int)l2); tokenBucket.d = l; if (this.c > 0) { --this.c; return true; } return false; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.queues; import java.util.concurrent.TimeUnit; /** * TokenBucket implements a token bucket rate limiter algorithm. * This class is used to control the rate of requests in a distributed system. * It allows a certain number of requests (tokens) to be processed in a time frame, * based on the defined refill rate. * * Applications: Computer networks, API rate limiting, distributed systems, etc. * * @author Hardvan */ public final class TokenBucket { private final int maxTokens; private final int refillRate; // tokens per second private int tokens; private long lastRefill; // Timestamp in nanoseconds /** * Constructs a TokenBucket instance. * * @param maxTokens Maximum number of tokens the bucket can hold. * @param refillRate The rate at which tokens are refilled (tokens per second). */ public TokenBucket(int maxTokens, int refillRate) { this.maxTokens = maxTokens; this.refillRate = refillRate; this.tokens = maxTokens; this.lastRefill = System.nanoTime(); } /** * Attempts to allow a request based on the available tokens. * If a token is available, it decrements the token count and allows the request. * Otherwise, the request is denied. * * @return true if the request is allowed, false if the request is denied. */ public synchronized boolean allowRequest() { refillTokens(); if (tokens > 0) { tokens--; return true; } return false; } /** * Refills the tokens based on the time elapsed since the last refill. * The number of tokens to be added is calculated based on the elapsed time * and the refill rate, ensuring the total does not exceed maxTokens. */ private void refillTokens() { long now = System.nanoTime(); long tokensToAdd = (now - lastRefill) / TimeUnit.SECONDS.toNanos(1) * refillRate; tokens = Math.min(maxTokens, tokens + (int) tokensToAdd); lastRefill = now; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; enum TopologicalSort$Color { WHITE, GRAY, BLACK; }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; enum TopologicalSort$Color { WHITE, GRAY, BLACK; }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.TopologicalSort$Vertex; import java.util.Collections; import java.util.HashMap; import java.util.LinkedHashMap; class TopologicalSort$Graph { private final HashMap a = new LinkedHashMap(); TopologicalSort$Graph() { } public void addEdge(String string, String ... stringArray) { this.a.put(string, new TopologicalSort$Vertex(string)); if (!stringArray[0].isEmpty()) { Collections.addAll(((TopologicalSort$Vertex)this.a.get((Object)string)).next, stringArray); } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.TopologicalSort$Vertex; import java.util.Collections; import java.util.HashMap; import java.util.LinkedHashMap; class TopologicalSort$Graph { private final HashMap a = new LinkedHashMap(); TopologicalSort$Graph() { } public void addEdge(String string, String ... stringArray) { this.a.put(string, new TopologicalSort$Vertex(string)); if (!stringArray[0].isEmpty()) { Collections.addAll(((TopologicalSort$Vertex)this.a.get((Object)string)).next, stringArray); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.TopologicalSort$Color; import java.util.ArrayList; class TopologicalSort$Vertex { public final String label; public TopologicalSort$Color color = TopologicalSort$Color.WHITE; public final ArrayList next = new ArrayList(); TopologicalSort$Vertex(String string) { this.label = string; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.TopologicalSort$Color; import java.util.ArrayList; class TopologicalSort$Vertex { public final String label; public TopologicalSort$Color color = TopologicalSort$Color.WHITE; public final ArrayList next = new ArrayList(); TopologicalSort$Vertex(String string) { this.label = string; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.TopologicalSort$Color; import com.thealgorithms.sorts.TopologicalSort$Graph; import com.thealgorithms.sorts.TopologicalSort$Vertex; import java.util.LinkedList; public final class TopologicalSort { private TopologicalSort() { } public static LinkedList sort(TopologicalSort$Graph topologicalSort$Graph) { LinkedList linkedList = new LinkedList(); topologicalSort$Graph.a.forEach((string, topologicalSort$Vertex) -> { if (topologicalSort$Vertex.color == TopologicalSort$Color.WHITE) { linkedList.addFirst(TopologicalSort.a(topologicalSort$Graph, topologicalSort$Vertex, linkedList)); } }); return linkedList; } private static String a(TopologicalSort$Graph topologicalSort$Graph, TopologicalSort$Vertex topologicalSort$Vertex, LinkedList linkedList) { topologicalSort$Vertex.color = TopologicalSort$Color.GRAY; ((TopologicalSort$Vertex)topologicalSort$Graph.a.get((Object)topologicalSort$Vertex.label)).next.forEach(string -> { if (((TopologicalSort$Vertex)topologicalSort$Graph.a.get((Object)string)).color == TopologicalSort$Color.WHITE) { TopologicalSort$Graph topologicalSort$Graph2 = topologicalSort$Graph; linkedList.addFirst(TopologicalSort.a(topologicalSort$Graph2, (TopologicalSort$Vertex)topologicalSort$Graph2.a.get(string), linkedList)); return; } if (((TopologicalSort$Vertex)topologicalSort$Graph.a.get((Object)string)).color == TopologicalSort$Color.GRAY) { throw new RuntimeException(\"This graph contains a cycle. No linear ordering is possible. Back edge: \" + topologicalSort$Vertex.label + \" -> \" + string); } }); topologicalSort$Vertex.color = TopologicalSort$Color.BLACK; return topologicalSort$Vertex.label; } }", "deobfuscated_code": "package com.thealgorithms.sorts; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.LinkedHashMap; import java.util.LinkedList; /** * The Topological Sorting algorithm linearly orders a DAG or Directed Acyclic Graph into * a linked list. A Directed Graph is proven to be acyclic when a DFS or Depth First Search is * performed, yielding no back-edges. * * https://en.wikipedia.org/wiki/Topological_sorting * * @author Jonathan Taylor (https://github.com/Jtmonument) * Based on Introduction to Algorithms 3rd Edition */ public final class TopologicalSort { private TopologicalSort() { } /* * Enum to represent the colors for the depth first search * */ private enum Color { WHITE, GRAY, BLACK, } /* * Class to represent vertices * */ private static class Vertex { /* * Name of vertex * */ public final String label; /* * Represents the category of visit in DFS * */ public Color color = Color.WHITE; /* * The array of names of descendant vertices * */ public final ArrayList<String> next = new ArrayList<>(); Vertex(String label) { this.label = label; } } /* * Graph class uses the adjacency list representation * */ static class Graph { /* * Adjacency list representation * */ private final HashMap<String, Vertex> adj = new LinkedHashMap<>(); /* * Function to add an edge to the graph * */ public void addEdge(String label, String... next) { adj.put(label, new Vertex(label)); if (!next[0].isEmpty()) { Collections.addAll(adj.get(label).next, next); } } } /* * Depth First Search * * DFS(G) * for each vertex u  G.V * u.color = WHITE * u. = NIL * time = 0 * for each vertex u  G.V * if u.color == WHITE * DFS-VISIT(G, u) * * Performed in (V + E) time * */ public static LinkedList<String> sort(Graph graph) { LinkedList<String> list = new LinkedList<>(); graph.adj.forEach((name, vertex) -> { if (vertex.color == Color.WHITE) { list.addFirst(sort(graph, vertex, list)); } }); return list; } /* * Depth First Search Visit * * DFS-Visit(G, u) * time = time + 1 * u.d = time * u.color = GRAY * for each v  G.Adj[u] * if v.color == WHITE * v. = u * DFS-Visit(G, u) * u.color = BLACK * time = time + 1 * u.f = time * */ private static String sort(Graph graph, Vertex u, LinkedList<String> list) { u.color = Color.GRAY; graph.adj.get(u.label).next.forEach(label -> { if (graph.adj.get(label).color == Color.WHITE) { list.addFirst(sort(graph, graph.adj.get(label), list)); } else if (graph.adj.get(label).color == Color.GRAY) { /* * A back edge exists if an edge (u, v) connects a vertex u to its ancestor vertex v * in a depth first tree. If v.d  u.d < u.f  v.f * * In many cases, we will not know u.f, but v.color denotes the type of edge * */ throw new RuntimeException(\"This graph contains a cycle. No linear ordering is possible. Back edge: \" + u.label + \" -> \" + label); } }); u.color = Color.BLACK; return u.label; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.puzzlesandgames; import java.util.List; final class TowerOfHanoi { private TowerOfHanoi() { } public static void shift(int n, String string, String string2, String string3, List list) { while (n != 0) { TowerOfHanoi.shift(n - 1, string, string3, string2, list); list.add(String.format(\"Move %d from %s to %s\", n, string, string3)); String string4 = string2; string2 = string; string = string4; --n; } } }", "deobfuscated_code": "package com.thealgorithms.puzzlesandgames; import java.util.List; /** * The {@code TowerOfHanoi} class provides a recursive solution to the Tower of Hanoi puzzle. * This puzzle involves moving a set of discs from one pole to another, following specific rules: * 1. Only one disc can be moved at a time. * 2. A disc can only be placed on top of a larger disc. * 3. All discs must start on one pole and end on another. * * This implementation recursively calculates the steps required to solve the puzzle and stores them * in a provided list. * * <p> * For more information about the Tower of Hanoi, see * <a href=\"https://en.wikipedia.org/wiki/Tower_of_Hanoi\">Tower of Hanoi on Wikipedia</a>. * </p> * * The {@code shift} method takes the number of discs and the names of the poles, * and appends the steps required to solve the puzzle to the provided list. * Time Complexity: O(2^n) - Exponential time complexity due to the recursive nature of the problem. * Space Complexity: O(n) - Linear space complexity due to the recursion stack. * Wikipedia: https://en.wikipedia.org/wiki/Tower_of_Hanoi */ final class TowerOfHanoi { private TowerOfHanoi() { } /** * Recursively solve the Tower of Hanoi puzzle by moving discs between poles. * * @param n The number of discs to move. * @param startPole The name of the start pole from which discs are moved. * @param intermediatePole The name of the intermediate pole used as a temporary holding area. * @param endPole The name of the end pole to which discs are moved. * @param result A list to store the steps required to solve the puzzle. * * <p> * This method is called recursively to move n-1 discs * to the intermediate pole, * then moves the nth disc to the end pole, and finally * moves the n-1 discs from the * intermediate pole to the end pole. * </p> * * <p> * Time Complexity: O(2^n) - Exponential time complexity due to the recursive nature of the problem. * Space Complexity: O(n) - Linear space complexity due to the recursion stack. * </p> */ public static void shift(int n, String startPole, String intermediatePole, String endPole, List<String> result) { if (n != 0) { // Move n-1 discs from startPole to intermediatePole shift(n - 1, startPole, endPole, intermediatePole, result); // Add the move of the nth disc from startPole to endPole result.add(String.format(\"Move %d from %s to %s\", n, startPole, endPole)); // Move the n-1 discs from intermediatePole to endPole shift(n - 1, intermediatePole, startPole, endPole, result); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.graph; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; public final class TravelingSalesman { private TravelingSalesman() { } public static int bruteForce(int[][] nArray) { if (nArray.length <= 1) { return 0; } ArrayList<Integer> arrayList = new ArrayList<Integer>(); for (int i = 1; i < nArray.length; ++i) { arrayList.add(i); } Object object = new ArrayList(); TravelingSalesman.a(arrayList, 0, object); int n = Integer.MAX_VALUE; object = object.iterator(); while (object.hasNext()) { List list = (List)object.next(); ArrayList<Integer> arrayList2 = new ArrayList<Integer>(); arrayList2.add(0); arrayList2.addAll(list); int n2 = TravelingSalesman.calculateDistance(nArray, arrayList2); if (n2 >= n) continue; n = n2; } return n; } public static int calculateDistance(int[][] nArray, List list) { int n; int n2 = 0; for (n = 0; n < list.size() - 1; ++n) { int n3 = nArray[(Integer)list.get(n)][(Integer)list.get(n + 1)]; if (n3 == Integer.MAX_VALUE) { return Integer.MAX_VALUE; } n2 += n3; } List list2 = list; n = nArray[(Integer)list2.get(list2.size() - 1)][(Integer)list.get(0)]; if (n == Integer.MAX_VALUE) { return Integer.MAX_VALUE; } return n2 + n; } private static void a(List list, int n, List list2) { if (n == list.size()) { list2.add(new ArrayList(list)); return; } for (int i = n; i < list.size(); ++i) { Collections.swap(list, i, n); TravelingSalesman.a(list, n + 1, list2); Collections.swap(list, i, n); } } public static int dynamicProgramming(int[][] nArray) { int n; int n2; int n3; if (nArray.length == 0) { return 0; } int n4 = nArray.length; int[][] nArray2 = nArray; int n5 = nArray.length; for (n3 = 0; n3 < n5; ++n3) { int[] nArray3 = nArray2[n3]; if (nArray3.length == n4) continue; throw new IllegalArgumentException(\"Matrix must be square\"); } nArray2 = new int[n4][1 << n4]; int[][] nArray4 = nArray2; n3 = nArray2.length; for (n2 = 0; n2 < n3; ++n2) { int[] nArray5 = nArray4[n2]; Arrays.fill(nArray5, Integer.MAX_VALUE); } nArray2[0][1] = 0; for (n = 1; n < 1 << n4; ++n) { for (n3 = 0; n3 < n4; ++n3) { if ((n & 1 << n3) == 0 || nArray2[n3][n] == Integer.MAX_VALUE) continue; for (n2 = 0; n2 < n4; ++n2) { if ((n & 1 << n2) != 0 || nArray[n3][n2] == Integer.MAX_VALUE) continue; int n6 = n | 1 << n2; nArray2[n2][n6] = Math.min(nArray2[n2][n6], nArray2[n3][n] + nArray[n3][n2]); } } } n = Integer.MAX_VALUE; n3 = (1 << n4) - 1; for (n2 = 1; n2 < n4; ++n2) { if (nArray2[n2][n3] == Integer.MAX_VALUE || nArray[n2][0] == Integer.MAX_VALUE) continue; n = Math.min(n, nArray2[n2][n3] + nArray[n2][0]); } if (n == Integer.MAX_VALUE) { return 0; } return n; } }", "deobfuscated_code": "package com.thealgorithms.graph; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; /** * This class provides solutions to the Traveling Salesman Problem (TSP) using both brute-force and dynamic programming approaches. * For more information, see <a href=\"https://en.wikipedia.org/wiki/Travelling_salesman_problem\">Wikipedia</a>. * @author <a href=\"https://github.com/DenizAltunkapan\">Deniz Altunkapan</a> */ public final class TravelingSalesman { // Private constructor to prevent instantiation private TravelingSalesman() { } /** * Solves the Traveling Salesman Problem (TSP) using brute-force approach. * This method generates all possible permutations of cities, calculates the total distance for each route, and returns the shortest distance found. * * @param distanceMatrix A square matrix where element [i][j] represents the distance from city i to city j. * @return The shortest possible route distance visiting all cities exactly once and returning to the starting city. */ public static int bruteForce(int[][] distanceMatrix) { if (distanceMatrix.length <= 1) { return 0; } List<Integer> cities = new ArrayList<>(); for (int i = 1; i < distanceMatrix.length; i++) { cities.add(i); } List<List<Integer>> permutations = generatePermutations(cities); int minDistance = Integer.MAX_VALUE; for (List<Integer> permutation : permutations) { List<Integer> route = new ArrayList<>(); route.add(0); route.addAll(permutation); int currentDistance = calculateDistance(distanceMatrix, route); if (currentDistance < minDistance) { minDistance = currentDistance; } } return minDistance; } /** * Computes the total distance of a given route. * * @param distanceMatrix A square matrix where element [i][j] represents the * distance from city i to city j. * @param route A list representing the order in which the cities are visited. * @return The total distance of the route, or Integer.MAX_VALUE if the route is invalid. */ public static int calculateDistance(int[][] distanceMatrix, List<Integer> route) { int distance = 0; for (int i = 0; i < route.size() - 1; i++) { int d = distanceMatrix[route.get(i)][route.get(i + 1)]; if (d == Integer.MAX_VALUE) { return Integer.MAX_VALUE; } distance += d; } int returnDist = distanceMatrix[route.get(route.size() - 1)][route.get(0)]; return (returnDist == Integer.MAX_VALUE) ? Integer.MAX_VALUE : distance + returnDist; } /** * Generates all permutations of a given list of cities. * * @param cities A list of cities to permute. * @return A list of all possible permutations. */ private static List<List<Integer>> generatePermutations(List<Integer> cities) { List<List<Integer>> permutations = new ArrayList<>(); permute(cities, 0, permutations); return permutations; } /** * Recursively generates permutations using backtracking. * * @param arr The list of cities. * @param k The current index in the permutation process. * @param output The list to store generated permutations. */ private static void permute(List<Integer> arr, int k, List<List<Integer>> output) { if (k == arr.size()) { output.add(new ArrayList<>(arr)); return; } for (int i = k; i < arr.size(); i++) { Collections.swap(arr, i, k); permute(arr, k + 1, output); Collections.swap(arr, i, k); } } /** * Solves the Traveling Salesman Problem (TSP) using dynamic programming with the Held-Karp algorithm. * * @param distanceMatrix A square matrix where element [i][j] represents the distance from city i to city j. * @return The shortest possible route distance visiting all cities exactly once and returning to the starting city. * @throws IllegalArgumentException if the input matrix is not square. */ public static int dynamicProgramming(int[][] distanceMatrix) { if (distanceMatrix.length == 0) { return 0; } int n = distanceMatrix.length; for (int[] row : distanceMatrix) { if (row.length != n) { throw new IllegalArgumentException(\"Matrix must be square\"); } } int[][] dp = new int[n][1 << n]; for (int[] row : dp) { Arrays.fill(row, Integer.MAX_VALUE); } dp[0][1] = 0; for (int mask = 1; mask < (1 << n); mask++) { for (int u = 0; u < n; u++) { if ((mask & (1 << u)) == 0 || dp[u][mask] == Integer.MAX_VALUE) { continue; } for (int v = 0; v < n; v++) { if ((mask & (1 << v)) != 0 || distanceMatrix[u][v] == Integer.MAX_VALUE) { continue; } int newMask = mask | (1 << v); dp[v][newMask] = Math.min(dp[v][newMask], dp[u][mask] + distanceMatrix[u][v]); } } } int minDistance = Integer.MAX_VALUE; int fullMask = (1 << n) - 1; for (int i = 1; i < n; i++) { if (dp[i][fullMask] != Integer.MAX_VALUE && distanceMatrix[i][0] != Integer.MAX_VALUE) { minDistance = Math.min(minDistance, dp[i][fullMask] + distanceMatrix[i][0]); } } return minDistance == Integer.MAX_VALUE ? 0 : minDistance; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; public class Treap$TreapNode { public int value; private int a; private int b; public Treap$TreapNode left; public Treap$TreapNode right; public Treap$TreapNode(int n, int n2) { this.value = n; this.a = n2; this.b = 1; this.left = null; this.right = null; } private void a() { this.b = 1; if (this.left != null) { this.b += this.left.b; } if (this.right != null) { this.b += this.right.b; } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; public class Treap$TreapNode { public int value; private int a; private int b; public Treap$TreapNode left; public Treap$TreapNode right; public Treap$TreapNode(int n, int n2) { this.value = n; this.a = n2; this.b = 1; this.left = null; this.right = null; } private void a() { this.b = 1; if (this.left != null) { this.b += this.left.b; } if (this.right != null) { this.b += this.right.b; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.Treap$TreapNode; import java.util.Random; public class Treap { private Treap$TreapNode a = null; private Random b = new Random(); private Treap$TreapNode a(Treap$TreapNode treap$TreapNode, Treap$TreapNode treap$TreapNode2) { if (treap$TreapNode == null) { return treap$TreapNode2; } if (treap$TreapNode2 == null) { return treap$TreapNode; } if (treap$TreapNode.a > treap$TreapNode2.a) { treap$TreapNode.right = this.a(treap$TreapNode.right, treap$TreapNode2); treap$TreapNode.a(); return treap$TreapNode; } treap$TreapNode2.left = this.a(treap$TreapNode, treap$TreapNode2.left); treap$TreapNode2.a(); return treap$TreapNode2; } private Treap$TreapNode[] a(Treap$TreapNode treap$TreapNode, int n) { Treap$TreapNode[] treap$TreapNodeArray; if (treap$TreapNode == null) { return new Treap$TreapNode[]{null, null}; } if (treap$TreapNode.value <= n) { treap$TreapNodeArray = this.a(treap$TreapNode.right, n); treap$TreapNode.right = treap$TreapNodeArray[0]; treap$TreapNode.a(); treap$TreapNodeArray[0] = treap$TreapNode; } else { treap$TreapNodeArray = this.a(treap$TreapNode.left, n); treap$TreapNode.left = treap$TreapNodeArray[1]; treap$TreapNode.a(); treap$TreapNodeArray[1] = treap$TreapNode; } return treap$TreapNodeArray; } public Treap$TreapNode insert(int n) { if (this.a == null) { this.a = new Treap$TreapNode(n, this.b.nextInt()); return this.a; } Treap treap = this; Treap$TreapNode[] treap$TreapNodeArray = treap.a(treap.a, n); Treap$TreapNode treap$TreapNode = new Treap$TreapNode(n, this.b.nextInt()); treap$TreapNode = this.a(treap$TreapNodeArray[0], treap$TreapNode); treap$TreapNode.a(); treap$TreapNode = this.a(treap$TreapNode, treap$TreapNodeArray[1]); treap$TreapNode.a(); this.a = treap$TreapNode; return this.a; } public Treap$TreapNode delete(int n) { this.a = this.b(this.a, n); return this.a; } private Treap$TreapNode b(Treap$TreapNode treap$TreapNode, int n) { if (treap$TreapNode == null) { return null; } if (n < treap$TreapNode.value) { treap$TreapNode.left = this.b(treap$TreapNode.left, n); } else if (n > treap$TreapNode.value) { treap$TreapNode.right = this.b(treap$TreapNode.right, n); } else { treap$TreapNode = this.a(treap$TreapNode.left, treap$TreapNode.right); } if (treap$TreapNode != null) { treap$TreapNode.a(); } return treap$TreapNode; } public void inOrder() { System.out.print(\"{\"); Treap treap = this; treap.a(treap.a); System.out.print(\"}\"); } private void a(Treap$TreapNode treap$TreapNode) { while (treap$TreapNode != null) { this.a(treap$TreapNode.left); System.out.print(treap$TreapNode.value + \",\"); treap$TreapNode = treap$TreapNode.right; } return; } public void preOrder() { System.out.print(\"{\"); Treap treap = this; treap.b(treap.a); System.out.print(\"}\"); } private void b(Treap$TreapNode treap$TreapNode) { while (treap$TreapNode != null) { System.out.print(treap$TreapNode.value + \",\"); this.b(treap$TreapNode.left); treap$TreapNode = treap$TreapNode.right; } return; } public void postOrder() { System.out.print(\"{\"); Treap treap = this; treap.c(treap.a); System.out.print(\"}\"); } private void c(Treap$TreapNode treap$TreapNode) { if (treap$TreapNode == null) { return; } this.c(treap$TreapNode.left); this.c(treap$TreapNode.right); System.out.print(treap$TreapNode.value + \",\"); } public Treap$TreapNode search(int n) { Treap treap = this; return treap.c(treap.a, n); } private Treap$TreapNode c(Treap$TreapNode treap$TreapNode, int n) { while (treap$TreapNode != null) { if (treap$TreapNode.value == n) { return treap$TreapNode; } if (treap$TreapNode.value < n) { treap$TreapNode = treap$TreapNode.right; continue; } treap$TreapNode = treap$TreapNode.left; } return null; } public Treap$TreapNode lowerBound(int n) { Treap$TreapNode treap$TreapNode = null; Treap$TreapNode treap$TreapNode2 = this.a; while (treap$TreapNode2 != null) { if (treap$TreapNode2.value >= n) { treap$TreapNode = treap$TreapNode2; treap$TreapNode2 = treap$TreapNode2.left; continue; } treap$TreapNode2 = treap$TreapNode2.right; } return treap$TreapNode; } public Treap$TreapNode upperBound(int n) { Treap$TreapNode treap$TreapNode = null; Treap$TreapNode treap$TreapNode2 = this.a; while (treap$TreapNode2 != null) { if (treap$TreapNode2.value > n) { treap$TreapNode = treap$TreapNode2; treap$TreapNode2 = treap$TreapNode2.left; continue; } treap$TreapNode2 = treap$TreapNode2.right; } return treap$TreapNode; } public int size() { if (this.a == null) { return 0; } return this.a.b; } public boolean isEmpty() { return this.a == null; } public Treap$TreapNode getRoot() { return this.a; } public Treap$TreapNode getLeft(Treap$TreapNode treap$TreapNode) { return treap$TreapNode.left; } public Treap$TreapNode getRight(Treap$TreapNode treap$TreapNode) { return treap$TreapNode.right; } public String toString(Treap$TreapNode treap$TreapNode) { return \"{value : \" + treap$TreapNode.value + \", priority : \" + treap$TreapNode.a + \", subTreeSize = \" + treap$TreapNode.b + \", left = \" + String.valueOf(treap$TreapNode.left) + \", right = \" + String.valueOf(treap$TreapNode.right) + \"}\"; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.Random; /** * Treap -> Tree + Heap * Also called as cartesian tree * * @see * <a href = \"https://cp-algorithms.com/data_structures/treap.html\" /> */ public class Treap { public static class TreapNode { /** * TreapNode class defines the individual nodes in the Treap * * value -> holds the value of the node. * Binary Search Tree is built based on value. * * priority -> holds the priority of the node. * Heaps are maintained based on priority. * It is randomly assigned * * size -> holds the size of the subtree with current node as root * * left -> holds the left subtree * right -> holds the right subtree */ public int value; private int priority; private int size; public TreapNode left; public TreapNode right; public TreapNode(int valueParam, int priorityParam) { value = valueParam; priority = priorityParam; size = 1; left = null; right = null; } /** * updateSize -> updates the subtree size of the current node */ private void updateSize() { size = 1; if (left != null) { size += left.size; } if (right != null) { size += right.size; } } } /** * root -> holds the root node in the Treap * random -> to generate random priority for the nodes in the Treap */ private TreapNode root; private Random random = new Random(); /** * Constructors * * Treap() -> create an empty Treap * Treap(int[] nodeValues) -> add the elements given in the array to the Treap */ public Treap() { root = null; } /** * merges two Treaps left and right into a single Treap * * @param left left Treap * @param right right Treap * @return root of merged Treap */ private TreapNode merge(TreapNode left, TreapNode right) { if (left == null) { return right; } if (right == null) { return left; } if (left.priority > right.priority) { left.right = merge(left.right, right); left.updateSize(); return left; } else { right.left = merge(left, right.left); right.updateSize(); return right; } } /** * split the Treap into two Treaps where left Treap has nodes <= key and right Treap has nodes > key * * @param node root node to be split * @param key key to compare the nodes * @return TreapNode array of size 2. * TreapNode[0] contains the root of left Treap after split * TreapNode[1] contains the root of right Treap after split */ private TreapNode[] split(TreapNode node, int key) { if (node == null) { return new TreapNode[] {null, null}; } TreapNode[] result; if (node.value <= key) { result = split(node.right, key); node.right = result[0]; node.updateSize(); result[0] = node; } else { result = split(node.left, key); node.left = result[1]; node.updateSize(); result[1] = node; } return result; } /** * insert a node into the Treap * * @param value value to be inserted into the Treap * @return root of the Treap where the value is inserted */ public TreapNode insert(int value) { if (root == null) { root = new TreapNode(value, random.nextInt()); return root; } TreapNode[] splitted = split(root, value); TreapNode node = new TreapNode(value, random.nextInt()); TreapNode tempMerged = merge(splitted[0], node); tempMerged.updateSize(); TreapNode merged = merge(tempMerged, splitted[1]); merged.updateSize(); root = merged; return root; } /** * delete a value from root if present * * @param value value to be deleted from the Treap * @return root of the Treap where delete has been performed */ public TreapNode delete(int value) { root = deleteNode(root, value); return root; } private TreapNode deleteNode(TreapNode root, int value) { if (root == null) { return null; } if (value < root.value) { root.left = deleteNode(root.left, value); } else if (value > root.value) { root.right = deleteNode(root.right, value); } else { root = merge(root.left, root.right); } if (root != null) { root.updateSize(); } return root; } /** * print inorder traversal of the Treap */ public void inOrder() { System.out.print(\"{\"); printInorder(root); System.out.print(\"}\"); } private void printInorder(TreapNode root) { if (root == null) { return; } printInorder(root.left); System.out.print(root.value + \",\"); printInorder(root.right); } /** * print preOrder traversal of the Treap */ public void preOrder() { System.out.print(\"{\"); printPreOrder(root); System.out.print(\"}\"); } private void printPreOrder(TreapNode root) { if (root == null) { return; } System.out.print(root.value + \",\"); printPreOrder(root.left); printPreOrder(root.right); } /** * print postOrder traversal of the Treap */ public void postOrder() { System.out.print(\"{\"); printPostOrder(root); System.out.print(\"}\"); } private void printPostOrder(TreapNode root) { if (root == null) { return; } printPostOrder(root.left); printPostOrder(root.right); System.out.print(root.value + \",\"); } /** * Search a value in the Treap * * @param value value to be searched for * @return node containing the value * null if not found */ public TreapNode search(int value) { return searchVal(root, value); } private TreapNode searchVal(TreapNode root, int value) { if (root == null) { return null; } if (root.value == value) { return root; } else if (root.value < value) { return searchVal(root.right, value); } else { return searchVal(root.left, value); } } /** * find the lowerBound of a value in the Treap * * @param value value for which lowerBound is to be found * @return node which is the lowerBound of the value passed */ public TreapNode lowerBound(int value) { TreapNode lowerBoundNode = null; TreapNode current = root; while (current != null) { if (current.value >= value) { lowerBoundNode = current; current = current.left; } else { current = current.right; } } return lowerBoundNode; } /** * find the upperBound of a value in the Treap * * @param value value for which upperBound is to be found * @return node which is the upperBound of the value passed */ public TreapNode upperBound(int value) { TreapNode upperBoundNode = null; TreapNode current = root; while (current != null) { if (current.value > value) { upperBoundNode = current; current = current.left; } else { current = current.right; } } return upperBoundNode; } /** * returns size of the Treap */ public int size() { if (root == null) { return 0; } return root.size; } /** * returns if Treap is empty */ public boolean isEmpty() { return root == null; } /** * returns root node of the Treap */ public TreapNode getRoot() { return root; } /** * returns left node of the TreapNode */ public TreapNode getLeft(TreapNode node) { return node.left; } /** * returns the right node of the TreapNode */ public TreapNode getRight(TreapNode node) { return node.right; } /** * prints the value, priority, size of the subtree of the TreapNode, left TreapNode and right TreapNode of the node */ public String toString(TreapNode node) { return \"{value : \" + node.value + \", priority : \" + node.priority + \", subTreeSize = \" + node.size + \", left = \" + node.left + \", right = \" + node.right + \"}\"; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.QItem; import com.thealgorithms.datastructures.trees.TreeNode; import java.util.HashSet; import java.util.LinkedList; class Tree { private TreeNode a; Tree() { this.a = null; } Tree(TreeNode treeNode) { this.a = treeNode; } public void printTopView() { if (this.a == null) { return; } HashSet<Integer> hashSet = new HashSet<Integer>(); LinkedList<QItem> linkedList = new LinkedList<QItem>(); linkedList.add(new QItem(this.a, 0)); while (!linkedList.isEmpty()) { Object object = (QItem)linkedList.remove(); int n = ((QItem)object).b; object = ((QItem)object).a; if (!hashSet.contains(n)) { hashSet.add(n); System.out.print(((TreeNode)object).a + \" \"); } if (((TreeNode)object).b != null) { linkedList.add(new QItem(((TreeNode)object).b, n - 1)); } if (((TreeNode)object).c == null) continue; linkedList.add(new QItem(((TreeNode)object).c, n + 1)); } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.QItem; import com.thealgorithms.datastructures.trees.TreeNode; import java.util.HashSet; import java.util.LinkedList; class Tree { private TreeNode a; Tree() { this.a = null; } Tree(TreeNode treeNode) { this.a = treeNode; } public void printTopView() { if (this.a == null) { return; } HashSet<Integer> hashSet = new HashSet<Integer>(); LinkedList<QItem> linkedList = new LinkedList<QItem>(); linkedList.add(new QItem(this.a, 0)); while (!linkedList.isEmpty()) { Object object = (QItem)linkedList.remove(); int n = ((QItem)object).b; object = ((QItem)object).a; if (!hashSet.contains(n)) { hashSet.add(n); System.out.print(((TreeNode)object).a + \" \"); } if (((TreeNode)object).b != null) { linkedList.add(new QItem(((TreeNode)object).b, n - 1)); } if (((TreeNode)object).c == null) continue; linkedList.add(new QItem(((TreeNode)object).c, n + 1)); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import com.thealgorithms.datastructures.graphs.UndirectedAdjacencyListGraph; import java.util.Iterator; public class TreeMatching { private UndirectedAdjacencyListGraph a; private int[][] b; public TreeMatching(UndirectedAdjacencyListGraph undirectedAdjacencyListGraph) { this.a = undirectedAdjacencyListGraph; this.b = new int[undirectedAdjacencyListGraph.size()][2]; } public int getMaxMatching(int n, int n2) { if (n < 0 || n >= this.a.size()) { throw new IllegalArgumentException(\"Invalid root: \" + n); } this.a(n, n2); return Math.max(this.b[n][0], this.b[n][1]); } private void a(int n, int n2) { int n3; this.b[n][0] = 0; this.b[n][1] = 0; int n4 = 0; Iterator iterator = this.a.getNeighbors(n).iterator(); while (iterator.hasNext()) { n3 = (Integer)iterator.next(); if (n3 == n2) continue; this.a(n3, n); n4 += Math.max(this.b[n3][0], this.b[n3][1]); } this.b[n][0] = n4; iterator = this.a.getNeighbors(n).iterator(); while (iterator.hasNext()) { n3 = (Integer)iterator.next(); if (n3 == n2) continue; int n5 = this.a.getEdgeWeight(n, n3); this.b[n][1] = Math.max(this.b[n][1], n4 - Math.max(this.b[n3][0], this.b[n3][1]) + this.b[n3][0] + n5); } } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import com.thealgorithms.datastructures.graphs.UndirectedAdjacencyListGraph; /** * This class implements the algorithm for calculating the maximum weighted matching in a tree. * The tree is represented as an undirected graph with weighted edges. * * Problem Description: * Given an undirected tree G = (V, E) with edge weights : E  N and a root r  V, * the goal is to find a maximum weight matching M  E such that no two edges in M * share a common vertex. The sum of the weights of the edges in M,  eM (e), should be maximized. * For more Information: <a href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)\">Matching (graph theory)</a> * * @author <a href=\"https://github.com/DenizAltunkapan\">Deniz Altunkapan</a> */ public class TreeMatching { private UndirectedAdjacencyListGraph graph; private int[][] dp; /** * Constructor that initializes the graph and the DP table. * * @param graph The graph that represents the tree and is used for the matching algorithm. */ public TreeMatching(UndirectedAdjacencyListGraph graph) { this.graph = graph; this.dp = new int[graph.size()][2]; } /** * Calculates the maximum weighted matching for the tree, starting from the given root node. * * @param root The index of the root node of the tree. * @param parent The index of the parent node (used for recursion). * @return The maximum weighted matching for the tree, starting from the root node. * */ public int getMaxMatching(int root, int parent) { if (root < 0 || root >= graph.size()) { throw new IllegalArgumentException(\"Invalid root: \" + root); } maxMatching(root, parent); return Math.max(dp[root][0], dp[root][1]); } /** * Recursively computes the maximum weighted matching for a node, assuming that the node * can either be included or excluded from the matching. * * @param node The index of the current node for which the matching is calculated. * @param parent The index of the parent node (to avoid revisiting the parent node during recursion). */ private void maxMatching(int node, int parent) { dp[node][0] = 0; dp[node][1] = 0; int sumWithoutEdge = 0; for (int adjNode : graph.getNeighbors(node)) { if (adjNode == parent) { continue; } maxMatching(adjNode, node); sumWithoutEdge += Math.max(dp[adjNode][0], dp[adjNode][1]); } dp[node][0] = sumWithoutEdge; for (int adjNode : graph.getNeighbors(node)) { if (adjNode == parent) { continue; } int weight = graph.getEdgeWeight(node, adjNode); dp[node][1] = Math.max(dp[node][1], sumWithoutEdge - Math.max(dp[adjNode][0], dp[adjNode][1]) + dp[adjNode][0] + weight); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.devutils.nodes; import com.thealgorithms.devutils.nodes.Node; public abstract class TreeNode extends Node { private TreeNode a; private int b; public TreeNode() { this.b = 0; } public TreeNode(Object object) { super(object); this.b = 0; } public TreeNode(Object object, TreeNode treeNode) { super(object); this.a = treeNode; this.b = this.a.getDepth() + 1; } public abstract boolean isLeafNode(); public boolean isRootNode() { return this.a == null; } public TreeNode getParent() { return this.a; } public void setParent(TreeNode treeNode) { this.a = treeNode; this.b = this.a.getDepth() + 1; } public int getDepth() { return this.b; } }", "deobfuscated_code": "package com.thealgorithms.devutils.nodes; /** * Base class for any tree node which holds a reference to the parent node. * * All known subclasses: {@link SimpleTreeNode}, {@link LargeTreeNode}. * * @param <E> The type of the data held in the Node. * * @author <a href=\"https://github.com/aitorfi\">aitorfi</a> */ public abstract class TreeNode<E> extends Node<E> { /** * Refernce to the parent Node. */ private TreeNode<E> parentNode; /** * Indicates the depth at which this node is in the tree. */ private int depth; /** * Empty contructor. */ public TreeNode() { super(); depth = 0; } /** * Initializes the Nodes' data. * * @param data Value to which data will be initialized. * @see Node#Node(Object) */ public TreeNode(E data) { super(data); depth = 0; } /** * Initializes the Nodes' data and parent node reference. * * @param data Value to which data will be initialized. * @param parentNode Value to which the nodes' parent reference will be set. */ public TreeNode(E data, TreeNode<E> parentNode) { super(data); this.parentNode = parentNode; depth = this.parentNode.getDepth() + 1; } /** * @return True if the node is a leaf node, otherwise false. */ public abstract boolean isLeafNode(); /** * @return True if the node is the root node, otherwise false. */ public boolean isRootNode() { return (parentNode == null); } public TreeNode<E> getParent() { return parentNode; } public void setParent(TreeNode<E> parentNode) { this.parentNode = parentNode; depth = this.parentNode.getDepth() + 1; } public int getDepth() { return depth; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; final class TreeRandomNode$Node { int a; TreeRandomNode$Node b; TreeRandomNode$Node c; }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; final class TreeRandomNode$Node { int a; TreeRandomNode$Node b; TreeRandomNode$Node c; }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.TreeRandomNode$Node; import java.util.ArrayList; public class TreeRandomNode { private static ArrayList a = new ArrayList(); private TreeRandomNode$Node b = null; TreeRandomNode() { } private static void a(TreeRandomNode$Node treeRandomNode$Node) { while (treeRandomNode$Node != null) { TreeRandomNode.a(treeRandomNode$Node.b); a.add(treeRandomNode$Node.a); treeRandomNode$Node = treeRandomNode$Node.c; } return; } public void getRandom(TreeRandomNode$Node treeRandomNode$Node) { TreeRandomNode.a(treeRandomNode$Node); int n = a.size(); --n; n = (int)(Math.random() * (double)(n + 1) + 0.0); n = (Integer)a.get(n); System.out.println(\"Random Node : \" + n); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; /* Author : Suraj Kumar Github : https://github.com/skmodi649 */ /* PROBLEM DESCRIPTION : There is a Binary Search Tree given, and we are supposed to find a random node in the given binary tree. */ /* ALGORITHM : Step 1: START Step 2: First create a binary tree using the steps mentioned in the first approach Step 3: Now use a method inOrder() that takes a node as input parameter to traverse through the binary tree in inorder fashion as also store the values in a ArrayList simultaneously. Step 4: Now define a method getRandom() that takes a node as input parameter, in this first call the inOrder() method to store the values in the arraylist, then find the size of the binary tree and now just generate a random number between 0 to n-1. Step 5: After generating the number display the value of the ArrayList at the generated index Step 6: STOP */ import java.util.ArrayList; // Using auxiliary array to find the random node in a given binary tree public class TreeRandomNode { private final class Node { int item; Node left; Node right; } // Using an arraylist to store the inorder traversal of the given binary tree static ArrayList<Integer> list = new ArrayList<>(); // root of Tree Node root; TreeRandomNode() { root = null; } // Now lets find the inorder traversal of the given binary tree static void inOrder(Node node) { if (node == null) { return; } // traverse the left child inOrder(node.left); list.add(node.item); // traverse the right child inOrder(node.right); } public void getRandom(Node val) { inOrder(val); // getting the count of node of the binary tree int n = list.size(); int min = 0; int max = n - 1; // Generate random int value from 0 to n-1 int b = (int) (Math.random() * (max - min + 1) + min); // displaying the value at the generated index int random = list.get(b); System.out.println(\"Random Node : \" + random); } } /* Explanation of the Approach : (a) Form the required binary tree (b) Now use the inOrder() method to get the nodes in inOrder fashion and also store them in the given arraylist 'list' (c) Using the getRandom() method generate a random number between 0 to n-1, then get the value at the generated random number from the arraylist using get() method and finally display the result. */ /* OUTPUT : First output : Random Node : 15 Second output : Random Node : 99 */ /* Time Complexity : O(n) Auxiliary Space Complexity : O(1) */"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.datastructures.trees.BSTRecursiveGeneric; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; import java.util.Iterator; import java.util.List; public class TreeSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { Comparable comparable; BSTRecursiveGeneric bSTRecursiveGeneric = new BSTRecursiveGeneric(); Object object = comparableArray; int n = comparableArray.length; for (int i = 0; i < n; ++i) { comparable = object[i]; bSTRecursiveGeneric.add(comparable); } object = bSTRecursiveGeneric.inorderSort(); n = 0; Iterator iterator = object.iterator(); while (iterator.hasNext()) { comparable = (Comparable)iterator.next(); comparableArray[n++] = comparable; } return comparableArray; } @Override public List sort(List object) { BSTRecursiveGeneric bSTRecursiveGeneric = new BSTRecursiveGeneric(); object = object.iterator(); while (object.hasNext()) { Comparable comparable = (Comparable)object.next(); bSTRecursiveGeneric.add(comparable); } return bSTRecursiveGeneric.inorderSort(); } public static void main(String[] object) { object = new TreeSort(); System.out.println(\"Testing for Integer Array....\"); Object object2 = new Integer[]{3, -7, 45, 1, 343, -5, 2, 9}; System.out.printf(\"%-10s\", \"unsorted: \"); SortUtils.a(object2); object2 = (Integer[])((TreeSort)object).sort((Comparable[])object2); System.out.printf(\"%-10s\", \"sorted: \"); SortUtils.a(object2); System.out.println(); System.out.println(\"Testing for Integer List....\"); object2 = List.of(Integer.valueOf(3), Integer.valueOf(-7), Integer.valueOf(45), Integer.valueOf(1), Integer.valueOf(343), Integer.valueOf(-5), Integer.valueOf(2), Integer.valueOf(9)); System.out.printf(\"%-10s\", \"unsorted: \"); SortUtils.a((List)object2); object2 = ((TreeSort)object).sort((List)object2); System.out.printf(\"%-10s\", \"sorted: \"); SortUtils.a((List)object2); System.out.println(); System.out.println(\"Testing for String Array....\"); object2 = new String[]{\"banana\", \"berry\", \"orange\", \"grape\", \"peach\", \"cherry\", \"apple\", \"pineapple\"}; System.out.printf(\"%-10s\", \"unsorted: \"); SortUtils.a(object2); object2 = (String[])((TreeSort)object).sort((Comparable[])object2); System.out.printf(\"%-10s\", \"sorted: \"); SortUtils.a(object2); System.out.println(); System.out.println(\"Testing for String List....\"); object2 = List.of(\"banana\", \"berry\", \"orange\", \"grape\", \"peach\", \"cherry\", \"apple\", \"pineapple\"); System.out.printf(\"%-10s\", \"unsorted: \"); SortUtils.a((List)object2); object2 = ((TreeSort)object).sort((List)object2); System.out.printf(\"%-10s\", \"sorted: \"); SortUtils.a((List)object2); } }", "deobfuscated_code": "package com.thealgorithms.sorts; import static com.thealgorithms.sorts.SortUtils.print; import com.thealgorithms.datastructures.trees.BSTRecursiveGeneric; import java.util.List; /** * <h1> Implementation of the Tree Sort algorithm</h1> * * <p> * Tree Sort: A sorting algorithm which constructs a Binary Search Tree using * the unsorted data and then outputs the data by inorder traversal of the tree. * * Reference: https://en.wikipedia.org/wiki/Tree_sort * </p> * * @author Madhur Panwar (https://github.com/mdrpanwar) */ public class TreeSort implements SortAlgorithm { @Override public <T extends Comparable<T>> T[] sort(T[] unsortedArray) { return doTreeSortArray(unsortedArray); } @Override public <T extends Comparable<T>> List<T> sort(List<T> unsortedList) { return doTreeSortList(unsortedList); } private <T extends Comparable<T>> T[] doTreeSortArray(T[] unsortedArray) { // create a generic BST tree BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>(); // add all elements to the tree for (T element : unsortedArray) { tree.add(element); } // get the sorted list by inorder traversal of the tree List<T> sortedList = tree.inorderSort(); // add the elements back to the initial array int i = 0; for (T element : sortedList) { unsortedArray[i++] = element; } // return the array return unsortedArray; } private <T extends Comparable<T>> List<T> doTreeSortList(Iterable<T> unsortedList) { // create a generic BST tree BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>(); // add all elements to the tree for (T element : unsortedList) { tree.add(element); } // get the sorted list by inorder traversal of the tree and return it return tree.inorderSort(); } public static void main(String[] args) { TreeSort treeSort = new TreeSort(); // ==== Integer Array ======= System.out.println(\"Testing for Integer Array....\"); Integer[] a = {3, -7, 45, 1, 343, -5, 2, 9}; System.out.printf(\"%-10s\", \"unsorted: \"); print(a); a = treeSort.sort(a); System.out.printf(\"%-10s\", \"sorted: \"); print(a); System.out.println(); // ==== Integer List ======= System.out.println(\"Testing for Integer List....\"); List<Integer> intList = List.of(3, -7, 45, 1, 343, -5, 2, 9); System.out.printf(\"%-10s\", \"unsorted: \"); print(intList); intList = treeSort.sort(intList); System.out.printf(\"%-10s\", \"sorted: \"); print(intList); System.out.println(); // ==== String Array ======= System.out.println(\"Testing for String Array....\"); String[] b = { \"banana\", \"berry\", \"orange\", \"grape\", \"peach\", \"cherry\", \"apple\", \"pineapple\", }; System.out.printf(\"%-10s\", \"unsorted: \"); print(b); b = treeSort.sort(b); System.out.printf(\"%-10s\", \"sorted: \"); print(b); System.out.println(); // ==== String List ======= System.out.println(\"Testing for String List....\"); List<String> stringList = List.of(\"banana\", \"berry\", \"orange\", \"grape\", \"peach\", \"cherry\", \"apple\", \"pineapple\"); System.out.printf(\"%-10s\", \"unsorted: \"); print(stringList); stringList = treeSort.sort(stringList); System.out.printf(\"%-10s\", \"sorted: \"); print(stringList); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class Tribonacci { private Tribonacci() { } public static int compute(int n) { if (n == 0) { return 0; } if (n == 1 || n == 2) { return 1; } int n2 = 0; int n3 = 1; int n4 = 1; for (int i = 3; i <= n; ++i) { int n5 = n2 + n3 + n4; n2 = n3; n3 = n4; n4 = n5; } return n4; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * The {@code Tribonacci} class provides a method to compute the n-th number in the Tribonacci sequence. * N-th Tribonacci Number - https://leetcode.com/problems/n-th-tribonacci-number/description/ */ public final class Tribonacci { private Tribonacci() { } /** * Computes the n-th Tribonacci number. * * @param n the index of the Tribonacci number to compute * @return the n-th Tribonacci number */ public static int compute(int n) { if (n == 0) { return 0; } if (n == 1 || n == 2) { return 1; } int first = 0; int second = 1; int third = 1; for (int i = 3; i <= n; i++) { int next = first + second + third; first = second; second = third; third = next; } return third; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.puzzlesandgames; import com.thealgorithms.puzzlesandgames.TrieNode; class Trie { TrieNode a = new TrieNode(); private char b = (char)42; Trie() { } public void add(String string) { TrieNode trieNode = this.a; for (int i = 0; i < string.length(); ++i) { char c = string.charAt(i); if (!trieNode.a.containsKey(Character.valueOf(c))) { TrieNode trieNode2 = new TrieNode(); trieNode.a.put(Character.valueOf(c), trieNode2); } trieNode = (TrieNode)trieNode.a.get(Character.valueOf(c)); } trieNode.a.put(Character.valueOf(this.b), null); trieNode.b = string; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.puzzlesandgames; import com.thealgorithms.puzzlesandgames.TrieNode; class Trie { TrieNode a = new TrieNode(); private char b = (char)42; Trie() { } public void add(String string) { TrieNode trieNode = this.a; for (int i = 0; i < string.length(); ++i) { char c = string.charAt(i); if (!trieNode.a.containsKey(Character.valueOf(c))) { TrieNode trieNode2 = new TrieNode(); trieNode.a.put(Character.valueOf(c), trieNode2); } trieNode = (TrieNode)trieNode.a.get(Character.valueOf(c)); } trieNode.a.put(Character.valueOf(this.b), null); trieNode.b = string; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.puzzlesandgames; import java.util.HashMap; import java.util.Map; class TrieNode { Map a = new HashMap(); String b = \"\"; TrieNode() { } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.puzzlesandgames; import java.util.HashMap; import java.util.Map; class TrieNode { Map a = new HashMap(); String b = \"\"; TrieNode() { } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; class Trieac$TrieNode { Trieac$TrieNode[] a = new Trieac$TrieNode[26]; boolean b; Trieac$TrieNode() { } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; class Trieac$TrieNode { Trieac$TrieNode[] a = new Trieac$TrieNode[26]; boolean b; Trieac$TrieNode() { } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.Trieac$TrieNode; class Trieac { public static final int ALPHABET_SIZE = 26; Trieac() { } private static Trieac$TrieNode a() { Trieac$TrieNode trieac$TrieNode = new Trieac$TrieNode(); new Trieac$TrieNode().b = false; for (int i = 0; i < 26; ++i) { trieac$TrieNode.a[i] = null; } return trieac$TrieNode; } private static void a(Trieac$TrieNode trieac$TrieNode, String string) { for (int i = 0; i < string.length(); ++i) { int n = string.charAt(i) - 97; if (trieac$TrieNode.a[n] == null) { trieac$TrieNode.a[n] = Trieac.a(); } trieac$TrieNode = trieac$TrieNode.a[n]; } trieac$TrieNode.b = true; } private static boolean a(Trieac$TrieNode trieac$TrieNode) { for (int i = 0; i < 26; ++i) { if (trieac$TrieNode.a[i] == null) continue; return false; } return true; } private static void b(Trieac$TrieNode trieac$TrieNode, String object) { if (trieac$TrieNode.b) { System.out.println((String)object); } if (Trieac.a(trieac$TrieNode)) { return; } for (int i = 0; i < 26; ++i) { if (trieac$TrieNode.a[i] == null) continue; object = (String)object + (char)(i + 97); Trieac.b(trieac$TrieNode.a[i], (String)object); } } /* * Unable to fully structure code * Could not resolve type clashes */ public static void main(String[] var0) { var0 /* !! */ = Trieac.a(); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"hello\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"dog\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"hell\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"cat\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"a\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"hel\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"help\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"helps\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"helping\"); var1_2 = \"hel\"; var3_3 = var1_2.length(); for (var2_4 = 0; var2_4 < var3_3; ++var2_4) { var4_5 = var1_2.charAt(var2_4) - 97; if (var0 /* !! */ .a[var4_5] != null) { var0 /* !! */ = var0 /* !! */ .a[var4_5]; continue; } ** GOTO lbl-1000 } var4_5 = var0 /* !! */ .b; var2_4 = (int)Trieac.a((Trieac$TrieNode)var0 /* !! */ ); if (var4_5 != 0 && var2_4 != 0) { System.out.println(var1_2); v0 = -1; } else if (var2_4 == 0) { Trieac.b((Trieac$TrieNode)var0 /* !! */ , var1_2); v0 = 1; } else lbl-1000: // 2 sources { v0 = var0_1 = 0; } if (v0 == -1) { System.out.println(\"No other strings found with this prefix\\n\"); return; } if (var0_1 == 0) { System.out.println(\"No string found with this prefix\\n\"); } } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.Trieac$TrieNode; class Trieac { public static final int ALPHABET_SIZE = 26; Trieac() { } private static Trieac$TrieNode a() { Trieac$TrieNode trieac$TrieNode = new Trieac$TrieNode(); new Trieac$TrieNode().b = false; for (int i = 0; i < 26; ++i) { trieac$TrieNode.a[i] = null; } return trieac$TrieNode; } private static void a(Trieac$TrieNode trieac$TrieNode, String string) { for (int i = 0; i < string.length(); ++i) { int n = string.charAt(i) - 97; if (trieac$TrieNode.a[n] == null) { trieac$TrieNode.a[n] = Trieac.a(); } trieac$TrieNode = trieac$TrieNode.a[n]; } trieac$TrieNode.b = true; } private static boolean a(Trieac$TrieNode trieac$TrieNode) { for (int i = 0; i < 26; ++i) { if (trieac$TrieNode.a[i] == null) continue; return false; } return true; } private static void b(Trieac$TrieNode trieac$TrieNode, String object) { if (trieac$TrieNode.b) { System.out.println((String)object); } if (Trieac.a(trieac$TrieNode)) { return; } for (int i = 0; i < 26; ++i) { if (trieac$TrieNode.a[i] == null) continue; object = (String)object + (char)(i + 97); Trieac.b(trieac$TrieNode.a[i], (String)object); } } /* * Unable to fully structure code * Could not resolve type clashes */ public static void main(String[] var0) { var0 /* !! */ = Trieac.a(); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"hello\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"dog\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"hell\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"cat\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"a\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"hel\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"help\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"helps\"); Trieac.a((Trieac$TrieNode)var0 /* !! */ , \"helping\"); var1_2 = \"hel\"; var3_3 = var1_2.length(); for (var2_4 = 0; var2_4 < var3_3; ++var2_4) { var4_5 = var1_2.charAt(var2_4) - 97; if (var0 /* !! */ .a[var4_5] != null) { var0 /* !! */ = var0 /* !! */ .a[var4_5]; continue; } ** GOTO lbl-1000 } var4_5 = var0 /* !! */ .b; var2_4 = (int)Trieac.a((Trieac$TrieNode)var0 /* !! */ ); if (var4_5 != 0 && var2_4 != 0) { System.out.println(var1_2); v0 = -1; } else if (var2_4 == 0) { Trieac.b((Trieac$TrieNode)var0 /* !! */ , var1_2); v0 = 1; } else lbl-1000: // 2 sources { v0 = var0_1 = 0; } if (v0 == -1) { System.out.println(\"No other strings found with this prefix\\n\"); return; } if (var0_1 == 0) { System.out.println(\"No string found with this prefix\\n\"); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class TrinomialTriangle { private TrinomialTriangle() { } public static int trinomialValue(int n, int n2) { if (n == 0 && n2 == 0) { return 1; } if (n2 < -n || n2 > n) { return 0; } return TrinomialTriangle.trinomialValue(n - 1, n2 - 1) + TrinomialTriangle.trinomialValue(n - 1, n2) + TrinomialTriangle.trinomialValue(n - 1, n2 + 1); } public static void printTrinomial(int n) { for (int i = 0; i < n; ++i) { int n2; for (n2 = -i; n2 <= 0; ++n2) { System.out.print(TrinomialTriangle.trinomialValue(i, n2) + \" \"); } for (n2 = 1; n2 <= i; ++n2) { System.out.print(TrinomialTriangle.trinomialValue(i, n2) + \" \"); } System.out.println(); } } public static void main(String[] stringArray) { TrinomialTriangle.printTrinomial(6); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * The trinomial triangle is a variation of Pascals triangle. The difference * between the two is that an entry in the trinomial triangle is the sum of the * three (rather than the two in Pasacals triangle) entries above it * * Example Input: n = 4 Output 1 1 1 1 1 2 3 2 1 1 3 6 7 6 3 1 */ public final class TrinomialTriangle { private TrinomialTriangle() { } public static int trinomialValue(int n, int k) { if (n == 0 && k == 0) { return 1; } if (k < -n || k > n) { return 0; } return (trinomialValue(n - 1, k - 1) + trinomialValue(n - 1, k) + trinomialValue(n - 1, k + 1)); } public static void printTrinomial(int n) { for (int i = 0; i < n; i++) { for (int j = -i; j <= 0; j++) { System.out.print(trinomialValue(i, j) + \" \"); } for (int j = 1; j <= i; j++) { System.out.print(trinomialValue(i, j) + \" \"); } System.out.println(); } } public static void main(String[] argc) { int n = 6; printTrinomial(n); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; public final class TurkishToLatinConversion { private TurkishToLatinConversion() { } public static String convertTurkishToLatin(String string) { char[] cArray = new char[]{'\\u0131', '\\u0130', '\\u00fc', '\\u00dc', '\\u00f6', '\\u00d6', '\\u015f', '\\u015e', '\\u00e7', '\\u00c7', '\\u011f', '\\u011e'}; char[] cArray2 = new char[]{'i', 'I', 'u', 'U', 'o', 'O', 's', 'S', 'c', 'C', 'g', 'G'}; for (int i = 0; i < cArray.length; ++i) { string = string.replaceAll(String.valueOf(cArray[i]), String.valueOf(cArray2[i])); } return string; } }", "deobfuscated_code": "package com.thealgorithms.conversions; /** * Converts turkish character to latin character * * @author zgn Gkenli */ public final class TurkishToLatinConversion { private TurkishToLatinConversion() { } /** * This method converts a turkish character to latin character. * Steps: * 1. Define turkish characters and their corresponding latin characters * 2. Replace all turkish characters with their corresponding latin characters * 3. Return the converted string * * @param param String paramter * @return String */ public static String convertTurkishToLatin(String param) { char[] turkishChars = new char[] { 0x131, 0x130, 0xFC, 0xDC, 0xF6, 0xD6, 0x15F, 0x15E, 0xE7, 0xC7, 0x11F, 0x11E, }; char[] latinChars = new char[] { 'i', 'I', 'u', 'U', 'o', 'O', 's', 'S', 'c', 'C', 'g', 'G', }; for (int i = 0; i < turkishChars.length; i++) { param = param.replaceAll(String.valueOf(turkishChars[i]), String.valueOf(latinChars[i])); } return param; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class TwinPrime { private TwinPrime() { } }", "deobfuscated_code": "package com.thealgorithms.maths; /* * Java program to find 'twin prime' of a prime number * Twin Prime: Twin prime of a number n is (n+2) * if and only if n & (n+2) are prime. * Wikipedia: https://en.wikipedia.org/wiki/Twin_prime * * Author: Akshay Dubey (https://github.com/itsAkshayDubey) * * */ import com.thealgorithms.maths.Prime.PrimeCheck; public final class TwinPrime { private TwinPrime() { } /** * This method returns twin prime of the integer value passed as argument * * @param inputNumber Integer value of which twin prime is to be found * @return (number + 2) if number and (number + 2) are prime, -1 otherwise */ static int getTwinPrime(int inputNumber) { // if inputNumber and (inputNumber + 2) are both prime // then return (inputNumber + 2) as a result if (PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2)) { return inputNumber + 2; } // if any one from inputNumber and (inputNumber + 2) or if both of them are not prime // then return -1 as a result return -1; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.crdt; import java.util.HashSet; import java.util.Set; public class TwoPSet { private final Set a = new HashSet(); private final Set b = new HashSet(); public boolean lookup(Object object) { return this.a.contains(object) && !this.b.contains(object); } public void add(Object object) { this.a.add(object); } public void remove(Object object) { if (this.lookup(object)) { this.b.add(object); } } public boolean compare(TwoPSet twoPSet) { return twoPSet.a.containsAll(this.a) && twoPSet.b.containsAll(this.b); } public TwoPSet merge(TwoPSet twoPSet) { TwoPSet twoPSet2 = new TwoPSet(); twoPSet2.a.addAll(this.a); twoPSet2.a.addAll(twoPSet.a); twoPSet2.b.addAll(this.b); twoPSet2.b.addAll(twoPSet.b); return twoPSet2; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.crdt; import java.util.HashSet; import java.util.Set; /** * TwoPhaseSet (2P-Set) is a state-based CRDT (Conflict-free Replicated Data Type) designed for managing sets * with support for both addition and removal operations in a distributed and concurrent environment. * It combines two G-Sets (grow-only sets) - one set for additions and another set (tombstone set) for removals. * Once an element is removed and placed in the tombstone set, it cannot be re-added, adhering to \"remove-wins\" semantics. * This implementation supports querying the presence of elements, adding elements, removing elements, * comparing with other 2P-Sets, and merging two 2P-Sets while preserving the remove-wins semantics. * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) * * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah) */ public class TwoPSet<T> { private final Set<T> setA; private final Set<T> setR; /** * Constructs an empty Two-Phase Set. */ public TwoPSet() { this.setA = new HashSet<>(); this.setR = new HashSet<>(); } /** * Checks if an element is in the set and has not been removed. * * @param element The element to be checked. * @return True if the element is in the set and has not been removed, otherwise false. */ public boolean lookup(T element) { return setA.contains(element) && !setR.contains(element); } /** * Adds an element to the set. * * @param element The element to be added. */ public void add(T element) { setA.add(element); } /** * Removes an element from the set. The element will be placed in the tombstone set. * * @param element The element to be removed. */ public void remove(T element) { if (lookup(element)) { setR.add(element); } } /** * Compares the current 2P-Set with another 2P-Set. * * @param otherSet The other 2P-Set to compare with. * @return True if both SetA and SetR are subset, otherwise false. */ public boolean compare(TwoPSet<T> otherSet) { return otherSet.setA.containsAll(setA) && otherSet.setR.containsAll(setR); } /** * Merges the current 2P-Set with another 2P-Set. * * @param otherSet The other 2P-Set to merge with. * @return A new 2P-Set containing the merged elements. */ public TwoPSet<T> merge(TwoPSet<T> otherSet) { TwoPSet<T> mergedSet = new TwoPSet<>(); mergedSet.setA.addAll(this.setA); mergedSet.setA.addAll(otherSet.setA); mergedSet.setR.addAll(this.setR); mergedSet.setR.addAll(otherSet.setR); return mergedSet; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; public final class TwoPointers { private TwoPointers() { } public static boolean isPairedSum(int[] nArray, int n) { if (nArray == null) { throw new IllegalArgumentException(\"Input array must not be null.\"); } int n2 = 0; int n3 = nArray.length - 1; while (n2 < n3) { int n4 = nArray[n2] + nArray[n3]; if (n4 == n) { return true; } if (n4 < n) { ++n2; continue; } --n3; } return false; } }", "deobfuscated_code": "package com.thealgorithms.others; /** * The two-pointer technique is a useful tool to utilize when searching for * pairs in a sorted array. * * <p> * Link: https://www.geeksforgeeks.org/two-pointers-technique/ */ public final class TwoPointers { private TwoPointers() { } /** * Checks whether there exists a pair of elements in a sorted array whose sum equals the specified key. * * @param arr a sorted array of integers in ascending order (must not be null) * @param key the target sum to find * @return {@code true} if there exists at least one pair whose sum equals {@code key}, {@code false} otherwise * @throws IllegalArgumentException if {@code arr} is {@code null} */ public static boolean isPairedSum(int[] arr, int key) { if (arr == null) { throw new IllegalArgumentException(\"Input array must not be null.\"); } int left = 0; int right = arr.length - 1; while (left < right) { int sum = arr[left] + arr[right]; if (sum == key) { return true; } if (sum < key) { left++; } else { right--; } } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. * * Could not load the following classes: * org.apache.commons.lang3.tuple.Pair */ package com.thealgorithms.misc; import java.util.HashMap; import java.util.Optional; import org.apache.commons.lang3.tuple.Pair; public final class TwoSumProblem { private TwoSumProblem() { } public static Optional twoSum(int[] nArray, int n) { HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>(); for (int i = 0; i < nArray.length; ++i) { int n2 = n - nArray[i]; if (hashMap.containsKey(n2)) { return Optional.of(Pair.of((Object)((Integer)hashMap.get(n2)), (Object)i)); } if (hashMap.containsKey(nArray[i])) continue; hashMap.put(nArray[i], i); } return Optional.empty(); } }", "deobfuscated_code": "package com.thealgorithms.misc; import java.util.HashMap; import java.util.Optional; import org.apache.commons.lang3.tuple.Pair; public final class TwoSumProblem { private TwoSumProblem() { } /** * The function \"twoSum\" takes an array of integers and a target integer as input, and returns an * array of two indices where the corresponding elements in the input array add up to the target. * @param values An array of integers. * @param target The target is the sum that we are trying to find using two numbers from the given array. * @return A pair or indexes such that sum of values at these indexes equals to the target * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi) */ public static Optional<Pair<Integer, Integer>> twoSum(final int[] values, final int target) { HashMap<Integer, Integer> valueToIndex = new HashMap<>(); for (int i = 0; i < values.length; i++) { final var remainder = target - values[i]; if (valueToIndex.containsKey(remainder)) { return Optional.of(Pair.of(valueToIndex.get(remainder), i)); } if (!valueToIndex.containsKey(values[i])) { valueToIndex.put(values[i], i); } } return Optional.empty(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class TwosComplement { private TwosComplement() { } public static String twosComplement(String object) { int n; if (!((String)object).matches(\"[01]+\")) { throw new IllegalArgumentException(\"Input must contain only '0' and '1'.\"); } StringBuilder stringBuilder = new StringBuilder(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n2 = cArray.length; for (n = 0; n < n2; ++n) { Object object2 = object[n]; stringBuilder.append(object2 == 48 ? (char)'1' : '0'); } object = new StringBuilder(stringBuilder); n2 = 1; for (n = stringBuilder.length() - 1; n >= 0 && n2 != 0; --n) { if (stringBuilder.charAt(n) == '1') { ((StringBuilder)object).setCharAt(n, '0'); continue; } ((StringBuilder)object).setCharAt(n, '1'); n2 = 0; } if (n2 != 0) { ((StringBuilder)object).insert(0, '1'); } return ((StringBuilder)object).toString(); } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class provides a method to compute the Two's Complement of a given binary number. * * <p>In two's complement representation, a binary number's negative value is obtained * by taking the one's complement (inverting all bits) and then adding 1 to the result. * This method handles both small and large binary strings and ensures the output is * correct for all binary inputs, including edge cases like all zeroes and all ones. * * <p>For more information on Two's Complement: * @see <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\">Wikipedia - Two's Complement</a> * * <p>Algorithm originally suggested by Jon von Neumann. * * @author Abhinay Verma (https://github.com/Monk-AbhinayVerma) */ public final class TwosComplement { private TwosComplement() { } /** * Computes the Two's Complement of the given binary string. * Steps: * 1. Compute the One's Complement (invert all bits). * 2. Add 1 to the One's Complement to get the Two's Complement. * 3. Iterate from the rightmost bit to the left, adding 1 and carrying over as needed. * 4. If a carry is still present after the leftmost bit, prepend '1' to handle overflow. * * @param binary The binary number as a string (only '0' and '1' characters allowed). * @return The two's complement of the input binary string as a new binary string. * @throws IllegalArgumentException If the input contains non-binary characters. */ public static String twosComplement(String binary) { if (!binary.matches(\"[01]+\")) { throw new IllegalArgumentException(\"Input must contain only '0' and '1'.\"); } StringBuilder onesComplement = new StringBuilder(); for (char bit : binary.toCharArray()) { onesComplement.append(bit == '0' ? '1' : '0'); } StringBuilder twosComplement = new StringBuilder(onesComplement); boolean carry = true; for (int i = onesComplement.length() - 1; i >= 0 && carry; i--) { if (onesComplement.charAt(i) == '1') { twosComplement.setCharAt(i, '0'); } else { twosComplement.setCharAt(i, '1'); carry = false; } } if (carry) { twosComplement.insert(0, '1'); } return twosComplement.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; public class UndirectedAdjacencyListGraph { private ArrayList a = new ArrayList(); public int addNode() { this.a.add(new HashMap()); return this.a.size() - 1; } public boolean addEdge(int n, int n2, int n3) { int n4 = this.a.size(); if (n >= n4 || n2 >= n4 || n < 0 || n2 < 0) { return false; } if (((HashMap)this.a.get(n)).containsKey(n2)) { return false; } ((HashMap)this.a.get(n)).put(n2, n3); ((HashMap)this.a.get(n2)).put(n, n3); return true; } public HashSet getNeighbors(int n) { return new HashSet(((HashMap)this.a.get(n)).keySet()); } public Integer getEdgeWeight(int n, int n2) { return ((HashMap)this.a.get(n)).getOrDefault(n2, null); } public int size() { return this.a.size(); } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; public class UndirectedAdjacencyListGraph { private ArrayList<HashMap<Integer, Integer>> adjacencyList = new ArrayList<>(); /** * Adds a new node to the graph by adding an empty HashMap for its neighbors. * @return the index of the newly added node in the adjacency list */ public int addNode() { adjacencyList.add(new HashMap<>()); return adjacencyList.size() - 1; } /** * Adds an undirected edge between the origin node (@orig) and the destination node (@dest) with the specified weight. * If the edge already exists, no changes are made. * @param orig the index of the origin node * @param dest the index of the destination node * @param weight the weight of the edge between @orig and @dest * @return true if the edge was successfully added, false if the edge already exists or if any node index is invalid */ public boolean addEdge(int orig, int dest, int weight) { int numNodes = adjacencyList.size(); if (orig >= numNodes || dest >= numNodes || orig < 0 || dest < 0) { return false; } if (adjacencyList.get(orig).containsKey(dest)) { return false; } adjacencyList.get(orig).put(dest, weight); adjacencyList.get(dest).put(orig, weight); return true; } /** * Returns the set of all adjacent nodes (neighbors) for the given node. * @param node the index of the node whose neighbors are to be retrieved * @return a HashSet containing the indices of all neighboring nodes */ public HashSet<Integer> getNeighbors(int node) { return new HashSet<>(adjacencyList.get(node).keySet()); } /** * Returns the weight of the edge between the origin node (@orig) and the destination node (@dest). * If no edge exists, returns null. * @param orig the index of the origin node * @param dest the index of the destination node * @return the weight of the edge between @orig and @dest, or null if no edge exists */ public Integer getEdgeWeight(int orig, int dest) { return adjacencyList.get(orig).getOrDefault(dest, null); } /** * Returns the number of nodes currently in the graph. * @return the number of nodes in the graph */ public int size() { return adjacencyList.size(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class UniformNumbers { private UniformNumbers() { } public static int uniformNumbers(int n) { String string = Integer.toString(n); int n2 = (string.length() - 1) * 9; int n3 = Integer.parseInt(String.valueOf(string.charAt(0)).repeat(string.length())); n2 = n3 <= n ? (n2 += Integer.parseInt(String.valueOf(string.charAt(0)))) : (n2 += Integer.parseInt(String.valueOf(string.charAt(0))) - 1); return n2; } public static int countUniformIntegers(int n, int n2) { if (n2 > n && n2 > 0 && n > 0) { return UniformNumbers.uniformNumbers(n2) - UniformNumbers.uniformNumbers(n - 1); } if (n2 == n) { return 1; } return 0; } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * A positive integer is considered uniform if all * of its digits are equal. For example, 222 is uniform, * while 223 is not. * Given two positive integers a and b, determine the * number of uniform integers between a and b. */ public final class UniformNumbers { // Private constructor to prevent instantiation of the utility class private UniformNumbers() { // Prevent instantiation } /** * This function will find the number of uniform numbers * from 1 to num * @param num upper limit to find the uniform numbers * @return the count of uniform numbers between 1 and num */ public static int uniformNumbers(int num) { String numStr = Integer.toString(num); int uniformCount = (numStr.length() - 1) * 9; int finalUniform = Integer.parseInt(String.valueOf(numStr.charAt(0)).repeat(numStr.length())); if (finalUniform <= num) { uniformCount += Integer.parseInt(String.valueOf(numStr.charAt(0))); } else { uniformCount += Integer.parseInt(String.valueOf(numStr.charAt(0))) - 1; } return uniformCount; } /** * This function will calculate the number of uniform numbers * between a and b * @param a lower bound of range * @param b upper bound of range * @return the count of uniform numbers between a and b */ public static int countUniformIntegers(int a, int b) { if (b > a && b > 0 && a > 0) { return uniformNumbers(b) - uniformNumbers(a - 1); } else if (b == a) { return 1; } else { return 0; } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import java.util.ArrayList; import java.util.Arrays; public class UnionFind { private final int[] a; private final int[] b; public UnionFind(int n) { this.a = new int[n]; this.b = new int[n]; int n2 = 0; while (n2 < n) { int n3 = n2++; this.a[n3] = n3; } } public int find(int n) { int n2 = this.a[n]; if (n == n2) { return n; } this.a[n] = n2 = this.find(n2); return n2; } public void union(int n, int n2) { n = this.find(n); if ((n2 = this.find(n2)) == n) { return; } if (this.b[n] > this.b[n2]) { this.a[n2] = n; return; } if (this.b[n2] > this.b[n]) { this.a[n] = n2; return; } this.a[n2] = n; int n3 = n; this.b[n3] = this.b[n3] + 1; } public int count() { ArrayList<Integer> arrayList = new ArrayList<Integer>(); for (int i = 0; i < this.a.length; ++i) { int n = this.find(i); if (arrayList.contains(n)) continue; arrayList.add(n); } return arrayList.size(); } public String toString() { return \"p \" + Arrays.toString(this.a) + \" r \" + Arrays.toString(this.b) + \"\\n\"; } }", "deobfuscated_code": "package com.thealgorithms.searches; import java.util.ArrayList; import java.util.Arrays; import java.util.List; /** * The Union-Find data structure, also known as Disjoint Set Union (DSU), * is a data structure that tracks a set of elements partitioned into * disjoint (non-overlapping) subsets. It supports two main operations: * * 1. **Find**: Determine which subset a particular element is in. * 2. **Union**: Join two subsets into a single subset. * * This implementation uses path compression in the `find` operation * and union by rank in the `union` operation for efficiency. */ public class UnionFind { private final int[] p; // Parent array private final int[] r; // Rank array /** * Initializes a Union-Find data structure with n elements. * Each element is its own parent initially. * * @param n the number of elements */ public UnionFind(int n) { p = new int[n]; r = new int[n]; for (int i = 0; i < n; i++) { p[i] = i; } } /** * Finds the root of the set containing the element i. * Uses path compression to flatten the structure. * * @param i the element to find * @return the root of the set */ public int find(int i) { int parent = p[i]; if (i == parent) { return i; } // Path compression final int result = find(parent); p[i] = result; return result; } /** * Unites the sets containing elements x and y. * Uses union by rank to attach the smaller tree under the larger tree. * * @param x the first element * @param y the second element */ public void union(int x, int y) { int r0 = find(x); int r1 = find(y); if (r1 == r0) { return; } // Union by rank if (r[r0] > r[r1]) { p[r1] = r0; } else if (r[r1] > r[r0]) { p[r0] = r1; } else { p[r1] = r0; r[r0]++; } } /** * Counts the number of disjoint sets. * * @return the number of disjoint sets */ public int count() { List<Integer> parents = new ArrayList<>(); for (int i = 0; i < p.length; i++) { int root = find(i); if (!parents.contains(root)) { parents.add(root); } } return parents.size(); } @Override public String toString() { return \"p \" + Arrays.toString(p) + \" r \" + Arrays.toString(r) + \"\\n\"; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import java.util.Arrays; public final class UniquePaths { private UniquePaths() { } public static int uniquePaths(int n, int n2) { while (n > n2) { int n3 = n2; n2 = n; n = n3; } int[] nArray = new int[n2]; Arrays.fill(nArray, 1); for (int i = 1; i < n; ++i) { for (int j = 1; j < n2; ++j) { nArray[j] = Math.addExact(nArray[j], nArray[j - 1]); } } return nArray[n2 - 1]; } public static int uniquePaths2(int n, int n2) { int n3; int[][] nArray = new int[n][n2]; for (n3 = 0; n3 < n; ++n3) { nArray[n3][0] = 1; } for (n3 = 0; n3 < n2; ++n3) { nArray[0][n3] = 1; } for (n3 = 1; n3 < n; ++n3) { for (int i = 1; i < n2; ++i) { nArray[n3][i] = Math.addExact(nArray[n3 - 1][i], nArray[n3][i - 1]); } } return nArray[n - 1][n2 - 1]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.Arrays; /** * Author: Siddhant Swarup Mallick * Github: https://github.com/siddhant2002 * <p> * Problem Description: * A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). * The robot can only move either down or right at any point in time. * The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). * How many possible unique paths are there? * <p> * Program Description: * This program calculates the number of unique paths possible for a robot to reach the bottom-right corner * of an m x n grid using dynamic programming. */ public final class UniquePaths { private UniquePaths() { } /** * Calculates the number of unique paths using a 1D dynamic programming array. * Time complexity O(n*m) * Space complexity O(min(n,m)) * * @param m The number of rows in the grid. * @param n The number of columns in the grid. * @return The number of unique paths. */ public static int uniquePaths(final int m, final int n) { if (m > n) { return uniquePaths(n, m); // Recursive call to handle n > m cases } int[] dp = new int[n]; // Create a 1D array to store unique paths for each column Arrays.fill(dp, 1); // Initialize all values to 1 (one way to reach each cell) for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { dp[j] = Math.addExact(dp[j], dp[j - 1]); // Update the number of unique paths for each cell } } return dp[n - 1]; // The result is stored in the last column of the array } /** * Calculates the number of unique paths using a 2D dynamic programming array. * Time complexity O(n*m) * Space complexity O(n*m) * * @param m The number of rows in the grid. * @param n The number of columns in the grid. * @return The number of unique paths. */ public static int uniquePaths2(final int m, final int n) { int[][] dp = new int[m][n]; // Create a 2D array to store unique paths for each cell for (int i = 0; i < m; i++) { dp[i][0] = 1; // Initialize the first column to 1 (one way to reach each cell) } for (int j = 0; j < n; j++) { dp[0][j] = 1; // Initialize the first row to 1 (one way to reach each cell) } for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { dp[i][j] = Math.addExact(dp[i - 1][j], dp[i][j - 1]); // Update the number of unique paths for each cell } } return dp[m - 1][n - 1]; // The result is stored in the bottom-right cell of the array } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; import java.util.Arrays; import java.util.HashSet; public final class UniqueSubsequencesCount { private UniqueSubsequencesCount() { throw new UnsupportedOperationException(\"Utility class\"); } public static int countSubseq(String string) { int[] nArray = new int[string.length() + 1]; Arrays.fill(nArray, -1); return UniqueSubsequencesCount.countSubsequences(string, 0, nArray); } public static int countSubsequences(String string, int n, int[] nArray) { if (n >= string.length()) { return 0; } if (nArray[n] != -1) { return nArray[n]; } HashSet<Character> hashSet = new HashSet<Character>(); int n2 = 0; for (int i = n; i < string.length(); ++i) { if (hashSet.contains(Character.valueOf(string.charAt(i)))) continue; hashSet.add(Character.valueOf(string.charAt(i))); n2 = 1 + UniqueSubsequencesCount.countSubsequences(string, i + 1, nArray) + n2; } nArray[n] = n2; return nArray[n]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; import java.util.Arrays; import java.util.HashSet; import java.util.Set; /** * Utility class to find the number of unique subsequences that can be * produced from a given string. * * <p> This class contains static methods to compute the unique subsequence count * using dynamic programming and recursion. It ensures that duplicate characters * are not counted multiple times in the subsequences.</p> * * <p> Author: https://github.com/Tuhinm2002 </p> */ public final class UniqueSubsequencesCount { /** * Private constructor to prevent instantiation of this utility class. * This class should only be used in a static context. * * @throws UnsupportedOperationException if attempted to instantiate. */ private UniqueSubsequencesCount() { throw new UnsupportedOperationException(\"Utility class\"); } /** * Finds the number of unique subsequences that can be generated from * the given string. * * <p> This method initializes a dynamic programming (DP) array and invokes * the recursive helper function to compute the subsequence count.</p> * * @param str the input string from which subsequences are generated * @return the total count of unique subsequences */ public static int countSubseq(String str) { // DP array initialized to store intermediate results int[] dp = new int[str.length() + 1]; Arrays.fill(dp, -1); // Calls the recursive function to compute the result return countSubsequences(str, 0, dp); } /** * Recursive helper function to count the number of unique subsequences * starting from the given index. * * <p> Uses a HashSet to avoid counting duplicate characters within * a single subsequence.</p> * * @param st the input string * @param idx the current index from which to calculate subsequences * @param dp dynamic programming array used to memoize results * @return the total number of unique subsequences starting from the * current index */ public static int countSubsequences(String st, int idx, int[] dp) { // Base case: when index exceeds the string length if (idx >= st.length()) { return 0; } // If result is already calculated, return the memoized value if (dp[idx] != -1) { return dp[idx]; } // Set to store characters to avoid duplicates Set<Character> set = new HashSet<>(); int res = 0; // Iterate over the string starting from current index for (int j = idx; j < st.length(); j++) { // If character is already in the set, skip it if (set.contains(st.charAt(j))) { continue; } // Add character to set and recursively calculate subsequences set.add(st.charAt(j)); // 1 for the current subsequence + recursive call for the rest of the string res = 1 + countSubsequences(st, j + 1, dp) + res; } // Memoize the result dp[idx] = res; return dp[idx]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. * * Could not load the following classes: * org.apache.commons.lang3.tuple.Pair */ package com.thealgorithms.conversions; import com.thealgorithms.conversions.AffineConverter; import com.thealgorithms.conversions.UnitsConverter; import java.util.Map; import org.apache.commons.lang3.tuple.Pair; public final class UnitConversions { public static final UnitsConverter TEMPERATURE = new UnitsConverter(Map.ofEntries(Map.entry(Pair.of((Object)\"Kelvin\", (Object)\"Celsius\"), new AffineConverter(1.0, -273.15)), Map.entry(Pair.of((Object)\"Celsius\", (Object)\"Fahrenheit\"), new AffineConverter(1.8, 32.0)), Map.entry(Pair.of((Object)\"R\\u00e9aumur\", (Object)\"Celsius\"), new AffineConverter(1.25, 0.0)), Map.entry(Pair.of((Object)\"Delisle\", (Object)\"Celsius\"), new AffineConverter(-0.6666666666666666, 100.0)), Map.entry(Pair.of((Object)\"Rankine\", (Object)\"Kelvin\"), new AffineConverter(0.5555555555555556, 0.0)))); private UnitConversions() { } }", "deobfuscated_code": "package com.thealgorithms.conversions; import static java.util.Map.entry; import java.util.Map; import org.apache.commons.lang3.tuple.Pair; /** * A utility class to perform unit conversions between different measurement systems. * * <p>Currently, the class supports temperature conversions between several scales: * Celsius, Fahrenheit, Kelvin, Raumur, Delisle, and Rankine. * * <h2>Example Usage</h2> * <pre> * double result = UnitConversions.TEMPERATURE.convert(\"Celsius\", \"Fahrenheit\", 100.0); * // Output: 212.0 (Celsius to Fahrenheit conversion of 100C) * </pre> * * <p>This class makes use of an {@link UnitsConverter} that handles the conversion logic * based on predefined affine transformations. These transformations include scaling factors * and offsets for temperature conversions. * * <h2>Temperature Scales Supported</h2> * <ul> * <li>Celsius</li> * <li>Fahrenheit</li> * <li>Kelvin</li> * <li>Raumur</li> * <li>Delisle</li> * <li>Rankine</li> * </ul> */ public final class UnitConversions { private UnitConversions() { } /** * A preconfigured instance of {@link UnitsConverter} for temperature conversions. * The converter handles conversions between the following temperature units: * <ul> * <li>Kelvin to Celsius</li> * <li>Celsius to Fahrenheit</li> * <li>Raumur to Celsius</li> * <li>Delisle to Celsius</li> * <li>Rankine to Kelvin</li> * </ul> */ public static final UnitsConverter TEMPERATURE = new UnitsConverter(Map.ofEntries(entry(Pair.of(\"Kelvin\", \"Celsius\"), new AffineConverter(1.0, -273.15)), entry(Pair.of(\"Celsius\", \"Fahrenheit\"), new AffineConverter(9.0 / 5.0, 32.0)), entry(Pair.of(\"Raumur\", \"Celsius\"), new AffineConverter(5.0 / 4.0, 0.0)), entry(Pair.of(\"Delisle\", \"Celsius\"), new AffineConverter(-2.0 / 3.0, 100.0)), entry(Pair.of(\"Rankine\", \"Kelvin\"), new AffineConverter(5.0 / 9.0, 0.0)))); }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. * * Could not load the following classes: * org.apache.commons.lang3.tuple.Pair */ package com.thealgorithms.conversions; import com.thealgorithms.conversions.AffineConverter; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.NoSuchElementException; import java.util.Set; import org.apache.commons.lang3.tuple.Pair; public final class UnitsConverter { private final Map a; private final Set b; private static void a(Map map, String string, String string2, AffineConverter affineConverter) { if (!string.equals(string2)) { string = Pair.of((Object)string, (Object)string2); map.putIfAbsent(string, affineConverter); } } private static Map a(Map hashMap) { String string; HashMap hashMap2 = new HashMap(); for (Map.Entry entry : hashMap.entrySet()) { string = (String)((Pair)entry.getKey()).getKey(); String string2 = (String)((Pair)entry.getKey()).getValue(); UnitsConverter.a(hashMap2, string, string2, (AffineConverter)entry.getValue()); UnitsConverter.a(hashMap2, string2, string, ((AffineConverter)entry.getValue()).invert()); } hashMap = hashMap2; hashMap2 = new HashMap(); for (Map.Entry entry : hashMap.entrySet()) { string = (Pair)entry.getKey(); UnitsConverter.a(hashMap2, (String)string.getKey(), (String)string.getValue(), (AffineConverter)entry.getValue()); for (Map.Entry entry2 : hashMap.entrySet()) { Pair pair = (Pair)entry2.getKey(); if (!((String)string.getValue()).equals(pair.getKey())) continue; AffineConverter affineConverter = ((AffineConverter)entry2.getValue()).compose((AffineConverter)entry.getValue()); UnitsConverter.a(hashMap2, (String)string.getKey(), (String)pair.getValue(), affineConverter); } } return hashMap2; } public UnitsConverter(Map object) { HashSet<String> object2 = object; object = UnitsConverter.a((Map)object); while (object.size() != object2.size()) { object2 = object; object = UnitsConverter.a((Map)((Object)object2)); } object = this.a = object; object2 = new HashSet<String>(); for (Map.Entry entry : object.entrySet()) { object2.add((String)((Pair)entry.getKey()).getKey()); } this.b = object2; } public final double convert(String string, String string2, double d) { if (string.equals(string2)) { throw new IllegalArgumentException(\"inputUnit must be different from outputUnit.\"); } string = Pair.of((Object)string, (Object)string2); return this.a.computeIfAbsent(string, pair -> { throw new NoSuchElementException(\"No converter for: \" + String.valueOf(pair)); }).convert(d); } public final Set availableUnits() { return this.b; } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.NoSuchElementException; import java.util.Set; import org.apache.commons.lang3.tuple.Pair; /** * A class that handles unit conversions using affine transformations. * * <p>The {@code UnitsConverter} allows converting values between different units using * pre-defined affine conversion formulas. Each conversion is represented by an * {@link AffineConverter} that defines the scaling and offset for the conversion. * * <p>For each unit, both direct conversions (e.g., Celsius to Fahrenheit) and inverse * conversions (e.g., Fahrenheit to Celsius) are generated automatically. It also computes * transitive conversions (e.g., Celsius to Kelvin via Fahrenheit if both conversions exist). * * <p>Key features include: * <ul> * <li>Automatic handling of inverse conversions (e.g., Fahrenheit to Celsius).</li> * <li>Compositional conversions, meaning if conversions between A -> B and B -> C exist, * it can automatically generate A -> C conversion.</li> * <li>Supports multiple unit systems as long as conversions are provided in pairs.</li> * </ul> * * <h2>Example Usage</h2> * <pre> * Map&lt;Pair&lt;String, String&gt;, AffineConverter&gt; basicConversions = Map.ofEntries( * entry(Pair.of(\"Celsius\", \"Fahrenheit\"), new AffineConverter(9.0 / 5.0, 32.0)), * entry(Pair.of(\"Kelvin\", \"Celsius\"), new AffineConverter(1.0, -273.15)) * ); * * UnitsConverter converter = new UnitsConverter(basicConversions); * double result = converter.convert(\"Celsius\", \"Fahrenheit\", 100.0); * // Output: 212.0 (Celsius to Fahrenheit conversion of 100C) * </pre> * * <h2>Exception Handling</h2> * <ul> * <li>If the input unit and output unit are the same, an {@link IllegalArgumentException} is thrown.</li> * <li>If a conversion between the requested units does not exist, a {@link NoSuchElementException} is thrown.</li> * </ul> */ public final class UnitsConverter { private final Map<Pair<String, String>, AffineConverter> conversions; private final Set<String> units; private static void putIfNeeded(Map<Pair<String, String>, AffineConverter> conversions, final String inputUnit, final String outputUnit, final AffineConverter converter) { if (!inputUnit.equals(outputUnit)) { final var key = Pair.of(inputUnit, outputUnit); conversions.putIfAbsent(key, converter); } } private static Map<Pair<String, String>, AffineConverter> addInversions(final Map<Pair<String, String>, AffineConverter> knownConversions) { Map<Pair<String, String>, AffineConverter> res = new HashMap<Pair<String, String>, AffineConverter>(); for (final var curConversion : knownConversions.entrySet()) { final var inputUnit = curConversion.getKey().getKey(); final var outputUnit = curConversion.getKey().getValue(); putIfNeeded(res, inputUnit, outputUnit, curConversion.getValue()); putIfNeeded(res, outputUnit, inputUnit, curConversion.getValue().invert()); } return res; } private static Map<Pair<String, String>, AffineConverter> addCompositions(final Map<Pair<String, String>, AffineConverter> knownConversions) { Map<Pair<String, String>, AffineConverter> res = new HashMap<Pair<String, String>, AffineConverter>(); for (final var first : knownConversions.entrySet()) { final var firstKey = first.getKey(); putIfNeeded(res, firstKey.getKey(), firstKey.getValue(), first.getValue()); for (final var second : knownConversions.entrySet()) { final var secondKey = second.getKey(); if (firstKey.getValue().equals(secondKey.getKey())) { final var newConversion = second.getValue().compose(first.getValue()); putIfNeeded(res, firstKey.getKey(), secondKey.getValue(), newConversion); } } } return res; } private static Map<Pair<String, String>, AffineConverter> addAll(final Map<Pair<String, String>, AffineConverter> knownConversions) { final var res = addInversions(knownConversions); return addCompositions(res); } private static Map<Pair<String, String>, AffineConverter> computeAllConversions(final Map<Pair<String, String>, AffineConverter> basicConversions) { var tmp = basicConversions; var res = addAll(tmp); while (res.size() != tmp.size()) { tmp = res; res = addAll(tmp); } return res; } private static Set<String> extractUnits(final Map<Pair<String, String>, AffineConverter> conversions) { Set<String> res = new HashSet<>(); for (final var conversion : conversions.entrySet()) { res.add(conversion.getKey().getKey()); } return res; } /** * Constructor for {@code UnitsConverter}. * * <p>Accepts a map of basic conversions and automatically generates inverse and * transitive conversions. * * @param basicConversions the initial set of unit conversions to add. */ public UnitsConverter(final Map<Pair<String, String>, AffineConverter> basicConversions) { conversions = computeAllConversions(basicConversions); units = extractUnits(conversions); } /** * Converts a value from one unit to another. * * @param inputUnit the unit of the input value. * @param outputUnit the unit to convert the value into. * @param value the value to convert. * @return the converted value in the target unit. * @throws IllegalArgumentException if inputUnit equals outputUnit. * @throws NoSuchElementException if no conversion exists between the units. */ public double convert(final String inputUnit, final String outputUnit, final double value) { if (inputUnit.equals(outputUnit)) { throw new IllegalArgumentException(\"inputUnit must be different from outputUnit.\"); } final var conversionKey = Pair.of(inputUnit, outputUnit); return conversions.computeIfAbsent(conversionKey, k -> { throw new NoSuchElementException(\"No converter for: \" + k); }).convert(value); } /** * Retrieves the set of all units supported by this converter. * * @return a set of available units. */ public Set<String> availableUnits() { return units; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; public final class Upper { private Upper() { } public static void main(String[] stringArray) { String[] stringArray2 = new String[]{\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"}; stringArray = stringArray2; stringArray = stringArray2; int cfr_ignored_0 = stringArray2.length; for (int i = 0; i < 4; ++i) { String string = stringArray[i]; assert (Upper.toUpperCase(string).equals(string.toUpperCase())); } } public static String toUpperCase(String charSequence) { if (charSequence == null) { throw new IllegalArgumentException(\"Input string connot be null\"); } if (((String)charSequence).isEmpty()) { return charSequence; } charSequence = new StringBuilder((String)charSequence); for (int i = 0; i < ((StringBuilder)charSequence).length(); ++i) { char c = ((StringBuilder)charSequence).charAt(i); if (!Character.isLetter(c) || !Character.isLowerCase(c)) continue; ((StringBuilder)charSequence).setCharAt(i, Character.toUpperCase(c)); } return ((StringBuilder)charSequence).toString(); } }", "deobfuscated_code": "package com.thealgorithms.strings; public final class Upper { private Upper() { } /** * Driver Code */ public static void main(String[] args) { String[] strings = {\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"}; for (String s : strings) { assert toUpperCase(s).equals(s.toUpperCase()); } } /** * Converts all the characters in this {@code String} to upper case * * @param s the string to convert * @return the {@code String}, converted to uppercase. */ public static String toUpperCase(String s) { if (s == null) { throw new IllegalArgumentException(\"Input string connot be null\"); } if (s.isEmpty()) { return s; } StringBuilder result = new StringBuilder(s); for (int i = 0; i < result.length(); ++i) { char currentChar = result.charAt(i); if (Character.isLetter(currentChar) && Character.isLowerCase(currentChar)) { result.setCharAt(i, Character.toUpperCase(currentChar)); } } return result.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; class UpperBound implements SearchAlgorithm { UpperBound() { } @Override public int find(Comparable[] comparableArray, Comparable comparable) { return this.a(comparableArray, comparable, 0, comparableArray.length - 1); } private int a(Comparable[] comparableArray, Comparable comparable, int n, int n2) { while (n2 > n) { int n3 = n + n2 >>> 1; int n4 = comparable.compareTo(comparableArray[n3]); if (n4 < 0) { n2 = n3; continue; } n = n3 + 1; } return n; } }", "deobfuscated_code": "package com.thealgorithms.searches; import com.thealgorithms.devutils.searches.SearchAlgorithm; /** * The UpperBound method is used to return an index pointing to the first * element in the range [first, last) which has a value greater than val, or the * last index if no such element exists i.e. the index of the next smallest * number just greater than that number. If there are multiple values that are * equal to val it returns the index of the first such value. * * <p> * This is an extension of BinarySearch. * * <p> * Worst-case performance O(log n) Best-case performance O(1) Average * performance O(log n) Worst-case space complexity O(1) * * @author Pratik Padalia (https://github.com/15pratik) * @see SearchAlgorithm * @see BinarySearch */ class UpperBound implements SearchAlgorithm { /** * @param array is an array where the UpperBound value is to be found * @param key is an element for which the UpperBound is to be found * @param <T> is any comparable type * @return index of the UpperBound element */ @Override public <T extends Comparable<T>> int find(T[] array, T key) { return search(array, key, 0, array.length - 1); } /** * This method implements the Generic Binary Search * * @param array The array to make the binary search * @param key The number you are looking for * @param left The lower bound * @param right The upper bound * @return the location of the key */ private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) { if (right <= left) { return left; } // find median int median = (left + right) >>> 1; int comp = key.compareTo(array[median]); if (comp < 0) { // key is smaller, median position can be a possible solution return search(array, key, left, median); } else { // key we are looking is greater, so we must look on the right of median position return search(array, key, median + 1, right); } } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers.a5; import java.util.BitSet; public final class Utils { private Utils() { } public static boolean increment(BitSet bitSet, int n) { --n; while (n >= 0 && bitSet.get(n)) { bitSet.set(n--, false); } if (n < 0) { return false; } bitSet.set(n, true); return true; } }", "deobfuscated_code": "package com.thealgorithms.ciphers.a5; // Source // http://www.java2s.com/example/java-utility-method/bitset/increment-bitset-bits-int-size-9fd84.html // package com.java2s; // License from project: Open Source License import java.util.BitSet; public final class Utils { private Utils() { } public static boolean increment(BitSet bits, int size) { int i = size - 1; while (i >= 0 && bits.get(i)) { bits.set(i--, false); /*from w w w . j a v a 2s .c o m*/ } if (i < 0) { return false; } bits.set(i, true); return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.ArrayDeque; import java.util.Map; public final class ValidParentheses { private static final Map a = Map.of(Character.valueOf(')'), Character.valueOf('('), Character.valueOf('}'), Character.valueOf('{'), Character.valueOf(']'), Character.valueOf('[')); private ValidParentheses() { } public static boolean isValid(String object) { if (object == null) { throw new IllegalArgumentException(\"Input string cannot be null\"); } ArrayDeque<Character> arrayDeque = new ArrayDeque<Character>(); char[] cArray = ((String)object).toCharArray(); object = cArray; int n = cArray.length; for (int i = 0; i < n; ++i) { Object object2 = object[i]; if (a.containsValue(Character.valueOf((char)object2))) { arrayDeque.push(Character.valueOf((char)object2)); continue; } if (a.containsKey(Character.valueOf((char)object2))) { if (!arrayDeque.isEmpty() && arrayDeque.pop() == a.get(Character.valueOf((char)object2))) continue; return false; } throw new IllegalArgumentException(\"Unexpected character: \" + (char)object2); } return arrayDeque.isEmpty(); } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.ArrayDeque; import java.util.Deque; import java.util.Map; /** * Validates if a given string has valid matching parentheses. * <p> * A string is considered valid if: * <ul> * <li>Open brackets are closed by the same type of brackets.</li> * <li>Brackets are closed in the correct order.</li> * <li>Every closing bracket has a corresponding open bracket of the same type.</li> * </ul> * * Allowed characters: '(', ')', '{', '}', '[', ']' */ public final class ValidParentheses { private ValidParentheses() { } private static final Map<Character, Character> BRACKET_PAIRS = Map.of(')', '(', '}', '{', ']', '['); /** * Checks if the input string has valid parentheses. * * @param s the string containing only bracket characters * @return true if valid, false otherwise * @throws IllegalArgumentException if the string contains invalid characters or is null */ public static boolean isValid(String s) { if (s == null) { throw new IllegalArgumentException(\"Input string cannot be null\"); } Deque<Character> stack = new ArrayDeque<>(); for (char c : s.toCharArray()) { if (BRACKET_PAIRS.containsValue(c)) { stack.push(c); // opening bracket } else if (BRACKET_PAIRS.containsKey(c)) { if (stack.isEmpty() || stack.pop() != BRACKET_PAIRS.get(c)) { return false; } } else { throw new IllegalArgumentException(\"Unexpected character: \" + c); } } return stack.isEmpty(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class VampireNumber { private VampireNumber() { } }", "deobfuscated_code": "package com.thealgorithms.maths; import java.util.ArrayList; /** * In number theory, a vampire number (or true vampire number) is a composite * natural number with an even number of digits, that can be factored into two * natural numbers each with half as many digits as the original number and not * both with trailing zeroes, where the two factors contain precisely all the * digits of the original number, in any order, counting multiplicity. The first * vampire number is 1260 = 21  60. * * @see <a href='https://en.wikipedia.org/wiki/Vampire_number'>Vampire number on Wikipedia</a> */ public final class VampireNumber { // Forbid instantiation. private VampireNumber() { } static boolean isVampireNumber(int a, int b, boolean ignorePseudoVampireNumbers) { // Pseudo vampire numbers don't have to be of n/2 digits. E.g., 126 = 6 x 21 is such a number. if (ignorePseudoVampireNumbers && String.valueOf(a).length() != String.valueOf(b).length()) { return false; } String mulDigits = splitIntoSortedDigits(a * b); String factorDigits = splitIntoSortedDigits(a, b); return mulDigits.equals(factorDigits); } // Method to split a pair of numbers to digits and sort them in the ascending order. static String splitIntoSortedDigits(int... nums) { // Collect all digits in a list. ArrayList<Integer> digits = new ArrayList<>(); for (int num : nums) { while (num > 0) { digits.add(num % 10); num /= 10; } } // Sort all digits and convert to String. StringBuilder res = new StringBuilder(); digits.stream().sorted().forEach(res::append); return res.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public class VectorCrossProduct { private int a; private int b; private int c; VectorCrossProduct() { this.a = 0; this.b = 0; this.c = 0; } private VectorCrossProduct(int n, int n2, int n3) { this.a = n; this.b = n2; this.c = 3; } public static void main(String[] object) { VectorCrossProduct vectorCrossProduct; object = new VectorCrossProduct(1, -2, 3); VectorCrossProduct vectorCrossProduct2 = vectorCrossProduct = new VectorCrossProduct(2, 0, 3); Object object2 = object; VectorCrossProduct vectorCrossProduct3 = new VectorCrossProduct(); new VectorCrossProduct().a = object2.b * vectorCrossProduct2.c - object2.c * vectorCrossProduct2.b; vectorCrossProduct3.b = -(object2.a * vectorCrossProduct2.c - object2.c * vectorCrossProduct2.a); vectorCrossProduct3.c = object2.a * vectorCrossProduct2.b - object2.b * vectorCrossProduct2.a; object2 = vectorCrossProduct3; System.out.println(\"x : \" + object2.a + \"\\ty : \" + object2.b + \"\\tz : \" + object2.c); vectorCrossProduct2 = vectorCrossProduct; object2 = object; int n = object.a * vectorCrossProduct2.a + object2.b * vectorCrossProduct2.b + object2.c * vectorCrossProduct2.c; System.out.println(\"Dot Product of a and b: \" + n); } }", "deobfuscated_code": "package com.thealgorithms.maths; /** * @file * * @brief Calculates the [Cross * Product](https://en.wikipedia.org/wiki/Cross_product) and the magnitude of * two mathematical 3D vectors. * * * @details Cross Product of two vectors gives a vector. Direction Ratios of a * vector are the numeric parts of the given vector. They are the tree parts of * the vector which determine the magnitude (value) of the vector. The method of * finding a cross product is the same as finding the determinant of an order 3 * matrix consisting of the first row with unit vectors of magnitude 1, the * second row with the direction ratios of the first vector and the third row * with the direction ratios of the second vector. The magnitude of a vector is * it's value expressed as a number. Let the direction ratios of the first * vector, P be: a, b, c Let the direction ratios of the second vector, Q be: x, * y, z Therefore the calculation for the cross product can be arranged as: * * ``` P x Q: 1 1 1 a b c x y z ``` * * The direction ratios (DR) are calculated as follows: 1st DR, J: (b * z) - (c * * y) 2nd DR, A: -((a * z) - (c * x)) 3rd DR, N: (a * y) - (b * x) * * Therefore, the direction ratios of the cross product are: J, A, N The * following Java Program calculates the direction ratios of the cross products * of two vector. The program uses a function, cross() for doing so. The * direction ratios for the first and the second vector has to be passed one by * one separated by a space character. * * Magnitude of a vector is the square root of the sum of the squares of the * direction ratios. * * * For maintaining filename consistency, Vector class has been termed as * VectorCrossProduct * * @author [Syed](https://github.com/roeticvampire) */ public class VectorCrossProduct { int x; int y; int z; // Default constructor, initialises all three Direction Ratios to 0 VectorCrossProduct() { x = 0; y = 0; z = 0; } /** * constructor, initialises Vector with given Direction Ratios * * @param vectorX set to x * @param vectorY set to y * @param vectorZ set to z */ VectorCrossProduct(int vectorX, int vectorY, int vectorZ) { x = vectorX; y = vectorY; z = vectorZ; } /** * Returns the magnitude of the vector * * @return double */ double magnitude() { return Math.sqrt(x * x + y * y + z * z); } /** * Returns the dot product of the current vector with a given vector * * @param b: the second vector * @return int: the dot product */ int dotProduct(VectorCrossProduct b) { return x * b.x + y * b.y + z * b.z; } /** * Returns the cross product of the current vector with a given vector * * @param b: the second vector * @return vectorCrossProduct: the cross product */ VectorCrossProduct crossProduct(VectorCrossProduct b) { VectorCrossProduct product = new VectorCrossProduct(); product.x = (y * b.z) - (z * b.y); product.y = -((x * b.z) - (z * b.x)); product.z = (x * b.y) - (y * b.x); return product; } /** * Display the Vector */ void displayVector() { System.out.println(\"x : \" + x + \"\\ty : \" + y + \"\\tz : \" + z); } public static void main(String[] args) { test(); } static void test() { // Create two vectors VectorCrossProduct a = new VectorCrossProduct(1, -2, 3); VectorCrossProduct b = new VectorCrossProduct(2, 0, 3); // Determine cross product VectorCrossProduct crossProd = a.crossProduct(b); crossProd.displayVector(); // Determine dot product int dotProd = a.dotProduct(b); System.out.println(\"Dot Product of a and b: \" + dotProd); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import java.util.Objects; public final class Verhoeff { private static final byte[][] a = new byte[][]{{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, {1, 2, 3, 4, 0, 6, 7, 8, 9, 5}, {2, 3, 4, 0, 1, 7, 8, 9, 5, 6}, {3, 4, 0, 1, 2, 8, 9, 5, 6, 7}, {4, 0, 1, 2, 3, 9, 5, 6, 7, 8}, {5, 9, 8, 7, 6, 0, 4, 3, 2, 1}, {6, 5, 9, 8, 7, 1, 0, 4, 3, 2}, {7, 6, 5, 9, 8, 2, 1, 0, 4, 3}, {8, 7, 6, 5, 9, 3, 2, 1, 0, 4}, {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}}; private static final byte[] b = new byte[]{0, 4, 3, 2, 1, 5, 6, 7, 8, 9}; private static final byte[][] c = new byte[][]{{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, {1, 5, 7, 6, 2, 8, 3, 0, 9, 4}, {5, 8, 0, 3, 7, 9, 6, 1, 4, 2}, {8, 9, 1, 6, 0, 4, 3, 5, 2, 7}, {9, 4, 5, 3, 1, 2, 6, 8, 7, 0}, {4, 2, 8, 6, 5, 7, 3, 9, 0, 1}, {2, 7, 9, 3, 8, 0, 6, 4, 1, 5}, {7, 0, 4, 6, 9, 1, 3, 2, 5, 8}}; private Verhoeff() { } public static boolean verhoeffCheck(String object) { Verhoeff.b((String)object); object = Verhoeff.c((String)object); int n = 0; for (int i = 0; i < ((Object)object).length; ++i) { int n2 = ((Object)object).length - i - 1; n2 = c[i % 8][object[n2]]; n = a[n][n2]; } return n == 0; } public static String addVerhoeffChecksum(String string) { Verhoeff.b(string); Object object = string + \"0\"; object = Verhoeff.c((String)object); int n = 0; for (int i = 0; i < ((Object)object).length; ++i) { int n2 = ((Object)object).length - i - 1; n2 = c[i % 8][object[n2]]; n = a[n][n2]; } n = b[n]; return string + n; } public static void main(String[] object) { System.out.println(\"Verhoeff algorithm usage examples:\"); object = \"2363\"; String string = \"2364\"; Verhoeff.a((String)object); Verhoeff.a(string); System.out.println(\"\\nCheck digit generation example:\"); object = \"236\"; object = \"236\"; string = Verhoeff.addVerhoeffChecksum(\"236\"); System.out.println(\"Generate and add checksum to initial value '\" + (String)object + \"'. Result: '\" + string + \"'\"); } private static void a(String string) { String string2 = Verhoeff.verhoeffCheck(string) ? \"valid\" : \"not valid\"; System.out.println(\"Input '\" + string + \"' is \" + string2); } private static void b(String string) { Objects.requireNonNull(string); if (!string.matches(\"\\\\d+\")) { throw new IllegalArgumentException(\"Input '\" + string + \"' contains not only digits\"); } } private static int[] c(String string) { return string.chars().map(n -> Character.digit(n, 10)).toArray(); } }", "deobfuscated_code": "package com.thealgorithms.others; import java.util.Objects; /** * The Verhoeff algorithm is a checksum formula for error detection developed by * the Dutch mathematician Jacobus Verhoeff and was first published in 1969. It * was the first decimal check digit algorithm which detects all single-digit * errors, and all transposition errors involving two adjacent digits. * * <p> * The strengths of the algorithm are that it detects all transliteration and * transposition errors, and additionally most twin, twin jump, jump * transposition and phonetic errors. The main weakness of the Verhoeff * algorithm is its complexity. The calculations required cannot easily be * expressed as a formula. For easy calculation three tables are required:</p> * <ol> * <li>multiplication table</li> * <li>inverse table</li> * <li>permutation table</li> * </ol> * * @see <a href=\"https://en.wikipedia.org/wiki/Verhoeff_algorithm\">Wiki. * Verhoeff algorithm</a> */ public final class Verhoeff { private Verhoeff() { } /** * Table {@code d}. Based on multiplication in the dihedral group D5 and is * simply the Cayley table of the group. Note that this group is not * commutative, that is, for some values of {@code j} and {@code k}, * {@code d(j,k)  d(k, j)}. * * @see <a href=\"https://en.wikipedia.org/wiki/Dihedral_group\">Wiki. * Dihedral group</a> */ private static final byte[][] MULTIPLICATION_TABLE = { {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, {1, 2, 3, 4, 0, 6, 7, 8, 9, 5}, {2, 3, 4, 0, 1, 7, 8, 9, 5, 6}, {3, 4, 0, 1, 2, 8, 9, 5, 6, 7}, {4, 0, 1, 2, 3, 9, 5, 6, 7, 8}, {5, 9, 8, 7, 6, 0, 4, 3, 2, 1}, {6, 5, 9, 8, 7, 1, 0, 4, 3, 2}, {7, 6, 5, 9, 8, 2, 1, 0, 4, 3}, {8, 7, 6, 5, 9, 3, 2, 1, 0, 4}, {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}, }; /** * The inverse table {@code inv}. Represents the multiplicative inverse of a * digit, that is, the value that satisfies {@code d(j, inv(j)) = 0}. */ private static final byte[] MULTIPLICATIVE_INVERSE = { 0, 4, 3, 2, 1, 5, 6, 7, 8, 9, }; /** * The permutation table {@code p}. Applies a permutation to each digit * based on its position in the number. This is actually a single * permutation {@code (1 5 8 9 4 2 7 0)(3 6)} applied iteratively; i.e. * {@code p(i+j,n) = p(i, p(j,n))}. */ private static final byte[][] PERMUTATION_TABLE = { {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, {1, 5, 7, 6, 2, 8, 3, 0, 9, 4}, {5, 8, 0, 3, 7, 9, 6, 1, 4, 2}, {8, 9, 1, 6, 0, 4, 3, 5, 2, 7}, {9, 4, 5, 3, 1, 2, 6, 8, 7, 0}, {4, 2, 8, 6, 5, 7, 3, 9, 0, 1}, {2, 7, 9, 3, 8, 0, 6, 4, 1, 5}, {7, 0, 4, 6, 9, 1, 3, 2, 5, 8}, }; /** * Check input digits by Verhoeff algorithm. * * @param digits input to check * @return true if check was successful, false otherwise * @throws IllegalArgumentException if input parameter contains not only * digits * @throws NullPointerException if input is null */ public static boolean verhoeffCheck(String digits) { checkInput(digits); int[] numbers = toIntArray(digits); // The Verhoeff algorithm int checksum = 0; for (int i = 0; i < numbers.length; i++) { int index = numbers.length - i - 1; byte b = PERMUTATION_TABLE[i % 8][numbers[index]]; checksum = MULTIPLICATION_TABLE[checksum][b]; } return checksum == 0; } /** * Calculate check digit for initial digits and add it tho the last * position. * * @param initialDigits initial value * @return digits with the checksum in the last position * @throws IllegalArgumentException if input parameter contains not only * digits * @throws NullPointerException if input is null */ public static String addVerhoeffChecksum(String initialDigits) { checkInput(initialDigits); // Add zero to end of input value var modifiedDigits = initialDigits + \"0\"; int[] numbers = toIntArray(modifiedDigits); int checksum = 0; for (int i = 0; i < numbers.length; i++) { int index = numbers.length - i - 1; byte b = PERMUTATION_TABLE[i % 8][numbers[index]]; checksum = MULTIPLICATION_TABLE[checksum][b]; } checksum = MULTIPLICATIVE_INVERSE[checksum]; return initialDigits + checksum; } public static void main(String[] args) { System.out.println(\"Verhoeff algorithm usage examples:\"); var validInput = \"2363\"; var invalidInput = \"2364\"; checkAndPrint(validInput); checkAndPrint(invalidInput); System.out.println(\"\\nCheck digit generation example:\"); var input = \"236\"; generateAndPrint(input); } private static void checkAndPrint(String input) { String validationResult = Verhoeff.verhoeffCheck(input) ? \"valid\" : \"not valid\"; System.out.println(\"Input '\" + input + \"' is \" + validationResult); } private static void generateAndPrint(String input) { String result = addVerhoeffChecksum(input); System.out.println(\"Generate and add checksum to initial value '\" + input + \"'. Result: '\" + result + \"'\"); } private static void checkInput(String input) { Objects.requireNonNull(input); if (!input.matches(\"\\\\d+\")) { throw new IllegalArgumentException(\"Input '\" + input + \"' contains not only digits\"); } } private static int[] toIntArray(String string) { return string.chars().map(i -> Character.digit(i, 10)).toArray(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.LinkedList; public final class VerticalOrderTraversal { private VerticalOrderTraversal() { } public static ArrayList verticalTraversal(BinaryTree$Node arrayList) { if (arrayList == null) { return new ArrayList(); } LinkedList<BinaryTree$Node> linkedList = new LinkedList<BinaryTree$Node>(); LinkedList<Integer> linkedList2 = new LinkedList<Integer>(); HashMap hashMap = new HashMap(); int n = 0; int n2 = 0; linkedList.offer((BinaryTree$Node)((Object)arrayList)); linkedList2.offer(0); while (!linkedList.isEmpty()) { if (((BinaryTree$Node)linkedList.peek()).left != null) { LinkedList<BinaryTree$Node> linkedList3 = linkedList; linkedList3.offer(((BinaryTree$Node)linkedList3.peek()).left); LinkedList<Integer> linkedList4 = linkedList2; linkedList4.offer((Integer)linkedList4.peek() - 1); } if (((BinaryTree$Node)linkedList.peek()).right != null) { LinkedList<BinaryTree$Node> linkedList5 = linkedList; linkedList5.offer(((BinaryTree$Node)linkedList5.peek()).right); LinkedList<Integer> linkedList6 = linkedList2; linkedList6.offer((Integer)linkedList6.peek() + 1); } if (!hashMap.containsKey(linkedList2.peek())) { arrayList = new ArrayList(); hashMap.put((Integer)linkedList2.peek(), arrayList); } ((ArrayList)hashMap.get(linkedList2.peek())).add(((BinaryTree$Node)linkedList.peek()).data); n = Math.max(n, (Integer)linkedList2.peek()); n2 = Math.min(n2, (Integer)linkedList2.peek()); linkedList2.poll(); linkedList.poll(); } arrayList = new ArrayList(); for (int i = n2; i <= n; ++i) { arrayList.addAll((Collection)hashMap.get(i)); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayList; import java.util.HashMap; import java.util.LinkedList; import java.util.Map; import java.util.Queue; /* The following class implements a vertical order traversal in a tree from top to bottom and left to right, so for a tree : 1 / \\ 2 3 / \\ \\ 4 5 6 \\ / \\ 7 8 10 \\ 9 the sequence will be : 4 2 7 1 5 9 3 8 6 10 */ public final class VerticalOrderTraversal { private VerticalOrderTraversal() { } /*Function that receives a root Node and prints the tree in Vertical Order.*/ public static ArrayList<Integer> verticalTraversal(BinaryTree.Node root) { if (root == null) { return new ArrayList<>(); } /*Queue to store the Nodes.*/ Queue<BinaryTree.Node> queue = new LinkedList<>(); /*Queue to store the index of particular vertical column of a tree , with root at 0, Nodes on left with negative index and Nodes on right with positive index. */ Queue<Integer> index = new LinkedList<>(); /*Map of Integer and ArrayList to store all the elements in a particular index in a single arrayList that will have a key equal to the index itself. */ Map<Integer, ArrayList<Integer>> map = new HashMap<>(); /* min and max stores leftmost and right most index to later print the tree in vertical fashion.*/ int max = 0; int min = 0; queue.offer(root); index.offer(0); while (!queue.isEmpty()) { if (queue.peek().left != null) { /*Adding the left Node if it is not null and its index by subtracting 1 from it's parent's index*/ queue.offer(queue.peek().left); index.offer(index.peek() - 1); } if (queue.peek().right != null) { /*Adding the right Node if it is not null and its index by adding 1 from it's parent's index*/ queue.offer(queue.peek().right); index.offer(index.peek() + 1); } /*If the map does not contains the index a new ArrayList is created with the index as key.*/ if (!map.containsKey(index.peek())) { ArrayList<Integer> a = new ArrayList<>(); map.put(index.peek(), a); } /*For a index, corresponding Node data is added to the respective ArrayList present at that index. */ map.get(index.peek()).add(queue.peek().data); max = Math.max(max, index.peek()); min = Math.min(min, index.peek()); /*The Node and its index are removed from their respective queues.*/ index.poll(); queue.poll(); } /*Finally map data is printed here which has keys from min to max. Each ArrayList represents a vertical column that is added in ans ArrayList.*/ ArrayList<Integer> ans = new ArrayList<>(); for (int i = min; i <= max; i++) { ans.addAll(map.get(i)); } return ans; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; public class Vigenere { public String encrypt(String string, String string2) { if (string2.isEmpty()) { throw new IllegalArgumentException(\"Key cannot be empty.\"); } StringBuilder stringBuilder = new StringBuilder(); int n = 0; for (int i = 0; i < string.length(); ++i) { char c = string.charAt(i); if (Character.isLetter(c)) { if (Character.isUpperCase(c)) { stringBuilder.append((char)((c + string2.toUpperCase().charAt(n) - 130) % 26 + 65)); } else { stringBuilder.append((char)((c + string2.toLowerCase().charAt(n) - 194) % 26 + 97)); } ++n; n %= string2.length(); continue; } stringBuilder.append(c); } return stringBuilder.toString(); } public String decrypt(String string, String string2) { if (string2.isEmpty()) { throw new IllegalArgumentException(\"Key cannot be empty.\"); } StringBuilder stringBuilder = new StringBuilder(); int n = 0; for (int i = 0; i < string.length(); ++i) { char c = string.charAt(i); if (Character.isLetter(c)) { if (Character.isUpperCase(c)) { stringBuilder.append((char)(90 - (25 - (c - string2.toUpperCase().charAt(n))) % 26)); } else { stringBuilder.append((char)(122 - (25 - (c - string2.toLowerCase().charAt(n))) % 26)); } ++n; n %= string2.length(); continue; } stringBuilder.append(c); } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; /** * A Java implementation of the Vigenre Cipher. * * The Vigenre Cipher is a polyalphabetic substitution cipher that uses a * keyword to shift letters in the plaintext by different amounts, depending * on the corresponding character in the keyword. It wraps around the alphabet, * ensuring the shifts are within 'A'-'Z' or 'a'-'z'. * * Non-alphabetic characters (like spaces, punctuation) are kept unchanged. * * Encryption Example: * - Plaintext: \"Hello World!\" * - Key: \"suchsecret\" * - Encrypted Text: \"Zynsg Yfvev!\" * * Decryption Example: * - Ciphertext: \"Zynsg Yfvev!\" * - Key: \"suchsecret\" * - Decrypted Text: \"Hello World!\" * * Wikipedia Reference: * <a href=\"https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher\">Vigenre Cipher - Wikipedia</a> * * @author straiffix * @author beingmartinbmc */ public class Vigenere { /** * Encrypts a given message using the Vigenre Cipher with the specified key. * Steps: * 1. Iterate over each character in the message. * 2. If the character is a letter, shift it by the corresponding character in the key. * 3. Preserve the case of the letter. * 4. Preserve non-alphabetic characters. * 5. Move to the next character in the key (cyclic). * 6. Return the encrypted message. * * @param message The plaintext message to encrypt. * @param key The keyword used for encryption. * @throws IllegalArgumentException if the key is empty. * @return The encrypted message. */ public String encrypt(final String message, final String key) { if (key.isEmpty()) { throw new IllegalArgumentException(\"Key cannot be empty.\"); } StringBuilder result = new StringBuilder(); int j = 0; for (int i = 0; i < message.length(); i++) { char c = message.charAt(i); if (Character.isLetter(c)) { if (Character.isUpperCase(c)) { result.append((char) ((c + key.toUpperCase().charAt(j) - 2 * 'A') % 26 + 'A')); } else { result.append((char) ((c + key.toLowerCase().charAt(j) - 2 * 'a') % 26 + 'a')); } j = ++j % key.length(); } else { result.append(c); } } return result.toString(); } /** * Decrypts a given message encrypted with the Vigenre Cipher using the specified key. * Steps: * 1. Iterate over each character in the message. * 2. If the character is a letter, shift it back by the corresponding character in the key. * 3. Preserve the case of the letter. * 4. Preserve non-alphabetic characters. * 5. Move to the next character in the key (cyclic). * 6. Return the decrypted message. * * @param message The encrypted message to decrypt. * @param key The keyword used for decryption. * @throws IllegalArgumentException if the key is empty. * @return The decrypted plaintext message. */ public String decrypt(final String message, final String key) { if (key.isEmpty()) { throw new IllegalArgumentException(\"Key cannot be empty.\"); } StringBuilder result = new StringBuilder(); int j = 0; for (int i = 0; i < message.length(); i++) { char c = message.charAt(i); if (Character.isLetter(c)) { if (Character.isUpperCase(c)) { result.append((char) ('Z' - (25 - (c - key.toUpperCase().charAt(j))) % 26)); } else { result.append((char) ('z' - (25 - (c - key.toLowerCase().charAt(j))) % 26)); } j = ++j % key.length(); } else { result.append(c); } } return result.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.maths; public final class Volume { private Volume() { } public static double volumeCube(double d) { double d2 = d; return d2 * d2 * d; } public static double volumeCuboid(double d, double d2, double d3) { return d * d2 * d3; } public static double volumeSphere(double d) { return d * (Math.PI * 4) * d * d / 3.0; } public static double volumeCylinder(double d, double d2) { return d * Math.PI * d * d2; } public static double volumeHemisphere(double d) { return d * (Math.PI * 2) * d * d / 3.0; } public static double volumeCone(double d, double d2) { return d * Math.PI * d * d2 / 3.0; } public static double volumePrism(double d, double d2) { return d * d2; } public static double volumePyramid(double d, double d2) { return d * d2 / 3.0; } public static double volumeFrustumOfCone(double d, double d2, double d3) { double d4 = d; double d5 = d2; return d3 * Math.PI / 3.0 * (d4 * d4 + d5 * d5 + d * d2); } }", "deobfuscated_code": "package com.thealgorithms.maths; /* Calculate the volume of various shapes.*/ public final class Volume { private Volume() { } /** * Calculate the volume of a cube. * * @param sideLength length of the given cube's sides * @return volume of the given cube */ public static double volumeCube(double sideLength) { return sideLength * sideLength * sideLength; } /** * Calculate the volume of a cuboid. * * @param width width of given cuboid * @param height height of given cuboid * @param length length of given cuboid * @return volume of given cuboid */ public static double volumeCuboid(double width, double height, double length) { return width * height * length; } /** * Calculate the volume of a sphere. * * @param radius radius of given sphere * @return volume of given sphere */ public static double volumeSphere(double radius) { return (4 * Math.PI * radius * radius * radius) / 3; } /** * Calculate volume of a cylinder * * @param radius radius of the given cylinder's floor * @param height height of the given cylinder * @return volume of given cylinder */ public static double volumeCylinder(double radius, double height) { return Math.PI * radius * radius * height; } /** * Calculate the volume of a hemisphere. * * @param radius radius of given hemisphere * @return volume of given hemisphere */ public static double volumeHemisphere(double radius) { return (2 * Math.PI * radius * radius * radius) / 3; } /** * Calculate the volume of a cone. * * @param radius radius of given cone * @param height of given cone * @return volume of given cone */ public static double volumeCone(double radius, double height) { return (Math.PI * radius * radius * height) / 3; } /** * Calculate the volume of a prism. * * @param baseArea area of the given prism's base * @param height of given prism * @return volume of given prism */ public static double volumePrism(double baseArea, double height) { return baseArea * height; } /** * Calculate the volume of a pyramid. * * @param baseArea of the given pyramid's base * @param height of given pyramid * @return volume of given pyramid */ public static double volumePyramid(double baseArea, double height) { return (baseArea * height) / 3; } /** * Calculate the volume of a frustum of a cone. * * @param r1 radius of the top of the frustum * @param r2 radius of the bottom of the frustum * @param height height of the frustum * @return volume of the frustum */ public static double volumeFrustumOfCone(double r1, double r2, double height) { return (Math.PI * height / 3) * (r1 * r1 + r2 * r2 + r1 * r2); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; public class WaveSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] comparableArray) { for (int i = 0; i < comparableArray.length; i += 2) { if (i > 0 && SortUtils.less(comparableArray[i], comparableArray[i - 1])) { int n = i; SortUtils.swap(comparableArray, n, n - 1); } if (i >= comparableArray.length - 1 || !SortUtils.less(comparableArray[i], comparableArray[i + 1])) continue; int n = i; SortUtils.swap(comparableArray, n, n + 1); } return comparableArray; } public boolean isWaveSorted(Comparable[] comparableArray) { for (int i = 0; i < comparableArray.length; i += 2) { if (i > 0 && SortUtils.less(comparableArray[i], comparableArray[i - 1])) { return false; } if (i >= comparableArray.length - 1 || !SortUtils.less(comparableArray[i], comparableArray[i + 1])) continue; return false; } return true; } }", "deobfuscated_code": "package com.thealgorithms.sorts; /** * The WaveSort algorithm sorts an array so that every alternate element is greater than its adjacent elements. * This implementation also provides a method to check if an array is wave sorted. */ public class WaveSort implements SortAlgorithm { /** * Sorts the given array such that every alternate element is greater than its adjacent elements. * * @param array The array to be sorted. * @param <T> The type of elements in the array, which must be Comparable. * @return The sorted array. */ @Override public <T extends Comparable<T>> T[] sort(T[] array) { for (int i = 0; i < array.length; i += 2) { if (i > 0 && SortUtils.less(array[i], array[i - 1])) { SortUtils.swap(array, i, i - 1); } if (i < array.length - 1 && SortUtils.less(array[i], array[i + 1])) { SortUtils.swap(array, i, i + 1); } } return array; } /** * Checks if the given array is wave sorted. An array is wave sorted if every alternate element is greater than its adjacent elements. * * @param array The array to check. * @param <T> The type of elements in the array, which must be Comparable. * @return true if the array is wave sorted, false otherwise. */ public <T extends Comparable<T>> boolean isWaveSorted(T[] array) { for (int i = 0; i < array.length; i += 2) { if (i > 0 && SortUtils.less(array[i], array[i - 1])) { return false; } if (i < array.length - 1 && SortUtils.less(array[i], array[i + 1])) { return false; } } return true; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.Arrays; import java.util.HashSet; final class WelshPowell$Graph { private final HashSet[] a; private WelshPowell$Graph(int n2) { if (n2 < 0) { throw new IllegalArgumentException(\"Number of vertices cannot be negative\"); } this.a = new HashSet[n2]; Arrays.setAll(this.a, n -> new HashSet()); } private void a(int n, int n2) { this.b(n); this.b(n2); if (n == n2) { throw new IllegalArgumentException(\"Self-loops are not allowed\"); } this.a[n].add(n2); this.a[n2].add(n); } private void b(int n) { block3: { block2: { if (n < 0) break block2; WelshPowell$Graph welshPowell$Graph = this; if (n < welshPowell$Graph.a.length) break block3; } throw new IllegalArgumentException(\"Vertex \" + n + \" is out of bounds\"); } } final HashSet a(int n) { return this.a[n]; } final int a() { return this.a.length; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import java.util.Arrays; import java.util.HashSet; final class WelshPowell$Graph { private final HashSet[] a; private WelshPowell$Graph(int n2) { if (n2 < 0) { throw new IllegalArgumentException(\"Number of vertices cannot be negative\"); } this.a = new HashSet[n2]; Arrays.setAll(this.a, n -> new HashSet()); } private void a(int n, int n2) { this.b(n); this.b(n2); if (n == n2) { throw new IllegalArgumentException(\"Self-loops are not allowed\"); } this.a[n].add(n2); this.a[n2].add(n); } private void b(int n) { block3: { block2: { if (n < 0) break block2; WelshPowell$Graph welshPowell$Graph = this; if (n < welshPowell$Graph.a.length) break block3; } throw new IllegalArgumentException(\"Vertex \" + n + \" is out of bounds\"); } } final HashSet a(int n) { return this.a[n]; } final int a() { return this.a.length; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.graphs; import com.thealgorithms.datastructures.graphs.WelshPowell$Graph; import java.util.Arrays; import java.util.Comparator; import java.util.stream.IntStream; public final class WelshPowell { private WelshPowell() { } public static WelshPowell$Graph makeGraph(int n, int[][] nArray) { WelshPowell$Graph welshPowell$Graph = new WelshPowell$Graph(n); for (int[] nArray2 : nArray) { if (nArray2.length != 2) { throw new IllegalArgumentException(\"Edge array must have exactly two elements\"); } welshPowell$Graph.a(nArray2[0], nArray2[1]); } return welshPowell$Graph; } public static int[] findColoring(WelshPowell$Graph welshPowell$Graph) { Integer[] integerArray; int n2 = welshPowell$Graph.a(); int[] nArray = new int[n2]; Arrays.fill(nArray, -1); int[] nArray2 = nArray; WelshPowell$Graph welshPowell$Graph2 = welshPowell$Graph; Integer[] integerArray2 = integerArray = (Integer[])IntStream.range(0, welshPowell$Graph2.a()).boxed().sorted(Comparator.comparingInt(n -> -welshPowell$Graph2.a((int)n).size())).toArray(Integer[]::new); int n4 = integerArray.length; for (int i = 0; i < n4; ++i) { int n5; int n6 = integerArray2[i]; if (!WelshPowell.a(nArray2[n6])) continue; int[] nArray3 = nArray2; int n7 = n6; Object object = welshPowell$Graph; boolean[] blArray = new boolean[((WelshPowell$Graph)object).a()]; ((WelshPowell$Graph)object).a(n7).stream().map(n -> nArray3[n]).filter(n -> !WelshPowell.a((int)n)).forEach(n -> { blArray[n.intValue()] = true; }); object = blArray; object = blArray; nArray2[n6] = n5 = IntStream.range(0, ((Object)object).length).filter(arg_0 -> WelshPowell.a((boolean[])object, arg_0)).findFirst().getAsInt(); Arrays.stream(integerArray).forEach(n3 -> { if (WelshPowell.a(nArray2[n3])) { int[] nArray2 = nArray2; int n4 = n3; if (!welshPowell$Graph.a(n4).stream().anyMatch(n -> !WelshPowell.a(nArray2[n]))) { nArray[n3.intValue()] = n5; } } }); } return nArray2; } private static boolean a(int n) { return n == -1; } private static /* synthetic */ boolean a(boolean[] blArray, int n) { return !blArray[n]; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.graphs; import java.util.Arrays; import java.util.Comparator; import java.util.HashSet; import java.util.stream.IntStream; /** * The Welsh-Powell algorithm is a graph coloring algorithm that aims to color a graph * using the minimum number of colors such that no two adjacent vertices share the same color. * * <p> * The algorithm works by: * <ol> * <li>Sorting the vertices in descending order based on their degrees (number of edges connected).</li> * <li>Iterating through each vertex and assigning it the smallest available color that has not been used by its adjacent vertices.</li> * <li>Coloring adjacent vertices with the same color is avoided.</li> * </ol> * </p> * * <p> * For more information, see <a href=\"https://en.wikipedia.org/wiki/Graph_coloring\">Graph Coloring</a>. * </p> */ @SuppressWarnings({\"rawtypes\", \"unchecked\"}) public final class WelshPowell { private static final int BLANK_COLOR = -1; // Constant representing an uncolored state private WelshPowell() { } /** * Represents a graph using an adjacency list. */ static final class Graph { private final HashSet<Integer>[] adjacencyLists; /** * Initializes a graph with a specified number of vertices. * * @param vertices the number of vertices in the graph * @throws IllegalArgumentException if the number of vertices is negative */ private Graph(int vertices) { if (vertices < 0) { throw new IllegalArgumentException(\"Number of vertices cannot be negative\"); } adjacencyLists = new HashSet[vertices]; Arrays.setAll(adjacencyLists, i -> new HashSet<>()); } /** * Adds an edge between two vertices in the graph. * * @param nodeA one end of the edge * @param nodeB the other end of the edge * @throws IllegalArgumentException if the vertices are out of bounds or if a self-loop is attempted */ private void addEdge(int nodeA, int nodeB) { validateVertex(nodeA); validateVertex(nodeB); if (nodeA == nodeB) { throw new IllegalArgumentException(\"Self-loops are not allowed\"); } adjacencyLists[nodeA].add(nodeB); adjacencyLists[nodeB].add(nodeA); } /** * Validates that the vertex index is within the bounds of the graph. * * @param vertex the index of the vertex to validate * @throws IllegalArgumentException if the vertex is out of bounds */ private void validateVertex(int vertex) { if (vertex < 0 || vertex >= getNumVertices()) { throw new IllegalArgumentException(\"Vertex \" + vertex + \" is out of bounds\"); } } /** * Returns the adjacency list for a specific vertex. * * @param vertex the index of the vertex * @return the set of adjacent vertices */ HashSet<Integer> getAdjacencyList(int vertex) { return adjacencyLists[vertex]; } /** * Returns the number of vertices in the graph. * * @return the number of vertices */ int getNumVertices() { return adjacencyLists.length; } } /** * Creates a graph with the specified number of vertices and edges. * * @param numberOfVertices the total number of vertices * @param listOfEdges a 2D array representing edges where each inner array contains two vertex indices * @return a Graph object representing the created graph * @throws IllegalArgumentException if the edge array is invalid or vertices are out of bounds */ public static Graph makeGraph(int numberOfVertices, int[][] listOfEdges) { Graph graph = new Graph(numberOfVertices); for (int[] edge : listOfEdges) { if (edge.length != 2) { throw new IllegalArgumentException(\"Edge array must have exactly two elements\"); } graph.addEdge(edge[0], edge[1]); } return graph; } /** * Finds the coloring of the given graph using the Welsh-Powell algorithm. * * @param graph the input graph to color * @return an array of integers where each index represents a vertex and the value represents the color assigned */ public static int[] findColoring(Graph graph) { int[] colors = initializeColors(graph.getNumVertices()); Integer[] sortedVertices = getSortedNodes(graph); for (int vertex : sortedVertices) { if (isBlank(colors[vertex])) { boolean[] usedColors = computeUsedColors(graph, vertex, colors); final var newColor = firstUnusedColor(usedColors); colors[vertex] = newColor; Arrays.stream(sortedVertices).forEach(otherVertex -> { if (isBlank(colors[otherVertex]) && !isAdjacentToColored(graph, otherVertex, colors)) { colors[otherVertex] = newColor; } }); } } return colors; } /** * Helper method to check if a color is unassigned * * @param color the color to check * @return {@code true} if the color is unassigned, {@code false} otherwise */ private static boolean isBlank(int color) { return color == BLANK_COLOR; } /** * Checks if a vertex has adjacent colored vertices * * @param graph the input graph * @param vertex the vertex to check * @param colors the array of colors assigned to the vertices * @return {@code true} if the vertex has adjacent colored vertices, {@code false} otherwise */ private static boolean isAdjacentToColored(Graph graph, int vertex, int[] colors) { return graph.getAdjacencyList(vertex).stream().anyMatch(otherVertex -> !isBlank(colors[otherVertex])); } /** * Initializes the colors array with blank color * * @param numberOfVertices the number of vertices in the graph * @return an array of integers representing the colors assigned to the vertices */ private static int[] initializeColors(int numberOfVertices) { int[] colors = new int[numberOfVertices]; Arrays.fill(colors, BLANK_COLOR); return colors; } /** * Sorts the vertices by their degree in descending order * * @param graph the input graph * @return an array of integers representing the vertices sorted by degree */ private static Integer[] getSortedNodes(final Graph graph) { return IntStream.range(0, graph.getNumVertices()).boxed().sorted(Comparator.comparingInt(v -> - graph.getAdjacencyList(v).size())).toArray(Integer[] ::new); } /** * Computes the colors already used by the adjacent vertices * * @param graph the input graph * @param vertex the vertex to check * @param colors the array of colors assigned to the vertices * @return an array of booleans representing the colors used by the adjacent vertices */ private static boolean[] computeUsedColors(final Graph graph, final int vertex, final int[] colors) { boolean[] usedColors = new boolean[graph.getNumVertices()]; graph.getAdjacencyList(vertex).stream().map(neighbor -> colors[neighbor]).filter(color -> !isBlank(color)).forEach(color -> usedColors[color] = true); return usedColors; } /** * Finds the first unused color * * @param usedColors the array of colors used by the adjacent vertices * @return the first unused color */ private static int firstUnusedColor(boolean[] usedColors) { return IntStream.range(0, usedColors.length).filter(color -> !usedColors[color]).findFirst().getAsInt(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.sorts; import com.thealgorithms.maths.Ceil; import com.thealgorithms.maths.Floor; import com.thealgorithms.searches.QuickSelect; import com.thealgorithms.sorts.SortAlgorithm; import com.thealgorithms.sorts.SortUtils; import java.util.Arrays; public class WiggleSort implements SortAlgorithm { @Override public Comparable[] sort(Comparable[] object) { int n; Object[] objectArray = object; object = this; Object[] objectArray2 = QuickSelect.select(Arrays.asList(objectArray), (int)Floor.floor((double)objectArray.length / 2.0)); int n2 = 0; Object object2 = objectArray; int n3 = objectArray.length; for (n = 0; n < n3; ++n) { Comparable comparable = object2[n]; if (0 != comparable.compareTo(objectArray2)) continue; ++n2; } if (objectArray.length % 2 == 1 && (double)n2 == Ceil.ceil((double)objectArray.length / 2.0) && 0 != (object2 = QuickSelect.select(Arrays.asList(objectArray), 0)).compareTo(objectArray2)) { throw new IllegalArgumentException(\"For odd Arrays if the median appears ceil(n/2) times, the median has to be the smallest values in the array.\"); } if ((double)n2 > Ceil.ceil((double)objectArray.length / 2.0)) { throw new IllegalArgumentException(\"No more than half the number of values may be the same.\"); } Object[] objectArray3 = objectArray2; objectArray2 = objectArray; int n4 = objectArray2.length; int n5 = 0; n3 = 0; n = n4 - 1; while (n3 <= n) { if (0 < objectArray2[WiggleSort.a(n3, n4)].compareTo(objectArray3)) { SortUtils.swap(objectArray2, WiggleSort.a(n3, n4), WiggleSort.a(n5, n4)); ++n5; ++n3; continue; } if (0 > objectArray2[WiggleSort.a(n3, n4)].compareTo(objectArray3)) { SortUtils.swap(objectArray2, WiggleSort.a(n3, n4), WiggleSort.a(n, n4)); --n; continue; } ++n3; } return objectArray; } private static int a(int n, int n2) { return (2 * n + 1) % (n2 | 1); } }", "deobfuscated_code": "package com.thealgorithms.sorts; import static com.thealgorithms.maths.Ceil.ceil; import static com.thealgorithms.maths.Floor.floor; import static com.thealgorithms.searches.QuickSelect.select; import java.util.Arrays; /** * A wiggle sort implementation based on John L.s' answer in * https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity * Also have a look at: * https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity?noredirect=1&lq=1 * Not all arrays are wiggle-sortable. This algorithm will find some obviously not wiggle-sortable * arrays and throw an error, but there are some exceptions that won't be caught, for example [1, 2, * 2]. */ public class WiggleSort implements SortAlgorithm { @Override public <T extends Comparable<T>> T[] sort(T[] unsorted) { return wiggleSort(unsorted); } private int mapIndex(int index, int n) { return ((2 * index + 1) % (n | 1)); } /** * Modified Dutch National Flag Sort. See also: sorts/DutchNationalFlagSort * * @param sortThis array to sort into group \"greater\", \"equal\" and \"smaller\" than median * @param median defines the groups * @param <T> extends interface Comparable */ private <T extends Comparable<T>> void triColorSort(T[] sortThis, T median) { int n = sortThis.length; int i = 0; int j = 0; int k = n - 1; while (j <= k) { if (0 < sortThis[mapIndex(j, n)].compareTo(median)) { SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(i, n)); i++; j++; } else if (0 > sortThis[mapIndex(j, n)].compareTo(median)) { SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(k, n)); k--; } else { j++; } } } private <T extends Comparable<T>> T[] wiggleSort(T[] sortThis) { // find the median using quickSelect (if the result isn't in the array, use the next greater // value) T median; median = select(Arrays.asList(sortThis), (int) floor(sortThis.length / 2.0)); int numMedians = 0; for (T sortThi : sortThis) { if (0 == sortThi.compareTo(median)) { numMedians++; } } // added condition preventing off-by-one errors for odd arrays. // https://cs.stackexchange.com/questions/150886/how-to-find-wiggle-sortable-arrays-did-i-misunderstand-john-l-s-answer?noredirect=1&lq=1 if (sortThis.length % 2 == 1 && numMedians == ceil(sortThis.length / 2.0)) { T smallestValue = select(Arrays.asList(sortThis), 0); if (!(0 == smallestValue.compareTo(median))) { throw new IllegalArgumentException(\"For odd Arrays if the median appears ceil(n/2) times, \" + \"the median has to be the smallest values in the array.\"); } } if (numMedians > ceil(sortThis.length / 2.0)) { throw new IllegalArgumentException(\"No more than half the number of values may be the same.\"); } triColorSort(sortThis, median); return sortThis; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class WildcardMatching { private WildcardMatching() { } public static boolean isMatch(String string, String string2) { int n; int n2 = string.length(); int n3 = string2.length(); boolean[][] blArray = new boolean[n2 + 1][n3 + 1]; blArray[0][0] = true; for (n = 1; n <= n3; ++n) { if (string2.charAt(n - 1) != '*') continue; blArray[0][n] = blArray[0][n - 1]; } for (n = 1; n <= n2; ++n) { for (int i = 1; i <= n3; ++i) { char c = string.charAt(n - 1); char c2 = string2.charAt(i - 1); blArray[n][i] = c2 == c || c2 == '?' ? blArray[n - 1][i - 1] : (c2 == '*' ? blArray[n - 1][i] || blArray[n][i - 1] : false); } } return blArray[n2][n3]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * * Author: Janmesh Singh * Github: https://github.com/janmeshjs * Problem Statement: To determine if the pattern matches the text. * The pattern can include two special wildcard characters: * ' ? ': Matches any single character. * ' * ': Matches zero or more of any character sequence. * * Use DP to return True if the pattern matches the entire text and False otherwise * */ public final class WildcardMatching { private WildcardMatching() { } public static boolean isMatch(String text, String pattern) { int m = text.length(); int n = pattern.length(); // Create a DP table to store intermediate results boolean[][] dp = new boolean[m + 1][n + 1]; // Base case: an empty pattern matches an empty text dp[0][0] = true; // Handle patterns starting with '*' for (int j = 1; j <= n; j++) { if (pattern.charAt(j - 1) == '*') { dp[0][j] = dp[0][j - 1]; } } // Fill the DP table for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { char textChar = text.charAt(i - 1); char patternChar = pattern.charAt(j - 1); if (patternChar == textChar || patternChar == '?') { dp[i][j] = dp[i - 1][j - 1]; } else if (patternChar == '*') { // '*' can match zero or more characters dp[i][j] = dp[i - 1][j] || dp[i][j - 1]; } else { dp[i][j] = false; } } } // The result is in the bottom-right cell of the DP table return dp[m][n]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.dynamicprogramming; public final class WineProblem { private WineProblem() { } public static int wpRecursion(int[] nArray, int n, int n2) { int n3 = nArray.length; n3 = n3 - (n2 - n + 1) + 1; if (n == n2) { return nArray[n] * n3; } int n4 = WineProblem.wpRecursion(nArray, n + 1, n2) + nArray[n] * n3; int n5 = WineProblem.wpRecursion(nArray, n, n2 - 1) + nArray[n2] * n3; return Math.max(n4, n5); } public static int wptd(int[] nArray, int n, int n2, int[][] nArray2) { int n3 = nArray.length; n3 = n3 - (n2 - n + 1) + 1; if (n == n2) { return nArray[n] * n3; } if (nArray2[n][n2] != 0) { return nArray2[n][n2]; } int n4 = WineProblem.wptd(nArray, n + 1, n2, nArray2) + nArray[n] * n3; int n5 = WineProblem.wptd(nArray, n, n2 - 1, nArray2) + nArray[n2] * n3; nArray2[n][n2] = n5 = Math.max(n4, n5); return n5; } public static int wpbu(int[] nArray) { if (nArray == null || nArray.length == 0) { throw new IllegalArgumentException(\"Input array cannot be null or empty.\"); } int n = nArray.length; int[][] nArray2 = new int[n][n]; for (int i = 0; i <= n - 1; ++i) { for (int j = 0; j <= n - i - 1; ++j) { int n2 = j + i; int n3 = n - (n2 - j + 1) + 1; if (j == n2) { nArray2[j][n2] = nArray[j] * n3; continue; } int n4 = nArray2[j + 1][n2] + nArray[j] * n3; n3 = nArray2[j][n2 - 1] + nArray[n2] * n3; nArray2[j][n2] = Math.max(n4, n3); } } return nArray2[0][n - 1]; } }", "deobfuscated_code": "package com.thealgorithms.dynamicprogramming; /** * The WineProblem class provides a solution to the wine selling problem. * Given a collection of N wines with different prices, the objective is to maximize profit by selling * one wine each year, considering the constraint that only the leftmost or rightmost wine can be sold * at any given time. * * The price of the ith wine is pi, and the selling price increases by a factor of the year in which * it is sold. This class implements three approaches to solve the problem: * * 1. **Recursion**: A straightforward recursive method that computes the maximum profit. * - Time Complexity: O(2^N) * - Space Complexity: O(N) due to recursive calls. * * 2. **Top-Down Dynamic Programming (Memoization)**: This approach caches the results of subproblems * to avoid redundant computations. * - Time Complexity: O(N^2) * - Space Complexity: O(N^2) for the storage of results and O(N) for recursion stack. * * 3. **Bottom-Up Dynamic Programming (Tabulation)**: This method builds a table iteratively to * compute the maximum profit for all possible subproblems. * - Time Complexity: O(N^2) * - Space Complexity: O(N^2) for the table. */ public final class WineProblem { private WineProblem() { } /** * Calculate maximum profit using recursion. * * @param arr Array of wine prices. * @param si Start index of the wine to consider. * @param ei End index of the wine to consider. * @return Maximum profit obtainable by selling the wines. */ public static int wpRecursion(int[] arr, int si, int ei) { int n = arr.length; int year = (n - (ei - si + 1)) + 1; if (si == ei) { return arr[si] * year; } int start = wpRecursion(arr, si + 1, ei) + arr[si] * year; int end = wpRecursion(arr, si, ei - 1) + arr[ei] * year; return Math.max(start, end); } /** * Calculate maximum profit using top-down dynamic programming with memoization. * * @param arr Array of wine prices. * @param si Start index of the wine to consider. * @param ei End index of the wine to consider. * @param strg 2D array to store results of subproblems. * @return Maximum profit obtainable by selling the wines. */ public static int wptd(int[] arr, int si, int ei, int[][] strg) { int n = arr.length; int year = (n - (ei - si + 1)) + 1; if (si == ei) { return arr[si] * year; } if (strg[si][ei] != 0) { return strg[si][ei]; } int start = wptd(arr, si + 1, ei, strg) + arr[si] * year; int end = wptd(arr, si, ei - 1, strg) + arr[ei] * year; int ans = Math.max(start, end); strg[si][ei] = ans; return ans; } /** * Calculate maximum profit using bottom-up dynamic programming with tabulation. * * @param arr Array of wine prices. * @throws IllegalArgumentException if the input array is null or empty. * @return Maximum profit obtainable by selling the wines. */ public static int wpbu(int[] arr) { if (arr == null || arr.length == 0) { throw new IllegalArgumentException(\"Input array cannot be null or empty.\"); } int n = arr.length; int[][] strg = new int[n][n]; for (int slide = 0; slide <= n - 1; slide++) { for (int si = 0; si <= n - slide - 1; si++) { int ei = si + slide; int year = (n - (ei - si + 1)) + 1; if (si == ei) { strg[si][ei] = arr[si] * year; } else { int start = strg[si + 1][ei] + arr[si] * year; int end = strg[si][ei - 1] + arr[ei] * year; strg[si][ei] = Math.max(start, end); } } } return strg[0][n - 1]; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.puzzlesandgames; import com.thealgorithms.puzzlesandgames.Trie; import com.thealgorithms.puzzlesandgames.TrieNode; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; public final class WordBoggle { private WordBoggle() { } public static List boggleBoard(char[][] cArray, String[] object) { int n; Trie trie = new Trie(); Object object2 = object; int n2 = ((Object)object2).length; for (n = 0; n < n2; ++n) { Object object3 = object2[n]; trie.add((String)object3); } HashSet hashSet = new HashSet(); boolean[][] blArray = new boolean[cArray.length][cArray.length]; for (n = 0; n < cArray.length; ++n) { for (int i = 0; i < cArray[n].length; ++i) { WordBoggle.explore(n, i, cArray, trie.a, blArray, hashSet); } } return new ArrayList(hashSet); } public static void explore(int n, int n2, char[][] cArray, TrieNode trieNode, boolean[][] blArray, Set set) { if (blArray[n][n2]) { return; } char c = cArray[n][n2]; if (!trieNode.a.containsKey(Character.valueOf(c))) { return; } blArray[n][n2] = true; trieNode = (TrieNode)trieNode.a.get(Character.valueOf(c)); if (trieNode.a.containsKey(Character.valueOf('*'))) { set.add(trieNode.b); } Object object = WordBoggle.getNeighbors(n, n2, cArray); object = object.iterator(); while (object.hasNext()) { Integer[] integerArray = (Integer[])object.next(); WordBoggle.explore(integerArray[0], integerArray[1], cArray, trieNode, blArray, set); } blArray[n][n2] = false; } public static List getNeighbors(int n, int n2, char[][] cArray) { ArrayList<Integer[]> arrayList = new ArrayList<Integer[]>(); if (n > 0 && n2 > 0) { arrayList.add(new Integer[]{n - 1, n2 - 1}); } if (n > 0 && n2 < cArray[0].length - 1) { arrayList.add(new Integer[]{n - 1, n2 + 1}); } if (n < cArray.length - 1 && n2 < cArray[0].length - 1) { arrayList.add(new Integer[]{n + 1, n2 + 1}); } if (n < cArray.length - 1 && n2 > 0) { arrayList.add(new Integer[]{n + 1, n2 - 1}); } if (n > 0) { arrayList.add(new Integer[]{n - 1, n2}); } if (n < cArray.length - 1) { arrayList.add(new Integer[]{n + 1, n2}); } if (n2 > 0) { arrayList.add(new Integer[]{n, n2 - 1}); } if (n2 < cArray[0].length - 1) { arrayList.add(new Integer[]{n, n2 + 1}); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.puzzlesandgames; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public final class WordBoggle { private WordBoggle() { } /** * O(nm * 8^s + ws) time where n = width of boggle board, m = height of * boggle board, s = length of longest word in string array, w = length of * string array, 8 is due to 8 explorable neighbours O(nm + ws) space. */ public static List<String> boggleBoard(char[][] board, String[] words) { Trie trie = new Trie(); for (String word : words) { trie.add(word); } Set<String> finalWords = new HashSet<>(); boolean[][] visited = new boolean[board.length][board.length]; for (int i = 0; i < board.length; i++) { for (int j = 0; j < board[i].length; j++) { explore(i, j, board, trie.root, visited, finalWords); } } return new ArrayList<>(finalWords); } public static void explore(int i, int j, char[][] board, TrieNode trieNode, boolean[][] visited, Set<String> finalWords) { if (visited[i][j]) { return; } char letter = board[i][j]; if (!trieNode.children.containsKey(letter)) { return; } visited[i][j] = true; trieNode = trieNode.children.get(letter); if (trieNode.children.containsKey('*')) { finalWords.add(trieNode.word); } List<Integer[]> neighbors = getNeighbors(i, j, board); for (Integer[] neighbor : neighbors) { explore(neighbor[0], neighbor[1], board, trieNode, visited, finalWords); } visited[i][j] = false; } public static List<Integer[]> getNeighbors(int i, int j, char[][] board) { List<Integer[]> neighbors = new ArrayList<>(); if (i > 0 && j > 0) { neighbors.add(new Integer[] {i - 1, j - 1}); } if (i > 0 && j < board[0].length - 1) { neighbors.add(new Integer[] {i - 1, j + 1}); } if (i < board.length - 1 && j < board[0].length - 1) { neighbors.add(new Integer[] {i + 1, j + 1}); } if (i < board.length - 1 && j > 0) { neighbors.add(new Integer[] {i + 1, j - 1}); } if (i > 0) { neighbors.add(new Integer[] {i - 1, j}); } if (i < board.length - 1) { neighbors.add(new Integer[] {i + 1, j}); } if (j > 0) { neighbors.add(new Integer[] {i, j - 1}); } if (j < board[0].length - 1) { neighbors.add(new Integer[] {i, j + 1}); } return neighbors; } } // Trie used to optimize string search class TrieNode { Map<Character, TrieNode> children = new HashMap<>(); String word = \"\"; } class Trie { TrieNode root; char endSymbol; Trie() { this.root = new TrieNode(); this.endSymbol = '*'; } public void add(String str) { TrieNode node = this.root; for (int i = 0; i < str.length(); i++) { char letter = str.charAt(i); if (!node.children.containsKey(letter)) { TrieNode newNode = new TrieNode(); node.children.put(letter, newNode); } node = node.children.get(letter); } node.children.put(this.endSymbol, null); node.word = str; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings; import java.util.Collection; import java.util.HashSet; import java.util.LinkedList; public final class WordLadder { private WordLadder() { } public static int ladderLength(String string, String string2, Collection hashSet) { if (!(hashSet = new HashSet(hashSet)).contains(string2)) { return 0; } LinkedList<String> linkedList = new LinkedList<String>(); linkedList.offer(string); int n = 1; while (!linkedList.isEmpty()) { int n2 = linkedList.size(); for (int i = 0; i < n2; ++i) { Object object = (String)linkedList.poll(); object = ((String)object).toCharArray(); for (int j = 0; j < ((Object)object).length; ++j) { Object object2 = object[j]; for (int n3 = 97; n3 <= 122; n3 = (int)((char)(n3 + 1))) { if (object[j] == n3) continue; object[j] = n3; String string3 = new String((char[])object); if (string3.equals(string2)) { return n + 1; } if (!hashSet.remove(string3)) continue; linkedList.offer(string3); } object[j] = object2; } } ++n; } return 0; } }", "deobfuscated_code": "package com.thealgorithms.strings; import java.util.Collection; import java.util.HashSet; import java.util.LinkedList; import java.util.Queue; import java.util.Set; /** * Class to find the shortest transformation sequence from a beginWord to an endWord using a dictionary of words. * A transformation sequence is a sequence of words where each adjacent pair differs by exactly one letter. */ public final class WordLadder { private WordLadder() { } /** * Finds the shortest transformation sequence from beginWord to endWord. * * @param beginWord the starting word of the transformation sequence * @param endWord the target word of the transformation sequence * @param wordList a list of words that can be used in the transformation sequence * @return the number of words in the shortest transformation sequence, or 0 if no such sequence exists */ public static int ladderLength(String beginWord, String endWord, Collection<String> wordList) { Set<String> wordSet = new HashSet<>(wordList); if (!wordSet.contains(endWord)) { return 0; } Queue<String> queue = new LinkedList<>(); queue.offer(beginWord); int level = 1; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { String currentWord = queue.poll(); char[] currentWordChars = currentWord.toCharArray(); for (int j = 0; j < currentWordChars.length; j++) { char originalChar = currentWordChars[j]; for (char c = 'a'; c <= 'z'; c++) { if (currentWordChars[j] == c) { continue; } currentWordChars[j] = c; String newWord = new String(currentWordChars); if (newWord.equals(endWord)) { return level + 1; } if (wordSet.remove(newWord)) { queue.offer(newWord); } } currentWordChars[j] = originalChar; } } level++; } return 0; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; import java.util.HashMap; import java.util.Map; public final class WordPatternMatcher { private WordPatternMatcher() { } public static boolean matchWordPattern(String string, String string2) { HashMap hashMap = new HashMap(); HashMap hashMap2 = new HashMap(); return WordPatternMatcher.a(string, string2, 0, 0, hashMap, hashMap2); } private static boolean a(String string, String string2, int n, int n2, Map map, Map map2) { char c; block5: { while (true) { if (n == string.length() && n2 == string2.length()) { return true; } if (n == string.length() || n2 == string2.length()) { return false; } c = string.charAt(n); if (!map.containsKey(Character.valueOf(c))) break block5; String string3 = (String)map.get(Character.valueOf(c)); if (!string2.startsWith(string3, n2)) break; n2 += string3.length(); ++n; } return false; } for (int i = n2 + 1; i <= string2.length(); ++i) { String string4 = string2.substring(n2, i); if (map2.containsKey(string4)) continue; map.put(Character.valueOf(c), string4); map2.put(string4, Character.valueOf(c)); if (WordPatternMatcher.a(string, string2, n + 1, i, map, map2)) { return true; } map.remove(Character.valueOf(c)); map2.remove(string4); } return false; } }", "deobfuscated_code": "package com.thealgorithms.backtracking; import java.util.HashMap; import java.util.Map; /** * Class to determine if a pattern matches a string using backtracking. * * Example: * Pattern: \"abab\" * Input String: \"JavaPythonJavaPython\" * Output: true * * Pattern: \"aaaa\" * Input String: \"JavaJavaJavaJava\" * Output: true * * Pattern: \"aabb\" * Input String: \"JavaPythonPythonJava\" * Output: false */ public final class WordPatternMatcher { private WordPatternMatcher() { } /** * Determines if the given pattern matches the input string using backtracking. * * @param pattern The pattern to match. * @param inputString The string to match against the pattern. * @return True if the pattern matches the string, False otherwise. */ public static boolean matchWordPattern(String pattern, String inputString) { Map<Character, String> patternMap = new HashMap<>(); Map<String, Character> strMap = new HashMap<>(); return backtrack(pattern, inputString, 0, 0, patternMap, strMap); } /** * Backtracking helper function to check if the pattern matches the string. * * @param pattern The pattern string. * @param inputString The string to match against the pattern. * @param patternIndex Current index in the pattern. * @param strIndex Current index in the input string. * @param patternMap Map to store pattern characters to string mappings. * @param strMap Map to store string to pattern character mappings. * @return True if the pattern matches, False otherwise. */ private static boolean backtrack(String pattern, String inputString, int patternIndex, int strIndex, Map<Character, String> patternMap, Map<String, Character> strMap) { if (patternIndex == pattern.length() && strIndex == inputString.length()) { return true; } if (patternIndex == pattern.length() || strIndex == inputString.length()) { return false; } char currentChar = pattern.charAt(patternIndex); if (patternMap.containsKey(currentChar)) { String mappedStr = patternMap.get(currentChar); if (inputString.startsWith(mappedStr, strIndex)) { return backtrack(pattern, inputString, patternIndex + 1, strIndex + mappedStr.length(), patternMap, strMap); } else { return false; } } for (int end = strIndex + 1; end <= inputString.length(); end++) { String substring = inputString.substring(strIndex, end); if (strMap.containsKey(substring)) { continue; } patternMap.put(currentChar, substring); strMap.put(substring, currentChar); if (backtrack(pattern, inputString, patternIndex + 1, end, patternMap, strMap)) { return true; } patternMap.remove(currentChar); strMap.remove(substring); } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.backtracking; public class WordSearch { private final int[] a = new int[]{0, 0, 1, -1}; private final int[] b = new int[]{1, -1, 0, 0}; private boolean[][] c; private char[][] d; private String e; private boolean a(int n, int n2, int n3) { this.c[n][n2] = true; if (n3 == this.e.length()) { return true; } for (int i = 0; i < 4; ++i) { int n4; int n5 = n + this.a[i]; int n6 = n4 = n2 + this.b[i]; int n7 = n5; WordSearch wordSearch = this; if (!(n7 >= 0 && n7 < wordSearch.d.length && n6 >= 0 && n6 < wordSearch.d[0].length) || this.d[n5][n4] != this.e.charAt(n3) || this.c[n5][n4]) continue; boolean bl = this.a(n5, n4, n3 + 1); n5 = bl ? 1 : 0; if (!bl) continue; return true; } this.c[n][n2] = false; return false; } public boolean exist(char[][] cArray, String string) { this.d = cArray; this.e = string; for (int i = 0; i < cArray.length; ++i) { for (int j = 0; j < cArray[0].length; ++j) { if (cArray[i][j] != string.charAt(0)) continue; this.c = new boolean[cArray.length][cArray[0].length]; boolean bl = this.a(i, j, 1); if (!bl) continue; return true; } } return false; } }", "deobfuscated_code": "package com.thealgorithms.backtracking; /** * Word Search Problem * * This class solves the word search problem where given an m x n grid of characters (board) * and a target word, the task is to check if the word exists in the grid. * The word can be constructed from sequentially adjacent cells (horizontally or vertically), * and the same cell may not be used more than once in constructing the word. * * Example: * - For board = * [ * ['A','B','C','E'], * ['S','F','C','S'], * ['A','D','E','E'] * ] * and word = \"ABCCED\", -> returns true * and word = \"SEE\", -> returns true * and word = \"ABCB\", -> returns false * * Solution: * - Depth First Search (DFS) with backtracking is used to explore possible paths from any cell * matching the first letter of the word. DFS ensures that we search all valid paths, while * backtracking helps in reverting decisions when a path fails to lead to a solution. * * Time Complexity: O(m * n * 3^L) * - m = number of rows in the board * - n = number of columns in the board * - L = length of the word * - For each cell, we look at 3 possible directions (since we exclude the previously visited direction), * and we do this for L letters. * * Space Complexity: O(L) * - Stack space for the recursive DFS function, where L is the maximum depth of recursion (length of the word). */ public class WordSearch { private final int[] dx = {0, 0, 1, -1}; private final int[] dy = {1, -1, 0, 0}; private boolean[][] visited; private char[][] board; private String word; /** * Checks if the given (x, y) coordinates are valid positions in the board. * * @param x The row index. * @param y The column index. * @return True if the coordinates are within the bounds of the board; false otherwise. */ private boolean isValid(int x, int y) { return x >= 0 && x < board.length && y >= 0 && y < board[0].length; } /** * Performs Depth First Search (DFS) from the cell (x, y) * to search for the next character in the word. * * @param x The current row index. * @param y The current column index. * @param nextIdx The index of the next character in the word to be matched. * @return True if a valid path is found to match the remaining characters of the word; false otherwise. */ private boolean doDFS(int x, int y, int nextIdx) { visited[x][y] = true; if (nextIdx == word.length()) { return true; } for (int i = 0; i < 4; ++i) { int xi = x + dx[i]; int yi = y + dy[i]; if (isValid(xi, yi) && board[xi][yi] == word.charAt(nextIdx) && !visited[xi][yi]) { boolean exists = doDFS(xi, yi, nextIdx + 1); if (exists) { return true; } } } visited[x][y] = false; // Backtrack return false; } /** * Main function to check if the word exists in the board. It initiates DFS from any * cell that matches the first character of the word. * * @param board The 2D grid of characters (the board). * @param word The target word to search for in the board. * @return True if the word exists in the board; false otherwise. */ public boolean exist(char[][] board, String word) { this.board = board; this.word = word; for (int i = 0; i < board.length; ++i) { for (int j = 0; j < board[0].length; ++j) { if (board[i][j] == word.charAt(0)) { visited = new boolean[board.length][board[0].length]; boolean exists = doDFS(i, j, 1); if (exists) { return true; } } } } return false; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; enum WordsToNumber$NumberWord { ZERO(\"zero\", 0), ONE(\"one\", 1), TWO(\"two\", 2), THREE(\"three\", 3), FOUR(\"four\", 4), FIVE(\"five\", 5), SIX(\"six\", 6), SEVEN(\"seven\", 7), EIGHT(\"eight\", 8), NINE(\"nine\", 9), TEN(\"ten\", 10), ELEVEN(\"eleven\", 11), TWELVE(\"twelve\", 12), THIRTEEN(\"thirteen\", 13), FOURTEEN(\"fourteen\", 14), FIFTEEN(\"fifteen\", 15), SIXTEEN(\"sixteen\", 16), SEVENTEEN(\"seventeen\", 17), EIGHTEEN(\"eighteen\", 18), NINETEEN(\"nineteen\", 19), TWENTY(\"twenty\", 20), THIRTY(\"thirty\", 30), FORTY(\"forty\", 40), FIFTY(\"fifty\", 50), SIXTY(\"sixty\", 60), SEVENTY(\"seventy\", 70), EIGHTY(\"eighty\", 80), NINETY(\"ninety\", 90); private final String a; private final int b; /* * WARNING - void declaration */ private WordsToNumber$NumberWord() { void var4_1; void var3_2; this.a = var3_2; this.b = var4_1; } public static Integer getValue(String string) { for (WordsToNumber$NumberWord wordsToNumber$NumberWord : WordsToNumber$NumberWord.values()) { if (!string.equals(wordsToNumber$NumberWord.a)) continue; return wordsToNumber$NumberWord.b; } return null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; enum WordsToNumber$NumberWord { ZERO(\"zero\", 0), ONE(\"one\", 1), TWO(\"two\", 2), THREE(\"three\", 3), FOUR(\"four\", 4), FIVE(\"five\", 5), SIX(\"six\", 6), SEVEN(\"seven\", 7), EIGHT(\"eight\", 8), NINE(\"nine\", 9), TEN(\"ten\", 10), ELEVEN(\"eleven\", 11), TWELVE(\"twelve\", 12), THIRTEEN(\"thirteen\", 13), FOURTEEN(\"fourteen\", 14), FIFTEEN(\"fifteen\", 15), SIXTEEN(\"sixteen\", 16), SEVENTEEN(\"seventeen\", 17), EIGHTEEN(\"eighteen\", 18), NINETEEN(\"nineteen\", 19), TWENTY(\"twenty\", 20), THIRTY(\"thirty\", 30), FORTY(\"forty\", 40), FIFTY(\"fifty\", 50), SIXTY(\"sixty\", 60), SEVENTY(\"seventy\", 70), EIGHTY(\"eighty\", 80), NINETY(\"ninety\", 90); private final String a; private final int b; /* * WARNING - void declaration */ private WordsToNumber$NumberWord() { void var4_1; void var3_2; this.a = var3_2; this.b = var4_1; } public static Integer getValue(String string) { for (WordsToNumber$NumberWord wordsToNumber$NumberWord : WordsToNumber$NumberWord.values()) { if (!string.equals(wordsToNumber$NumberWord.a)) continue; return wordsToNumber$NumberWord.b; } return null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.math.BigDecimal; enum WordsToNumber$PowerOfTen { THOUSAND(\"thousand\", new BigDecimal(\"1000\")), MILLION(\"million\", new BigDecimal(\"1000000\")), BILLION(\"billion\", new BigDecimal(\"1000000000\")), TRILLION(\"trillion\", new BigDecimal(\"1000000000000\")); private final String a; private final BigDecimal b; /* * WARNING - void declaration */ private WordsToNumber$PowerOfTen() { void var4_1; void var3_2; this.a = var3_2; this.b = var4_1; } public static BigDecimal getValue(String string) { for (WordsToNumber$PowerOfTen wordsToNumber$PowerOfTen : WordsToNumber$PowerOfTen.values()) { if (!string.equals(wordsToNumber$PowerOfTen.a)) continue; return wordsToNumber$PowerOfTen.b; } return null; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import java.math.BigDecimal; enum WordsToNumber$PowerOfTen { THOUSAND(\"thousand\", new BigDecimal(\"1000\")), MILLION(\"million\", new BigDecimal(\"1000000\")), BILLION(\"billion\", new BigDecimal(\"1000000000\")), TRILLION(\"trillion\", new BigDecimal(\"1000000000000\")); private final String a; private final BigDecimal b; /* * WARNING - void declaration */ private WordsToNumber$PowerOfTen() { void var4_1; void var3_2; this.a = var3_2; this.b = var4_1; } public static BigDecimal getValue(String string) { for (WordsToNumber$PowerOfTen wordsToNumber$PowerOfTen : WordsToNumber$PowerOfTen.values()) { if (!string.equals(wordsToNumber$PowerOfTen.a)) continue; return wordsToNumber$PowerOfTen.b; } return null; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import com.thealgorithms.conversions.WordsToNumber$NumberWord; import com.thealgorithms.conversions.WordsToNumber$PowerOfTen; import com.thealgorithms.conversions.WordsToNumberException; import com.thealgorithms.conversions.WordsToNumberException$ErrorType; import java.io.Serializable; import java.math.BigDecimal; import java.util.AbstractCollection; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Iterator; public final class WordsToNumber { private WordsToNumber() { } public static String convert(String arrayDeque) { int n; if (arrayDeque == null) { throw new WordsToNumberException(WordsToNumberException$ErrorType.NULL_INPUT, \"\"); } Object object = ((String)((Object)arrayDeque)).trim().split(\"[ ,-]\"); AbstractCollection abstractCollection = new ArrayDeque<String>(); String[] stringArray = object; int n2 = ((String[])object).length; for (n = 0; n < n2; ++n) { String string = stringArray[n]; if (string.isEmpty()) continue; ((ArrayDeque)abstractCollection).add(string.toLowerCase()); } if (((ArrayDeque)abstractCollection).isEmpty()) { throw new WordsToNumberException(WordsToNumberException$ErrorType.NULL_INPUT, \"\"); } arrayDeque = abstractCollection; object = BigDecimal.ZERO; abstractCollection = new ArrayList(); boolean bl = \"negative\".equals(arrayDeque.peek()); if (bl) { arrayDeque.poll(); } n2 = 0; n = 0; block17: while (!arrayDeque.isEmpty()) { Object object2; Serializable serializable; String string; Object object3; switch (object3 = (String)arrayDeque.poll()) { case \"and\": { boolean bl2; ArrayDeque<String> arrayDeque2 = arrayDeque; int n3 = n; int n4 = n2; if (arrayDeque2.isEmpty()) { throw new WordsToNumberException(WordsToNumberException$ErrorType.INVALID_CONJUNCTION, \"\"); } String string2 = (String)arrayDeque2.pollFirst(); string = (String)arrayDeque2.peekFirst(); arrayDeque2.addFirst(string2); serializable = WordsToNumber$NumberWord.getValue(string2); n3 = n4 != 0 || n3 != 0 ? 1 : 0; boolean bl3 = bl2 = serializable != null && ((Integer)serializable >= 10 || string == null || \"point\".equals(string)); if (n3 != 0 && bl2) continue block17; throw new WordsToNumberException(WordsToNumberException$ErrorType.INVALID_CONJUNCTION, \"\"); } case \"hundred\": { boolean bl4; int n5 = n; object2 = object3; object3 = object; boolean bl5 = bl4 = ((BigDecimal)object3).compareTo(BigDecimal.ZERO) == 0; if (((BigDecimal)object3).compareTo(BigDecimal.TEN) >= 0 || n5 != 0) { throw new WordsToNumberException(WordsToNumberException$ErrorType.UNEXPECTED_WORD, (String)object2); } if (bl4) { object3 = ((BigDecimal)object3).add(BigDecimal.ONE); } object = ((BigDecimal)object3).multiply(BigDecimal.valueOf(100L)); n2 = 1; continue block17; } } n2 = 0; object2 = WordsToNumber$PowerOfTen.getValue((String)object3); if (object2 != null) { int n6 = n; Object object4 = object3; Object object5 = object2; object2 = object; object3 = abstractCollection; boolean bl6 = ((BigDecimal)object2).compareTo(BigDecimal.ZERO) == 0; if (bl6 || n6 != 0) { throw new WordsToNumberException(WordsToNumberException$ErrorType.UNEXPECTED_WORD, (String)object4); } object2 = ((BigDecimal)object2).multiply((BigDecimal)object5); if (!object3.isEmpty() && !WordsToNumber.a((BigDecimal)object3.getLast(), (BigDecimal)object2)) { throw new WordsToNumberException(WordsToNumberException$ErrorType.UNEXPECTED_WORD, (String)object4); } object3.add(object2); object = BigDecimal.ZERO; n = 1; continue; } n = 0; Object object6 = WordsToNumber$NumberWord.getValue((String)object3); if (object6 != null) { boolean bl7; Integer n7 = object6; object6 = object3; object2 = object; object3 = abstractCollection; boolean bl8 = bl7 = ((BigDecimal)object2).compareTo(BigDecimal.ZERO) == 0; if (!(n7 != 0 || bl7 && object3.isEmpty())) { throw new WordsToNumberException(WordsToNumberException$ErrorType.UNEXPECTED_WORD, (String)object6); } serializable = BigDecimal.valueOf(n7.intValue()); if (!bl7 && !WordsToNumber.a((BigDecimal)object2, (BigDecimal)serializable)) { throw new WordsToNumberException(WordsToNumberException$ErrorType.UNEXPECTED_WORD, (String)object6); } object = ((BigDecimal)object2).add((BigDecimal)serializable); continue; } switch (object3) { case \"point\": { Object object7 = arrayDeque; object2 = object; object3 = abstractCollection; boolean bl9 = ((BigDecimal)object2).compareTo(BigDecimal.ZERO) == 0; if (!bl9) { object3.add(object2); } serializable = object7; object2 = new StringBuilder(\".\"); while (!((ArrayDeque)serializable).isEmpty()) { object7 = (String)((ArrayDeque)serializable).poll(); object = WordsToNumber$NumberWord.getValue((String)object7); if (object == null) { throw new WordsToNumberException(WordsToNumberException$ErrorType.UNEXPECTED_WORD_AFTER_POINT, (String)object7); } ((StringBuilder)object2).append(object); } boolean bl10 = ((StringBuilder)object2).length() == 1; if (bl10) { throw new WordsToNumberException(WordsToNumberException$ErrorType.MISSING_DECIMAL_NUMBERS, \"\"); } string = ((StringBuilder)object2).toString(); object3.add(new BigDecimal(string)); object = BigDecimal.ZERO; continue block17; } case \"negative\": { boolean bl11 = bl; if (bl11) { throw new WordsToNumberException(WordsToNumberException$ErrorType.MULTIPLE_NEGATIVES, \"\"); } throw new WordsToNumberException(WordsToNumberException$ErrorType.INVALID_NEGATIVE, \"\"); } } throw new WordsToNumberException(WordsToNumberException$ErrorType.UNKNOWN_WORD, (String)object3); } if (((BigDecimal)object).compareTo(BigDecimal.ZERO) != 0) { abstractCollection.add((Object)object); } Serializable serializable = abstractCollection; BigDecimal bigDecimal = BigDecimal.ZERO; Iterator iterator = serializable.iterator(); while (iterator.hasNext()) { BigDecimal bigDecimal2 = (BigDecimal)iterator.next(); bigDecimal = bigDecimal.add(bigDecimal2); } serializable = bigDecimal; arrayDeque = bl ? ((BigDecimal)serializable).multiply(BigDecimal.valueOf(-1L)) : serializable; return ((BigDecimal)((Object)arrayDeque)).toString(); } public static BigDecimal convertToBigDecimal(String string) { string = WordsToNumber.convert(string); return new BigDecimal(string); } private static boolean a(BigDecimal bigDecimal, BigDecimal bigDecimal2) { int n; int n2 = bigDecimal.toString().length(); return n2 > (n = bigDecimal2.toString().length()); } }", "deobfuscated_code": "package com.thealgorithms.conversions; import java.io.Serial; import java.math.BigDecimal; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Collection; import java.util.List; /** A Java-based utility for converting English word representations of numbers into their numeric form. This utility supports whole numbers, decimals, large values up to trillions, and even scientific notation where applicable. It ensures accurate parsing while handling edge cases like negative numbers, improper word placements, and ambiguous inputs. * */ public final class WordsToNumber { private WordsToNumber() { } private enum NumberWord { ZERO(\"zero\", 0), ONE(\"one\", 1), TWO(\"two\", 2), THREE(\"three\", 3), FOUR(\"four\", 4), FIVE(\"five\", 5), SIX(\"six\", 6), SEVEN(\"seven\", 7), EIGHT(\"eight\", 8), NINE(\"nine\", 9), TEN(\"ten\", 10), ELEVEN(\"eleven\", 11), TWELVE(\"twelve\", 12), THIRTEEN(\"thirteen\", 13), FOURTEEN(\"fourteen\", 14), FIFTEEN(\"fifteen\", 15), SIXTEEN(\"sixteen\", 16), SEVENTEEN(\"seventeen\", 17), EIGHTEEN(\"eighteen\", 18), NINETEEN(\"nineteen\", 19), TWENTY(\"twenty\", 20), THIRTY(\"thirty\", 30), FORTY(\"forty\", 40), FIFTY(\"fifty\", 50), SIXTY(\"sixty\", 60), SEVENTY(\"seventy\", 70), EIGHTY(\"eighty\", 80), NINETY(\"ninety\", 90); private final String word; private final int value; NumberWord(String word, int value) { this.word = word; this.value = value; } public static Integer getValue(String word) { for (NumberWord num : values()) { if (word.equals(num.word)) { return num.value; } } return null; } } private enum PowerOfTen { THOUSAND(\"thousand\", new BigDecimal(\"1000\")), MILLION(\"million\", new BigDecimal(\"1000000\")), BILLION(\"billion\", new BigDecimal(\"1000000000\")), TRILLION(\"trillion\", new BigDecimal(\"1000000000000\")); private final String word; private final BigDecimal value; PowerOfTen(String word, BigDecimal value) { this.word = word; this.value = value; } public static BigDecimal getValue(String word) { for (PowerOfTen power : values()) { if (word.equals(power.word)) { return power.value; } } return null; } } public static String convert(String numberInWords) { if (numberInWords == null) { throw new WordsToNumberException(WordsToNumberException.ErrorType.NULL_INPUT, \"\"); } ArrayDeque<String> wordDeque = preprocessWords(numberInWords); BigDecimal completeNumber = convertWordQueueToBigDecimal(wordDeque); return completeNumber.toString(); } public static BigDecimal convertToBigDecimal(String numberInWords) { String conversionResult = convert(numberInWords); return new BigDecimal(conversionResult); } private static ArrayDeque<String> preprocessWords(String numberInWords) { String[] wordSplitArray = numberInWords.trim().split(\"[ ,-]\"); ArrayDeque<String> wordDeque = new ArrayDeque<>(); for (String word : wordSplitArray) { if (word.isEmpty()) { continue; } wordDeque.add(word.toLowerCase()); } if (wordDeque.isEmpty()) { throw new WordsToNumberException(WordsToNumberException.ErrorType.NULL_INPUT, \"\"); } return wordDeque; } private static void handleConjunction(boolean prevNumWasHundred, boolean prevNumWasPowerOfTen, ArrayDeque<String> wordDeque) { if (wordDeque.isEmpty()) { throw new WordsToNumberException(WordsToNumberException.ErrorType.INVALID_CONJUNCTION, \"\"); } String nextWord = wordDeque.pollFirst(); String afterNextWord = wordDeque.peekFirst(); wordDeque.addFirst(nextWord); Integer number = NumberWord.getValue(nextWord); boolean isPrevWordValid = prevNumWasHundred || prevNumWasPowerOfTen; boolean isNextWordValid = number != null && (number >= 10 || afterNextWord == null || \"point\".equals(afterNextWord)); if (!isPrevWordValid || !isNextWordValid) { throw new WordsToNumberException(WordsToNumberException.ErrorType.INVALID_CONJUNCTION, \"\"); } } private static BigDecimal handleHundred(BigDecimal currentChunk, String word, boolean prevNumWasPowerOfTen) { boolean currentChunkIsZero = currentChunk.compareTo(BigDecimal.ZERO) == 0; if (currentChunk.compareTo(BigDecimal.TEN) >= 0 || prevNumWasPowerOfTen) { throw new WordsToNumberException(WordsToNumberException.ErrorType.UNEXPECTED_WORD, word); } if (currentChunkIsZero) { currentChunk = currentChunk.add(BigDecimal.ONE); } return currentChunk.multiply(BigDecimal.valueOf(100)); } private static void handlePowerOfTen(List<BigDecimal> chunks, BigDecimal currentChunk, BigDecimal powerOfTen, String word, boolean prevNumWasPowerOfTen) { boolean currentChunkIsZero = currentChunk.compareTo(BigDecimal.ZERO) == 0; if (currentChunkIsZero || prevNumWasPowerOfTen) { throw new WordsToNumberException(WordsToNumberException.ErrorType.UNEXPECTED_WORD, word); } BigDecimal nextChunk = currentChunk.multiply(powerOfTen); if (!(chunks.isEmpty() || isAdditionSafe(chunks.getLast(), nextChunk))) { throw new WordsToNumberException(WordsToNumberException.ErrorType.UNEXPECTED_WORD, word); } chunks.add(nextChunk); } private static BigDecimal handleNumber(Collection<BigDecimal> chunks, BigDecimal currentChunk, String word, Integer number) { boolean currentChunkIsZero = currentChunk.compareTo(BigDecimal.ZERO) == 0; if (number == 0 && !(currentChunkIsZero && chunks.isEmpty())) { throw new WordsToNumberException(WordsToNumberException.ErrorType.UNEXPECTED_WORD, word); } BigDecimal bigDecimalNumber = BigDecimal.valueOf(number); if (!currentChunkIsZero && !isAdditionSafe(currentChunk, bigDecimalNumber)) { throw new WordsToNumberException(WordsToNumberException.ErrorType.UNEXPECTED_WORD, word); } return currentChunk.add(bigDecimalNumber); } private static void handlePoint(Collection<BigDecimal> chunks, BigDecimal currentChunk, ArrayDeque<String> wordDeque) { boolean currentChunkIsZero = currentChunk.compareTo(BigDecimal.ZERO) == 0; if (!currentChunkIsZero) { chunks.add(currentChunk); } String decimalPart = convertDecimalPart(wordDeque); chunks.add(new BigDecimal(decimalPart)); } private static void handleNegative(boolean isNegative) { if (isNegative) { throw new WordsToNumberException(WordsToNumberException.ErrorType.MULTIPLE_NEGATIVES, \"\"); } throw new WordsToNumberException(WordsToNumberException.ErrorType.INVALID_NEGATIVE, \"\"); } private static BigDecimal convertWordQueueToBigDecimal(ArrayDeque<String> wordDeque) { BigDecimal currentChunk = BigDecimal.ZERO; List<BigDecimal> chunks = new ArrayList<>(); boolean isNegative = \"negative\".equals(wordDeque.peek()); if (isNegative) { wordDeque.poll(); } boolean prevNumWasHundred = false; boolean prevNumWasPowerOfTen = false; while (!wordDeque.isEmpty()) { String word = wordDeque.poll(); switch (word) { case \"and\" -> { handleConjunction(prevNumWasHundred, prevNumWasPowerOfTen, wordDeque); continue; } case \"hundred\" -> { currentChunk = handleHundred(currentChunk, word, prevNumWasPowerOfTen); prevNumWasHundred = true; continue; } default -> { } } prevNumWasHundred = false; BigDecimal powerOfTen = PowerOfTen.getValue(word); if (powerOfTen != null) { handlePowerOfTen(chunks, currentChunk, powerOfTen, word, prevNumWasPowerOfTen); currentChunk = BigDecimal.ZERO; prevNumWasPowerOfTen = true; continue; } prevNumWasPowerOfTen = false; Integer number = NumberWord.getValue(word); if (number != null) { currentChunk = handleNumber(chunks, currentChunk, word, number); continue; } switch (word) { case \"point\" -> { handlePoint(chunks, currentChunk, wordDeque); currentChunk = BigDecimal.ZERO; continue; } case \"negative\" -> { handleNegative(isNegative); } default -> { } } throw new WordsToNumberException(WordsToNumberException.ErrorType.UNKNOWN_WORD, word); } if (currentChunk.compareTo(BigDecimal.ZERO) != 0) { chunks.add(currentChunk); } BigDecimal completeNumber = combineChunks(chunks); return isNegative ? completeNumber.multiply(BigDecimal.valueOf(-1)) : completeNumber; } private static boolean isAdditionSafe(BigDecimal currentChunk, BigDecimal number) { int chunkDigitCount = currentChunk.toString().length(); int numberDigitCount = number.toString().length(); return chunkDigitCount > numberDigitCount; } private static String convertDecimalPart(ArrayDeque<String> wordDeque) { StringBuilder decimalPart = new StringBuilder(\".\"); while (!wordDeque.isEmpty()) { String word = wordDeque.poll(); Integer number = NumberWord.getValue(word); if (number == null) { throw new WordsToNumberException(WordsToNumberException.ErrorType.UNEXPECTED_WORD_AFTER_POINT, word); } decimalPart.append(number); } boolean missingNumbers = decimalPart.length() == 1; if (missingNumbers) { throw new WordsToNumberException(WordsToNumberException.ErrorType.MISSING_DECIMAL_NUMBERS, \"\"); } return decimalPart.toString(); } private static BigDecimal combineChunks(List<BigDecimal> chunks) { BigDecimal completeNumber = BigDecimal.ZERO; for (BigDecimal chunk : chunks) { completeNumber = completeNumber.add(chunk); } return completeNumber; } } class WordsToNumberException extends RuntimeException { @Serial private static final long serialVersionUID = 1L; enum ErrorType { NULL_INPUT(\"'null' or empty input provided\"), UNKNOWN_WORD(\"Unknown Word: \"), UNEXPECTED_WORD(\"Unexpected Word: \"), UNEXPECTED_WORD_AFTER_POINT(\"Unexpected Word (after Point): \"), MISSING_DECIMAL_NUMBERS(\"Decimal part is missing numbers.\"), MULTIPLE_NEGATIVES(\"Multiple 'Negative's detected.\"), INVALID_NEGATIVE(\"Incorrect 'negative' placement\"), INVALID_CONJUNCTION(\"Incorrect 'and' placement\"); private final String message; ErrorType(String message) { this.message = message; } public String formatMessage(String details) { return \"Invalid Input. \" + message + (details.isEmpty() ? \"\" : details); } } public final ErrorType errorType; WordsToNumberException(ErrorType errorType, String details) { super(errorType.formatMessage(details)); this.errorType = errorType; } public ErrorType getErrorType() { return errorType; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; enum WordsToNumberException$ErrorType { NULL_INPUT(\"'null' or empty input provided\"), UNKNOWN_WORD(\"Unknown Word: \"), UNEXPECTED_WORD(\"Unexpected Word: \"), UNEXPECTED_WORD_AFTER_POINT(\"Unexpected Word (after Point): \"), MISSING_DECIMAL_NUMBERS(\"Decimal part is missing numbers.\"), MULTIPLE_NEGATIVES(\"Multiple 'Negative's detected.\"), INVALID_NEGATIVE(\"Incorrect 'negative' placement\"), INVALID_CONJUNCTION(\"Incorrect 'and' placement\"); private final String a; /* * WARNING - Possible parameter corruption * WARNING - void declaration */ private WordsToNumberException$ErrorType() { void var3_2; this.a = var3_2; } public final String formatMessage(String string) { return \"Invalid Input. \" + this.a + (string.isEmpty() ? \"\" : string); } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; enum WordsToNumberException$ErrorType { NULL_INPUT(\"'null' or empty input provided\"), UNKNOWN_WORD(\"Unknown Word: \"), UNEXPECTED_WORD(\"Unexpected Word: \"), UNEXPECTED_WORD_AFTER_POINT(\"Unexpected Word (after Point): \"), MISSING_DECIMAL_NUMBERS(\"Decimal part is missing numbers.\"), MULTIPLE_NEGATIVES(\"Multiple 'Negative's detected.\"), INVALID_NEGATIVE(\"Incorrect 'negative' placement\"), INVALID_CONJUNCTION(\"Incorrect 'and' placement\"); private final String a; /* * WARNING - Possible parameter corruption * WARNING - void declaration */ private WordsToNumberException$ErrorType() { void var3_2; this.a = var3_2; } public final String formatMessage(String string) { return \"Invalid Input. \" + this.a + (string.isEmpty() ? \"\" : string); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import com.thealgorithms.conversions.WordsToNumberException$ErrorType; class WordsToNumberException extends RuntimeException { public final WordsToNumberException$ErrorType errorType; WordsToNumberException(WordsToNumberException$ErrorType wordsToNumberException$ErrorType, String string) { super(wordsToNumberException$ErrorType.formatMessage(string)); this.errorType = wordsToNumberException$ErrorType; } public WordsToNumberException$ErrorType getErrorType() { return this.errorType; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.conversions; import com.thealgorithms.conversions.WordsToNumberException$ErrorType; class WordsToNumberException extends RuntimeException { public final WordsToNumberException$ErrorType errorType; WordsToNumberException(WordsToNumberException$ErrorType wordsToNumberException$ErrorType, String string) { super(wordsToNumberException$ErrorType.formatMessage(string)); this.errorType = wordsToNumberException$ErrorType; } public WordsToNumberException$ErrorType getErrorType() { return this.errorType; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.MemoryManagementAlgorithms; import java.util.ArrayList; class WorstFitCPU extends MemoryManagementAlgorithms { WorstFitCPU() { } @Override public ArrayList fitProcess(int[] nArray, int[] nArray2) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); int n = nArray2.length; for (int i = 0; i < n; ++i) { int n2; int n3 = n2 = nArray2[i]; int[] nArray3 = nArray; int n4 = -1; int n5 = -1; for (int j = 0; j < nArray3.length; ++j) { if (nArray3[j] <= n4) continue; n4 = nArray3[j]; n5 = j; } int n6 = n3 > nArray3[n5] ? -255 : n5; arrayList.add(n6); if (n6 == -255) continue; int n7 = n6; nArray[n7] = nArray[n7] - n2; } return arrayList; } }", "deobfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.others; import com.thealgorithms.others.MemoryManagementAlgorithms; import java.util.ArrayList; class WorstFitCPU extends MemoryManagementAlgorithms { WorstFitCPU() { } @Override public ArrayList fitProcess(int[] nArray, int[] nArray2) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); int n = nArray2.length; for (int i = 0; i < n; ++i) { int n2; int n3 = n2 = nArray2[i]; int[] nArray3 = nArray; int n4 = -1; int n5 = -1; for (int j = 0; j < nArray3.length; ++j) { if (nArray3[j] <= n4) continue; n4 = nArray3[j]; n5 = j; } int n6 = n3 > nArray3[n5] ? -255 : n5; arrayList.add(n6); if (n6 == -255) continue; int n7 = n6; nArray[n7] = nArray[n7] - n2; } return arrayList; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.ciphers; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.util.HexFormat; public final class XORCipher { private static final Charset a = StandardCharsets.UTF_8; private XORCipher() { } public static byte[] xor(byte[] byArray, byte[] byArray2) { byte[] byArray3 = new byte[byArray.length]; for (int i = 0; i < byArray.length; ++i) { byArray3[i] = (byte)(byArray[i] ^ byArray2[i % byArray2.length]); } return byArray3; } public static String encrypt(String object, String object2) { if (((String)object2).isEmpty()) { throw new IllegalArgumentException(\"Key must not be empty\"); } object = ((String)object).getBytes(a); object2 = ((String)object2).getBytes(a); object = XORCipher.xor((byte[])object, (byte[])object2); return HexFormat.of().formatHex((byte[])object); } public static String decrypt(String object, String object2) { if (((String)object2).isEmpty()) { throw new IllegalArgumentException(\"Key must not be empty\"); } object = HexFormat.of().parseHex((CharSequence)object); object2 = ((String)object2).getBytes(a); object = XORCipher.xor((byte[])object, (byte[])object2); return new String((byte[])object, a); } }", "deobfuscated_code": "package com.thealgorithms.ciphers; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.util.HexFormat; /** * A simple implementation of the XOR cipher that allows both encryption and decryption * using a given key. This cipher works by applying the XOR bitwise operation between * the bytes of the input text and the corresponding bytes of the key (repeating the key * if necessary). * * Usage: * - Encryption: Converts plaintext into a hexadecimal-encoded ciphertext. * - Decryption: Converts the hexadecimal ciphertext back into plaintext. * * Characteristics: * - Symmetric: The same key is used for both encryption and decryption. * - Simple but vulnerable: XOR encryption is insecure for real-world cryptography, * especially when the same key is reused. * * Example: * Plaintext: \"Hello!\" * Key: \"key\" * Encrypted: \"27090c03120b\" * Decrypted: \"Hello!\" * * Reference: <a href=\"https://en.wikipedia.org/wiki/XOR_cipher\">XOR Cipher - Wikipedia</a> * * @author <a href=\"https://github.com/lcsjunior\">lcsjunior</a> */ public final class XORCipher { // Default character encoding for string conversion private static final Charset CS_DEFAULT = StandardCharsets.UTF_8; private XORCipher() { } /** * Applies the XOR operation between the input bytes and the key bytes. * If the key is shorter than the input, it wraps around (cyclically). * * @param inputBytes The input byte array (plaintext or ciphertext). * @param keyBytes The key byte array used for XOR operation. * @return A new byte array containing the XOR result. */ public static byte[] xor(final byte[] inputBytes, final byte[] keyBytes) { byte[] outputBytes = new byte[inputBytes.length]; for (int i = 0; i < inputBytes.length; ++i) { outputBytes[i] = (byte) (inputBytes[i] ^ keyBytes[i % keyBytes.length]); } return outputBytes; } /** * Encrypts the given plaintext using the XOR cipher with the specified key. * The result is a hexadecimal-encoded string representing the ciphertext. * * @param plainText The input plaintext to encrypt. * @param key The encryption key. * @throws IllegalArgumentException if the key is empty. * @return A hexadecimal string representing the encrypted text. */ public static String encrypt(final String plainText, final String key) { if (key.isEmpty()) { throw new IllegalArgumentException(\"Key must not be empty\"); } byte[] plainTextBytes = plainText.getBytes(CS_DEFAULT); byte[] keyBytes = key.getBytes(CS_DEFAULT); byte[] xorResult = xor(plainTextBytes, keyBytes); return HexFormat.of().formatHex(xorResult); } /** * Decrypts the given ciphertext (in hexadecimal format) using the XOR cipher * with the specified key. The result is the original plaintext. * * @param cipherText The hexadecimal string representing the encrypted text. * @param key The decryption key (must be the same as the encryption key). * @throws IllegalArgumentException if the key is empty. * @return The decrypted plaintext. */ public static String decrypt(final String cipherText, final String key) { if (key.isEmpty()) { throw new IllegalArgumentException(\"Key must not be empty\"); } byte[] cipherBytes = HexFormat.of().parseHex(cipherText); byte[] keyBytes = key.getBytes(CS_DEFAULT); byte[] xorResult = xor(cipherBytes, keyBytes); return new String(xorResult, CS_DEFAULT); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.bitmanipulation; public final class Xs3Conversion { private Xs3Conversion() { } public static int xs3ToBinary(int n) { int n2 = 0; int n3 = 1; while (n > 0) { int n4 = (n & 0xF) - 3; n2 += n4 * n3; n3 *= 10; n >>= 4; } return n2; } public static int binaryToXs3(int n) { int n2 = 0; int n3 = 0; while (n > 0) { int n4 = n % 10 + 3; n2 |= n4 << (n3 << 2); n /= 10; ++n3; } return n2; } }", "deobfuscated_code": "package com.thealgorithms.bitmanipulation; /** * This class provides methods to convert between XS-3 (Excess-3) and binary. * * Excess-3, also called XS-3, is a binary-coded decimal (BCD) code in which each decimal digit is represented by its corresponding 4-bit binary value plus 3. * * For more information, refer to the * <a href=\"https://en.wikipedia.org/wiki/Excess-3\">Excess-3</a> Wikipedia page. * * <b>Example usage:</b> * <pre> * int binary = Xs3Conversion.xs3ToBinary(0x4567); * System.out.println(\"XS-3 0x4567 to binary: \" + binary); // Output: 1234 * * int xs3 = Xs3Conversion.binaryToXs3(1234); * System.out.println(\"Binary 1234 to XS-3: \" + Integer.toHexString(xs3)); // Output: 0x4567 * </pre> */ public final class Xs3Conversion { private Xs3Conversion() { } /** * Converts an XS-3 (Excess-3) number to binary. * * @param xs3 The XS-3 number. * @return The corresponding binary number. */ public static int xs3ToBinary(int xs3) { int binary = 0; int multiplier = 1; while (xs3 > 0) { int digit = (xs3 & 0xF) - 3; // Extract the last 4 bits (one XS-3 digit) and subtract 3 binary += digit * multiplier; multiplier *= 10; xs3 >>= 4; // Shift right by 4 bits to process the next XS-3 digit } return binary; } /** * Converts a binary number to XS-3 (Excess-3). * * @param binary The binary number. * @return The corresponding XS-3 number. */ public static int binaryToXs3(int binary) { int xs3 = 0; int shift = 0; while (binary > 0) { int digit = (binary % 10) + 3; // Extract the last decimal digit and add 3 xs3 |= (digit << (shift * 4)); // Shift the digit to the correct XS-3 position binary /= 10; // Remove the last decimal digit shift++; } return xs3; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.strings.zigZagPattern; final class ZigZagPattern { private ZigZagPattern() { } public static String encode(String string, int n) { if (n < 2 || string.length() < n) { return string; } StringBuilder stringBuilder = new StringBuilder(string.length()); int n2 = 2 * n - 2; for (int i = 0; i < n; ++i) { for (int j = i; j < string.length(); j += n2) { int n3; stringBuilder.append(string.charAt(j)); if (i <= 0 || i >= n - 1 || (n3 = j + n2 - 2 * i) >= string.length()) continue; stringBuilder.append(string.charAt(n3)); } } return stringBuilder.toString(); } }", "deobfuscated_code": "package com.thealgorithms.strings.zigZagPattern; final class ZigZagPattern { private ZigZagPattern() { } /** * Encodes a given string into a zig-zag pattern. * * @param s the input string to be encoded * @param numRows the number of rows in the zigzag pattern * @return the encoded string in zigzag pattern format */ public static String encode(String s, int numRows) { if (numRows < 2 || s.length() < numRows) { return s; } StringBuilder result = new StringBuilder(s.length()); int cycleLength = 2 * numRows - 2; for (int row = 0; row < numRows; row++) { for (int j = row; j < s.length(); j += cycleLength) { result.append(s.charAt(j)); if (row > 0 && row < numRows - 1) { int diagonal = j + cycleLength - 2 * row; if (diagonal < s.length()) { result.append(s.charAt(diagonal)); } } } } return result.toString(); } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.BinaryTree$Node; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; public final class ZigzagTraversal { private ZigzagTraversal() { } public static List traverse(BinaryTree$Node binaryTree$Node) { if (binaryTree$Node == null) { return List.of(); } ArrayList arrayList = new ArrayList(); ArrayDeque<BinaryTree$Node> arrayDeque = new ArrayDeque<BinaryTree$Node>(); arrayDeque.offer(binaryTree$Node); boolean bl = false; while (!arrayDeque.isEmpty()) { int n = arrayDeque.size(); LinkedList<Integer> linkedList = new LinkedList<Integer>(); for (int i = 0; i < n; ++i) { BinaryTree$Node binaryTree$Node2 = (BinaryTree$Node)arrayDeque.poll(); if (bl) { linkedList.add(0, binaryTree$Node2.data); } else { linkedList.add(binaryTree$Node2.data); } if (binaryTree$Node2.left != null) { arrayDeque.offer(binaryTree$Node2.left); } if (binaryTree$Node2.right == null) continue; arrayDeque.offer(binaryTree$Node2.right); } bl = !bl; arrayList.add(linkedList); } return arrayList; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Deque; import java.util.LinkedList; import java.util.List; /** * Given a binary tree. * This code returns the zigzag level order traversal of its nodes' values. * Binary tree: * 7 * / \\ * 6 3 * / \\ / \\ * 2 4 10 19 * Zigzag traversal: * [[7], [3, 6], [2, 4, 10, 19]] * <p> * This solution implements the breadth-first search (BFS) algorithm using a queue. * 1. The algorithm starts with a root node. This node is added to a queue. * 2. While the queue is not empty: * - each time we enter the while-loop we get queue size. Queue size refers to the number of nodes * at the current level. * - we traverse all the level nodes in 2 ways: from left to right OR from right to left * (this state is stored on `prevLevelFromLeftToRight` variable) * - if the current node has children we add them to a queue * - add level with nodes to a result. * <p> * Complexities: * O(N) - time, where N is the number of nodes in a binary tree * O(N) - space, where N is the number of nodes in a binary tree * * @author Albina Gimaletdinova on 11/01/2023 */ public final class ZigzagTraversal { private ZigzagTraversal() { } public static List<List<Integer>> traverse(BinaryTree.Node root) { if (root == null) { return List.of(); } List<List<Integer>> result = new ArrayList<>(); // create a queue Deque<BinaryTree.Node> q = new ArrayDeque<>(); q.offer(root); // start with writing nodes from left to right boolean prevLevelFromLeftToRight = false; while (!q.isEmpty()) { int nodesOnLevel = q.size(); List<Integer> level = new LinkedList<>(); // traverse all the level nodes for (int i = 0; i < nodesOnLevel; i++) { BinaryTree.Node node = q.poll(); if (prevLevelFromLeftToRight) { level.add(0, node.data); } else { level.add(node.data); } if (node.left != null) { q.offer(node.left); } if (node.right != null) { q.offer(node.right); } } // the next level node traversal will be from the other side prevLevelFromLeftToRight = !prevLevelFromLeftToRight; result.add(level); } return result; } }"}
{"language": "java", "obfuscated_code": "/* * Decompiled with CFR 0.152. */ package com.thealgorithms.datastructures.trees; import com.thealgorithms.datastructures.trees.NRKTree; import java.util.Scanner; import java.util.concurrent.ThreadLocalRandom; final class NearestRightKey { private NearestRightKey() { } public static void main(String[] object) { object = NearestRightKey.buildTree(); Scanner scanner = new Scanner(System.in); System.out.print(\"Enter first number: \"); int n = scanner.nextInt(); int n2 = NearestRightKey.nearestRightKey((NRKTree)object, n); System.out.println(\"Key: \" + n2); scanner.close(); } public static NRKTree buildTree() { int n = ThreadLocalRandom.current().nextInt(0, 101); NRKTree nRKTree = new NRKTree(null, null, n); for (int i = 0; i < 1000; ++i) { n = ThreadLocalRandom.current().nextInt(0, 101); NRKTree nRKTree2 = nRKTree; nRKTree = nRKTree2.insertKey(nRKTree2, n); } return nRKTree; } public static int nearestRightKey(NRKTree nRKTree, int n) { while (nRKTree != null) { if (nRKTree.data - n > 0) { if ((n = NearestRightKey.nearestRightKey(nRKTree.left, n)) == 0) { return nRKTree.data; } return n; } nRKTree = nRKTree.right; } return 0; } }", "deobfuscated_code": "package com.thealgorithms.datastructures.trees; import java.util.Scanner; import java.util.concurrent.ThreadLocalRandom; final class NearestRightKey { private NearestRightKey() { } public static void main(String[] args) { NRKTree root = buildTree(); Scanner sc = new Scanner(System.in); System.out.print(\"Enter first number: \"); int inputX0 = sc.nextInt(); int toPrint = nearestRightKey(root, inputX0); System.out.println(\"Key: \" + toPrint); sc.close(); } public static NRKTree buildTree() { int randomX = ThreadLocalRandom.current().nextInt(0, 100 + 1); NRKTree root = new NRKTree(null, null, randomX); for (int i = 0; i < 1000; i++) { randomX = ThreadLocalRandom.current().nextInt(0, 100 + 1); root = root.insertKey(root, randomX); } return root; } public static int nearestRightKey(NRKTree root, int x0) { // Check whether tree is empty if (root == null) { return 0; } else { if (root.data - x0 > 0) { // Go left int temp = nearestRightKey(root.left, x0); if (temp == 0) { return root.data; } return temp; } else { // Go right return nearestRightKey(root.right, x0); } } } } class NRKTree { public NRKTree left; public NRKTree right; public int data; NRKTree(int x) { this.left = null; this.right = null; this.data = x; } NRKTree(NRKTree right, NRKTree left, int x) { this.left = left; this.right = right; this.data = x; } public NRKTree insertKey(NRKTree current, int value) { if (current == null) { return new NRKTree(value); } if (value < current.data) { current.left = insertKey(current.left, value); } else if (value > current.data) { current.right = insertKey(current.right, value); } return current; } }"}
